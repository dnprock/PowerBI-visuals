{"version":3,"sources":["../ts/customVisuals/visuals/globeMap/visual/globeMap.ts","CustomVisuals.js","../ts/customVisuals/visuals/asterPlot/visual/asterPlot.ts","../ts/customVisuals/visuals/tornadoChart/visual/tornadoChart.ts","../ts/customVisuals/visuals/mekkoChart/visual/mekkoChart.ts","../ts/customVisuals/visuals/sankeyDiagram/visual/sankeyDiagram.ts","../ts/customVisuals/visuals/bulletChart/visual/bulletChart.ts","../ts/customVisuals/visuals/wordCloud/visual/wordCloud.ts","../ts/customVisuals/visuals/chicletSlicer/visual/chicletSlicer.ts","../ts/customVisuals/visuals/chordChart/visual/chordChart.ts","../ts/customVisuals/visuals/enhancedScatterChart/visual/enhancedScatterChart.ts","../ts/customVisuals/visuals/radarChart/visual/radarChart.ts","../ts/customVisuals/visuals/histogram/visual/histogram.ts","../ts/customVisuals/visuals/colorBarChart/visual/colorBarChart.ts","../ts/customVisuals/visuals/dotPlot/visual/dotPlot.ts","../ts/customVisuals/visuals/forceGraph/visual/forceGraph.ts","../ts/customVisuals/visuals/gantt/visual/gantt.ts","../ts/customVisuals/visuals/timeline/visual/timeline.ts","../ts/customVisuals/visuals/streamGraph/visual/streamGraph.ts","../ts/customVisuals/visuals/sunburst/visual/sunburst.ts","../ts/customVisuals/visuals/lineDotChart/visual/lineDotChart.ts","../ts/customVisuals/plugins.ts","../ts/customVisuals/services/customVisualPluginService.ts"],"names":["loadGlobeMapLibs","__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","powerbi","visuals","samples","createClassAndSelector","jsCommon","CssConstants","PixelConverter","ValueFormatter","valueFormatter","AsterPlotVisualClassName","AsterPlotLegendObjectName","AsterDefaultOuterLineThickness","AsterDefaultLabelFill","solid","color","AsterDefaultLegendFontSize","AsterRadiusRatio","AsterConflictRatio","MaxPrecision","AsterPlotWebBehavior","bindEvents","options","selectionHandler","selection","highlightedSelection","clearCatcher","interactivityService","on","i","handleSelection","data","d3","event","ctrlKey","handleClearSelection","renderSelection","hasSelection","hasHighlights","style","ColumnUtil","getFillOpacity","selected","highlight","AsterPlotWarning","message","defineProperty","get","enumerable","configurable","getMessages","resourceProvider","title","detail","AsterPlot","margin","top","right","bottom","left","getDefaultAsterData","dataPoints","highlightedDataPoints","legendData","fontSize","labelColor","LegendData","DefaultLegendLabelFillColor","legendSettings","show","position","showTitle","titleText","labelSettings","displayUnits","precision","dataLabelUtils","defaultLabelPrecision","defaultLabelColor","DefaultFontSizeInPt","showOuterLine","outerLineThickness","converter","dataView","colors","asterDataResult","dataViewContainsCategory","categorical","categories","length","catDv","cat","catSource","source","catValues","values","catObjects","objects","colorHelper","ColorHelper","Properties","dataPoint","fill","highlights","metadata","getLabelSettings","updateLegendSettings","DataViewObjects","getValue","outerLine","thickness","formatStringProp","general","formatString","maxValue","Math","max","min","minValue","labelFormatter","format","getFormatString","value","categorySourceFormatString","fontSizeInPx","fromPoint","formattedCategoryValue","currentValue","tooltipInfo","TooltipBuilder","createTooltipInfo","toolTip","push","identity","getColorForMeasure","key","selector","SelectionId","createWithId","sliceWidth","sliceHeight","label","labelFontSize","icon","LegendIcon","Box","highlightIdentity","createWithHighlight","notNull","asterPlotLabelsProperties","labels","labelPrecision","undefined","labelDisplayUnits","legendProperties","legend","_","isEmpty","displayName","getFillColor","init","hostService","host","element","svg","select","append","classed","colorPalette","dataColors","mainGroupElement","mainLabelsElement","behavior","appendClearCatcher","interactivity","createInteractivityService","createLegend","isInteractiveLegend","update","dataViews","duration","suppressAnimations","AnimatorCommon","MinervaAnimationDuration","currentViewport","height","viewport","width","convertedData","clearData","applySelectionStateToData","renderLegend","updateViewPortAccordingToLegend","attr","transformX","transformY","SVGUtil","translate","selectAll","AsterSlice","remove","AsterHighlightedSlice","cleanDataLabels","renderArcsAndLabels","behaviorOptions","bind","concat","isHighlight","radius","innerRadius","maxScore","totalWeight","sum","pie","layout","sort","isNaN","arc","outerRadius","heightIsLabelsOn","arcDescriptorDataPoints","classSelector","idx","getKey","enter","transition","attrTween","oldData","interpolation","interpolate","x","exit","TooltipManager","addTooltip","tooltipEvent","labelRadCalc_1","labelArc","lineRadCalc_1","outlineArc","getLabelLayout","drawLabels","drawCenterText","drawOuterLine","midAngle","startAngle","endAngle","textProperties","fontFamily","StandardFontFamily","text","isLabelsHasConflict","pos","centroid","textWidth","TextMeasurementService","measureSvgTextWidth","horizontalSpaceAvaliableForLabels","abs","textHeight","estimateSvgTextHeight","verticalSpaceAvaliableForLabels","isLabelHasConflict","labelText","xPos","spaceAvaliableForLabels","getTailoredTextOrDefault","labelLayout","y","yPos","filter","font-size","text-anchor","PI","context","_this","dataLabelManager","DataLabelManager","filteredData","hideCollidedLabels","labelGraphicsContextClass","empty","labelX","labelY","dy","labeltext","linesGraphicsContextClass","lines","labelLinePadding","chartLinePadding","textPoint","chartPoint","opacity","fill-opacity","stroke","asterPlotData","legendObjectProperties","getObject","changeOrientation","LegendPosition","drawLegend","clone","Legend","positionChartArea","legendMargins","getMargins","legendPosition","Top","TopCenter","Bottom","BottomCenter","Left","LeftCenter","Right","RightCenter","mainGroup","OuterThickness","OuterLine","stroke-width","getCenterText","columns","_i","_a","column","isMeasure","CenterLabelClass","centerTextProperties","fontWeight","toString","CenterTextFontHeightCoefficient","centerText","line-height","font-weight","getLabelFill","CenterTextFontWidthCoefficient","dataViewContainsObjects","enumerateLegend","instances","instance","objectName","properties","onClearSelection","clearSelection","enumerateLabels","enumerateObjectInstances","capabilities","dataRoles","name","kind","VisualDataRoleKind","Grouping","Measure","dataViewMappings","conditions","Category","Y","for","in","dataReductionAlgorithm","to","createDisplayNameGetter","type","formatting","description","bool","enumeration","suppressFormatPainterCopy","placeHolderText","numeric","supportsHighlight","propertyName","getTornadoChartWarning","TornadoChartWarning","TornadoWebBehavior","TornadoChartScrolling","getRoot","getViewport","getMargin","isScrollable","scrollYBrush","brush","renderY","prefferedHeight","onScroll","isYScrollBarVisible","brushGraphicsContextY","createOrRemoveScrollbar","updateScrollViewport","call","jQuery","extend","scrollSpaceLength","extentData","getExtentData","onRender","wheelDelta","extent","halfScrollsize","offset","scrollPosition","toScrollPosition","setScrollBarSize","scrollYScale","scale","ordinal","rangeBands","renderScrollbar","scrollViewport","TornadoChart","ScrollBarWidth","isVisible","brushGraphicsContext","brushClass","root","brushX","window","requestAnimationFrame","wheelEvent","deltaY","transform","drag-resize-disabled","cursor","minExtent","isVertical","svgLength","scaleMultipler","ScrollBarMinLength","scrollSize","start","end","visualMessage","titleKey","detailKey","tornadoChartConstructorOptions","DefaultTornadoChartSettings","labelOutsideFillColor","DefaultFontSize","defaultInsideLabelColor","showCategories","showLegend","legendFontSize","DefaultLegendFontSize","legendColor","categoriesFillColor","DefaultFillColors","columnPadding","leftLabelMargin","InnerTextHeightDelta","textOptions","heightColumn","widthLeftSection","widthRightSection","animator","visualInitOptions","ClassName","sizeUnit","slice","Number","scrolling","main","Columns","axes","Axes","Labels","Categories","defaultTornadoChartDataView","series","settings","visualUpdateOptions","durationAnimations","GetAnimationDuration","tornadoChartDataView","render","updateElements","elementsTranslate","MaxSeries","setWarnings","category","categoryValues","categoryValuesLength","getObjectsFromDataView","valuesSourceFormatString","parseSettings","hasDynamicSeries","labelHeight","categoriesLabels","groupedValues","grouped","maxCategoryLength","textData","getTextData","scrollBarWidth","CategoryMinHeight","LabelPadding","maxColumnWidth","seriesIndex","parsedSeries","parseSeries","currentSeries","measureName","queryName","SelectionIdBuilder","builder","withCategory","withSeries","withMeasure","createSelectionId","currentMaxValue","categoryAxisEnd","tooltipData","categoryIndex","highlightedValue","getLegendData","getPrecision","labelValueFormatter","getColor","outsideFill","insideFill","defaultColor","dataViewValueColumns","index","isGrouped","categoryAxisObject","dataViewValueColumn","seriesGroup","selectionId","groupName","legendDataPoints","map","renderWithScrolling","scrollStart","scrollEnd","categoriesLength","startIndex","endIndex","startIndexRound","floor","endIndexRound","maxValues","computeHeightColumn","renderMiddleSection","renderAxes","renderCategories","updateViewport","legendProps","calculateDataPoints","dataPointsWithHighlights","renderColumns","renderLabels","py","pyHighlighted","HighlightedShapeFactor","maxSeries","shiftToMiddle","shiftToRight","widthOfColumn","getColumnWidth","dx","highlighted","highlightOffset","getLabelData","px","angle","columnsData","selectSecondSeries","columnsSelection","Column","translateAndRotate","renderTooltip","columnWidth","dxColumn","isColumnPositionLeft","tornadoChartSettings","maxOutsideLabelWidth","maxLabelWidth","valueAfterValueFormatter","textDataAfterValueFormatter","linesData","axesSelection","axesElements","Axis","generateAxesData","x1","y1","x2","y2","labelsSettings","labelEnterSelection","labelSelection","Label","labelYOffset","LabelTitle","DefaultDy","LabelText","categoriesEnterSelection","categoriesSelection","categoryElements","self","CategoryTitle","CategoryText","shift","measureWidth","measureHeight","overrideFontSize","ObjectEnumerationBuilder","enumerateDataPoint","enumerateCategoryAxis","pushInstance","DataViewObject","getOrientation","complete","series_1","normalizeSelector","getSelector","series_2","destroy","class","Values","Series","group","by","categoryAxis","getTickLabelMargins","yMarginLimit","textWidthMeasurer","textHeightMeasurer","bottomMarginLimit","xAxisTextProperties","y1AxisTextProperties","y2AxisTextProperties","enableOverflowCheck","scrollbarVisible","showOnRight","renderXAxis","renderY1Axis","renderY2Axis","XLabelMaxAllowedOverflow","xAxisProperties","y1AxisProperties","y2AxisProperties","xLabels","y1Labels","leftOverflow","rightOverflow","maxWidthY1","maxWidthY2","xMax","ordinalLabelOffset","categoryThickness","scaleIsOrdinal","AxisHelper","isOrdinalScale","xLabelOuterPadding","outerPadding","xLabelMaxWidth","getRecommendedNumberOfTicksForXAxis","getRecommendedNumberOfTicksForYAxis","rotation","LabelLayoutStrategy","DefaultRotationWithScrollbar","DefaultRotation","len","y2Labels","maxNumLines","xScale","xDomain","domain","willLabelsWordBreak","wordBreaks","WordBreaker","splitByWidth","willLabelsFit","sine","cosine","rightMargin","leftMargin","bottomMargin","ceil","yLeft","yRight","getLayerData","currentIdx","totalLayers","shouldShowYAxisLabel","layerNumber","valueAxisProperties","yAxisWillMerge","calculateAxes","layers","categoryAxisProperties","existingAxisProperties","visualOptions","forcedXDomain","forceMerge","showCategoryAxisLabel","showValueAxisLabel","categoryAxisScaleType","axisScale","linear","valueAxisScaleType","trimOrdinalDataOnOverflow","forcedYDomain","applyCustomizedDomain","result","currentlayer","calculateAxesProperties","createLayers","cartesianOptions","createMekkoChartLayer","ColumnChartType","hundredPercentStackedColumn","defaultOptions","chartType","MekkoColumnChart","NewDataLabelUtils","MekkoDataWrapper","columnChartData","isScalar","lookupXValue","isDateTime","Date","firstSeries","seriesValues","categoryValue","MekkoColumnChartStrategy","setupVisualProps","columnChartProps","graphicsContext","categoryLayout","viewportHeight","viewportWidth","setData","createFormatter","scaleDomain","dataDomain","dataType","bestTickCount","tickValues","getValueFn","useTickIntervalForDisplayUnits","formatter","dateTime","value2","tickCount","minDate","maxDate","domainMin","domainMax","allowFormatBeautification","createDefaultFormatter","formatAxisTickValues","axis","formattedTickValues","tickFormat","createAxis","pixelSpan","metaDataColumn","isCategoryAxis","getCategoryValueType","isLogScaleAllowed","isLogScalePossible","borderWidth","getBorderWidth","borderSettings","chartWidth","MekkoChart","MinOrdinalRectThickness","range","tickSize","orient","ticks","CartesianChart","TickLabelPadding","labelAreaCount","axisType","axisLabel","usingDefaultDomain","getCategoryAxis","size","forcedXMin","forcedXMax","axisScaleType","outerPaddingRatio","dw","domainDoubles","item","originalPosition","indexOf","axisProperties","categoryMetadata","domainIndex","scaleType","setXScale","is100Pct","forcedTickCount","props","xProps","setYScale","valueDomain","StackedUtil","calcValueDomain","valueDomainArr","combinedDomain","combineDomain","shouldClamp","scaleShouldClamp","metadataColumn","valuesMetadata","getLocalizedString","mekkoMekkoCreateAxisOptions","axisDisplayUnits","axisPrecision","yProps","drawColumns","useAnimation","columnsCenters","shapes","axisOptions","yScale","stackedColumnLayout","getLayout","labelDataPoints","createMekkoLabelDataPoints","drawSeries","mainGraphicsContext","animate","viewModel","itemCS","classes","viewPort","failed","drawDefaultShapes","applyInteractivity","onDragStart","shapesSelection","filterZeros","rectName","dataSelector","datapoint","shapeSelection","shapeLayout","borderSelection","BorderClass","borders","borderColor","getBorderColor","DimmedOpacity","DefaultOpacity","shapeBorder","selectColumn","selectedColumnIndex","lastSelectedColumnIndex","setChosenColumnOpacity","moveHandle","getClosestColumnIndex","getColumnsCenters","categoryWidth","InnerPaddingRatio","xScaleOffset","columnCenters","columnSelectionLineHandle","handle","cx","cy","r","scaledY0","scaledX0","columnWidthScale","diffScaled","columnStart","borderStart","getSize","valueAbsolute","shapeLayoutWithoutHighlights","originalValueAbsolute","zeroShapeLayout","shapeXAxis","formattersCache","createColumnFormatterCacheManager","ilen","axisFormatter","getDisplayUnitValueFromAxisFormatter","j","parentRect","valueOriginal","hundredPercentFormat","getOrCreate","getLabelFormattedText","LabelTextProperties","isPreferred","textSize","isParentRect","parentShape","rect","orientation","validPositions","validLabelPositions","parentType","highlightItem","cartesianSmallViewPortProperties","MekkoChartBehavior","ColumnChartWebBehavior","getTextProperties","FontSize","hostServices","addClass","yAxisOrientation","yAxisPosition","adjustMargins","sharedColorPalette","SharedColorPalette","showLinesOnX","showLinesOnY","axisGraphicsContext","AxisGraphicsContextClassName","svgScrollable","axisGraphicsContextScrollable","labelGraphicsContextScrollable","axisGroup","xAxisGraphicsContext","y1AxisGraphicsContext","y2AxisGraphicsContext","renderAxesLabels","heightOffset","hideXAxisTitle","xAxisLabel","axisLabels","each","xLabelColor","clip","svgEllipsis","hideYAxisTitle","yAxisLabel","legendMargin","yLabelColor","hideY2AxisTitle","y2AxisLabel","y2LabelColor","xAxis","find","hide","translateAxes","showY1OnRight","isXScrollBarVisible","getIsScalar","propertyId","axisTypeValue","scalar","isOrdinal","populateObjectProperties","dataViewMetadata","borderObjectProperties","CartesianHelper","getCategoryAxisProperties","getValueAxisProperties","valueAxis","axisPosition","MinWidth","MinHeight","createAndInitLayers","warnings","getInvalidValueWarnings","clearPreferredScale","rotateScale","hasSetData","parseLabelSettings","getDefaultColumnLabelSettings","labelsObj","minPrecision","DefaultSettings","maxPrecision","updateLabelSettingsFromLabelsObject","parseBorderSettings","columnBorder","maxWidth","enumerateBorder","layersLength","shouldShowLegendCard","layerLegendData","DefaultLabelFontSizeInPt","hasCategoryAxis","getCategoryAxisValues","getValueAxisValues","layer","layersWithValuesCtr","hasLegend","supportedType","both","logPossible","scaleOptions","log","getSupportedCategoryAxisType","validValues","yAxisIsCategorical","axisStyle","showTitleOnly","categoryAxisHasUnitType","showUnitOnly","showBoth","secAxisScale","valueAxisHasUnitType","y2AxisExists","Prototype","inherit","cartesianHost","updateLegend","getSharedColors","triggerRender","calculateLegend","hideLegends","hideLegendOnSmallViewPort","MinHeightLegendVisible","addUnitTypeToAxisLabel","unitType","getUnitType","createAxisLabel","secValueAxisHasUnitType","shouldRenderSecondaryAxis","shouldRenderAxis","maxMarginFactor","getMaxMarginFactor","leftRightMarginLimit","MinBottomMargin","parseFloat","mainAxisScale","preferredViewport","getVisualCategoryAxisIsScalar","getPreferredPlotArea","scrollX","categoryCount","scrollY","doneWithMargins","maxIterations","numIterations","tickLabelMargins","chartHasAxisLabels","maxMainYaxisSide","maxSecondYaxisSide","LeftPadding","RightPadding","BottomPadding","hideAxisLabels","XAxisLabelPadding","YAxisLabelPadding","previousTickCountY1","previousTickCountY2","renderChart","hideAxesOnSmallViewPort","MinHeightAxesVisible","axisPropertiesLookup","displayUnit","MaxMarginFactor","getChartViewport","wordBreak","columnsWidth","maxHeight","allowedLength","node","scrollScale","xFontSize","yFontSize","chartViewport","tickPadding","TickPaddingRotatedX","xAxisGraphicsElement","darkenZeroLine","setAxisLabelColor","setAxisLabelFontSize","xAxisTextNodes","getColumnsWidth","moveBorder","TickPaddingY","toLowerCase","y1AxisGraphicsElement","renderAxisOptions","layerBehaviorOptions","labelDataPointsGroup","labelDataPointGroups","resultLabelDataPointsGroups","jlen","resultLabelDataPointsGroup","maxNumberOfLabels","resultsLabelDataPoints","reducedDataPoints","labelLayoutOptions","maximumOffset","maxLabelOffset","startingOffset","startingLabelOffset","LabelLayout","dataLabels","drawLabelBackground","animateDefaultLabels","getDuration","drawDefaultLabels","layerOptions","g","zeroTick","yOffset","showSeries","showAll","showAxisTitle","intersection","showAllDataPoints","fillRule","rule","inputRole","output","property","Width","rowCount","preferred","supported","sorting","default","drilldown","roles","MinScalarRectThickness","OuterPaddingRatio","MaxNumberOfLabels","EnumExtensions","ArrayExtensions","flagBar","flagStacked","RoleNames","categoryAxisType","unclippedGraphicsContext","labelGraphicsContext","cartesianVisualHost","supportsOverflow","hasFlag","ColumnChartClassName","columnChart","getCategoryLayout","numCategoryValues","availableWidth","categoryDataType","scalarCategoryAxis","createDomain","border","is100PercentStacked","xAxisCardProperties","applyUserMinMax","converterStrategy","ColumnChartConverterHelper","categoryInfo","converterHelper","getPivotedCategories","categoryFormatter","categoryIdentities","defaultDataPointColor","legendAndSeriesInfo","getLegend","seriesSources","createDataPoints","seriesObjects","categoryIsAlsoSeriesRole","categoryObjects","columnSeries","createAxesLabels","categoriesWidth","axesLabels","isMultiMeasure","getStackedMultiplier","rawValues","rowIdx","seriesCount","neg","normalizeNonFiniteNumber","absTotal","dataViewCat","seriesObjectsList","defaultLabelSettings","isCategoryAlsoSeries","categoryObjectsList","dvCategories","categoryType","baseValuesPos","baseValuesNeg","rawHighlightValues","widthColumns","widthIndex","highlightsOverflow","hasHighlightValues","widthValues","valuesLen","seriesHighlightValues","getValueBySeriesAndCategory","highlightValue","getHighlightBySeriesAndCategory","totalSum","linearScale","columnStartX","stepWidth","dataPointObjects","seriesLabelSettings","seriesDataPoints","legendItem","labelsSeriesGroup","labelObjects","originalValue","getTime","multipliers","unadjustedValue","isNegative","columnGroup","getMeasureNameByIndex","rawCategoryValue","getDataPointColor","seriesData","seriesValueColumn","columnIndex","columnValues","dataPointLabelSettings","lastValue","getStackedLabelColor","labelFill","labelFormatString","lastSeries","valueHighlight","unadjustedValueHighlight","highlightedTooltip","absoluteValueHighlight","highlightPosition","highlightDataPoint","drawThinner","colorOverride","nextValues","sliceSeries","newSeries","iNewSeries","getInteractiveColumnChartDomElement","children","is100PctStacked","createInteractiveMekkoLegendDataPoints","MekkoLegendDataPoints","isUndefinedOrEmpty","GradientUtils","hasGradientRole","enumerateDataPoints","enumerateDataLabels","getLabelSettingsOptions","isSeries","dataLabelsSettings","singleSeriesData","getColorByIndex","singleSeriesDataPoints","origCatgSize","chartLayout","preferredPlotArea","chartContext","isComboChart","ApplyInteractivity","isBarChart","temp","yAxisProperties","preferredWidth","getPreferredCategorySpan","dragDataPoint","datum","dragMove","mousePoint","mouse","ColumnChartSvg","ColumnChart","drag","origin","indexOfColumnSelected","force","lastInteractiveSelectedColumnIndex","allSeries","dataPointColor","measure","valueMetadata","formattedLabel","getFormattedLegendLabel","createNull","overrideXScale","xProperties","MekkoColumnChartDrawInfo","allDataPoints","datapoints","bars","eventGroup","showLabel","flushAllD3TransitionsIfNeeded","labelsAreNumeric","valueType","setFilteredData","SeriesClasses","hasRole","legendTitle","allValues","valueGroups","valueGroupsIndex","valueGroupsLen","valueGroup","valueGroupObjects","valueIndex","createWithIdAndMeasure","createWithMeasure","getColorForSeriesValue","identityFields","dvValues","behaviors","SelectionManager","utility","SankeyDiagram","constructorOptions","nodeWidth","curvatureOfLinks","getProperties","objectKey","propKey","visualsInitOptions","selectionManager","colours","DataColorPalette","links","Links","nodes","Nodes","sankeyDiagramDataView","findNodePosition","getPositiveNumber","Infinity","colourOfLabels","allCategories","valueFormatterForCategories","valuesFormatterForWeigth","labelColour","shiftOfColour","secondCategories","valuesColumn","weightValues","formatOfWeigth","linksObjects","identities","getColour","destination","weigth","forEach","some","selectionIds","formattedValue","formattedName","colour","inputWeight","outputWeight","DefaultColourOfNode","getAllColors","sourceNode","destinationNode","link","linkColour","DefaultColourOfLink","getTooltipDataForLink","updateValueOfNode","getTooltipForNode","sourceNodeName","destinationNodeName","linkWeight","formattedLinkWeight","rows","reduce","previousValue","nodeName","nodeWeight","formattedNodeWeigth","isVisibleLabels","findNodePositionByX","findNodePositionByY","nextNodes","previousNodes","isRecursiveDependencies","every","previousNode","nextNode","getScaleByAxisX","scaleByAxisX","numberOfColumns","currentX","maxIndex","sumValueOfNodes","maxValueOfNodes","firstNode","secondNode","getScaleByAxisY","scaleByAxisY","numberOfRows","NodePadding","shiftByAxisY","firstLink","secondLink","firstY","secondY","shiftByAxisYOfLeftLink","shiftByAxisYOfRightLink","dySource","dyDestination","nodesSelection","linksSelection","renderLinks","renderNodes","bindSelectionHandler","nodesEnterSelection","nodeElements","Node","NodeRect","NodeLabel","rgb","darker","getLabelPositionByAxisX","isNotVisibleLabel","labelPositionByAxisX","getCurrentPositionOfLabelByAxisX","MinWidthOfLabel","isLabelLargerWidth","shiftByAxisX","linksElements","Link","getSvgPath","x0","xi","x3","y0","interpolateNumber","isEqual","getSelectionIds","selectMany","then","setSelection","stopPropagation","clear","selectionDeffered","id","$","when","apply","selectedNodesSelection","selectedId","selectedLinksSelection","enumerateLinks","Source","Destination","Weight","bulletChartProps","targetValue","minimumPercent","needsImprovementPercent","satisfactoryPercent","goodPercent","veryGoodPercent","maximumPercent","targetValue2","badColor","needsImprovementColor","satisfactoryColor","goodColor","veryGoodColor","bulletColor","axisColor","measureUnits","unitsColor","bulletChartRoleNames","needsImprovementValue","satisfactoryValue","goodValue","veryGoodValue","Orientation","HORIZONTALLEFT","HORIZONTALRIGHT","VERTICALTOP","VERTICALBOTTOM","createEnumType","BulletChart","baselineDelta","model","bulletChartSettings","reverse","vertical","DefaultStyleProperties","viewportIn","ScrollBarSize","FontFamily","defaultSettings","bulletModel","bulletValueFormatString","barRects","valueRects","targetValues","DefaultSubtitleFontSizeInPt","MaxLabelWidth","categoryFormatString","categoryValuesLen","toolTipItems","minimum","satisfactory","good","maximum","needsImprovement","veryGood","categoryIdentity","StartMarginHorizontal","labelWidth","BiggestLabelWidth","BiggestLabelHeight","col","currentVal","viewportLength","MaxLabelHeight","sortedRanges","descending","clamp","firstScale","secondScale","thirdScale","fourthScale","fifthScale","lastScale","valueScale","firstColor","secondColor","thirdColor","fourthColor","lastColor","addItemToBarArray","barIndex","minTickSize","round","axisValues","bar","categoryLabel","StartMarginVertical","SpaceRequiredForBarVertically","SpaceRequiredForBar","collection","body","bulletBody","scrollContainer","bulletGraphicsContext","BulletWebBehavior","TextMeasurementHelper","estimateSvgTextBaselineDelta","ClearViewport","viewportScroll","setUpBulletsVertically","setUpBulletsHorizontally","calculateLabelWidth","barData","reversed","BarMargin","calculateLabelHeight","measureSvgTextHeight","reveresed","rects","barSelection","rectSelection","bullets","BulletSize","valueSelection","markerSelection","MarkerMarginHorizontal","transform-origin","xLocation","yLocation","AxisFontSizeInPt","getBoundingClientRect","SubtitleMargin","targetCollection","MarkerMarginVertical","enumerateValues","enumerateOrientation","enumerateAxis","enumerateColors","Value","TargetValue","Minimum","NeedsImprovement","Satisfactory","Good","VeryGood","Maximum","TargetValue2","estimateSvgTextRect","ensureDOM","spanElement","svgTextElement","canvasCtx","getContext","measureSvgTextRect","visibility","font-family","font-style","fontStyle","white-space","whiteSpace","getBBox","estimatedTextProperties","getAnimationDuration","WordCloudScaleType","VisualLayout","defaultViewport","defaultMargin","marginValue","set","restrictToMinMax","viewportValue","viewportInValue","keys","WordCloud","fakeViewport","canvasViewport","DefaultMargin","wordsSelection","wordsContainerSelection","Words","canvas","document","createElement","frequencies","texts","categoryObject","explore","util","getRandomColor","wordCloudTexts","count","hexToRgb","minFontSize","maxFontSize","minAngle","maxAngle","maxNumberOfOrientations","stopWords","stopWordsArray","maxNumberOfWords","isRotateText","isBrokenText","isRemoveStopWords","isDefaultStopWords","getNumberFromObjects","rotateText","words","split","StopWordsDelemiter","defaultValue","parseNumber","MAX_VALUE","parsedValue","computePositions","onPositionsComputed","getCanvasContext","surface","specialViewport","setTimeout","computeCycle","wordsForDraw","word","ratio","random","generateSprites","sprite","findPosition","updateBorders","leftBorder","rightBorder","currentWord","clearRect","pixels","quantityOfWords","currentWordData","widthOfWord","heightOfWord","save","font","Size","measureText","rotate","sr","sin","Radians","cr","cos","widthCr","widthSr","heightCr","heightSr","fillText","padding","lineWidth","strokeText","restore","xOff","yOff","getImageData","width32","x_1","y_1","seen","seenRow","k","l","index_1","m","point","startPoint","delta","sqrt","dt","archimedeanSpiral","checkIntersect","checkIntersectOfRectangles","shiftWidth","lx","sx","msx","lastSprite","leftMask","rightMask","mask","intersectMask","fillStyle","strokeStyle","textAlign","getReducedText","brokenStrings","getBrokenWords","punctuatuinRegExp","whiteSpaceRegExp","RegExp","Punctuation","join","words_1","replace","stopWords_1","StopWords","removeWord","toLocaleLowerCase","test","getWords","sortedValues","a","returnValues","getFontSize","getAngle","wordIndex","dataBeforeRender","weight","buffer","logn","MinAngle","MaxAngle","viewportInIsZero","UpdateSize","wordCloudDataView","fakeWidth","fakeHeight","animatedWordSelection","wordElements","Word","animation","scaleMainView","RenderDelay","setOpacity","MaxOpacity","selectedColumns","MinOpacity","opacityValue","disableAnimation","elementAnimation","durationAnimation","width2","height2","scaleByX","scaleByY","mainSVGRect","wordCategoriesIndex_1","callback","MaxNumberOfWords","implicit","clauses","role","direction","hex","shorthandRegex","exec","parseInt","red","green","blue","TableViewFactory","createTableView","TableView","baseContainer","visibleGroupContainer","SetDefaultOptions","rowHeight","defaultRowHeight","getDatumIndex","dataReset","_data","setTotalRows","scrollTop","_totalColumns","_totalRows","defaultColumns","groupedData","totalRows","totalColumns","totalItems","HORIZONTAL","VERTICAL","n","cellSelection","order","cellUpdateSelection","realColumnNumber","rowUpdateSelection","chicletSlicerProps","showDisabled","multiselect","header","fontColor","background","outline","outlineColor","outlineWeight","transparency","selectedColor","unselectedColor","disabledColor","borderStyle","images","imageSplit","stretchImage","bottomImage","selectedPropertyIdentifier","filterPropertyIdentifier","hasSavedSelection","ChicletBorderStyle","ROUNDED","CUT","SQUARE","ChicletSlicerShowDisabled","INPLACE","BOTTOM","HIDE","ChicletSlicer","ChicletSlicerWebBehavior","borderBottomWidth","headerText","marginLeft","marginTop","slicerText","hoverColor","slicerItemContainer","localizedSelectAllText","ChicletSlicerChartConversion","ChicletSlicerConverter","convert","slicerData","categorySourceName","slicerSettings","slicerDataPoints","hasSelectionOverride","initContainer","existingDataView","resetScrollbarPosition","DataViewAnalysis","hasSameCategoryIdentity","waitingForData","updateInternal","onResizing","finalViewport","enumerateRows","enumerateHeader","enumerateGeneral","enumerateImages","updateSlicerBodyDimensions","tableView","getSavedSelection","JSON","parse","ex","setSavedSelection","isSelectionSaved","persistProperties","merge","stringify","isSelectionLoaded","selectable","extraSpaceForCell","cellTotalInnerPaddings","cellTotalInnerBorders","getChicletTextProperties","hasImage","any","imageURL","inArray","getSlicerBodyViewport","slicerBodyViewport","slicerContainer","Container","slicerHeader","Header","Clear","HeaderText","margin-left","margin-top","border-style","getBorderStyle","border-color","border-width","slicerBody","Body","rowEnter","rowSelection","listItemElement","ItemContainer","rowUpdate","trim","background-color","chicletTotalInnerRightLeftPaddings","slicerImg","border-radius","getBorderRadius","hexToRGBString","slicerItemContainers","slicerItemLabels","slicerItemInputs","Input","slicerClear","overrideSelectionFromData","styleSlicerInputs","rowExit","tableViewOptions","getRowHeight","loadMoreData","onLoadMoreData","scrollEnabled","segment","headerHeight","getHeaderHeight","slicerBodyHeight","slicerViewport","DefaultFontFamily","textSettings","outlineElement","borderType","Image","includeEmptyGroups","suppressDefaultTitle","dataViewCategorical","categoryColumnRef","numberOfCategoriesSelectedInData","numberOfScopeIds","isInvertedSelectionMode","scopeIds","SQExprConverter","asScopeIdsContainer","isNot","isSelectionModeInverted","setSelectionModeInverted","isCategoryColumnSelected","categoryIsSelected","ChicletSlicerTextMeasurementHelper","filterPropertyId","slicers","loadSelection","mouseOver","mouseOut","renderMouseover","preventDefault","altKey","selectedIndexes","selIndex","persistSelectionFilter","saveSelection","savedSelectionIds","selectedDataPoints","selectionIdKeys","selectedIds","selectedItems","ChordChart","prevAxisVisible","getDefaultDataPointColor","getLabelsColor","getLabelsFontSize","dataMatrix","toolTipData","sliceTooltipData","seriesName","catIndex","isDiffFromTo","labelData","chordChartProps","iLen","seriesNameStr","getSeriesName","totalFields","union_arrays","getValidArrayLength","isCategory","thisCategoryObjects","barColor","jLen","elementValue","row","isInt","toFixed","chordLayout","chord","matrix","unitLength","convertToChordArcDescriptor","groups","tickUnit","pow","differentFromTo","getShowAllDataPoints","showLabels","getLabelsShow","showAxis","getAxisShow","array","labelDataPoint","calculateRadius","hw","denom","exp","drawDefaultCategoryLabels","chordData","InnerArcRadiusRatio","outerArc","OuterArcRadiusRatio","getChordChartLabelLayout","drawDefaultLabelsForChordChart","VisualClassName","prevAxisShow","sm","sliceShapes","sliceClass","insert","ids","target","chordShapes","chordClass","chords","drawTicks","subindex","cleanTicks","tickLines","tickLineClass","tickTexts","tickTextClass","tickPairClass","sliceTicksClass","tickShapes","animDuration","tickPairs","retval","v","divider","unitStr","retv","DefaultLabelColor","DefaultLabelsFontSize","selectLabels","isDonut","forAnimation","hasKey","hasDataPointIdentity","getIdentifier","labelsClass","newLabels","innerLinePointMultiplier","lineClass","midPoint","PolylineOpacity","minAvailableSpace","fromPointToPixel","colorInstance","obj","res","DataRoleHelper","EnhancedScatterChart","AxisFontSize","_margin","_viewportIn","substractMargin","_viewport","getCustomSymbolType","shape","customSymbolTypes","circle","cross","diamond","ry","tan","rx","square","triangle-up","triangle-down","star","results","currX","currY","hexagon","r2","uparrow","downarrow","entries","BaseAnimator","CartesianChartBehavior","ScatterChartWebBehavior","backgroundGraphicsContext","mainGraphicsG","MainGraphicsContextClassName","svgDefaultImage","keyArray","axisTitleOnByDefault","toReturn","valueAxisObject","secShow","secPosition","secStart","secEnd","secShowAxisTitle","secAxisStyle","categoryQueryName","scatterChartProps","dataValues","useShape","getMeasureIndexOfRole","useCustomColor","dvSource","scatterMetadata","getMetadata","getDefaultPointLabelSettings","fillPoint","backdrop","url","crosshair","backdropObject","crosshairObject","outlineObject","legendItems","createSeriesLegend","sizeRange","getSizeRangeForGroups","xStart","xEnd","yStart","yEnd","xCol","cols","yCol","grouping","Circle","dataViewValueGroups","sizeColumnIndex","sizeColumn","ScatterChart","getMeasureValue","currentRange","getRangeForColumn","sizeCol","colorFillCol","shapeCol","imageCol","rotationCol","backdropCol","xStartCol","xEndCol","yStartCol","yEndCol","xIndex","yIndex","sizeIndex","gradientIndex","colorFillIndex","shapeIndex","imageIndex","rotationIndex","backdropIndex","xStartIndex","xEndIndex","yStartIndex","yEndIndex","firstGroup","measureCount","getDefaultMeasureIndex","colorFill","image","usedIndexes","found","createLazyFormattedCategory","Lazy","indicies","dataValueSource","categoryIdx","seriesIdx","measureX","measureY","measureSize","measureColorFill","measureShape","measureImage","measureRotation","measureBackdrop","measureXStart","measureXEnd","measureYStart","measureYEnd","xVal","yVal","shapeSymbolType","hasNullValue","measureSource","sizeMeasure","formattedCategory","svgurl","legendLabelFontSize","LegendLabelFontSizeDefault","adjustViewportbyBackdrop","img","that","src","onload","oldBackdrop","deltaWidth","deltaHeight","legendViewport","updateAxis","sortedData","scatterMarkers","drawScatterMarkers","getEnhanchedScatterChartLabelLayout","clonedDataPoints","cloneDataPoints","drawDefaultLabelsForDataPointChart","DataLabelsOffset","dataPointsSelection","plotContext","cbehaviorOptions","Array","dataPoints_1","clonedDataPoint","getCategoryAxisFill","getBubbleRadius","labelMargin","getValueAxisFill","renderCrossHair","crossHair","hLine_1","vLine_1","text_1","addCrossHair_1","xCoord","yCoord","invert","coordinates","svgNode","viewportElement","scaledRect","domRect","ratioX","ratioY","Double","equalWithPrecision","renderBackground","yAxis","xZeroTick","xZeroColor","AxisTextProperties","yZeroTick","yZeroColor","scatterData","markers","shouldEnableFill","ImageClasses","DotClasses","stroke-opacity","getBubbleOpacity","area","valueAxisDisplayUnits","LabelDisplayUnitsDefault","categoryAxisDisplayUnits","minY","maxY","minX","maxX","combinedXDomain","legendDataPointLength","categoricalDataView","enumerateCategoryLabels","getLegendValue","legendLabelColor","DefaultBubbleOpacity","DimmedBubbleOpacity","X","Gradient","ColorFill","Shape","Rotation","Backdrop","X Start","X End","Y Start","Y End","sample","categoryLabels","THREE","WebGLHeatmap","GlobeMapCanvasLayers","GlobeMap","renderData","locationsToLoad","locationsLoaded","renderLoopEnabled","needsRender","container","readyToRender","globeMapLocationCache","setup","initSettings","initTextures","initMercartorSphere","initZoomControl","initScene","initHeatmap","composeRenderData","initRayCaster","autoRotate","earthRadius","cameraRadius","earthSegments","heatmapSize","heatPointSize","heatIntensity","heatmapScaleOnZoom","barWidth","barHeight","rotateSpeed","zoomSpeed","cameraAnimDuration","clickInterval","clock","Clock","renderer","WebGLRenderer","antialias","preserveDrawingBuffer","domElement","camera","PerspectiveCamera","orbitControls","OrbitControls","scene","Scene","setSize","setClearColor","z","maxDistance","minDistance","ambientLight","AmbientLight","light1","DirectionalLight","light2","earth","createEarth","add","_zis","shouldRender","getDelta","setEarthTexture","intersectBars","heatmap","display","e","geometry","MercartorSphere","material","MeshPhongMaterial","mapTextures","side","DoubleSide","shininess","emissive","Mesh","zoomClicked","zoomDirection","enabled","enableZoom","constraint","dollyOut","dollyIn","animateCamera","rotateCam","deltaX","enableRotate","rotateLeft","offsetHeight","rotateUp","zoomControlWidth","zoomControlHeight","startX","startY","gap","zoomCss","zIndex","zoomContainer","zoomControl","zoomIn","zoomOut","level","getBingMapCanvas","createTexture","texture","Texture","needsUpdate","resolution","intensityToAlpha","heatTexture","MeshBasicMaterial","transparent","SphereGeometry","mesh","distance","selectedBar","cleanHeatAndBar","aspect","updateProjectionMatrix","barsGroup","renderMagic","defferedRender","Object3D","barMaterials","shading","FlatShading","averageBarVector","Vector3","renderDatum","lat","lng","heat","addPoint","latRadians","lngRadians","measuresBySeries","dataPointToolTip","heightBySeries","c","seriesToolTipData","previousMeasureValue","CubeGeometry","multiplyScalar","lookAt","getToolTipDataForSeries","blur","dataPointValue","categoricalView","locations","heightIndex","intensityIndex","longitudeIndex","latitudeIndex","locationType","heights","heightsBySeries","toolTipDataBySeries","heats","latitudes","longitudes","locationDispName","heightDispName","heatDispName","heightFormat","heatFormat","locationCategory","maxHeat","heatFormatter","heightFormatter","latlng","place","placeKey","latitude","longitude","location","geocodeRenderDatum","geocoder","Services","GeocodingManager","geocode","services","always","deferredRenderTimerId","rayCaster","Raycaster","mouseDownTime","mousePosNormalized","Vector2","mousePos","clientX","clientY","now","hoveredBar","shiftKey","center","copy","normalize","originalEvent","multiply","setFromCamera","intersects","intersectObjects","object","ToolTipInstance","done","startTime","endTime","startPos","endPos","easeInOut","t","onUpdate","clearTimeout","extension","getExtension","loseContext","dispose","off","widthSegments","heightSegments","interplolate","interpolateVertex","u","maxLng","maxLat","sphereX","sphereY","sphereZ","planeX","planeY","planeZ","interpolateUV","normalizedV","Geometry","vertices","uvs","verticesRow","uvsRow","v1","v2","v3","v4","n1","n2","n3","n4","uv1","uv2","uv3","uv4","normals","faces","Face4","faceVertexUvs","computeCentroids","computeFaceNormals","boundingSphere","Sphere","generateQuads","quad","loadTile","template","numServers","server","language","navigator","coords","getCoords","tile","tilesLoaded","canvasContext","drawImage","tileSize","numTiles","trigger","crossOrigin","last","chr","charAt","numSegments","canvasSize","canvasElem","preferredTypes","geography","address","city","continent","country","county","postalCode","region","stateOrProvince","Height","Heat","custom","CreateClassAndSelector","RadarChartWebBehavior","RadarChart","DimmedAreaFillOpacity","AreaFillOpacity","serieIdentity","kLen","dataPointIdentity","isInteractiveChart","segments","Segments","chart","Chart","radarChartData","dataViewMetadataColumn","parseLegendProperties","SegmentFactor","Scale","drawCircularSegments","drawAxes","drawAxesLabels","drawChart","drawDataLabels","getRadarChartLabelLayout","getDataPoints","stack","halfHeight","halfWidth","formmater","maxDataPoint","factor","levels","SegmentLevels","levelFactor","SegmentNode","getAllDataPointsList","AxisNode","AxisLabel","dotRadius","calculatePoints","points","ChartNode","polygon","ChartPolygon","dots","ChartDot","dataPointsToBind","series_3","serie","series_4","series_5","HistogramChartWarning","ErrorInvalidDataValues","Histogram","histogramConstructorOptions","ColumnPadding","MinColumnHeight","NumberOfLabelsOnAxisY","MinNumberOfBins","MaxNumberOfBins","MinPrecision","TooltipDisplayName","SeparatorNumbers","LegendSize","AxisSize","ExcludeBrackets","IncludeBrackets","visualsOptions","axisX","axisY","Legends","histogramLayout","numericalValues","shiftByValues","sumFrequency","getValuesByFrequencies","frequency","histogram","bins","bin","filteredValues","isValueContainedInRange","getData","sourceValues","getRange","getTooltipData","step","includeLeftBorder","getLegendText","rangeToString","histogramSettings","DefaultHistogramSettings","fillColor","getBins","getFrequency","binsNumber","validateData","histogramDataView","updateColumnsSelection","countOfValues","getColumnHeight","rangesToArray","leftBracket","rightBracket","legendElements","legendSelection","datalegends","getDataLegends","bottomLegendText","FrequencyText","DensityText","columnSelection","Frequency","ColorBarChart","table","chartData","rangeRoundBands","rangeBand","getFill","GroupingOrMeasure","AxisScale","MaxXAxisHeight","LabelMargin","DefaultRadius","DefaultStrokeWidth","DefaultDataPointColor","DotPlotProperties","DotPlot","dotPlotSelectors","svgPlotSelector","plotSelector","plotGroupSelector","axisSelector","xAxisSelector","circleSeletor","DefaultDotPlotSettings","categorySettings","strokeWidth","defaultSetting","dataPointsGroup","getCategorySettings","categoryColumn","diameter","dotsTotalHeight","maxDots","values_1","length_1","minDots","dotsScale","categorySelectionId","DotplotBehavior","dotPlot","dotPlotDataView","renderAxis","drawDotPlot","getEnhanchedDotplotLayout","enumerateCategories","defaultDotPlotSettings","setting","circleSelection","categoryLabelColor","categoriesSettings","linkColorType","byWeight","byLinkType","interactive","forceProps","showArrow","colorLink","thickenLink","displayImage","defaultImage","imageUrl","imageExt","nameMaxLength","highlightReachableLinks","charge","ForceGraph","scale1to10","minFiles","maxFiles","rangeRound","getLinkColor","filecount","linkTypes","defaultLinkColor","getDefaultOptions","showDataLabels","defaultLinkHighlightColor","defaultLinkThickness","updateOptions","enumerateNodes","enumerateSize","linkedByName","linkDataPoints","linkTypeCount","sourceCol","targetCol","weightCol","linkTypeCol","sourceTypeCol","targetTypeCol","metadataColumns","categoryTargetFormatString","weightFormatString","adj","forceLayout","gravity","linkDistance","tick","updateNodes","paths","fadePath","fadeNode","substr","oldNodes","limitX","limitY","getPath","dr","theta","atan2","d90","dtxs","dtys","parentNode","insertBefore","o","isReachable","visited","name_1","cur","pop","nb","isConnected","thisOpacity","setAttribute","Target","LinkType","SourceType","TargetType","PercentFormat","MillisecondsInADay","MillisecondsInWeek","MillisecondsInAMonth","MillisecondsInAYear","DefaultDateType","dateTypeSelector","ChartLineHeight","PaddingTasks","day","week","month","year","GanttChartProps","taskCompletion","taskLabels","taskResource","ganttDateType","Selectors","ChartLine","AxisGroup","Domain","AxisTick","Tasks","SingleTask","TaskRect","TaskProgress","TaskResource","SingleMilestone","TaskLabels","TaskLines","SingleTaskLine","LegendItems","LegendTitle","Gantt","getMaxTaskOpacity","DefaultValues","MaxTaskOpacity","getMinTaskOpacity","MinTaskOpacity","createViewport","updateChartSize","GanttChartBehavior","ganttDiv","ganttSvg","lineGroup","chartGroup","taskGroup","clearViewport","createSeries","tasks","groupBy","taskType","taskTypes","getAllTasksTypes","types","taskLabelsShow","taskLabelsColor","TaskLabelColor","taskLabelsFontSize","LabelFontSize","taskLabelsWidth","TaskLabelWidth","taskProgressColor","ProgressColor","taskResourceColor","TaskResourceColor","taskResourceFontSize","ResourceFontSize","taskResourceShow","dateType","LegendFontSize","typeName","dateFormat","numberFormat","dvColumn","_b","_c","dvCategory","startDateFormatter","durationFormatter","completionFormatter","isValidDate","date","convertToDecimal","number","createTasks","formatters","columnSource","child","dateString","getTaskProperty","completionValue","completion","tasksTypeColor","task","resource","TaskColor","time","getTooltipInfo","findIndex","unique","timeInterval","tooltipDataArray","getDate","toLocaleDateString","isChartHasTask","tasksSortedByStartDate","sortBy","tasksSortedByEndDate","dateTypeMilliseconds","getDateType","startDate","endDate","valueOf","axisLength","ResourceWidth","timeScale","renderTasks","createMilestoneLine","updateTaskLabels","updateElementsPositions","taskSelection","milliSeconds","ticksCount","dataTypeDatetime","ValueType","fromPrimitiveTypeAndCategory","PrimitiveType","ganttFormatString","taskLineCoordinateX","getTaskLabelCoordinateY","taskRect","getBarYCoordinate","taskDurationToWidth","getBarHeight","taskProgress","ProgressBarHeight","setTaskProgress","taskIndex","getTaskLabelFontSize","fraction","progress","lineNumber","getTooltipForMilstoneLine","timestamp","milestoneTitle","stringDate","toDateString","tooltip","line","getMilestoneLineLength","chartLineSelection","numOfTasks","enumerateLegendOptions","LegendLabelColor","taskSeries","enumerateTaskCompletion","enumerateTaskLabels","enumerateDateType","AxisTickSize","TaskLineWidth","requiredTypes","integer","Task","StartDate","Duration","Completion","Resource","ganttMaxOpacity","ganttMinOpacity","GanttChartWarning","pt","Months","WeekDays","GranularityType","SelectedCellColorProp","UnselectedCellColorProp","TimeRangeColorProp","TimeRangeSizeProp","TimeRangeShowProp","LabelsColorProp","LabelsSizeProp","LabelsShowProp","CalendarMonthProp","CalendarDayProp","WeekDayProp","GranularityNames","granularityType","quarter","TimelineGranularity","datePeriods","shortMonthName","resetDatePeriods","getDatePeriods","getExtendedLabel","extendedLabel","setExtendedLabel","createLabels","granularity","lastDatePeriod","sameLabel","generateLabel","addDate","identifierArray","determineWeek","determineYear","setNewEndDate","splitPeriod","newFraction","newDate","oldDatePeriod","newDateObject","splice","previousMonth","nextMonth","countWeeks","totalDays","getFullYear","getMonth","lastMonth","inPreviousYear","dateOfFirstWeek","Timeline","calendar","getDateOfFirstWeek","weeks","firstDay","getFirstMonthOfYear","getFirstDayOfYear","DayGranularity","_super","arguments","getType","splitDate","firstDatePeriod","secondDatePeriod","datePeriod","MonthGranularity","WeekGranularity","QuarterGranularity","quarterText","getQuarterStartDate","YearGranularity","TimelineGranularityData","granularities","setDatesRange","lastDate","dates","endingDate","nextDay","previousDay","prevDay","setDate","addGranularity","getGranularity","createGranularities","dayLabels","weekLabels","monthLabels","quarterLabels","yearLabels","Utils","getStartSelectionDate","timelineData","currentGranularity","selectionStartIndex","getEndSelectionDate","selectionEndIndex","getEndSelectionPeriod","getCellColor","cellFormat","inSelectedPeriods","colorInProperty","colorOutProperty","getGranularityType","granularityName","getGranularityName","separateSelection","startDateIndex","endDateIndex","startRatio","getDateRatio","endRatio","startFration","fromStart","dateDifference","periodDifference","timeRangeText","startSelectionDateArray","endSelectionDateArray","dateRangeText","unseparateSelection","separationIndex","Calendar","calendarFormat","firstDayOfWeek","weekDayProperty","firstMonthOfYear","firstMonthProperty","firstDayOfYear","firstDayProperty","quarterFirstMonths","getFirstDayOfWeek","quarterIndex","isChanged","calculateDateOfFirstWeek","getDay","requiresNoUpdate","foreignSelection","timelineMargins","LeftMargin","RightMargin","TopMargin","BottomMargin","CellWidth","CellHeight","StartXpoint","StartYpoint","ElementWidth","MinCellWidth","MaxCellHeight","PeriodSlicerRectWidth","PeriodSlicerRectHeight","defaultTimelineProperties","DefaultLabelsShow","TimelineDefaultTextSize","TimelineDefaultCellColor","TimelineDefaultCellColorOut","TimelineDefaultTimeRangeShow","DefaultTimeRangeColor","DefaultGranularity","DefaultFirstMonth","DefaultFirstDay","DefaultFirstWeekDay","timelineSelectors","TimelineVisual","SelectionRangeContainer","textLabel","LowerTextCell","UpperTextCell","UpperTextArea","LowerTextArea","RangeTextArea","CellsArea","CursorsArea","MainArea","SelectionCursor","Cell","CellRect","VertLine","TimelineSlicer","PeriodSlicerGranularities","PeriodSlicerSelection","PeriodSlicerSelectionRect","PeriodSlicerRect","selectionIndex","timelineProperties","cellWidth","dragstarted","dragged","dragended","changeGranularity","timelineGranularityData","initialized","textYPosition","cellsYPosition","topMargin","startXpoint","startYpoint","cellHeight","elementWidth","timelineDiv","timeline","rangeText","yearLabelsElement","quarterLabelsElement","monthLabelsElement","weekLabelsElement","dayLabelsElement","cellsElement","cursorGroupElement","timelineDatapoints","selectPeriod","updateCursors","fillCells","timelineFormat","renderCursors","renderTimeRangeText","rangeTextFormat","drawGranular","dragPeriodRectState","selectorContainer","fillRect","selectorPeriods","fillVertLine","textLabels","selectedText","selRects","clickHandler","dragPeriodRect","periodSlicerRect","redrawPeriod","setMeasures","labelFormat","datePeriodsCount","labelSize","sizeProperty","showProperty","svgHeight","visualChangeOnly","newObjects_1","oldObjects_1","metadataChanged","unavailableType","unavailableChildIdentityField","dataViewTree","childIdentityFields","createTimelineOptions","tree","columnExp","ref","prepareValues","Boolean","String","createTimelineData","years","actualEndDate","daysPeriods","prevStartDate","prevEndDate","changedSelection","newGranularity","fillTimelineFormat","elementsCount","cursorDataPoints","visualChange","validOptions","periodNameIndex","isDataNotMatch","cursorIndex","columnIdentity","timelineElements","timelineElements_1","currentTimePeriod","countFullCells","timelineDatapointsCount","svgWidth","overflow-x","overflow-y","fixedTranslateString","translateString","extendedLabels","yDiff","renderCells","labelsElement","isLast","labelTextSelection","labelsGroupSelection","halfFirstTextWidth","halfSecondTextWidth","diff","labelFormattedTextOptions","colorProperty","totalX","cellsSelection","keyEvent","dragging","currentCursor","str","cursorOverElement","findCursorOverElement","currentlyMouseOverElement","currentlyMouseOverElementIndex","cursorSelection","timeRangeFormat","actualText","lower","SQExprBuilder","upper","filterExpr","between","SemanticFilter","fromSQExpr","onSelect","enumerateRangeHeader","enumerateCells","enumerateCalendar","enumerateWeekDay","dataview","fillSelected","fillUnselected","Time","weekDay","rangeHeader","cells","StreamGraphAxisGraphicsContextClassName","StreamGraphXAxisClassName","StreamGraphYAxisClassName","StreamGraphDefaultAxisColor","StreamGraphDefaultFontSizeInPoints","DefaultLegendFontSizeInPt","StreamGraphDefaultFontFamily","StreamGraphDefaultFontWeight","StreamGraphDefaultSettings","categoryAxisSettings","valueAxisSettings","StreamGraph","streamGraphSettings","updateViewPort","renderXAxisLabels","renderYAxisLabels","getWiggle","Layer","drawAxis","shiftY","shiftX","getTextPropertiesFunction","setMaxTicks","MaxNumberOfAxisXValues","YAxisLabel","marginLeft_1","isXAxisOn","isXTitleOn","height_1","yAxisText","yAxisClass_1","XAxisLabel","marginBottom_1","isYAxisOn","isYTitleOn","width_1","xAxisText","xAxisClass_1","streamGraphData","maxSize","maxTicks","getTicksByAxis","getFittedTickLength","getFittedTickValues","measureTickFunction","getMeasureTickFunction","measureTicks","maxWidthOf2Ticks","tickPairsWidths","currentMaxTicks","indexes","takeEvery","ticksIndexes","measureFunction","cache","enumerateValueAxisValues","enumerateCategoryAxisValues","wiggle","sunburstRoleNames","Sunburst","total","setAllUnhide","dataRootNode","partition","path","depth","highlightPath","percentageFixedText","percentage","toPrecision","onResize","getTreePath","current","parent","unshift","measureSvgTextElementWidth","sunBurst","setUnhide","parentsArray","minOpacity","covertTreeNodeToSunBurstNode","originParentNode","sunburstParentNode","pathIdentity","valueToSet","newSunNode","newChild","colorScale","getNewColorScale","roleNames","Groups","LineDotChart","Identity","axisY2","legends","resize","draw","setIsStopped","isstopped","lineoptions","lineFill","lineThickness","dotoptions","dotFill","dotSizeMin","dotSizeMax","counteroptions","counterTitle","misc","isanimated","selectDot","dotelement","dot","effectiveWidth","effectiveHeight","value_sum","yAxis2","generateAxisLabels","lineFillColorHelper","dotFillColorHelper","xAxisTitle","yAxisTitle","renderLegends","playBtn","lineSelection","totalLength","getTotalLength","line_left","getPointAtLength","line_right","href","interrupt","ease","point_time","counter_time","lineTipSelection","showDataPoint","hideDataPoint","delay","pointDelay","lineTextSelection","POSITIVE_INFINITY","num","animation_duration","val","plugins","sunburstCustom","watermarkKey","asterPlot","tornadoChart","sankeyDiagram","mekkoChart","customizeQuery","getSortableRoles","visualSortableOptions","bulletChart","wordCloud","chicletSlicer","chordChart","enhancedScatterChart","radarChart","colorBarChart","forceGraph","gantt","streamGraph","lineDotChart","visualPluginFactory","createCustomVisualPluginService","CustomVisualPluginService","initCustomVisualPlugins","getVisuals","registry","customVisualPlugins","names","getPlugin","plugin","createPlugin","WebColumnChartAnimator","VisualPluginService"],"mappings":"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","file":"CustomVisuals.min.js","sourcesContent":["/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *   \n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *   \n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nvar THREE: any;\nvar WebGLHeatmap;\nvar GlobeMapCanvasLayers: JQuery[];\n\nmodule powerbi.visuals.samples {\n    import TouchRect = controls.TouchUtils.Rectangle;\n    import DataRoleHelper = powerbi.data.DataRoleHelper;\n\n    interface RenderData {\n        lat: number;\n        lng: number;\n        height: number;\n        heightBySeries: number[];\n        seriesToolTipData: any[];\n        heat: number;\n        toolTipData: any;\n    }\n\n    export class GlobeMap implements IVisual {\n        public static MercartorSphere: any;\n        private viewport: IViewport;\n        private container: JQuery;\n        private domElement: HTMLElement;\n        private camera: any;\n        private renderer: any;\n        private scene: any;\n        private orbitControls: any;\n        private earth: any;\n        private settings: any;\n        private renderData: RenderData[] = [];\n        private heatmap: any;\n        private heatTexture: any;\n        private mapTextures: any[];\n        private barsGroup: any;\n        private readyToRender: boolean;\n        private categoricalView: any;\n        private deferredRenderTimerId: any;\n        private globeMapLocationCache: any;\n        private locationsToLoad: number = 0;\n        private locationsLoaded: number = 0;\n        private renderLoopEnabled = true;\n        private needsRender = false;\n        private mousePosNormalized: any;\n        private mousePos: any;\n        private rayCaster: any;\n        private selectedBar: any;\n        private hoveredBar: any;\n        private averageBarVector: any;\n        private zoomControl: any;\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: 'Category',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Location'),\n                    preferredTypes: [\n                        { geography: { address: true } },\n                        { geography: { city: true } },\n                        { geography: { continent: true } },\n                        { geography: { country: true } },\n                        { geography: { county: true } },\n                        { geography: { place: true } },\n                        { geography: { postalCode: true } },\n                        { geography: { region: true } },\n                        { geography: { stateOrProvince: true } },\n                    ],\n                },\n                {\n                    name: 'Series',\n                    kind: powerbi.VisualDataRoleKind.Grouping,\n                    displayName: \"Legend\",\n                },\n                {\n                    name: 'X',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Longitude',\n                    description: 'Use to override the longitude of locations',\n                    preferredTypes: [{ geography: { longitude: true } }],\n                },\n                {\n                    name: 'Y',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Latitude',\n                    description: 'Use to override the latitude of locations',\n                    preferredTypes: [{ geography: { latitude: true } }],\n                },\n                {\n                    name: 'Height',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Bar Height',\n                },\n                {\n                    name: 'Heat',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Heat Intensity',\n                }\n            ],\n            objects: {\n                general: {\n                    displayName: data.createDisplayNameGetter('Visual_General'),\n                    properties: {\n                        formatString: {\n                            type: { formatting: { formatString: true } },\n                        },\n                    },\n                },\n                legend: {\n                    displayName: data.createDisplayNameGetter('Visual_Legend'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendPosition'),\n                            type: { formatting: { legendPosition: true } }\n                        },\n                        showTitle: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendShowTitle'),\n                            type: { bool: true }\n                        },\n                        titleText: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendTitleText'),\n                            type: { text: true }\n                        }\n                    }\n                },\n                dataPoint: {\n                    displayName: data.createDisplayNameGetter('Visual_DataPoint'),\n                    properties: {\n                        defaultColor: {\n                            displayName: data.createDisplayNameGetter('Visual_DefaultColor'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        showAllDataPoints: {\n                            displayName: data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\n                            type: { bool: true }\n                        },\n                        fill: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fillRule: {\n                            displayName: data.createDisplayNameGetter('Visual_Gradient'),\n                            type: { fillRule: {} },\n                            rule: {\n                                inputRole: 'Gradient',\n                                output: {\n                                    property: 'fill',\n                                    selector: ['Category'],\n                                },\n                            },\n                        }\n                    }\n                },\n                categoryLabels: {\n                    displayName: data.createDisplayNameGetter('Visual_CategoryLabels'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        color: {\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                    },\n                },\n            },\n            dataViewMappings: [{\n                conditions: [\n                    { 'Category': { max: 1 }, 'Series': { max: 1 }, 'Height': { max: 1 }, 'Heat': { max: 1 } },\n                ],\n                categorical: {\n                    categories: {\n                        for: { in: 'Category' },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: {\n                        group: {\n                            by: 'Series',\n                            select: [\n                                { bind: { to: 'Height' } },\n                                { bind: { to: 'Heat' } },\n                                { bind: { to: 'X' } },\n                                { bind: { to: 'Y' } },\n                            ],\n                            dataReductionAlgorithm: { top: {} }\n                        }\n                    },\n                    rowCount: { preferred: { min: 2 } }\n                },\n            }],\n            sorting: {\n                custom: {},\n            }\n        };\n\n        public static converter(dataView: DataView): any {\n            return {};\n        }\n\n        public init(options: VisualInitOptions): void {\n            this.container = options.element;\n            this.viewport = options.viewport;\n            this.readyToRender = false;\n            if (!this.globeMapLocationCache) this.globeMapLocationCache = {};\n\n            if (!THREE) {\n                loadGlobeMapLibs();\n            }\n\n            if (THREE) {\n                this.setup();\n            }\n        }\n\n        private setup() {\n            this.initSettings();\n            this.initTextures();\n            this.initMercartorSphere();\n            this.initZoomControl();\n            this.initScene();\n            this.initHeatmap();\n            this.readyToRender = true;\n            this.composeRenderData();\n            this.initRayCaster();\n        }\n\n        private initSettings() {\n            var settings = this.settings = <any>{};\n            settings.autoRotate = false;\n            settings.earthRadius = 30;\n            settings.cameraRadius = 100;\n            settings.earthSegments = 100;\n            settings.heatmapSize = 1000;\n            settings.heatPointSize = 7;\n            settings.heatIntensity = 10;\n            settings.heatmapScaleOnZoom = 0.95;\n            settings.barWidth = 0.3;\n            settings.barHeight = 5;\n            settings.rotateSpeed = 0.5;\n            settings.zoomSpeed = 0.8;\n            settings.cameraAnimDuration = 1000; //ms\n            settings.clickInterval = 200; //ms\n        }\n\n        private initScene() {\n            var viewport = this.viewport;\n            var settings = this.settings;\n            var clock = new THREE.Clock();\n            var renderer = this.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });\n            this.container.append(renderer.domElement);\n            this.domElement = renderer.domElement;\n            var camera = this.camera = new THREE.PerspectiveCamera(35, viewport.width / viewport.height, 0.1, 10000);\n            var orbitControls = this.orbitControls = new THREE.OrbitControls(camera, this.domElement);\n            var scene = this.scene = new THREE.Scene();\n\n            renderer.setSize(viewport.width, viewport.height);\n            renderer.setClearColor(0xbac4d2, 1);\n            camera.position.z = settings.cameraRadius;\n\n            orbitControls.maxDistance = settings.cameraRadius;\n            orbitControls.minDistance = settings.earthRadius + 1;\n            orbitControls.rotateSpeed = settings.rotateSpeed;\n            orbitControls.zoomSpeed = settings.zoomSpeed;\n            orbitControls.autoRotate = settings.autoRotate;\n\n            var ambientLight = new THREE.AmbientLight(0x000000);\n            var light1 = new THREE.DirectionalLight(0xffffff, 0.4);\n            var light2 = new THREE.DirectionalLight(0xffffff, 0.4);\n            var earth = this.earth = this.createEarth();\n\n            scene.add(ambientLight);\n            scene.add(light1);\n            scene.add(light2);\n            scene.add(earth);\n\n            light1.position.set(20, 20, 20);\n            light2.position.set(0, 0, -20);\n\n            var _zis = this;\n\n            requestAnimationFrame(function render() {\n                try {\n                    if (_zis.renderLoopEnabled) requestAnimationFrame(render);\n                    if (!_zis.shouldRender()) return;\n                    orbitControls.update(clock.getDelta());\n                    _zis.setEarthTexture();\n                    _zis.intersectBars();\n                    _zis.heatmap.display(); // Needed for IE/Edge to behave nicely\n                    renderer.render(scene, camera);\n                    _zis.needsRender = false;\t\n                    //console.log(\"render\");\t\t\t\n                } catch (e) {\n                    console.error(e);\n                }\n            });\n        }\n\n        private shouldRender(): boolean {\n            return this.readyToRender && this.needsRender;\n        }\n\n        private createEarth() {\n            var geometry = new GlobeMap.MercartorSphere(this.settings.earthRadius, this.settings.earthSegments, this.settings.earthSegments);\n            var material = new THREE.MeshPhongMaterial({\n                map: this.mapTextures[0],\n                side: THREE.DoubleSide,\n                shininess: 1,\n                emissive: 0xaaaaaa,\n                //wireframe: true\n            });\n            return new THREE.Mesh(geometry, material);\n        }\n\n        public zoomClicked(zoomDirection: any) {\n            if (this.orbitControls.enabled === false || this.orbitControls.enableZoom === false)\n                return;\n\n            if (zoomDirection === -1)\n                this.orbitControls.constraint.dollyOut(Math.pow(0.95, this.settings.zoomSpeed));\n            else if (zoomDirection === 1)\n                this.orbitControls.constraint.dollyIn(Math.pow(0.95, this.settings.zoomSpeed));\n\n            this.orbitControls.update();\n            this.animateCamera(this.camera.position);\n        }\n\n        public rotateCam(deltaX: number, deltaY: number) {\n            if (this.orbitControls.enabled === false || this.orbitControls.enableRotate === false)\n                return;\n\n            this.orbitControls.constraint.rotateLeft(2 * Math.PI * deltaX / this.domElement.offsetHeight * this.settings.rotateSpeed);\n            this.orbitControls.constraint.rotateUp(2 * Math.PI * deltaY / this.domElement.offsetHeight * this.settings.rotateSpeed);\n            this.orbitControls.update();\n            this.animateCamera(this.camera.position);\n        }\n\n        private initZoomControl() {\n            let radius = 17;\n            let zoomControlWidth = radius * 8.5;\n            let zoomControlHeight = radius * 8.5;\n            let startX = radius * 3;\n            let startY = radius + 3;\n            let gap = radius * 2;\n\n            let zoomCss = {\n                'position': 'absolute',\n                'left': 'calc(100% - ' + zoomControlWidth + 'px)',\n                'top': 'calc(100% - ' + zoomControlHeight + 'px)',\n                'zIndex': '1000',\n            };\n\n            let zoomContainer =\n                d3.select(this.container[0])\n                    .append('div')\n                    .style(zoomCss);\n\n            this.zoomControl = zoomContainer.append(\"svg\")\n                .attr({\n                    \"width\": zoomControlWidth,\n                    \"height\": zoomControlHeight\n                });\n\n            let bottom = this.zoomControl.append(\"g\").on(\"click\", () => this.rotateCam(0, -5));\n\n            bottom.append(\"circle\").attr({\n                cx: startX + gap,\n                cy: startY + (2 * gap),\n                r: radius,\n                fill: \"white\",\n                opacity: 0.5,\n                stroke: 'gray',\n            });\n\n            bottom.append(\"path\").attr({\n                d: \"M\" + (startX + (2 * radius)) + \" \" + (startY + (radius * 4.7)) + \" l12 -20 a40,70 0 0,1 -24,0z\",\n                fill: \"gray\",\n            });\n\n            let left = this.zoomControl.append(\"g\").on(\"click\", () => this.rotateCam(5, 0));\n\n            left.append(\"circle\").attr({\n                cx: startX,\n                cy: startY + gap,\n                r: radius,\n                fill: \"white\",\n                stroke: \"gray\",\n                opacity: 0.5,\n            });\n\n            left.append(\"path\").attr({\n                d: \"M\" + (startX - radius / 1.5) + \" \" + (startY + (radius * 2)) + \" l20 -12 a70,40 0 0,0 0,24z\",\n                fill: \"gray\",\n            });\n\n            let top = this.zoomControl.append(\"g\").on(\"click\", () => this.rotateCam(0, 5));\n\n            top.append(\"circle\").attr({\n                cx: startX + gap,\n                cy: startY,\n                r: radius,\n                fill: \"white\",\n                stroke: \"gray\",\n                opacity: 0.5,\n            });\n\n            top.append(\"path\").attr({\n                d: \"M\" + (startX + (2 * radius)) + \" \" + (startY - (radius / 1.5)) + \" l12 20 a40,70 0 0,0 -24,0z\",\n                fill: \"gray\",\n            });\n\n            let right = this.zoomControl.append(\"g\").on(\"click\", () => this.rotateCam(-5, 0));\n\n            right.append(\"circle\").attr({\n                cx: startX + (2 * gap),\n                cy: startY + gap,\n                r: radius,\n                fill: \"white\",\n                stroke: \"gray\",\n                opacity: 0.5,\n            });\n\n            right.append(\"path\").attr({\n                d: \"M\" + (startX + (4.7 * radius)) + \" \" + (startY + (radius * 2)) + \" l-20 -12 a70,40 0 0,1 0,24z\",\n                fill: \"gray\",\n            });\n\n            let zoomIn = this.zoomControl.append(\"g\").on(\"click\", () => this.zoomClicked(-1));\n\n            zoomIn.append(\"circle\").attr({\n                cx: startX + 4 * radius,\n                cy: startY + 6 * radius,\n                r: radius,\n                fill: \"white\",\n                stroke: \"gray\",\n                opacity: 0.5,\n            });\n\n            zoomIn.append(\"rect\").attr({\n                x: startX + 3.5 * radius,\n                y: startY + 5.9 * radius,\n                width: radius,\n                height: radius / 3,\n                fill: \"gray\",\n            });\n            zoomIn.append(\"rect\").attr({\n                x: startX + (4 * radius) - radius / 6,\n                y: startY + 5.55 * radius,\n                width: radius / 3,\n                height: radius,\n                fill: \"gray\",\n            });\n\n            var zoomOut = this.zoomControl.append(\"g\").on(\"click\", () => this.zoomClicked(1));\n\n            zoomOut.append(\"circle\").attr({\n                cx: startX,\n                cy: startY + 6 * radius,\n                r: radius,\n                fill: \"white\",\n                stroke: \"gray\",\n                opacity: \"0.50\",\n            });\n\n            zoomOut.append(\"rect\").attr({\n                x: startX - (radius / 2),\n                y: startY + 5.9 * radius,\n                width: radius,\n                height: radius / 3,\n                fill: \"gray\",\n            });\n        }\n\n        private initTextures() {\n            if (!GlobeMapCanvasLayers) {\n                // Initialize once, since this is a CPU + Network heavy operation.\n                GlobeMapCanvasLayers = [];\n\n                for (var level = 2; level <= 5; ++level) {\n                    var canvas = this.getBingMapCanvas(level);\n                    GlobeMapCanvasLayers.push(canvas);\n                }\n            }\n\n            // Can't execute in for loop because variable assignement gets overwritten\n            var createTexture = (canvas: JQuery) => {\n                var texture = new THREE.Texture(canvas.get(0));\n                texture.needsUpdate = true;\n                canvas.on(\"ready\", (e, resolution) => {\n                    //console.log(\"level ready\", resolution, texture)\n                    texture.needsUpdate = true;\n                    this.needsRender = true;\n                });\n                return texture;\n\n            };\n\n            this.mapTextures = [];\n            for (var i = 0; i < GlobeMapCanvasLayers.length; ++i) {\n                this.mapTextures.push(createTexture(GlobeMapCanvasLayers[i]));\n            }\n        }\n\n        private initHeatmap() {\n            var settings = this.settings;\n\n            //console.log(\"initHeatmap\");\n            try {\n                var heatmap = this.heatmap = new WebGLHeatmap({ width: settings.heatmapSize, height: settings.heatmapSize, intensityToAlpha: true });\n            } catch (e) {\n                // IE & Edge will throw an error about texImage2D, we need to ignore it\n                console.error(e);\n            }\n\n            // canvas contents will be used for a texture\n            var texture = this.heatTexture = new THREE.Texture(heatmap.canvas);\n            texture.needsUpdate = true;\n\n            var material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });\n            var geometry = new THREE.SphereGeometry(settings.earthRadius + 0.01, settings.earthSegments, settings.earthSegments);\n            var mesh = new THREE.Mesh(geometry, material);\n\n            window[\"heatmap\"] = heatmap;\n            window[\"heatmapTexture\"] = texture;\n\n            this.scene.add(mesh);\n        }\n\n        private setEarthTexture() {\n            //get distance as arbitrary value from 0-1\n            if (!this.camera) return;\n            var maxDistance = this.settings.cameraRadius - this.settings.earthRadius;\n            var distance = (this.camera.position.length() - this.settings.earthRadius) / maxDistance;\n\n            var texture;\n            if (distance <= 1 / 5) {\n                texture = this.mapTextures[3];\n            } else if (distance <= 2 / 5) {\n                texture = this.mapTextures[2];\n            } else if (distance <= 3 / 5) {\n                texture = this.mapTextures[1];\n            } else {\n                texture = this.mapTextures[0];\n            }\n\n            if (this.earth.material.map !== texture) {\n                this.earth.material.map = texture;\n            }\n\n            if (this.selectedBar) {\n                this.orbitControls.rotateSpeed = this.settings.rotateSpeed;\n            } else {\n                this.orbitControls.rotateSpeed = this.settings.rotateSpeed * distance;\n            }\n\n            //console.log(distance, this.orbitControls.rotateSpeed);\n        }\n\n        public update(options: VisualUpdateOptions) {\n            this.needsRender = true;\n            this.cleanHeatAndBar();\n            if (options.viewport.height !== this.viewport.height || options.viewport.width !== this.viewport.width) {\n                var viewport = this.viewport = options.viewport;\n                if (this.camera && this.renderer) {\n                    this.camera.aspect = viewport.width / viewport.height;\n                    this.camera.updateProjectionMatrix();\n                    this.renderer.setSize(viewport.width, viewport.height);\n                }\n                return;\n            }\n\n            // PowerBI fires two update calls, one for size, one for data\n            if (options.dataViews[0] && options.dataViews[0].categorical) {\n                this.composeRenderData(options.dataViews[0].categorical);\n            }\n        }\n\n        public cleanHeatAndBar() {\n            this.heatmap.clear();\n            this.heatTexture.needsUpdate = true;\n            if (this.barsGroup) {\n                this.scene.remove(this.barsGroup);\n            }\n        }\n\n        private renderMagic() {\n            if (!this.readyToRender) {\n                //console.log(\"not ready to render\");\n                this.defferedRender();\n                return;\n            }\n\n            var renderData = this.renderData;\n            var heatmap = this.heatmap;\n            var settings = this.settings;\n\n            heatmap.clear();\n\n            if (this.barsGroup) {\n                this.scene.remove(this.barsGroup);\n            }\n\n            this.barsGroup = new THREE.Object3D();\n            this.scene.add(this.barsGroup);\n\n            //colors for stacked vector by series values\n            var barMaterials = [\n                new THREE.MeshPhongMaterial({ color: 0xff00ff, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                new THREE.MeshPhongMaterial({ color: 0xffff1a, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                new THREE.MeshPhongMaterial({ color: 0xff0000, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                new THREE.MeshPhongMaterial({ color: 0x00ffff, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                new THREE.MeshPhongMaterial({ color: 0x994d00, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                new THREE.MeshPhongMaterial({ color: 0xb3cccc, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                new THREE.MeshPhongMaterial({ color: 0xace600, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                new THREE.MeshPhongMaterial({ color: 0x52527a, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n            ];\n\n            this.averageBarVector = new THREE.Vector3();\n\n            for (var i = 0, len = renderData.length; i < len; ++i) {\n                var renderDatum = renderData[i];\n\n                if (!renderDatum.lat || !renderDatum.lng) continue;\n\n                if (renderDatum.heat > 0.001) {\n                    if (renderDatum.heat < 0.1) renderDatum.heat = 0.1;\n                    var x = (180 + renderDatum.lng) / 360 * settings.heatmapSize;\n                    var y = (1 - ((90 + renderDatum.lat) / 180)) * settings.heatmapSize;\n                    heatmap.addPoint(x, y, settings.heatPointSize, renderDatum.heat * settings.heatIntensity);\n                }\n\n                if (renderDatum.height >= 0) {\n                    if (renderDatum.height < 0.01) renderDatum.height = 0.01;\n                    var latRadians = renderDatum.lat / 180 * Math.PI; //radians\n                    var lngRadians = renderDatum.lng / 180 * Math.PI;\n\n                    var x = Math.cos(lngRadians) * Math.cos(latRadians);\n                    var z = -Math.sin(lngRadians) * Math.cos(latRadians);\n                    var y = Math.sin(latRadians);\n                    var v = new THREE.Vector3(x, y, z);\n\n                    this.averageBarVector.add(v);\n\n                    var barHeight = settings.barHeight * renderDatum.height;\n                    //this array holds the relative series values to the actual measure for example [0.2,0.3,0.5]\n                    //this is how we draw the vectors relativly to the complete value one on top of another. \n                    var measuresBySeries = [];\n                    //this array holds the original values of the series for the tool tips\n                    var dataPointToolTip = [];\n                    if (renderDatum.heightBySeries) {\n                        for (var c = 0; c < renderDatum.heightBySeries.length; c++) {\n                            if (renderDatum.heightBySeries[c])\n                                measuresBySeries.push(renderDatum.heightBySeries[c]);\n                            dataPointToolTip.push(renderDatum.seriesToolTipData[c]);\n                        }\n                    } else {\n                        //no category series so we'll just draw one value\n                        measuresBySeries.push(1);\n                    }\n\n                    var previousMeasureValue = 0;\n                    for (var j = 0; j < measuresBySeries.length; j++) {\n                        previousMeasureValue += measuresBySeries[j];\n                        var geometry = new THREE.CubeGeometry(settings.barWidth, settings.barWidth, barHeight * measuresBySeries[j]);\n                        var bar = new THREE.Mesh(geometry, barMaterials[j % (barMaterials.length - 1)]);\n                        bar.position = v.clone().multiplyScalar(settings.earthRadius + ((barHeight / 2) * previousMeasureValue));\n                        bar.lookAt(v);\n                        bar.toolTipData = dataPointToolTip.length === 0 ? renderDatum.toolTipData : this.getToolTipDataForSeries(renderDatum.toolTipData, dataPointToolTip[j]);\n                        this.barsGroup.add(bar);\n                        previousMeasureValue += measuresBySeries[j];\n                    }\n                }\n            }\n\n            if (this.barsGroup.children.length > 0 && this.camera) {\n                this.averageBarVector.multiplyScalar(1 / this.barsGroup.children.length);\n                if (this.locationsLoaded === this.locationsToLoad) {\n                    this.animateCamera(this.averageBarVector);\n                }\n            }\n\n            heatmap.update();\n            heatmap.blur();\n            this.heatTexture.needsUpdate = true;\n            this.needsRender = true;\t\t\t\n\n            //console.log(\"renderMagic done! locations:\", this.barsGroup.children.length, \"toload/loaded\", this.locationsToLoad, this.locationsLoaded)\n        }\n\n        private getToolTipDataForSeries(toolTipData, dataPointToolTip): any {\n            var result = jQuery.extend(true, {\n                series: { displayName: dataPointToolTip.displayName, value: dataPointToolTip.value }\n            }, toolTipData);\n            result.height.value = dataPointToolTip.dataPointValue;\n            return result;\n        }\n\n        private composeRenderData(categoricalView?) {\n            // memoize last value\n            if (categoricalView) {\n                this.categoricalView = categoricalView;\n            } else {\n                categoricalView = this.categoricalView;\n            }\n\n            this.renderData = [];\n            var locations = [];\n            var globeMapLocationCache = this.globeMapLocationCache;\n\n            //console.log(\"categoricalView\", categoricalView)\n            if (!categoricalView) return;\n            var categories = categoricalView.categories;\n            var grouped = categoricalView.values.grouped();\n            var heightIndex = 0;\n            var intensityIndex = 0;\n            try {\n                heightIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"Height\");\n                intensityIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"Heat\");\n                var longitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"X\");\n                var latitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"Y\");\n            } catch (e) { }\n\n            var locationType, heights, heightsBySeries, toolTipDataBySeries, heats, latitudes, longitudes, locationDispName, heightDispName, heatDispName, heightFormat, heatFormat;\n\n            if (heightIndex !== undefined && categoricalView.values[heightIndex] && categoricalView.values !== undefined) {\n                var locationCategory = categories[0];\n                locations = locationCategory.values;\n                locationDispName = locationCategory.source.displayName;\n                if (locationCategory.source.type.category) {\n                    locationType = locationCategory.source.type.category.toLowerCase();\n                } else {\n                    locationType = \"\";\n                }\n            } else {\n                locations = [];\n            }\n\n            // For debugging since devTools - salesByCountry isn't really sales by country\n            //var places = [\"kenya\", \"india\", \"united states\", \"london\", \"australia\", \"canada\"]\n            //heightIndex = 0;\n\n            if (heightIndex !== undefined && categoricalView.values[heightIndex]) {\n                // heights = categoricalView.values[heightIndex].values;\n                heightDispName = categoricalView.values[heightIndex].source.displayName;\n                heightFormat = categoricalView.values[heightIndex].source.format;\n                if (grouped.length > 1) {\n                    heights = new Array(locations.length);\n                    heightsBySeries = new Array(locations.length);\n                    toolTipDataBySeries = new Array(locations.length);\n                    //creating a matrix for drawing values by series later.\n                    for (var i = 0; i < grouped.length; i++) {\n                        var values = grouped[i].values[heightIndex].values;\n                        for (var j = 0; j < values.length; j++) {\n                            if (!heights[j]) heights[j] = 0;\n                            heights[j] += values[j] ? values[j] : 0;\n                            if (!heightsBySeries[j]) heightsBySeries[j] = [];\n                            heightsBySeries[j][i] = values[j];\n                            if (!toolTipDataBySeries[j]) toolTipDataBySeries[j] = [];\n                            toolTipDataBySeries[j][i] = { displayName: categoricalView.values.source.displayName, value: grouped[i].name, dataPointValue: values[j] };\n                        }\n                    }\n                    for (var i = 0; i < grouped.length; i++) {\n                        var values = grouped[i].values[heightIndex].values;\n                        for (var j = 0; j < values.length; j++) { \n                            //calculating relative size of series\n                            heightsBySeries[j][i] = values[j] / heights[j];\n                        }\n                    }\n                } else {\n                    heights = categoricalView.values[heightIndex].values;\n                    heightsBySeries = new Array(grouped.length);\n                }\n\n            } else {\n                heightsBySeries = new Array(locations.length);\n                heights = new Array(locations.length);\n            }\n\n            if (intensityIndex !== undefined && categoricalView.values[intensityIndex]) {\n                if (grouped.length > 1) {\n                    heats = new Array(locations.length);\n                    for (var i = 0; i < grouped.length; i++) {\n                        var values = grouped[i].values[intensityIndex].values;\n                        for (var j = 0; j < values.length; j++) {\n                            if (!heats[j]) heats[j] = 0;\n                            heats[j] += values[j] ? values[j] : 0;\n                        }\n                    }\n                } else {\n                    heats = categoricalView.values[intensityIndex].values;\n                }\n                heatDispName = categoricalView.values[intensityIndex].source.displayName;\n                heatFormat = categoricalView.values[intensityIndex].source.format;\n            } else {\n                heats = new Array(locations.length);\n            }\n\n            if (longitudeIndex !== undefined && categoricalView.values[longitudeIndex]\n                && latitudeIndex !== undefined && categoricalView.values[latitudeIndex]) {\n                longitudes = categoricalView.values[longitudeIndex].values;\n                latitudes = categoricalView.values[latitudeIndex].values;\n            }\n            else {\n                longitudes = null;\n                latitudes = null;\n            }\n\n            var maxHeight = Math.max.apply(null, heights) || 1;\n            var maxHeat = Math.max.apply(null, heats) || 1;\n            var heatFormatter = valueFormatter.create({ format: heatFormat, value: heats[0], value2: heats[1] });\n            var heightFormatter = valueFormatter.create({ format: heightFormat, value: heights[0], value2: heights[1] });\n\n            for (var i = 0, len = locations.length; i < len; ++i) {\n                var place = locations[i];\n                var lat, lng, latlng, height, heat;\n\n                //place = places[i];\n\n                if (place && typeof (place) === \"string\") {\n                    place = place.toLowerCase();\n                    var placeKey = place + \"/\" + locationType;\n\n                    if (!longitudes && globeMapLocationCache[placeKey]) {\n                        latlng = globeMapLocationCache[placeKey];\n                        lat = latlng.latitude;\n                        lng = latlng.longitude;\n                    }\n                    else if (longitudes) {\n                        lat = latitudes[i];\n                        lng = longitudes[i];\n                    }\n\n                    height = heights[i] / maxHeight;\n                    heat = heats[i] / maxHeat;\n\n                    var renderDatum = {\n                        lat: lat,\n                        lng: lng,\n                        height: height ? height || 0.01 : undefined,\n                        heightBySeries: heightsBySeries[i],\n                        seriesToolTipData: toolTipDataBySeries ? toolTipDataBySeries[i] : undefined,\n                        heat: heat || 0,\n                        toolTipData: {\n                            location: { displayName: locationDispName, value: locations[i] },\n                            height: { displayName: heightDispName, value: heightFormatter.format(heights[i]) },\n                            heat: { displayName: heatDispName, value: heatFormatter.format(heats[i]) }\n                        }\n                    };\n\n                    this.renderData.push(renderDatum);\n\n                    if (!longitudes && !latlng) {\n                        this.geocodeRenderDatum(renderDatum, place, locationType);\n                    }\n                }\n            }\n\n            try {\n                this.renderMagic();\n            } catch (e) {\n                console.error(e);\n            }\n        }\n\n        private geocodeRenderDatum(renderDatum, place, locationType) {\n            var placeKey = place + \"/\" + locationType;\n            this.globeMapLocationCache[placeKey] = {}; //store empty object so we don't send AJAX request again\n            this.locationsToLoad++;\n\n            try {\n                var geocoder = powerbi.visuals[\"BI\"].Services.GeocodingManager.geocode;\n            } catch (e) {\n                geocoder = services.geocode;\n            }\n\n            if (geocoder) {\n                geocoder(place, locationType).always((latlng: any) => {\n                    // we use always because we want to cache unknown values. \n                    // No point asking bing again and again when it tells us it doesn't know about a location\n                    this.globeMapLocationCache[placeKey] = latlng;\n                    this.locationsLoaded++;\n                    //console.log(place, latlng);\n\n                    if (latlng.latitude && latlng.longitude) {\n                        renderDatum.lat = latlng.latitude;\n                        renderDatum.lng = latlng.longitude;\n\n                        this.defferedRender();\n                    }\n                });\n            }\n        }\n\n        private defferedRender() {\n            if (!this.deferredRenderTimerId) {\n                this.deferredRenderTimerId = setTimeout(() => {\n                    this.deferredRenderTimerId = null;\n                    this.composeRenderData();\n                }, 500);\n            }\n        }\n\n        private initRayCaster() {\n            this.rayCaster = new THREE.Raycaster();\n            var settings = this.settings;\n            var mousePosNormalized = this.mousePosNormalized = new THREE.Vector2();\n            var mousePos = this.mousePos = new THREE.Vector2();\n            var element = this.container.get(0);\n            var mouseDownTime;\n\n            $(this.domElement).on(\"mousemove\", (event) => {\n                // get coordinates in -1 to +1 space\n                var rect = element.getBoundingClientRect();\n                mousePos.x = event.clientX;\n                mousePos.y = event.clientY;\n                mousePosNormalized.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n                mousePosNormalized.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n                this.needsRender = true;\n            }).on(\"mousedown\", (event) => {\n                mouseDownTime = Date.now();\n            }).on(\"mouseup\", (event) => {\n                // Debounce slow clicks\n                if ((Date.now() - mouseDownTime) > settings.clickInterval) return;\n                if (this.hoveredBar && event.shiftKey) {\n                    this.selectedBar = this.hoveredBar;\n                    this.animateCamera(this.selectedBar.position, () => {\n                        if (!this.selectedBar) return;\n                        this.orbitControls.center.copy(this.selectedBar.position.clone().normalize().multiplyScalar(settings.earthRadius));\n                        this.orbitControls.minDistance = 1;\n                    });\n                } else {\n                    if (this.selectedBar) {\n                        this.animateCamera(this.selectedBar.position, () => {\n                            this.orbitControls.center.set(0, 0, 0);\n                            this.orbitControls.minDistance = settings.earthRadius + 1;\n                        });\n                        this.selectedBar = null;\n                    }\n                }\n            }).on(\"mousewheel DOMMouseScroll\", (e: any) => {\n                this.needsRender = true;\n                if (this.orbitControls.enabled && this.orbitControls.enableZoom) {\n                    this.heatTexture.needsUpdate = true;\n                    e = e.originalEvent;\n                    var delta = e.wheelDelta > 0 || e.detail < 0 ? 1 : -1;\n                    var scale = delta > 0 ? this.settings.heatmapScaleOnZoom : (1 / this.settings.heatmapScaleOnZoom);\n                    this.heatmap.multiply(scale);\n                    this.heatmap.update();\n                }\n            });\n        }\n\n        private intersectBars() {\n            if (!this.rayCaster || !this.barsGroup) return;\n            var rayCaster = this.rayCaster;\n            rayCaster.setFromCamera(this.mousePosNormalized, this.camera);\n            var intersects = rayCaster.intersectObjects(this.barsGroup.children);\n\n            if (intersects && intersects.length > 0) {\n                //console.log(intersects[0], this.mousePos.x, this.mousePos.y);\n                var object = intersects[0].object;\n                if (!object || !object.toolTipData) return;\n                var toolTipData = object.toolTipData;\n                var toolTipItems: TooltipDataItem[] = [];\n                if (toolTipData.location.displayName) toolTipItems.push(toolTipData.location);\n                if (toolTipData.series) toolTipItems.push(toolTipData.series);\n                if (toolTipData.height.displayName) toolTipItems.push(toolTipData.height);\n                if (toolTipData.heat.displayName) toolTipItems.push(toolTipData.heat);\n                this.hoveredBar = object;\n                TooltipManager.ToolTipInstance.show(toolTipItems, <TouchRect>{ x: this.mousePos.x, y: this.mousePos.y, width: 0, height: 0 });\n            } else {\n                this.hoveredBar = null;\n                TooltipManager.ToolTipInstance.hide();\n            }\n        }\n\n        private animateCamera(to: any, done?: Function) {\n            if (!this.camera) return;\n            var startTime = Date.now();\n            var duration = this.settings.cameraAnimDuration;\n            var endTime = startTime + duration;\n            var startPos = this.camera.position.clone().normalize();\n            var endPos = to.clone().normalize();\n            var length = this.camera.position.length();\n\n            var easeInOut = function (t) {\n                t *= 2;\n                if (t < 1) return (t * t * t) / 2;\n                t -= 2;\n                return (t * t * t + 2) / 2;\n            };\n\n            var onUpdate = () => {\n                var now = Date.now();\n                var t = (now - startTime) / duration;\n                if (t > 1) t = 1;\n                t = easeInOut(t);\n\n                var pos = new THREE.Vector3()\n                    .add(startPos.clone().multiplyScalar(1 - t))\n                    .add(endPos.clone().multiplyScalar(t))\n                    .normalize()\n                    .multiplyScalar(length);\n\n                this.camera.position = pos;\n\n                if (now < endTime) {\n                    requestAnimationFrame(onUpdate);\n                } else if (done) {\n                    done();\n                }\n\n                this.needsRender = true;\n            };\n            requestAnimationFrame(onUpdate);\n        }\n\n        public destroy() {\n            clearTimeout(this.deferredRenderTimerId);\n            this.renderLoopEnabled = false;\n            this.scene = null;\n            this.heatmap = null;\n            this.heatTexture = null;\n            this.camera = null;\n            if (this.renderer) {\n                if (this.renderer.context) {\n                    let extension = this.renderer.context.getExtension('WEBGL_lose_context');\n                    if (extension)\n                        extension.loseContext();\n                    this.renderer.context = null;\n                }\n                this.renderer.domElement = null;\n            }\n            this.renderer = null;\n            this.renderData = null;\n            this.barsGroup = null;\n            if (this.orbitControls) this.orbitControls.dispose();\n            this.orbitControls = null;\n            if (this.domElement) $(this.domElement)\n                .off(\"mousemove mouseup mousedown mousewheel DOMMouseScroll\");\n            this.domElement = null;\n            if (this.container) this.container.empty();\n        }\n\n        private initMercartorSphere() {\n            if (GlobeMap.MercartorSphere) return;\n\n            var MercartorSphere = function (radius, widthSegments, heightSegments) {\n                THREE.Geometry.call(this);\n\n                this.radius = radius;\n                this.widthSegments = widthSegments;\n                this.heightSegments = heightSegments;\n\n                this.t = 0;\n\n                var x, y, vertices = [], uvs = [];\n\n                function interplolate(a, b, t) {\n                    return (1 - t) * a + t * b;\n                }\n\n                // interpolates between sphere and plane\n                function interpolateVertex(u, v, t) {\n                    var maxLng = Math.PI * 2;\n                    var maxLat = Math.PI;\n                    var radius = this.radius;\n\n                    var sphereX = - radius * Math.cos(u * maxLng) * Math.sin(v * maxLat);\n                    var sphereY = - radius * Math.cos(v * maxLat);\n                    var sphereZ = radius * Math.sin(u * maxLng) * Math.sin(v * maxLat);\n\n                    var planeX = u * radius * 2 - radius;\n                    var planeY = v * radius * 2 - radius;\n                    var planeZ = 0;\n\n                    var x = interplolate(sphereX, planeX, t);\n                    var y = interplolate(sphereY, planeY, t);\n                    var z = interplolate(sphereZ, planeZ, t);\n\n                    return new THREE.Vector3(x, y, z);\n                }\n\n                // http://mathworld.wolfram.com/MercatorProjection.html\n                // Mercator projection goes form +85.05 to -85.05 degrees\n                function interpolateUV(u, v, t) {\n                    var lat = (v - 0.5) * 90 * 2 / 180 * Math.PI; //turn from 0-1 into lat in radians\n                    var sin = Math.sin(lat);\n                    var normalizedV = 0.5 + 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n                    return new THREE.Vector2(u, normalizedV);//interplolate(normalizedV1, v, t))\n                }\n\n                for (y = 0; y <= heightSegments; y++) {\n\n                    var verticesRow = [];\n                    var uvsRow = [];\n\n                    for (x = 0; x <= widthSegments; x++) {\n\n                        var u = x / widthSegments;\n                        var v = y / heightSegments;\n\n                        this.vertices.push(interpolateVertex.call(this, u, v, this.t));\n                        uvsRow.push(interpolateUV.call(this, u, v, this.t));\n                        verticesRow.push(this.vertices.length - 1);\n                    }\n\n                    vertices.push(verticesRow);\n                    uvs.push(uvsRow);\n\n                }\n\n                //console.log(vertices, uvs);\n\n                for (y = 0; y < this.heightSegments; y++) {\n\n                    for (x = 0; x < this.widthSegments; x++) {\n\n                        var v1 = vertices[y][x + 1];\n                        var v2 = vertices[y][x];\n                        var v3 = vertices[y + 1][x];\n                        var v4 = vertices[y + 1][x + 1];\n\n                        var n1 = this.vertices[v1].clone().normalize();\n                        var n2 = this.vertices[v2].clone().normalize();\n                        var n3 = this.vertices[v3].clone().normalize();\n                        var n4 = this.vertices[v4].clone().normalize();\n\n                        var uv1 = uvs[y][x + 1].clone();\n                        var uv2 = uvs[y][x].clone();\n                        var uv3 = uvs[y + 1][x].clone();\n                        var uv4 = uvs[y + 1][x + 1].clone();\n\n                        var normals = [n1, n2, n3, n4];\n\n                        this.faces.push(new THREE.Face4(v1, v2, v3, v4, normals));\n                        this.faceVertexUvs[0].push([uv1, uv2, uv3, uv4]);\n                    }\n\n                }\n\n                this.computeCentroids();\n                this.computeFaceNormals();\n\n                this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\n            };\n\n            MercartorSphere.prototype = Object.create(THREE.Geometry.prototype);\n            GlobeMap.MercartorSphere = MercartorSphere;\n        }\n\n        private getBingMapCanvas(resolution): JQuery {\n            var tileSize = 256;\n            var numSegments = Math.pow(2, resolution);\n            var numTiles = numSegments * numSegments;\n            var tilesLoaded = 0;\n            var canvasSize = tileSize * numSegments;\n            var canvas: JQuery = $('<canvas/>').attr({ width: canvasSize, height: canvasSize });\n            var canvasElem: any = canvas.get(0);\n            var canvasContext = canvasElem.getContext(\"2d\");\n\n            function generateQuads(res, quad) {\n                if (res <= resolution) {\n                    if (res === resolution) {\n                        loadTile(quad);\n                        //console.log(res, maxResolution, quad);\n                    }\n\n                    generateQuads(res + 1, quad + \"0\");\n                    generateQuads(res + 1, quad + \"1\");\n                    generateQuads(res + 1, quad + \"2\");\n                    generateQuads(res + 1, quad + \"3\");\n                }\n            }\n\n            function loadTile(quad) {\n                var template: any = \"https://t{server}.tiles.virtualearth.net/tiles/r{quad}.jpeg?g=0&mkt={language}\";\n                var numServers = 7;\n                var server = Math.round(Math.random() * numServers);\n                var language = (navigator[\"languages\"] && navigator[\"languages\"].length) ? navigator[\"languages\"][0] : navigator.language;\n                var url = template.replace(\"{server}\", server)\n                    .replace(\"{quad}\", quad)\n                    .replace(\"{language}\", language);\n                var coords = getCoords(quad);\n                //console.log(quad, coords.x, coords.y)\n\n                var tile = new Image();\n                tile.onload = function () {\n                    tilesLoaded++;\n                    canvasContext.drawImage(tile, coords.x * tileSize, coords.y * tileSize, tileSize, tileSize);\n                    if (tilesLoaded === numTiles) {\n                        canvas.trigger(\"ready\", resolution);\n                    }\n                };\n\n                // So the canvas doesn't get tainted\n                tile.crossOrigin = '';\n                tile.src = url;\n            }\n\n            function getCoords(quad) {\n                var x = 0;\n                var y = 0;\n                var last = quad.length - 1;\n\n                for (var i = last; i >= 0; i--) {\n                    var chr = quad.charAt(i);\n                    var pow = Math.pow(2, last - i);\n\n                    if (chr === \"1\") {\n                        x += pow;\n                    } else if (chr === \"2\") {\n                        y += pow;\n                    } else if (chr === \"3\") {\n                        x += pow;\n                        y += pow;\n                    }\n                }\n\n                return { x: x, y: y };\n            }\n\n            generateQuads(0, \"\");\n            return canvas;\n        }\n    }\n}\n\nfunction loadGlobeMapLibs() {\n    // include GlobeMapLibs.js\n}","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n            var PixelConverter = jsCommon.PixelConverter;\n            var ValueFormatter = powerbi.visuals.valueFormatter;\n            var AsterPlotVisualClassName = 'asterPlot';\n            var AsterPlotLegendObjectName = 'legend';\n            var AsterDefaultOuterLineThickness = 1;\n            var AsterDefaultLabelFill = { solid: { color: '#333' } };\n            var AsterDefaultLegendFontSize = 8;\n            var AsterRadiusRatio = 0.9;\n            var AsterConflictRatio = 0.9;\n            var MaxPrecision = 17;\n            var AsterPlotWebBehavior = (function () {\n                function AsterPlotWebBehavior() {\n                }\n                AsterPlotWebBehavior.prototype.bindEvents = function (options, selectionHandler) {\n                    this.selection = options.selection;\n                    this.highlightedSelection = options.highlightedSelection;\n                    this.clearCatcher = options.clearCatcher;\n                    this.interactivityService = options.interactivityService;\n                    this.selection.on('click', function (d, i) {\n                        selectionHandler.handleSelection(d.data, d3.event.ctrlKey);\n                    });\n                    if (this.highlightedSelection)\n                        this.highlightedSelection.on('click', function (d, i) {\n                            selectionHandler.handleSelection(d.data, d3.event.ctrlKey);\n                        });\n                    this.clearCatcher.on('click', function () {\n                        selectionHandler.handleClearSelection();\n                    });\n                };\n                AsterPlotWebBehavior.prototype.renderSelection = function (hasSelection) {\n                    var hasHighlights = this.interactivityService.hasSelection();\n                    this.selection.style(\"fill-opacity\", function (d) {\n                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, !d.data.highlight && hasSelection, !d.data.selected && hasHighlights);\n                    });\n                };\n                return AsterPlotWebBehavior;\n            }());\n            var AsterPlotWarning = (function () {\n                function AsterPlotWarning(message) {\n                    this.message = message;\n                }\n                Object.defineProperty(AsterPlotWarning.prototype, \"code\", {\n                    get: function () {\n                        return \"AsterPlotWarning\";\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                AsterPlotWarning.prototype.getMessages = function (resourceProvider) {\n                    return {\n                        message: this.message,\n                        title: resourceProvider.get(\"\"),\n                        detail: resourceProvider.get(\"\")\n                    };\n                };\n                return AsterPlotWarning;\n            }());\n            samples.AsterPlotWarning = AsterPlotWarning;\n            var AsterPlot = (function () {\n                function AsterPlot() {\n                    this.margin = {\n                        top: 10,\n                        right: 10,\n                        bottom: 15,\n                        left: 10\n                    };\n                }\n                AsterPlot.prototype.getDefaultAsterData = function () {\n                    return {\n                        dataPoints: [],\n                        highlightedDataPoints: [],\n                        legendData: {\n                            dataPoints: [],\n                            title: null,\n                            fontSize: AsterDefaultLegendFontSize,\n                            labelColor: visuals.LegendData.DefaultLegendLabelFillColor\n                        },\n                        legendSettings: {\n                            show: false,\n                            position: 'Top',\n                            showTitle: true,\n                            labelColor: visuals.LegendData.DefaultLegendLabelFillColor,\n                            titleText: '',\n                            fontSize: AsterDefaultLegendFontSize,\n                        },\n                        valueFormatter: null,\n                        labelSettings: {\n                            show: false,\n                            displayUnits: 0,\n                            precision: visuals.dataLabelUtils.defaultLabelPrecision,\n                            labelColor: visuals.dataLabelUtils.defaultLabelColor,\n                            fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,\n                        },\n                        showOuterLine: false,\n                        outerLineThickness: AsterDefaultOuterLineThickness,\n                    };\n                };\n                AsterPlot.prototype.converter = function (dataView, colors) {\n                    var asterDataResult = this.getDefaultAsterData();\n                    if (!this.dataViewContainsCategory(dataView) || dataView.categorical.categories.length !== 1)\n                        return asterDataResult;\n                    var catDv = dataView.categorical;\n                    var cat = catDv.categories[0];\n                    var catSource = cat.source;\n                    var catValues = cat.values;\n                    var values = catDv.values;\n                    var catObjects = cat.objects;\n                    var colorHelper = new visuals.ColorHelper(colors, AsterPlot.Properties.dataPoint.fill);\n                    var hasHighlights = this.hasHighlights = !!(values && values.length > 0 && values[0].highlights);\n                    if (dataView.metadata || dataView.metadata.objects) {\n                        var objects = dataView.metadata.objects;\n                        asterDataResult.labelSettings = this.getLabelSettings(objects, asterDataResult.labelSettings);\n                        this.updateLegendSettings(objects, catSource, asterDataResult.legendSettings);\n                        asterDataResult.showOuterLine = powerbi.DataViewObjects.getValue(objects, AsterPlot.Properties.outerLine.show, asterDataResult.showOuterLine);\n                        asterDataResult.outerLineThickness = powerbi.DataViewObjects.getValue(objects, AsterPlot.Properties.outerLine.thickness, AsterDefaultOuterLineThickness);\n                    }\n                    var labelSettings = asterDataResult.labelSettings;\n                    if (!catValues || catValues.length < 1 || !values || values.length < 1)\n                        return asterDataResult;\n                    var formatStringProp = AsterPlot.Properties.general.formatString;\n                    var maxValue = Math.max(d3.min(values[0].values));\n                    var minValue = Math.min(0, d3.min(values[0].values));\n                    var labelFormatter = ValueFormatter.create({\n                        format: ValueFormatter.getFormatString(values[0].source, formatStringProp),\n                        precision: labelSettings.precision,\n                        value: (labelSettings.displayUnits === 0) && (maxValue != null) ? maxValue : labelSettings.displayUnits,\n                    });\n                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(catSource, formatStringProp);\n                    var fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize);\n                    for (var i = 0; i < catValues.length; i++) {\n                        var formattedCategoryValue = visuals.valueFormatter.format(catValues[i], categorySourceFormatString);\n                        var currentValue = values[0].values[i];\n                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, currentValue, null, null, 0);\n                        if (values.length > 1) {\n                            var toolTip = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, values[1].values[i], null, null, 1)[1];\n                            if (toolTip)\n                                tooltipInfo.push(toolTip);\n                            currentValue += values[1].values[i];\n                        }\n                        var identity = cat.identity[i];\n                        var color = colorHelper.getColorForMeasure(catObjects && catObjects[i], identity.key);\n                        var selector = visuals.SelectionId.createWithId(identity);\n                        var sliceWidth = Math.max(0, values.length > 1 ? values[1].values[i] : 1);\n                        asterDataResult.dataPoints.push({\n                            sliceHeight: values[0].values[i] - minValue,\n                            sliceWidth: sliceWidth,\n                            label: labelFormatter.format(currentValue),\n                            color: color,\n                            identity: selector,\n                            selected: false,\n                            tooltipInfo: tooltipInfo,\n                            labelFontSize: fontSizeInPx,\n                            highlight: false,\n                        });\n                        // Handle legend data\n                        if (asterDataResult.legendSettings.show)\n                            asterDataResult.legendData.dataPoints.push({\n                                label: catValues[i],\n                                color: color,\n                                icon: visuals.LegendIcon.Box,\n                                selected: false,\n                                identity: selector\n                            });\n                        // Handle highlights\n                        if (hasHighlights) {\n                            var highlightIdentity = visuals.SelectionId.createWithHighlight(selector);\n                            var notNull = values[0].highlights[i] != null;\n                            currentValue = notNull ? values[0].highlights[i] : 0;\n                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, currentValue, null, null, 0);\n                            if (values.length > 1) {\n                                var toolTip = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, values[1].highlights[i], null, null, 1)[1];\n                                if (toolTip)\n                                    tooltipInfo.push(toolTip);\n                                currentValue += values[1].highlights[i] !== null ? values[1].highlights[i] : 0;\n                            }\n                            asterDataResult.highlightedDataPoints.push({\n                                sliceHeight: notNull ? values[0].highlights[i] - minValue : null,\n                                sliceWidth: Math.max(0, (values.length > 1 && values[1].highlights[i] !== null) ? values[1].highlights[i] : sliceWidth),\n                                label: labelFormatter.format(currentValue),\n                                color: color,\n                                identity: highlightIdentity,\n                                selected: false,\n                                tooltipInfo: tooltipInfo,\n                                labelFontSize: fontSizeInPx,\n                                highlight: true,\n                            });\n                        }\n                    }\n                    return asterDataResult;\n                };\n                AsterPlot.prototype.dataViewContainsCategory = function (dataView) {\n                    return dataView &&\n                        dataView.categorical &&\n                        dataView.categorical.values &&\n                        dataView.categorical.categories &&\n                        dataView.categorical.categories[0];\n                };\n                AsterPlot.prototype.getLabelSettings = function (objects, labelSettings) {\n                    var asterPlotLabelsProperties = AsterPlot.Properties;\n                    var precision = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.labelPrecision, labelSettings.precision);\n                    labelSettings.precision = precision === undefined ? precision : Math.min(precision, MaxPrecision);\n                    labelSettings.show = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.show, labelSettings.show);\n                    labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.fontSize, labelSettings.fontSize);\n                    labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.labelDisplayUnits, labelSettings.displayUnits);\n                    var colorHelper = new visuals.ColorHelper(this.colors, asterPlotLabelsProperties.labels.color, labelSettings.labelColor);\n                    labelSettings.labelColor = colorHelper.getColorForMeasure(objects, \"\");\n                    return labelSettings;\n                };\n                AsterPlot.prototype.updateLegendSettings = function (objects, catSource, legendSettings) {\n                    var legendProperties = AsterPlot.Properties.legend;\n                    legendSettings.show = powerbi.DataViewObjects.getValue(objects, legendProperties.show, legendSettings.show);\n                    legendSettings.position = powerbi.DataViewObjects.getValue(objects, legendProperties.position, legendSettings.position);\n                    legendSettings.showTitle = powerbi.DataViewObjects.getValue(objects, legendProperties.showTitle, legendSettings.showTitle);\n                    var titleText = powerbi.DataViewObjects.getValue(objects, legendProperties.titleText, '');\n                    legendSettings.titleText = _.isEmpty(titleText) && catSource ? catSource.displayName : titleText;\n                    legendSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, legendProperties.labelColor, legendSettings.labelColor);\n                    legendSettings.fontSize = powerbi.DataViewObjects.getValue(objects, legendProperties.fontSize, legendSettings.fontSize);\n                };\n                AsterPlot.prototype.init = function (options) {\n                    this.hostService = options.host;\n                    var element = options.element;\n                    var svg = this.svg = d3.select(element.get(0))\n                        .append('svg')\n                        .classed(AsterPlotVisualClassName, true)\n                        .style('position', 'absolute');\n                    this.colors = options.style.colorPalette.dataColors;\n                    this.mainGroupElement = svg.append('g');\n                    this.mainLabelsElement = svg.append('g');\n                    this.behavior = new AsterPlotWebBehavior();\n                    this.clearCatcher = visuals.appendClearCatcher(this.mainGroupElement);\n                    var interactivity = options.interactivity;\n                    this.interactivityService = visuals.createInteractivityService(this.hostService);\n                    this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);\n                };\n                AsterPlot.prototype.update = function (options) {\n                    if (!options.dataViews || !options.dataViews[0])\n                        return; // or clear the view, display an error, etc.\n                    var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;\n                    this.currentViewport = {\n                        height: Math.max(0, options.viewport.height),\n                        width: Math.max(0, options.viewport.width)\n                    };\n                    var dataView = this.dataView = options.dataViews[0];\n                    var convertedData = this.data = this.converter(dataView, this.colors);\n                    if (!convertedData || !convertedData.dataPoints || convertedData.dataPoints.length === 0) {\n                        this.clearData();\n                        return;\n                    }\n                    if (this.interactivityService) {\n                        this.interactivityService.applySelectionStateToData(convertedData.dataPoints);\n                        this.interactivityService.applySelectionStateToData(convertedData.highlightedDataPoints);\n                    }\n                    this.renderLegend(convertedData);\n                    this.updateViewPortAccordingToLegend();\n                    this.svg\n                        .attr({\n                        height: Math.max(0, this.currentViewport.height),\n                        width: Math.max(0, this.currentViewport.width)\n                    });\n                    var margin = this.margin;\n                    var transformX = (this.currentViewport.width - margin.left) / 2;\n                    var transformY = (this.currentViewport.height - margin.top) / 2;\n                    this.mainGroupElement.attr('transform', visuals.SVGUtil.translate(transformX, transformY));\n                    this.mainLabelsElement.attr('transform', visuals.SVGUtil.translate(transformX, transformY));\n                    // Move back the clearCatcher\n                    this.clearCatcher.attr('transform', visuals.SVGUtil.translate(-transformX, -transformY));\n                    // Clear previous data\n                    this.mainGroupElement.selectAll(AsterPlot.AsterSlice.selector).remove();\n                    this.mainGroupElement.selectAll(AsterPlot.AsterHighlightedSlice.selector).remove();\n                    visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);\n                    var dataPoints = convertedData.dataPoints;\n                    if (!dataPoints || dataPoints.length === 0)\n                        return;\n                    var selection = this.renderArcsAndLabels(dataPoints, duration, convertedData.labelSettings);\n                    var highlightedSelection;\n                    if (this.hasHighlights)\n                        highlightedSelection = this.renderArcsAndLabels(convertedData.highlightedDataPoints, duration, convertedData.labelSettings, true);\n                    var interactivityService = this.interactivityService;\n                    if (interactivityService) {\n                        var behaviorOptions = {\n                            selection: selection,\n                            highlightedSelection: highlightedSelection,\n                            clearCatcher: this.clearCatcher,\n                            interactivityService: this.interactivityService,\n                        };\n                        interactivityService.bind(convertedData.dataPoints.concat(convertedData.highlightedDataPoints), this.behavior, behaviorOptions);\n                    }\n                };\n                AsterPlot.prototype.renderArcsAndLabels = function (dataPoints, duration, labelSettings, isHighlight) {\n                    if (isHighlight === void 0) { isHighlight = false; }\n                    var margin = this.margin;\n                    var width = this.currentViewport.width - margin.left - margin.right;\n                    var height = this.currentViewport.height - margin.top - margin.bottom;\n                    var radius = Math.min(width, height) / 2;\n                    var innerRadius = 0.3 * (labelSettings.show ? radius * AsterRadiusRatio : radius);\n                    var maxScore = d3.max(dataPoints, function (d) { return d.sliceHeight; });\n                    var totalWeight = d3.sum(dataPoints, function (d) { return d.sliceWidth; });\n                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();\n                    var hasHighlights = this.hasHighlights;\n                    var pie = d3.layout.pie()\n                        .sort(null)\n                        .value(function (d) { return (d && !isNaN(d.sliceWidth) ? d.sliceWidth : 0) / totalWeight; });\n                    var arc = d3.svg.arc()\n                        .innerRadius(innerRadius)\n                        .outerRadius(function (d) {\n                        var height = (radius - innerRadius) * (d && d.data && !isNaN(d.data.sliceHeight) ? d.data.sliceHeight : 1) / maxScore;\n                        //The chart should shrink if data labels are on\n                        var heightIsLabelsOn = innerRadius + (labelSettings.show ? height * AsterRadiusRatio : height);\n                        // Prevent from data to be inside the inner radius\n                        return Math.max(heightIsLabelsOn, innerRadius);\n                    });\n                    var arcDescriptorDataPoints = pie(dataPoints);\n                    var classSelector = isHighlight ? AsterPlot.AsterHighlightedSlice : AsterPlot.AsterSlice;\n                    var selection = this.mainGroupElement.selectAll(classSelector.selector)\n                        .data(arcDescriptorDataPoints, function (d, idx) { return d.data ? d.data.identity.getKey() : idx; });\n                    selection.enter()\n                        .append('path')\n                        .attr('stroke', '#333')\n                        .classed(classSelector.class, true);\n                    selection\n                        .attr('fill', function (d) { return d.data.color; })\n                        .style(\"fill-opacity\", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, hasSelection, hasHighlights); })\n                        .transition().duration(duration)\n                        .attrTween('d', function (data) {\n                        if (!this.oldData) {\n                            this.oldData = data;\n                            return function () { return arc(data); };\n                        }\n                        var interpolation = d3.interpolate(this.oldData, data);\n                        this.oldData = interpolation(0);\n                        return function (x) { return arc(interpolation(x)); };\n                    });\n                    selection\n                        .exit()\n                        .remove();\n                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });\n                    // Draw data labels only if they are on and there are no highlights or there are highlights and this is the highlighted data labels\n                    if (labelSettings.show && (!hasHighlights || (hasHighlights && isHighlight))) {\n                        var labelRadCalc_1 = function (d) {\n                            var height = radius * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore + innerRadius;\n                            return Math.max(height, innerRadius);\n                        };\n                        var labelArc = d3.svg.arc()\n                            .innerRadius(function (d) { return labelRadCalc_1(d.data); })\n                            .outerRadius(function (d) { return labelRadCalc_1(d.data); });\n                        var lineRadCalc_1 = function (d) {\n                            var height = (radius - innerRadius) * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore;\n                            height = innerRadius + height * AsterRadiusRatio;\n                            return Math.max(height, innerRadius);\n                        };\n                        var outlineArc = d3.svg.arc()\n                            .innerRadius(function (d) { return lineRadCalc_1(d.data); })\n                            .outerRadius(function (d) { return lineRadCalc_1(d.data); });\n                        var layout = this.getLabelLayout(labelSettings, labelArc, this.currentViewport);\n                        this.drawLabels(arcDescriptorDataPoints, this.mainLabelsElement, layout, this.currentViewport, outlineArc, labelArc);\n                    }\n                    else\n                        visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);\n                    // Draw center text and outline once for original data points\n                    if (!isHighlight) {\n                        this.drawCenterText(innerRadius);\n                        this.drawOuterLine(innerRadius, radius, arcDescriptorDataPoints);\n                    }\n                    return selection;\n                };\n                AsterPlot.prototype.getLabelLayout = function (labelSettings, arc, viewport) {\n                    var midAngle = function (d) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };\n                    var textProperties = {\n                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,\n                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize),\n                        text: '',\n                    };\n                    var isLabelsHasConflict = function (d) {\n                        var pos = arc.centroid(d);\n                        textProperties.text = d.data.label;\n                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);\n                        var horizontalSpaceAvaliableForLabels = viewport.width / 2 - Math.abs(pos[0]);\n                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);\n                        var verticalSpaceAvaliableForLabels = viewport.height / 2 - Math.abs(pos[1]);\n                        d.isLabelHasConflict = textWidth > horizontalSpaceAvaliableForLabels || textHeight > verticalSpaceAvaliableForLabels;\n                        return d.isLabelHasConflict;\n                    };\n                    return {\n                        labelText: function (d) {\n                            textProperties.text = d.data.label;\n                            var pos = arc.centroid(d);\n                            var xPos = isLabelsHasConflict(d) ? pos[0] * AsterConflictRatio : pos[0];\n                            var spaceAvaliableForLabels = viewport.width / 2 - Math.abs(xPos);\n                            return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);\n                        },\n                        labelLayout: {\n                            x: function (d) {\n                                var pos = arc.centroid(d);\n                                textProperties.text = d.data.label;\n                                var xPos = d.isLabelHasConflict ? pos[0] * AsterConflictRatio : pos[0];\n                                return xPos;\n                            },\n                            y: function (d) {\n                                var pos = arc.centroid(d);\n                                var yPos = d.isLabelHasConflict ? pos[1] * AsterConflictRatio : pos[1];\n                                return yPos;\n                            },\n                        },\n                        filter: function (d) { return (d != null && !_.isEmpty(d.data.label)); },\n                        style: {\n                            'fill': labelSettings.labelColor,\n                            'font-size': textProperties.fontSize,\n                            'text-anchor': function (d) { return midAngle(d) < Math.PI ? 'start' : 'end'; },\n                        },\n                    };\n                };\n                AsterPlot.prototype.drawLabels = function (data, context, layout, viewport, outlineArc, labelArc) {\n                    var _this = this;\n                    // Hide and reposition labels that overlap\n                    var dataLabelManager = new powerbi.DataLabelManager();\n                    var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, true /* addTransform */);\n                    if (filteredData.length === 0) {\n                        visuals.dataLabelUtils.cleanDataLabels(context, true);\n                        return;\n                    }\n                    // Draw labels\n                    if (context.select(AsterPlot.labelGraphicsContextClass.selector).empty())\n                        context.append('g').classed(AsterPlot.labelGraphicsContextClass.class, true);\n                    var labels = context\n                        .select(AsterPlot.labelGraphicsContextClass.selector)\n                        .selectAll('.data-labels').data(filteredData, function (d) { return d.data.identity.getKey(); });\n                    labels.enter().append('text').classed('data-labels', true);\n                    if (!labels)\n                        return;\n                    labels\n                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; }, dy: '.35em' })\n                        .text(function (d) { return d.labeltext; })\n                        .style(layout.style);\n                    labels\n                        .exit()\n                        .remove();\n                    // Draw lines\n                    if (context.select(AsterPlot.linesGraphicsContextClass.selector).empty())\n                        context.append('g').classed(AsterPlot.linesGraphicsContextClass.class, true);\n                    // Remove lines for null and zero values\n                    filteredData = _.filter(filteredData, function (d) { return d.data.sliceHeight !== null && d.data.sliceHeight !== 0; });\n                    var lines = context.select(AsterPlot.linesGraphicsContextClass.selector).selectAll('polyline')\n                        .data(filteredData, function (d) { return d.data.identity.getKey(); });\n                    var labelLinePadding = 4;\n                    var chartLinePadding = 1.02;\n                    var midAngle = function (d) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };\n                    lines.enter()\n                        .append('polyline')\n                        .classed('line-label', true);\n                    lines\n                        .attr('points', function (d) {\n                        var textPoint = [d.labelX, d.labelY];\n                        textPoint[0] = textPoint[0] + ((midAngle(d) < Math.PI ? -1 : 1) * labelLinePadding);\n                        var chartPoint = outlineArc.centroid(d);\n                        chartPoint[0] *= chartLinePadding;\n                        chartPoint[1] *= chartLinePadding;\n                        return [chartPoint, textPoint];\n                    }).\n                        style({\n                        'opacity': 0.5,\n                        'fill-opacity': 0,\n                        'stroke': function (d) { return _this.data.labelSettings.labelColor; },\n                    });\n                    lines\n                        .exit()\n                        .remove();\n                };\n                AsterPlot.prototype.renderLegend = function (asterPlotData) {\n                    if (!asterPlotData || !asterPlotData.legendData)\n                        return;\n                    var legendData = asterPlotData.legendData;\n                    var objects = this.dataView && this.dataView.metadata ? this.dataView.metadata.objects : null;\n                    var legendObjectProperties = powerbi.DataViewObjects.getObject(objects, AsterPlotLegendObjectName, {});\n                    if (legendObjectProperties) {\n                        var legendSettings = asterPlotData.legendSettings;\n                        // Force update for title text\n                        legendObjectProperties['titleText'] = legendSettings.titleText;\n                        visuals.LegendData.update(legendData, legendObjectProperties);\n                        this.legend.changeOrientation(visuals.LegendPosition[legendSettings.position]);\n                    }\n                    this.legend.drawLegend(legendData, _.clone(this.currentViewport));\n                    visuals.Legend.positionChartArea(this.svg, this.legend);\n                };\n                AsterPlot.prototype.updateViewPortAccordingToLegend = function () {\n                    var legendSettings = this.data.legendSettings;\n                    if (!legendSettings || !legendSettings.show)\n                        return;\n                    var legendMargins = this.legend.getMargins();\n                    var legendPosition = visuals.LegendPosition[legendSettings.position];\n                    switch (legendPosition) {\n                        case visuals.LegendPosition.Top:\n                        case visuals.LegendPosition.TopCenter:\n                        case visuals.LegendPosition.Bottom:\n                        case visuals.LegendPosition.BottomCenter: {\n                            this.currentViewport.height -= legendMargins.height;\n                            break;\n                        }\n                        case visuals.LegendPosition.Left:\n                        case visuals.LegendPosition.LeftCenter:\n                        case visuals.LegendPosition.Right:\n                        case visuals.LegendPosition.RightCenter: {\n                            this.currentViewport.width -= legendMargins.width;\n                            break;\n                        }\n                        default:\n                            break;\n                    }\n                };\n                AsterPlot.prototype.drawOuterLine = function (innerRadius, radius, data) {\n                    var mainGroup = this.mainGroupElement;\n                    var outlineArc = d3.svg.arc()\n                        .innerRadius(innerRadius)\n                        .outerRadius(radius);\n                    if (this.data.showOuterLine) {\n                        var OuterThickness = this.data.outerLineThickness + 'px';\n                        var outerLine = mainGroup.selectAll(AsterPlot.OuterLine.selector).data(data);\n                        outerLine.enter().append('path');\n                        outerLine.attr(\"fill\", \"none\")\n                            .attr({\n                            'stroke': '#333',\n                            'stroke-width': OuterThickness,\n                            'd': outlineArc\n                        })\n                            .style('opacity', 1)\n                            .classed(AsterPlot.OuterLine.class, true);\n                        outerLine.exit().remove();\n                    }\n                    else\n                        mainGroup.selectAll(AsterPlot.OuterLine.selector).remove();\n                };\n                AsterPlot.prototype.getCenterText = function (dataView) {\n                    if (dataView && dataView.metadata && dataView.metadata.columns && dataView.categorical && dataView.categorical.values)\n                        for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {\n                            var column = _a[_i];\n                            if (!column.isMeasure)\n                                return column.displayName;\n                        }\n                    return '';\n                };\n                AsterPlot.prototype.drawCenterText = function (innerRadius) {\n                    var text = this.getCenterText(this.dataView);\n                    if (_.isEmpty(text)) {\n                        this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove();\n                        return;\n                    }\n                    var centerTextProperties = {\n                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,\n                        fontWeight: 'bold',\n                        fontSize: PixelConverter.toString(innerRadius * AsterPlot.CenterTextFontHeightCoefficient),\n                        text: text\n                    };\n                    if (this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).empty())\n                        this.centerText = this.mainGroupElement.append('text').classed(AsterPlot.CenterLabelClass.class, true);\n                    this.centerText\n                        .style({\n                        'line-height': 1,\n                        'font-weight': centerTextProperties.fontWeight,\n                        'font-size': centerTextProperties.fontSize,\n                        'fill': this.getLabelFill(this.dataView).solid.color\n                    })\n                        .attr({\n                        'dy': '0.35em',\n                        'text-anchor': 'middle'\n                    })\n                        .text(powerbi.TextMeasurementService.getTailoredTextOrDefault(centerTextProperties, innerRadius * AsterPlot.CenterTextFontWidthCoefficient));\n                };\n                // This extracts fill color of the label from the DataView\n                AsterPlot.prototype.getLabelFill = function (dataView) {\n                    if (this.dataViewContainsObjects(dataView))\n                        return powerbi.DataViewObjects.getValue(dataView.metadata.objects, AsterPlot.Properties.label.fill, AsterDefaultLabelFill);\n                    return AsterDefaultLabelFill;\n                };\n                AsterPlot.prototype.dataViewContainsObjects = function (dataView) {\n                    return dataView && dataView.metadata && dataView.metadata.objects;\n                };\n                AsterPlot.prototype.enumerateLegend = function (instances) {\n                    var legendSettings = this.data.legendSettings;\n                    var instance = {\n                        selector: null,\n                        objectName: AsterPlotLegendObjectName,\n                        displayName: 'Legend',\n                        properties: {\n                            show: legendSettings.show,\n                            position: legendSettings.position,\n                            showTitle: legendSettings.showTitle,\n                            titleText: legendSettings.titleText,\n                            labelColor: legendSettings.labelColor,\n                            fontSize: legendSettings.fontSize,\n                        }\n                    };\n                    instances.push(instance);\n                };\n                AsterPlot.prototype.clearData = function () {\n                    this.mainGroupElement.selectAll(\"path\").remove();\n                    visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);\n                    this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);\n                };\n                AsterPlot.prototype.onClearSelection = function () {\n                    if (this.interactivityService)\n                        this.interactivityService.clearSelection();\n                };\n                AsterPlot.prototype.enumerateLabels = function (instances) {\n                    var labelSettings = this.data.labelSettings;\n                    var labels = {\n                        objectName: 'labels',\n                        displayName: 'Labels',\n                        selector: null,\n                        properties: {\n                            show: labelSettings.show,\n                            fontSize: labelSettings.fontSize,\n                            labelPrecision: labelSettings.precision,\n                            labelDisplayUnits: labelSettings.displayUnits,\n                            color: labelSettings.labelColor,\n                        }\n                    };\n                    instances.push(labels);\n                };\n                // This function retruns the values to be displayed in the property pane for each object.\n                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do\n                // validation and return other values/defaults\n                AsterPlot.prototype.enumerateObjectInstances = function (options) {\n                    var instances = [];\n                    if (!this.dataViewContainsCategory(this.dataView))\n                        return instances;\n                    switch (options.objectName) {\n                        case AsterPlotLegendObjectName:\n                            if (this.data)\n                                this.enumerateLegend(instances);\n                            break;\n                        case 'label':\n                            var label = {\n                                objectName: 'label',\n                                displayName: 'Label',\n                                selector: null,\n                                properties: {\n                                    fill: this.getLabelFill(this.dataView)\n                                }\n                            };\n                            instances.push(label);\n                            break;\n                        case 'labels':\n                            this.enumerateLabels(instances);\n                            break;\n                        case 'outerLine':\n                            var outerLine = {\n                                objectName: 'outerLine',\n                                displayName: 'Outer Line',\n                                selector: null,\n                                properties: {\n                                    show: this.data.showOuterLine,\n                                    thickness: this.data.outerLineThickness,\n                                }\n                            };\n                            instances.push(outerLine);\n                            break;\n                    }\n                    return instances;\n                };\n                AsterPlot.capabilities = {\n                    dataRoles: [\n                        {\n                            displayName: 'Category',\n                            name: 'Category',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                        },\n                        {\n                            displayName: 'Y Axis',\n                            name: 'Y',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                        },\n                    ],\n                    dataViewMappings: [{\n                            conditions: [\n                                { 'Category': { max: 1 }, 'Y': { max: 2 } }\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Category' },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: {\n                                    select: [{ bind: { to: 'Y' } }]\n                                },\n                            }\n                        }],\n                    objects: {\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),\n                            properties: {\n                                formatString: {\n                                    type: { formatting: { formatString: true } },\n                                },\n                            },\n                        },\n                        legend: {\n                            displayName: 'Legend',\n                            description: 'Display legend options',\n                            properties: {\n                                show: {\n                                    displayName: 'Show',\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: 'Position',\n                                    description: 'Select the location for the legend',\n                                    type: { enumeration: visuals.legendPosition.type }\n                                },\n                                showTitle: {\n                                    displayName: 'Title',\n                                    description: 'Display a title for legend symbols',\n                                    type: { bool: true }\n                                },\n                                titleText: {\n                                    displayName: 'Legend Name',\n                                    description: 'Title text',\n                                    type: { text: true },\n                                    suppressFormatPainterCopy: true\n                                },\n                                labelColor: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: 'Text Size',\n                                    type: { formatting: { fontSize: true } }\n                                }\n                            }\n                        },\n                        label: {\n                            displayName: 'Center Label',\n                            properties: {\n                                fill: {\n                                    displayName: 'Fill',\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        labels: {\n                            displayName: 'Detail Labels',\n                            properties: {\n                                show: {\n                                    type: { bool: true }\n                                },\n                                color: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                labelDisplayUnits: {\n                                    displayName: 'Display Units',\n                                    type: { formatting: { labelDisplayUnits: true } },\n                                },\n                                labelPrecision: {\n                                    displayName: 'Decimal Places',\n                                    placeHolderText: 'Auto',\n                                    type: { numeric: true },\n                                },\n                                fontSize: {\n                                    displayName: 'Text Size',\n                                    type: { formatting: { fontSize: true } },\n                                },\n                            },\n                        },\n                        outerLine: {\n                            displayName: 'Outer line',\n                            properties: {\n                                show: {\n                                    displayName: 'Show',\n                                    type: { bool: true }\n                                },\n                                thickness: {\n                                    displayName: 'Thickness',\n                                    type: { numeric: true }\n                                }\n                            }\n                        }\n                    },\n                    supportsHighlight: true,\n                };\n                AsterPlot.Properties = {\n                    general: {\n                        formatString: { objectName: 'general', propertyName: 'formatString' },\n                    },\n                    dataPoint: {\n                        fill: { objectName: 'dataPoint', propertyName: 'fill' },\n                    },\n                    legend: {\n                        show: { objectName: AsterPlotLegendObjectName, propertyName: 'show' },\n                        position: { objectName: AsterPlotLegendObjectName, propertyName: 'position' },\n                        showTitle: { objectName: AsterPlotLegendObjectName, propertyName: 'showTitle' },\n                        titleText: { objectName: AsterPlotLegendObjectName, propertyName: 'titleText' },\n                        labelColor: { objectName: AsterPlotLegendObjectName, propertyName: 'labelColor' },\n                        fontSize: { objectName: AsterPlotLegendObjectName, propertyName: 'fontSize' },\n                    },\n                    label: {\n                        fill: { objectName: 'label', propertyName: 'fill' },\n                    },\n                    labels: {\n                        show: { objectName: 'labels', propertyName: 'show' },\n                        color: { objectName: 'labels', propertyName: 'color' },\n                        labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },\n                        labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },\n                        fontSize: { objectName: 'labels', propertyName: 'fontSize' },\n                    },\n                    outerLine: {\n                        show: { objectName: 'outerLine', propertyName: 'show' },\n                        thickness: { objectName: 'outerLine', propertyName: 'thickness' },\n                    }\n                };\n                AsterPlot.AsterSlice = createClassAndSelector('asterSlice');\n                AsterPlot.AsterHighlightedSlice = createClassAndSelector('asterHighlightedSlice');\n                AsterPlot.OuterLine = createClassAndSelector('outerLine');\n                AsterPlot.labelGraphicsContextClass = createClassAndSelector('labels');\n                AsterPlot.linesGraphicsContextClass = createClassAndSelector('lines');\n                AsterPlot.CenterLabelClass = createClassAndSelector('centerLabel');\n                AsterPlot.CenterTextFontHeightCoefficient = 0.4;\n                AsterPlot.CenterTextFontWidthCoefficient = 1.9;\n                return AsterPlot;\n            }());\n            samples.AsterPlot = AsterPlot;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var PixelConverter = jsCommon.PixelConverter;\n            var TornadoWebBehavior = (function () {\n                function TornadoWebBehavior() {\n                }\n                TornadoWebBehavior.prototype.bindEvents = function (options, selectionHandler) {\n                    this.columns = options.columns;\n                    this.clearCatcher = options.clearCatcher;\n                    this.interactivityService = options.interactivityService;\n                    this.columns.on('click', function (d, i) {\n                        selectionHandler.handleSelection(d, d3.event.ctrlKey);\n                    });\n                    this.clearCatcher.on('click', function () {\n                        selectionHandler.handleClearSelection();\n                    });\n                };\n                TornadoWebBehavior.prototype.renderSelection = function (hasSelection) {\n                    var hasHighlights = this.interactivityService.hasSelection();\n                    this.columns.style(\"fill-opacity\", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights); });\n                };\n                return TornadoWebBehavior;\n            }());\n            var TornadoChartScrolling = (function () {\n                function TornadoChartScrolling(getRoot, getViewport, getMargin, isScrollable) {\n                    this.scrollYBrush = d3.svg.brush();\n                    this.getRoot = getRoot;\n                    this.getViewport = getViewport;\n                    this.isScrollable = isScrollable;\n                }\n                Object.defineProperty(TornadoChartScrolling.prototype, \"root\", {\n                    get: function () {\n                        return this.getRoot();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(TornadoChartScrolling.prototype, \"viewport\", {\n                    get: function () {\n                        return this.getViewport();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                TornadoChartScrolling.prototype.renderY = function (data, prefferedHeight, onScroll) {\n                    var _this = this;\n                    this.isYScrollBarVisible = prefferedHeight > this.viewport.height\n                        && this.viewport.height > 0\n                        && this.viewport.width > 0;\n                    this.brushGraphicsContextY = this.createOrRemoveScrollbar(this.isYScrollBarVisible, this.brushGraphicsContextY, 'y brush');\n                    this.updateScrollViewport();\n                    if (!this.isYScrollBarVisible) {\n                        onScroll.call(this, jQuery.extend(true, {}, data), 0, 1);\n                        return;\n                    }\n                    var scrollSpaceLength = this.viewport.height;\n                    var extentData = this.getExtentData(prefferedHeight, scrollSpaceLength);\n                    var onRender = function (wheelDelta) {\n                        if (wheelDelta === void 0) { wheelDelta = 0; }\n                        var position = _this.scrollYBrush.extent();\n                        if (wheelDelta !== 0) {\n                            // Handle mouse wheel manually by moving the scrollbar half of its size\n                            var halfScrollsize = (position[1] - position[0]) / 2;\n                            position[0] += (wheelDelta > 0) ? halfScrollsize : -halfScrollsize;\n                            position[1] += (wheelDelta > 0) ? halfScrollsize : -halfScrollsize;\n                            if (position[0] < 0) {\n                                var offset = 0 - position[0];\n                                position[0] += offset;\n                                position[1] += offset;\n                            }\n                            if (position[1] > scrollSpaceLength) {\n                                var offset = position[1] - scrollSpaceLength;\n                                position[0] -= offset;\n                                position[1] -= offset;\n                            }\n                            // Update the scroll bar accordingly and redraw\n                            _this.scrollYBrush.extent(position);\n                            _this.brushGraphicsContextY.select('.extent').attr('y', position[0]);\n                        }\n                        var scrollPosition = extentData.toScrollPosition(position, scrollSpaceLength);\n                        onScroll.call(_this, jQuery.extend(true, {}, data), scrollPosition[0], scrollPosition[1]);\n                        _this.setScrollBarSize(_this.brushGraphicsContextY, extentData.value[1], true);\n                    };\n                    var scrollYScale = d3.scale.ordinal().rangeBands([0, scrollSpaceLength]);\n                    this.scrollYBrush.y(scrollYScale).extent(extentData.value);\n                    this.renderScrollbar(this.scrollYBrush, this.brushGraphicsContextY, this.viewport.width, onRender);\n                    onRender();\n                };\n                TornadoChartScrolling.prototype.updateScrollViewport = function () {\n                    this.scrollViewport = { height: this.viewport.height, width: this.viewport.width };\n                    if (this.isYScrollBarVisible && this.isScrollable) {\n                        this.scrollViewport.width -= TornadoChart.ScrollBarWidth;\n                    }\n                };\n                TornadoChartScrolling.prototype.createOrRemoveScrollbar = function (isVisible, brushGraphicsContext, brushClass) {\n                    if (isVisible && this.isScrollable) {\n                        return brushGraphicsContext || this.root.append(\"g\").classed(brushClass, true);\n                    }\n                    return brushGraphicsContext ? void brushGraphicsContext.remove() : undefined;\n                };\n                TornadoChartScrolling.prototype.renderScrollbar = function (brush, brushGraphicsContext, brushX, onRender) {\n                    var _this = this;\n                    brush.on(\"brush\", function () { return window.requestAnimationFrame(function () { return onRender(0); }); });\n                    this.root.on('wheel', function () {\n                        if (!_this.isYScrollBarVisible)\n                            return;\n                        var wheelEvent = d3.event; // Casting to any to avoid compilation errors\n                        onRender(wheelEvent.deltaY);\n                    });\n                    brushGraphicsContext.attr({\n                        \"transform\": visuals.SVGUtil.translate(brushX, 0),\n                        \"drag-resize-disabled\": \"true\" /*disables resizing of the visual when dragging the scrollbar in edit mode*/\n                    });\n                    brushGraphicsContext.call(brush); /*call the brush function, causing it to create the rectangles   */\n                    /* Disabling the zooming feature */\n                    brushGraphicsContext.selectAll(\".resize\").remove();\n                    brushGraphicsContext.select(\".background\").remove();\n                    brushGraphicsContext.selectAll(\".extent\").style({\n                        \"fill-opacity\": 0.125,\n                        \"cursor\": \"default\",\n                    });\n                };\n                TornadoChartScrolling.prototype.setScrollBarSize = function (brushGraphicsContext, minExtent, isVertical) {\n                    brushGraphicsContext.selectAll(\"rect\").attr(isVertical ? \"width\" : \"height\", TornadoChart.ScrollBarWidth);\n                    brushGraphicsContext.selectAll(\"rect\").attr(isVertical ? \"height\" : \"width\", minExtent);\n                };\n                TornadoChartScrolling.prototype.getExtentData = function (svgLength, scrollSpaceLength) {\n                    var value = scrollSpaceLength * scrollSpaceLength / svgLength;\n                    var scaleMultipler = TornadoChartScrolling.ScrollBarMinLength <= value\n                        ? 1\n                        : value / TornadoChartScrolling.ScrollBarMinLength;\n                    value = Math.max(value, TornadoChartScrolling.ScrollBarMinLength);\n                    var toScrollPosition = function (extent, scrollSpaceLength) {\n                        var scrollSize = extent[1] - extent[0];\n                        var scrollPosition = extent[0] / (scrollSpaceLength - scrollSize);\n                        scrollSize *= scaleMultipler;\n                        var start = (scrollPosition * (scrollSpaceLength - scrollSize));\n                        var end = (start + scrollSize);\n                        return [start / scrollSpaceLength, end / scrollSpaceLength];\n                    };\n                    return { value: [0, value], toScrollPosition: toScrollPosition };\n                };\n                TornadoChartScrolling.prototype.clearData = function () {\n                    if (this.brushGraphicsContextY)\n                        this.brushGraphicsContextY.selectAll(\"*\").remove();\n                };\n                TornadoChartScrolling.ScrollBarMinLength = 15;\n                return TornadoChartScrolling;\n            }());\n            var TornadoChartWarning = (function () {\n                function TornadoChartWarning() {\n                }\n                Object.defineProperty(TornadoChartWarning.prototype, \"code\", {\n                    get: function () {\n                        return \"TornadoChartWarning\";\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                TornadoChartWarning.prototype.getMessages = function (resourceProvider) {\n                    var message = \"This visual requires two distinct values to be returned for the Legend field.\", titleKey = \"\", detailKey = \"\", visualMessage;\n                    visualMessage = {\n                        message: message,\n                        title: resourceProvider.get(titleKey),\n                        detail: resourceProvider.get(detailKey)\n                    };\n                    return visualMessage;\n                };\n                return TornadoChartWarning;\n            }());\n            samples.TornadoChartWarning = TornadoChartWarning;\n            function getTornadoChartWarning() {\n                return new TornadoChartWarning();\n            }\n            samples.getTornadoChartWarning = getTornadoChartWarning;\n            var TornadoChart = (function () {\n                function TornadoChart(tornadoChartConstructorOptions) {\n                    this.DefaultTornadoChartSettings = {\n                        labelOutsideFillColor: visuals.dataLabelUtils.defaultLabelColor,\n                        labelSettings: {\n                            show: true,\n                            precision: null,\n                            fontSize: TornadoChart.DefaultFontSize,\n                            displayUnits: 0,\n                            labelColor: visuals.dataLabelUtils.defaultInsideLabelColor,\n                        },\n                        showCategories: true,\n                        showLegend: true,\n                        legendFontSize: TornadoChart.DefaultLegendFontSize,\n                        legendColor: visuals.LegendData.DefaultLegendLabelFillColor,\n                        categoriesFillColor: \"#777\"\n                    };\n                    this.DefaultFillColors = [\n                        \"purple\", \"teal\"\n                    ];\n                    this.columnPadding = 5;\n                    this.leftLabelMargin = 4;\n                    this.InnerTextHeightDelta = 2;\n                    this.textOptions = {};\n                    this.margin = {\n                        top: 10,\n                        right: 5,\n                        bottom: 10,\n                        left: 10\n                    };\n                    this.heightColumn = 0;\n                    this.widthLeftSection = 0;\n                    this.widthRightSection = 0;\n                    if (tornadoChartConstructorOptions) {\n                        this.svg = tornadoChartConstructorOptions.svg || this.svg;\n                        this.margin = tornadoChartConstructorOptions.margin || this.margin;\n                        this.columnPadding = tornadoChartConstructorOptions.columnPadding || this.columnPadding;\n                        this.animator = tornadoChartConstructorOptions.animator;\n                    }\n                }\n                TornadoChart.prototype.init = function (visualInitOptions) {\n                    var _this = this;\n                    var style = visualInitOptions.style, fontSize;\n                    this.hostService = visualInitOptions.host;\n                    var element = visualInitOptions.element;\n                    this.colors = style.colorPalette.dataColors;\n                    var interactivity = visualInitOptions.interactivity;\n                    this.interactivityService = visuals.createInteractivityService(this.hostService);\n                    var root;\n                    if (this.svg)\n                        this.root = root = this.svg;\n                    else\n                        this.root = root = d3.select(element.get(0))\n                            .append(\"svg\");\n                    root\n                        .classed(TornadoChart.ClassName, true)\n                        .style('position', 'absolute');\n                    fontSize = root.style(\"font-size\");\n                    this.textOptions.sizeUnit = fontSize.slice(fontSize.length - 2);\n                    this.textOptions.fontSize = Number(fontSize.slice(0, fontSize.length - 2));\n                    this.textOptions.fontFamily = root.style(\"font-family\");\n                    this.scrolling = new TornadoChartScrolling(function () { return root; }, function () { return _this.viewport; }, function () { return _this.margin; }, true);\n                    var main = this.main = root.append(\"g\");\n                    this.clearCatcher = visuals.appendClearCatcher(main);\n                    this.columns = main\n                        .append(\"g\")\n                        .classed(TornadoChart.Columns.class, true);\n                    this.axes = main\n                        .append(\"g\")\n                        .classed(TornadoChart.Axes.class, true);\n                    this.labels = main\n                        .append(\"g\")\n                        .classed(TornadoChart.Labels.class, true);\n                    this.categories = main\n                        .append(\"g\")\n                        .classed(TornadoChart.Categories.class, true);\n                    this.behavior = new TornadoWebBehavior();\n                    this.defaultTornadoChartDataView = {\n                        categories: [],\n                        series: [],\n                        settings: null,\n                        legend: null,\n                        dataPoints: [],\n                        highlightedDataPoints: [],\n                    };\n                    this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);\n                };\n                TornadoChart.prototype.update = function (visualUpdateOptions) {\n                    if (!visualUpdateOptions ||\n                        !visualUpdateOptions.dataViews ||\n                        !visualUpdateOptions.dataViews[0]) {\n                        return;\n                    }\n                    this.viewport = {\n                        height: Math.max(0, visualUpdateOptions.viewport.height - this.margin.top - this.margin.bottom),\n                        width: Math.max(0, visualUpdateOptions.viewport.width - this.margin.left - this.margin.right)\n                    };\n                    if (this.animator)\n                        this.durationAnimations = visuals.AnimatorCommon.GetAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);\n                    else\n                        this.durationAnimations = visualUpdateOptions.suppressAnimations ? 0 : 250;\n                    this.tornadoChartDataView = this.converter(visualUpdateOptions.dataViews[0]);\n                    if (this.interactivityService) {\n                        this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.dataPoints);\n                        this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.highlightedDataPoints);\n                    }\n                    this.render();\n                };\n                TornadoChart.prototype.updateElements = function () {\n                    var elementsTranslate = visuals.SVGUtil.translate(this.widthLeftSection, 0);\n                    this.root.attr({\n                        \"height\": this.viewport.height + this.margin.top + this.margin.bottom,\n                        \"width\": this.viewport.width + this.margin.left + this.margin.right\n                    });\n                    this.columns\n                        .attr(\"transform\", elementsTranslate);\n                    this.labels\n                        .attr(\"transform\", elementsTranslate);\n                    this.axes\n                        .attr(\"transform\", elementsTranslate);\n                };\n                TornadoChart.prototype.converter = function (dataView) {\n                    if (!dataView ||\n                        !dataView.categorical ||\n                        !dataView.categorical.categories ||\n                        !dataView.categorical.categories[0] ||\n                        !dataView.categorical.categories[0].source ||\n                        !dataView.categorical.values ||\n                        !dataView.categorical.values[0]) {\n                        return this.defaultTornadoChartDataView;\n                    }\n                    var categorical = dataView.categorical;\n                    var categories = categorical.categories || [];\n                    var values = categorical.values;\n                    if (values.length > TornadoChart.MaxSeries) {\n                        this.hostService.setWarnings([getTornadoChartWarning()]);\n                        return this.defaultTornadoChartDataView;\n                    }\n                    var category = categories[0];\n                    var categoryValues = category.values;\n                    var categoryValuesLength = categoryValues.length;\n                    var objects = this.getObjectsFromDataView(dataView);\n                    var formatStringProp = TornadoChart.Properties.general.formatString;\n                    var valuesSourceFormatString = visuals.valueFormatter.getFormatString(values[0].source, formatStringProp);\n                    var maxValue = d3.max(values[0].values);\n                    var settings = this.parseSettings(objects, valuesSourceFormatString, maxValue);\n                    this.hasDynamicSeries = !!values.source;\n                    var hasHighlights = this.hasHighlights = !!(values.length > 0 && values[0].highlights);\n                    this.labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight({\n                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,\n                        fontSize: PixelConverter.fromPoint(settings.labelSettings.fontSize),\n                    });\n                    var series = [];\n                    var dataPoints = [];\n                    var highlightedDataPoints = [];\n                    var categoriesLabels = [];\n                    var groupedValues = [];\n                    if (values.grouped)\n                        groupedValues = values.grouped();\n                    // Parse category labels and compute maximum category length\n                    var maxCategoryLength = 0;\n                    var showCategories = settings.showCategories;\n                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(category.source, formatStringProp);\n                    for (var i = 0; i < categoryValuesLength; i++) {\n                        var formattedCategoryValue = visuals.valueFormatter.format(categoryValues[i], categorySourceFormatString);\n                        var textData = this.getTextData(formattedCategoryValue, true);\n                        categoriesLabels.push(textData);\n                        if (showCategories && textData.width > maxCategoryLength)\n                            maxCategoryLength = textData.width;\n                    }\n                    var scrollBarWidth = (categoryValuesLength * TornadoChart.CategoryMinHeight > this.viewport.height) ? TornadoChart.ScrollBarWidth : 0;\n                    this.widthLeftSection = maxCategoryLength + TornadoChart.LabelPadding;\n                    var maxColumnWidth = this.widthRightSection = this.viewport.width - this.widthLeftSection - scrollBarWidth;\n                    this.updateElements();\n                    var minValue = Math.min(d3.min(values[0].values), 0);\n                    if (values.length === TornadoChart.MaxSeries) {\n                        minValue = d3.min([minValue, d3.min(values[1].values)]);\n                        maxValue = d3.max([maxValue, d3.max(values[1].values)]);\n                        maxColumnWidth = maxColumnWidth / TornadoChart.MaxSeries;\n                    }\n                    for (var seriesIndex = 0; seriesIndex < values.length; seriesIndex++) {\n                        var parsedSeries = this.parseSeries(values, seriesIndex, this.hasDynamicSeries, groupedValues);\n                        series.push(parsedSeries);\n                        var currentSeries = values[seriesIndex];\n                        var measureName = currentSeries.source.queryName;\n                        for (var i = 0; i < categoryValuesLength; i++) {\n                            var value = currentSeries.values[i] == null || isNaN(currentSeries.values[i]) ? 0 : currentSeries.values[i];\n                            var identity = visuals.SelectionIdBuilder.builder()\n                                .withCategory(category, i)\n                                .withSeries(values, currentSeries)\n                                .withMeasure(measureName)\n                                .createSelectionId();\n                            var formattedCategoryValue = categoriesLabels[i].text;\n                            var tooltipInfo = void 0;\n                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null);\n                            // Limit maximum value with what the user choose\n                            var currentMaxValue = parsedSeries.categoryAxisEnd ? Math.min(parsedSeries.categoryAxisEnd, maxValue) : maxValue;\n                            var formatString = dataView.categorical.values[seriesIndex].source.format;\n                            dataPoints.push({\n                                value: value,\n                                minValue: minValue,\n                                maxValue: currentMaxValue,\n                                formatString: formatString,\n                                color: parsedSeries.fill,\n                                selected: false,\n                                identity: identity,\n                                tooltipData: tooltipInfo,\n                                categoryIndex: i,\n                            });\n                            if (hasHighlights) {\n                                var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);\n                                var highlight = currentSeries.highlights[i];\n                                var highlightedValue = highlight != null ? highlight : 0;\n                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue);\n                                highlightedDataPoints.push({\n                                    value: highlightedValue,\n                                    minValue: minValue,\n                                    maxValue: currentMaxValue,\n                                    formatString: formatString,\n                                    color: parsedSeries.fill,\n                                    selected: false,\n                                    identity: highlightIdentity,\n                                    tooltipData: tooltipInfo,\n                                    categoryIndex: i,\n                                    highlight: true,\n                                });\n                            }\n                        }\n                    }\n                    return {\n                        categories: categoriesLabels,\n                        series: series,\n                        settings: settings,\n                        legend: this.getLegendData(series),\n                        dataPoints: dataPoints,\n                        highlightedDataPoints: highlightedDataPoints,\n                    };\n                };\n                TornadoChart.prototype.parseSettings = function (objects, formatString, value) {\n                    var precision = this.getPrecision(objects);\n                    var displayUnits = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelDisplayUnits, this.DefaultTornadoChartSettings.labelSettings.displayUnits);\n                    var labelSettings = this.DefaultTornadoChartSettings.labelSettings;\n                    var labelValueFormatter = visuals.valueFormatter.create({\n                        format: formatString,\n                        precision: precision,\n                        value: (displayUnits === 0) && (value != null) ? value : displayUnits,\n                    });\n                    return {\n                        labelOutsideFillColor: this.getColor(TornadoChart.Properties.labels.outsideFill, this.DefaultTornadoChartSettings.labelOutsideFillColor, objects),\n                        labelSettings: {\n                            show: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.show, labelSettings.show),\n                            precision: precision,\n                            fontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.fontSize, labelSettings.fontSize),\n                            displayUnits: displayUnits,\n                            labelColor: this.getColor(TornadoChart.Properties.labels.insideFill, labelSettings.labelColor, objects),\n                        },\n                        showCategories: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.categories.show, this.DefaultTornadoChartSettings.showCategories),\n                        showLegend: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.show, this.DefaultTornadoChartSettings.showLegend),\n                        legendFontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.fontSize, this.DefaultTornadoChartSettings.legendFontSize),\n                        legendColor: this.getColor(TornadoChart.Properties.legend.labelColor, this.DefaultTornadoChartSettings.legendColor, objects),\n                        categoriesFillColor: this.getColor(TornadoChart.Properties.categories.fill, this.DefaultTornadoChartSettings.categoriesFillColor, objects),\n                        labelValueFormatter: labelValueFormatter\n                    };\n                };\n                TornadoChart.prototype.getColor = function (properties, defaultColor, objects) {\n                    var colorHelper = new visuals.ColorHelper(this.colors, properties, defaultColor);\n                    return colorHelper.getColorForMeasure(objects, \"\");\n                };\n                TornadoChart.prototype.getPrecision = function (objects) {\n                    var precision = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelPrecision, this.DefaultTornadoChartSettings.labelSettings.precision);\n                    if (precision >= TornadoChart.MaxPrecision) {\n                        return TornadoChart.MaxPrecision;\n                    }\n                    return precision;\n                };\n                TornadoChart.prototype.getObjectsFromDataView = function (dataView) {\n                    if (!dataView ||\n                        !dataView.metadata ||\n                        !dataView.metadata.columns ||\n                        !dataView.metadata.objects) {\n                        this.legendObjectProperties = {};\n                        return null;\n                    }\n                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, \"legend\", {});\n                    return dataView.metadata.objects;\n                };\n                TornadoChart.prototype.parseSeries = function (dataViewValueColumns, index, isGrouped, grouped) {\n                    var dataViewValueColumn = dataViewValueColumns[index];\n                    var seriesGroup = isGrouped ? grouped[index] : grouped[0].values[index];\n                    var source = dataViewValueColumn.source;\n                    var selectionId = seriesGroup.identity\n                        ? visuals.SelectionId.createWithId(seriesGroup.identity)\n                        : visuals.SelectionIdBuilder.builder()\n                            .withSeries(dataViewValueColumns, seriesGroup)\n                            .withMeasure(source.queryName)\n                            .createSelectionId();\n                    var displayName = source.groupName ? source.groupName : source.displayName;\n                    var objects;\n                    var categoryAxisObject;\n                    if (isGrouped) {\n                        categoryAxisObject = seriesGroup.objects ? seriesGroup.objects['categoryAxis'] : null;\n                        objects = seriesGroup.objects;\n                    }\n                    else {\n                        objects = source.objects;\n                        categoryAxisObject = objects ? objects['categoryAxis'] : null;\n                    }\n                    var color = this.getColor(TornadoChart.Properties.dataPoint.fill, this.DefaultFillColors[index], objects);\n                    var categoryAxisEnd = categoryAxisObject ? categoryAxisObject['end'] : null;\n                    return {\n                        fill: color,\n                        name: displayName,\n                        selectionId: selectionId,\n                        categoryAxisEnd: categoryAxisEnd,\n                    };\n                };\n                TornadoChart.prototype.getLegendData = function (series) {\n                    var legendDataPoints = [];\n                    if (this.hasDynamicSeries)\n                        legendDataPoints = series.map(function (series) {\n                            return {\n                                label: series.name,\n                                color: series.fill,\n                                icon: visuals.LegendIcon.Box,\n                                selected: false,\n                                identity: series.selectionId\n                            };\n                        });\n                    return {\n                        dataPoints: legendDataPoints\n                    };\n                };\n                TornadoChart.prototype.clearData = function () {\n                    this.columns.selectAll(\"*\").remove();\n                    this.axes.selectAll(\"*\").remove();\n                    this.labels.selectAll(\"*\").remove();\n                    this.categories.selectAll(\"*\").remove();\n                    this.legend.drawLegend({ dataPoints: [] }, this.viewport);\n                    this.scrolling.clearData();\n                };\n                TornadoChart.prototype.onClearSelection = function () {\n                    if (this.interactivityService)\n                        this.interactivityService.clearSelection();\n                };\n                TornadoChart.prototype.render = function () {\n                    var tornadoChartDataView = this.tornadoChartDataView;\n                    if (!tornadoChartDataView ||\n                        !tornadoChartDataView.settings) {\n                        this.clearData();\n                        return;\n                    }\n                    this.renderLegend();\n                    this.scrolling.renderY(tornadoChartDataView, tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight, this.renderWithScrolling.bind(this));\n                };\n                TornadoChart.prototype.renderWithScrolling = function (tornadoChartDataView, scrollStart, scrollEnd) {\n                    if (!this.tornadoChartDataView || !this.tornadoChartDataView.settings)\n                        return;\n                    var categoriesLength = tornadoChartDataView.categories.length;\n                    var startIndex = scrollStart * categoriesLength;\n                    var endIndex = scrollEnd * categoriesLength;\n                    var startIndexRound = Math.floor(startIndex);\n                    var endIndexRound = Math.floor(endIndex);\n                    var maxValues = Math.floor(this.scrolling.scrollViewport.height / TornadoChart.CategoryMinHeight);\n                    if (scrollEnd - scrollStart < 1 && maxValues < endIndexRound - startIndexRound) {\n                        if (startIndex - startIndexRound > endIndex - endIndexRound) {\n                            startIndexRound++;\n                        }\n                        else {\n                            endIndex--;\n                        }\n                    }\n                    if (this.interactivityService) {\n                        this.interactivityService.applySelectionStateToData(tornadoChartDataView.dataPoints);\n                        this.interactivityService.applySelectionStateToData(tornadoChartDataView.highlightedDataPoints);\n                    }\n                    var scrollBarWidth = (tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight > this.viewport.height) ? TornadoChart.ScrollBarWidth : 0;\n                    // Filter data according to the visible visual area\n                    tornadoChartDataView.categories = tornadoChartDataView.categories.slice(startIndexRound, endIndexRound);\n                    tornadoChartDataView.dataPoints = _.filter(tornadoChartDataView.dataPoints, function (d) { return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound; });\n                    tornadoChartDataView.highlightedDataPoints = _.filter(tornadoChartDataView.highlightedDataPoints, function (d) { return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound; });\n                    this.tornadoChartDataView = tornadoChartDataView;\n                    this.computeHeightColumn();\n                    this.renderMiddleSection(scrollBarWidth);\n                    this.renderAxes();\n                    this.renderCategories();\n                };\n                TornadoChart.prototype.updateViewport = function () {\n                    var legendMargins = this.legend.getMargins(), legendPosition;\n                    legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];\n                    switch (legendPosition) {\n                        case visuals.LegendPosition.Top:\n                        case visuals.LegendPosition.TopCenter:\n                        case visuals.LegendPosition.Bottom:\n                        case visuals.LegendPosition.BottomCenter: {\n                            this.viewport.height -= legendMargins.height;\n                            break;\n                        }\n                        case visuals.LegendPosition.Left:\n                        case visuals.LegendPosition.LeftCenter:\n                        case visuals.LegendPosition.Right:\n                        case visuals.LegendPosition.RightCenter: {\n                            this.viewport.width -= legendMargins.width;\n                            break;\n                        }\n                    }\n                };\n                TornadoChart.prototype.computeHeightColumn = function () {\n                    var length = this.tornadoChartDataView.categories.length;\n                    this.heightColumn = (this.scrolling.scrollViewport.height - ((length - 1) * this.columnPadding)) / length;\n                };\n                TornadoChart.prototype.renderMiddleSection = function (scrollBarWidth) {\n                    var tornadoChartDataView = this.tornadoChartDataView;\n                    this.calculateDataPoints(tornadoChartDataView.dataPoints, scrollBarWidth);\n                    this.calculateDataPoints(tornadoChartDataView.highlightedDataPoints, scrollBarWidth);\n                    var dataPointsWithHighlights = tornadoChartDataView.dataPoints.concat(tornadoChartDataView.highlightedDataPoints);\n                    this.renderColumns(dataPointsWithHighlights, tornadoChartDataView.series.length === 2);\n                    this.renderLabels(this.hasHighlights ? tornadoChartDataView.highlightedDataPoints : tornadoChartDataView.dataPoints, tornadoChartDataView.settings.labelSettings);\n                };\n                /**\n                 * Calculate the width, dx value and label info for every data point\n                 */\n                TornadoChart.prototype.calculateDataPoints = function (dataPoints, scrollBarWidth) {\n                    var maxColumnWidth = this.widthRightSection = (this.viewport.width - this.widthLeftSection - scrollBarWidth);\n                    var categoriesLength = this.tornadoChartDataView.categories.length;\n                    var settings = this.tornadoChartDataView.settings;\n                    var hasHighlights = this.hasHighlights;\n                    var heightColumn = Math.max(this.heightColumn, 0);\n                    var py = heightColumn / 2;\n                    var pyHighlighted = heightColumn * TornadoChart.HighlightedShapeFactor / 2;\n                    var maxSeries = this.tornadoChartDataView.series.length === TornadoChart.MaxSeries;\n                    if (maxSeries)\n                        maxColumnWidth /= 2;\n                    for (var i = 0; i < dataPoints.length; i++) {\n                        var dataPoint = dataPoints[i];\n                        var shiftToMiddle = i < categoriesLength && maxSeries;\n                        var shiftToRight = i > categoriesLength - 1;\n                        var widthOfColumn = this.getColumnWidth(dataPoint.value, dataPoint.minValue, dataPoint.maxValue, maxColumnWidth);\n                        var dx = (maxColumnWidth - widthOfColumn) * Number(shiftToMiddle) + maxColumnWidth * Number(shiftToRight) - scrollBarWidth;\n                        dx = Math.max(dx, 0);\n                        var highlighted = hasHighlights && dataPoint.highlight;\n                        var highlightOffset = highlighted ? heightColumn * (1 - TornadoChart.HighlightedShapeFactor) / 2 : 0;\n                        var dy = (heightColumn + this.columnPadding) * (i % categoriesLength) + highlightOffset;\n                        var label = this.getLabelData(dataPoint.value, dx, widthOfColumn, shiftToMiddle, dataPoint.formatString, settings);\n                        dataPoint.dx = dx;\n                        dataPoint.dy = dy;\n                        dataPoint.px = widthOfColumn / 2;\n                        dataPoint.py = highlighted ? pyHighlighted : py;\n                        dataPoint.angle = shiftToMiddle ? 180 : 0;\n                        dataPoint.width = widthOfColumn;\n                        dataPoint.height = highlighted ? heightColumn * TornadoChart.HighlightedShapeFactor : heightColumn;\n                        dataPoint.label = label;\n                    }\n                };\n                TornadoChart.prototype.renderColumns = function (columnsData, selectSecondSeries) {\n                    if (selectSecondSeries === void 0) { selectSecondSeries = false; }\n                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();\n                    var hasHighlights = this.hasHighlights;\n                    var columnsSelection = this.columns\n                        .selectAll(TornadoChart.Column.selector)\n                        .data(columnsData);\n                    columnsSelection\n                        .enter()\n                        .append(\"svg:rect\")\n                        .classed(TornadoChart.Column.class, true);\n                    columnsSelection\n                        .style(\"fill\", function (p) { return p.color; })\n                        .style(\"fill-opacity\", function (p) { return visuals.ColumnUtil.getFillOpacity(p.selected, p.highlight, hasSelection, hasHighlights); })\n                        .attr(\"transform\", function (p) { return visuals.SVGUtil.translateAndRotate(p.dx, p.dy, p.px, p.py, p.angle); })\n                        .attr(\"height\", function (p) { return p.height; })\n                        .attr(\"width\", function (p) { return p.width; });\n                    columnsSelection\n                        .exit()\n                        .remove();\n                    var interactivityService = this.interactivityService;\n                    if (interactivityService) {\n                        interactivityService.applySelectionStateToData(columnsData);\n                        var behaviorOptions = {\n                            columns: columnsSelection,\n                            clearCatcher: this.clearCatcher,\n                            interactivityService: this.interactivityService,\n                        };\n                        interactivityService.bind(columnsData, this.behavior, behaviorOptions);\n                    }\n                    this.renderTooltip(columnsSelection);\n                };\n                TornadoChart.prototype.renderTooltip = function (selection) {\n                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {\n                        return tooltipEvent.data.tooltipData;\n                    });\n                };\n                TornadoChart.prototype.getColumnWidth = function (value, minValue, maxValue, width) {\n                    if (minValue === maxValue) {\n                        return width;\n                    }\n                    var columnWidth = width * (value - minValue) / (maxValue - minValue);\n                    // In case the user specifies a custom category axis end we limit the\n                    // column width to the maximum available width\n                    return Math.max(0, Math.min(width, columnWidth));\n                };\n                TornadoChart.prototype.getLabelData = function (value, dxColumn, columnWidth, isColumnPositionLeft, formatStringProp, settings) {\n                    var dx, tornadoChartSettings = settings ? settings : this.tornadoChartDataView.settings, labelSettings = tornadoChartSettings.labelSettings, fontSize = labelSettings.fontSize, color = labelSettings.labelColor;\n                    var maxOutsideLabelWidth = isColumnPositionLeft\n                        ? dxColumn - this.leftLabelMargin\n                        : this.widthRightSection - (dxColumn + columnWidth + this.leftLabelMargin);\n                    var maxLabelWidth = Math.max(maxOutsideLabelWidth, columnWidth - this.leftLabelMargin);\n                    var textProperties = {\n                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,\n                        fontSize: PixelConverter.fromPoint(fontSize),\n                        text: tornadoChartSettings.labelValueFormatter.format(value)\n                    };\n                    var valueAfterValueFormatter = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxLabelWidth);\n                    var textDataAfterValueFormatter = this.getTextData(valueAfterValueFormatter, true, false, fontSize);\n                    if (columnWidth > textDataAfterValueFormatter.width + TornadoChart.LabelPadding) {\n                        dx = dxColumn + columnWidth / 2 - textDataAfterValueFormatter.width / 2;\n                    }\n                    else {\n                        if (isColumnPositionLeft) {\n                            dx = dxColumn - this.leftLabelMargin - textDataAfterValueFormatter.width;\n                        }\n                        else {\n                            dx = dxColumn + columnWidth + this.leftLabelMargin;\n                        }\n                        color = tornadoChartSettings.labelOutsideFillColor;\n                    }\n                    return {\n                        dx: dx,\n                        source: value,\n                        value: valueAfterValueFormatter,\n                        color: color\n                    };\n                };\n                TornadoChart.prototype.renderAxes = function () {\n                    var linesData, axesSelection, axesElements = this.main\n                        .select(TornadoChart.Axes.selector)\n                        .selectAll(TornadoChart.Axis.selector);\n                    if (this.tornadoChartDataView.series.length !== TornadoChart.MaxSeries) {\n                        axesElements.remove();\n                        return;\n                    }\n                    linesData = this.generateAxesData();\n                    axesSelection = axesElements.data(linesData);\n                    axesSelection\n                        .enter()\n                        .append(\"svg:line\")\n                        .classed(TornadoChart.Axis.class, true);\n                    axesSelection\n                        .transition()\n                        .duration(this.durationAnimations)\n                        .attr(\"x1\", function (data) { return data.x1; })\n                        .attr(\"y1\", function (data) { return data.y1; })\n                        .attr(\"x2\", function (data) { return data.x2; })\n                        .attr(\"y2\", function (data) { return data.y2; });\n                    axesSelection\n                        .exit()\n                        .remove();\n                };\n                TornadoChart.prototype.generateAxesData = function () {\n                    var x, y1, y2;\n                    x = this.widthRightSection / 2;\n                    y1 = 0;\n                    y2 = this.scrolling.scrollViewport.height;\n                    return [{\n                            x1: x,\n                            y1: y1,\n                            x2: x,\n                            y2: y2\n                        }];\n                };\n                TornadoChart.prototype.renderLabels = function (dataPoints, labelsSettings) {\n                    var _this = this;\n                    var labelEnterSelection, labelSelection = this.main\n                        .select(TornadoChart.Labels.selector)\n                        .selectAll(TornadoChart.Label.selector)\n                        .data(_.filter(dataPoints, function (p) { return p.label.dx >= 0; }));\n                    // Check if labels can be displayed\n                    if (!labelsSettings.show || this.labelHeight >= this.heightColumn) {\n                        this.labels.selectAll(\"*\").remove();\n                        return;\n                    }\n                    var fontSizeInPx = PixelConverter.fromPoint(labelsSettings.fontSize);\n                    var labelYOffset = this.heightColumn / 2 + this.labelHeight / 2 - this.InnerTextHeightDelta;\n                    var categoriesLength = this.tornadoChartDataView.categories.length;\n                    labelEnterSelection = labelSelection\n                        .enter()\n                        .append(\"g\");\n                    labelEnterSelection\n                        .append(\"svg:title\")\n                        .classed(TornadoChart.LabelTitle.class, true);\n                    labelEnterSelection\n                        .append(\"svg:text\")\n                        .attr(\"dy\", visuals.dataLabelUtils.DefaultDy)\n                        .classed(TornadoChart.LabelText.class, true);\n                    labelSelection\n                        .attr(\"pointer-events\", \"none\")\n                        .classed(TornadoChart.Label.class, true);\n                    labelSelection\n                        .select(TornadoChart.LabelTitle.selector)\n                        .text(function (p) { return p.label.source; });\n                    labelSelection\n                        .attr(\"transform\", function (p, index) {\n                        var dy = (_this.heightColumn + _this.columnPadding) * (index % categoriesLength);\n                        return visuals.SVGUtil.translate(p.label.dx, dy + labelYOffset);\n                    });\n                    labelSelection\n                        .select(TornadoChart.LabelText.selector)\n                        .attr(\"fill\", function (p) { return p.label.color; })\n                        .attr(\"font-size\", function (p) { return fontSizeInPx; })\n                        .text(function (p) { return p.label.value; });\n                    labelSelection\n                        .exit()\n                        .remove();\n                };\n                TornadoChart.prototype.renderCategories = function () {\n                    var _this = this;\n                    var settings = this.tornadoChartDataView.settings, color = settings.categoriesFillColor, categoriesEnterSelection, categoriesSelection, categoryElements = this.main\n                        .select(TornadoChart.Categories.selector)\n                        .selectAll(TornadoChart.Category.selector), self = this;\n                    if (!settings.showCategories) {\n                        categoryElements.remove();\n                        return;\n                    }\n                    categoriesSelection = categoryElements.data(this.tornadoChartDataView.categories);\n                    categoriesEnterSelection = categoriesSelection\n                        .enter()\n                        .append(\"g\");\n                    categoriesEnterSelection\n                        .append(\"svg:title\")\n                        .classed(TornadoChart.CategoryTitle.class, true);\n                    categoriesEnterSelection\n                        .append(\"svg:text\")\n                        .classed(TornadoChart.CategoryText.class, true);\n                    categoriesSelection\n                        .attr(\"transform\", function (text, index) {\n                        var shift = (_this.heightColumn + _this.columnPadding) * index + _this.heightColumn / 2, textData = _this.getTextData(text, false, true);\n                        shift = shift + textData.height / 2 - _this.InnerTextHeightDelta;\n                        return visuals.SVGUtil.translate(0, shift);\n                    })\n                        .classed(TornadoChart.Category.class, true);\n                    categoriesSelection\n                        .select(TornadoChart.CategoryTitle.selector)\n                        .text(function (text) { return text.text; });\n                    categoriesSelection\n                        .select(TornadoChart.CategoryText.selector)\n                        .attr(\"fill\", color)\n                        .text(function (data) {\n                        var textData = self.getTextData(data.text);\n                        return powerbi.TextMeasurementService.getTailoredTextOrDefault(textData.textProperties, self.widthLeftSection);\n                    });\n                    categoriesSelection\n                        .exit()\n                        .remove();\n                };\n                TornadoChart.prototype.renderLegend = function () {\n                    var legend = this.tornadoChartDataView.legend;\n                    if (!legend) {\n                        return;\n                    }\n                    var settings = this.tornadoChartDataView.settings;\n                    var legendData = {\n                        title: legend.title,\n                        dataPoints: legend.dataPoints,\n                        fontSize: settings.legendFontSize,\n                        labelColor: settings.legendColor,\n                    };\n                    if (this.legendObjectProperties) {\n                        var position = void 0;\n                        visuals.LegendData.update(legendData, this.legendObjectProperties);\n                        position = this.legendObjectProperties[visuals.legendProps.position];\n                        if (position) {\n                            this.legend.changeOrientation(visuals.LegendPosition[position]);\n                        }\n                    }\n                    // Draw the legend on a viewport with the original height and width\n                    var viewport = {\n                        height: this.viewport.height + this.margin.top + this.margin.bottom,\n                        width: this.viewport.width + this.margin.left + this.margin.right,\n                    };\n                    this.legend.drawLegend(legendData, viewport);\n                    visuals.Legend.positionChartArea(this.root, this.legend);\n                    if (legendData.dataPoints.length > 0 && settings.showLegend)\n                        this.updateViewport();\n                };\n                TornadoChart.prototype.getTextData = function (text, measureWidth, measureHeight, overrideFontSize) {\n                    if (measureWidth === void 0) { measureWidth = false; }\n                    if (measureHeight === void 0) { measureHeight = false; }\n                    var width = 0, height = 0, fontSize, textProperties;\n                    text = text || \"\";\n                    fontSize = overrideFontSize\n                        ? PixelConverter.fromPoint(overrideFontSize)\n                        : \"\" + this.textOptions.fontSize + this.textOptions.sizeUnit;\n                    textProperties = {\n                        text: text,\n                        fontFamily: this.textOptions.fontFamily,\n                        fontSize: fontSize\n                    };\n                    if (measureWidth) {\n                        width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);\n                    }\n                    if (measureHeight) {\n                        height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);\n                    }\n                    return {\n                        text: text,\n                        width: width,\n                        height: height,\n                        textProperties: textProperties\n                    };\n                };\n                TornadoChart.prototype.enumerateObjectInstances = function (options) {\n                    var enumeration = new visuals.ObjectEnumerationBuilder(), settings;\n                    if (!this.tornadoChartDataView ||\n                        !this.tornadoChartDataView.settings) {\n                        return [];\n                    }\n                    settings = this.tornadoChartDataView.settings;\n                    switch (options.objectName) {\n                        case \"dataPoint\": {\n                            this.enumerateDataPoint(enumeration);\n                            break;\n                        }\n                        case \"categoryAxis\": {\n                            this.enumerateCategoryAxis(enumeration);\n                            break;\n                        }\n                        case \"labels\": {\n                            var labelSettings = settings.labelSettings;\n                            var labels = {\n                                objectName: \"labels\",\n                                displayName: \"Labels\",\n                                selector: null,\n                                properties: {\n                                    show: labelSettings.show,\n                                    fontSize: labelSettings.fontSize,\n                                    labelPrecision: labelSettings.precision,\n                                    labelDisplayUnits: labelSettings.displayUnits,\n                                    insideFill: labelSettings.labelColor,\n                                    outsideFill: settings.labelOutsideFillColor\n                                }\n                            };\n                            enumeration.pushInstance(labels);\n                            break;\n                        }\n                        case \"legend\": {\n                            if (!this.hasDynamicSeries)\n                                return;\n                            var showTitle = true, titleText = \"\", legend = void 0;\n                            showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle);\n                            titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText);\n                            legend = {\n                                objectName: \"legend\",\n                                displayName: \"Legend\",\n                                selector: null,\n                                properties: {\n                                    show: settings.showLegend,\n                                    position: visuals.LegendPosition[this.legend.getOrientation()],\n                                    showTitle: showTitle,\n                                    titleText: titleText,\n                                    fontSize: settings.legendFontSize,\n                                    labelColor: settings.legendColor,\n                                }\n                            };\n                            enumeration.pushInstance(legend);\n                            break;\n                        }\n                        case \"categories\": {\n                            var categories = {\n                                objectName: \"categories\",\n                                displayName: \"Categories\",\n                                selector: null,\n                                properties: {\n                                    show: settings.showCategories,\n                                    fill: settings.categoriesFillColor\n                                }\n                            };\n                            enumeration.pushInstance(categories);\n                            break;\n                        }\n                    }\n                    return enumeration.complete();\n                };\n                TornadoChart.prototype.enumerateDataPoint = function (enumeration) {\n                    if (!this.tornadoChartDataView ||\n                        !this.tornadoChartDataView.series) {\n                        return;\n                    }\n                    var series = this.tornadoChartDataView.series;\n                    for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {\n                        var currentSeries = series_1[_i];\n                        enumeration.pushInstance({\n                            objectName: \"dataPoint\",\n                            displayName: currentSeries.name,\n                            selector: visuals.ColorHelper.normalizeSelector(currentSeries.selectionId.getSelector(), false),\n                            properties: {\n                                fill: { solid: { color: currentSeries.fill } }\n                            }\n                        });\n                    }\n                };\n                TornadoChart.prototype.enumerateCategoryAxis = function (enumeration) {\n                    if (!this.tornadoChartDataView || !this.tornadoChartDataView.series)\n                        return;\n                    var series = this.tornadoChartDataView.series;\n                    for (var _i = 0, series_2 = series; _i < series_2.length; _i++) {\n                        var currentSeries = series_2[_i];\n                        enumeration.pushInstance({\n                            objectName: \"categoryAxis\",\n                            displayName: currentSeries.name,\n                            selector: currentSeries.selectionId ? currentSeries.selectionId.getSelector() : null,\n                            properties: {\n                                end: currentSeries.categoryAxisEnd,\n                            }\n                        });\n                    }\n                };\n                TornadoChart.prototype.destroy = function () {\n                    this.root = null;\n                };\n                TornadoChart.ClassName = \"tornado-chart\";\n                TornadoChart.Properties = {\n                    general: {\n                        formatString: {\n                            objectName: \"general\",\n                            propertyName: \"formatString\"\n                        }\n                    },\n                    labels: {\n                        show: {\n                            objectName: \"labels\",\n                            propertyName: \"show\"\n                        },\n                        fontSize: {\n                            objectName: \"labels\",\n                            propertyName: \"fontSize\"\n                        },\n                        labelPrecision: {\n                            objectName: \"labels\",\n                            propertyName: \"labelPrecision\"\n                        },\n                        labelDisplayUnits: {\n                            objectName: \"labels\",\n                            propertyName: \"labelDisplayUnits\"\n                        },\n                        insideFill: {\n                            objectName: \"labels\",\n                            propertyName: \"insideFill\"\n                        },\n                        outsideFill: {\n                            objectName: \"labels\",\n                            propertyName: \"outsideFill\"\n                        }\n                    },\n                    dataPoint: {\n                        fill: {\n                            objectName: \"dataPoint\",\n                            propertyName: \"fill\"\n                        }\n                    },\n                    legend: {\n                        show: {\n                            objectName: \"legend\",\n                            propertyName: \"show\"\n                        },\n                        labelColor: {\n                            objectName: \"legend\",\n                            propertyName: \"labelColor\"\n                        },\n                        fontSize: {\n                            objectName: \"legend\",\n                            propertyName: \"fontSize\"\n                        },\n                    },\n                    categories: {\n                        show: {\n                            objectName: \"categories\",\n                            propertyName: \"show\"\n                        },\n                        fill: {\n                            objectName: \"categories\",\n                            propertyName: \"fill\"\n                        }\n                    }\n                };\n                TornadoChart.Columns = {\n                    \"class\": \"columns\",\n                    selector: \".columns\"\n                };\n                TornadoChart.Column = {\n                    \"class\": \"column\",\n                    selector: \".column\"\n                };\n                TornadoChart.Axes = {\n                    \"class\": \"axes\",\n                    selector: \".axes\"\n                };\n                TornadoChart.Axis = {\n                    \"class\": \"axis\",\n                    selector: \".axis\"\n                };\n                TornadoChart.Labels = {\n                    \"class\": \"labels\",\n                    selector: \".labels\"\n                };\n                TornadoChart.Label = {\n                    \"class\": \"label\",\n                    selector: \".label\"\n                };\n                TornadoChart.LabelTitle = {\n                    \"class\": \"label-title\",\n                    selector: \".label-title\"\n                };\n                TornadoChart.LabelText = {\n                    \"class\": \"label-text\",\n                    selector: \".label-text\"\n                };\n                TornadoChart.Categories = {\n                    \"class\": \"categories\",\n                    selector: \".categories\"\n                };\n                TornadoChart.Category = {\n                    \"class\": \"category\",\n                    selector: \".category\"\n                };\n                TornadoChart.CategoryTitle = {\n                    \"class\": \"category-title\",\n                    selector: \".category-title\"\n                };\n                TornadoChart.CategoryText = {\n                    \"class\": \"category-text\",\n                    selector: \".category-text\"\n                };\n                TornadoChart.MaxSeries = 2;\n                TornadoChart.MaxPrecision = 17; // max number of decimals in float\n                TornadoChart.LabelPadding = 2.5;\n                TornadoChart.CategoryMinHeight = 25;\n                TornadoChart.DefaultFontSize = 9;\n                TornadoChart.DefaultLegendFontSize = 8;\n                TornadoChart.HighlightedShapeFactor = 0.5;\n                TornadoChart.ScrollBarWidth = 10;\n                TornadoChart.capabilities = {\n                    dataRoles: [{\n                            name: \"Category\",\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: powerbi.data.createDisplayNameGetter(\"Role_DisplayName_Group\")\n                        }, {\n                            name: \"Series\",\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend')\n                        }, {\n                            name: \"Values\",\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: powerbi.data.createDisplayNameGetter(\"Role_DisplayName_Values\")\n                        }],\n                    dataViewMappings: [{\n                            conditions: [\n                                { \"Category\": { max: 1 }, \"Values\": { min: 0, max: 1 }, \"Series\": { min: 0, max: 1 } },\n                                { \"Category\": { max: 1 }, \"Values\": { min: 2, max: 2 }, \"Series\": { max: 0 } }\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: {\n                                        in: \"Category\"\n                                    }\n                                },\n                                values: {\n                                    group: {\n                                        by: \"Series\",\n                                        select: [{ for: { in: \"Values\" } }],\n                                        dataReductionAlgorithm: { top: {} }\n                                    }\n                                }\n                            }\n                        }],\n                    objects: {\n                        general: {\n                            displayName: 'General',\n                            properties: {\n                                formatString: {\n                                    type: {\n                                        formatting: {\n                                            formatString: true\n                                        }\n                                    },\n                                }\n                            }\n                        },\n                        dataPoint: {\n                            displayName: 'Data Colors',\n                            properties: {\n                                fill: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        categoryAxis: {\n                            displayName: 'X-Axis',\n                            properties: {\n                                end: {\n                                    displayName: 'End',\n                                    type: { numeric: true },\n                                    suppressFormatPainterCopy: true,\n                                },\n                            }\n                        },\n                        labels: {\n                            displayName: 'Data Labels',\n                            properties: {\n                                show: {\n                                    displayName: 'Show',\n                                    type: { bool: true }\n                                },\n                                labelPrecision: {\n                                    displayName: 'Decimal Places',\n                                    placeHolderText: 'Auto',\n                                    type: { numeric: true }\n                                },\n                                fontSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { formatting: { fontSize: true } }\n                                },\n                                labelDisplayUnits: {\n                                    displayName: 'Display Units',\n                                    type: { formatting: { labelDisplayUnits: true } },\n                                },\n                                insideFill: {\n                                    displayName: 'Inside fill',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                outsideFill: {\n                                    displayName: 'Outside fill',\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        legend: {\n                            displayName: 'Legend',\n                            properties: {\n                                show: {\n                                    displayName: 'Show',\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: 'Position',\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),\n                                    type: { enumeration: visuals.legendPosition.type }\n                                },\n                                showTitle: {\n                                    displayName: 'Title',\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),\n                                    type: { bool: true }\n                                },\n                                titleText: {\n                                    displayName: 'Legend Name',\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),\n                                    type: { text: true }\n                                },\n                                labelColor: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: 'TextSize',\n                                    type: { formatting: { fontSize: true } }\n                                },\n                            }\n                        },\n                        categories: {\n                            displayName: 'Group',\n                            properties: {\n                                show: {\n                                    displayName: 'Show',\n                                    type: { bool: true }\n                                },\n                                fill: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        }\n                    },\n                    supportsHighlight: true,\n                };\n                return TornadoChart;\n            }());\n            samples.TornadoChart = TornadoChart;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n            var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;\n            var MekkoDataWrapper = (function () {\n                function MekkoDataWrapper(columnChartData, isScalar) {\n                    this.data = columnChartData;\n                    this.isScalar = isScalar;\n                }\n                MekkoDataWrapper.prototype.lookupXValue = function (index, type) {\n                    debug.assertValue(this.data, 'this.data');\n                    var isDateTime = visuals.AxisHelper.isDateTime(type);\n                    if (isDateTime && this.isScalar) {\n                        return new Date(index);\n                    }\n                    var data = this.data;\n                    if (type.text) {\n                        debug.assert(index < data.categories.length, 'category index out of range');\n                        return data.categories[index];\n                    }\n                    else {\n                        var firstSeries = data.series[0];\n                        if (firstSeries) {\n                            var seriesValues = firstSeries.data;\n                            if (seriesValues) {\n                                if (this.data.hasHighlights) {\n                                    index = index * 2;\n                                }\n                                var dataPoint = seriesValues[index];\n                                if (dataPoint) {\n                                    if (isDateTime) {\n                                        return new Date(dataPoint.categoryValue);\n                                    }\n                                    return dataPoint.categoryValue;\n                                }\n                            }\n                        }\n                    }\n                    return index;\n                };\n                return MekkoDataWrapper;\n            }());\n            samples.MekkoDataWrapper = MekkoDataWrapper;\n            var MekkoColumnChartStrategy = (function () {\n                function MekkoColumnChartStrategy() {\n                }\n                MekkoColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {\n                    this.graphicsContext = columnChartProps;\n                    this.margin = columnChartProps.margin;\n                    this.width = this.graphicsContext.width;\n                    this.height = this.graphicsContext.height;\n                    this.categoryLayout = columnChartProps.layout;\n                    this.animator = columnChartProps.animator;\n                    this.interactivityService = columnChartProps.interactivityService;\n                    this.viewportHeight = columnChartProps.viewportHeight;\n                    this.viewportWidth = columnChartProps.viewportWidth;\n                };\n                MekkoColumnChartStrategy.prototype.setData = function (data) {\n                    this.data = data;\n                };\n                MekkoColumnChartStrategy.createFormatter = function (scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits) {\n                    if (useTickIntervalForDisplayUnits === void 0) { useTickIntervalForDisplayUnits = false; }\n                    var formatter;\n                    if (dataType.dateTime) {\n                        if (isScalar) {\n                            var value = new Date(scaleDomain[0]);\n                            var value2 = new Date(scaleDomain[1]);\n                            // datetime with only one value needs to pass the same value\n                            // (from the original dataDomain value, not the adjusted scaleDomain)\n                            // so formatting works correctly.\n                            if (bestTickCount === 1)\n                                value = value2 = new Date(dataDomain[0]);\n                            formatter = visuals.valueFormatter.create({ format: formatString, value: value, value2: value2, tickCount: bestTickCount });\n                        }\n                        else {\n                            if (getValueFn == null) {\n                                debug.assertFail('getValueFn must be supplied for ordinal datetime tickValues');\n                            }\n                            var minDate = getValueFn(0, dataType);\n                            var maxDate = getValueFn(scaleDomain.length - 1, dataType);\n                            formatter = visuals.valueFormatter.create({ format: formatString, value: minDate, value2: maxDate, tickCount: bestTickCount });\n                        }\n                    }\n                    else {\n                        if (getValueFn == null && !isScalar) {\n                            debug.assertFail('getValueFn must be supplied for ordinal tickValues');\n                        }\n                        if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {\n                            var domainMin = tickValues[1] - tickValues[0];\n                            var domainMax = 0; //force tickInterval to be used with display units\n                            formatter = visuals.valueFormatter.create({ format: formatString, value: domainMin, value2: domainMax, allowFormatBeautification: true });\n                        }\n                        else {\n                            // do not use display units, just the basic value formatter\n                            // datetime is handled above, so we are ordinal and either boolean, numeric, or text.\n                            formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);\n                        }\n                    }\n                    return formatter;\n                };\n                /**\n                 * Format the linear tick labels or the category labels.\n                 */\n                MekkoColumnChartStrategy.formatAxisTickValues = function (axis, tickValues, formatter, dataType, isScalar, getValueFn) {\n                    var formattedTickValues = [];\n                    if (formatter) {\n                        // getValueFn takes an ordinal axis index or builds DateTime from milliseconds, do not pass a numeric scalar value.\n                        if (getValueFn && !(dataType.numeric && isScalar)) {\n                            axis.tickFormat(function (d) { return formatter.format(getValueFn(d, dataType)); });\n                            formattedTickValues = tickValues.map(function (d) { return formatter.format(getValueFn(d, dataType)); });\n                        }\n                        else {\n                            axis.tickFormat(function (d) { return formatter.format(d); });\n                            formattedTickValues = tickValues.map(function (d) { return formatter.format(d); });\n                        }\n                    }\n                    else {\n                        formattedTickValues = tickValues.map(function (d) { return getValueFn(d, dataType); });\n                    }\n                    return formattedTickValues;\n                };\n                /**\n                 * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.\n                 * @param options The properties used to create the axis.\n                 */\n                MekkoColumnChartStrategy.prototype.createAxis = function (options) {\n                    var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatStringProp = options.formatStringProp, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?\n                    getValueFn = options.getValueFn, categoryThickness = options.categoryThickness;\n                    var formatString = visuals.valueFormatter.getFormatString(metaDataColumn, formatStringProp);\n                    var dataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn, isScalar);\n                    var isLogScaleAllowed = visuals.AxisHelper.isLogScalePossible(dataDomain, dataType);\n                    var scale = d3.scale.linear();\n                    var scaleDomain = [0, 1];\n                    var bestTickCount = dataDomain.length || 1;\n                    var borderWidth = MekkoColumnChart.getBorderWidth(options.borderSettings);\n                    var chartWidth = pixelSpan - borderWidth * (bestTickCount - 1);\n                    if (chartWidth < MekkoChart.MinOrdinalRectThickness) {\n                        chartWidth = MekkoChart.MinOrdinalRectThickness;\n                    }\n                    scale.domain(scaleDomain)\n                        .range([0, chartWidth]);\n                    var tickValues = dataDomain;\n                    var formatter = MekkoColumnChartStrategy.createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits);\n                    // sets default orientation only, cartesianChart will fix y2 for comboChart\n                    // tickSize(pixelSpan) is used to create gridLines\n                    var axis = d3.svg.axis()\n                        .scale(scale)\n                        .tickSize(6, 0)\n                        .orient(isVertical ? 'left' : 'bottom')\n                        .ticks(bestTickCount)\n                        .tickValues(dataDomain);\n                    var formattedTickValues = [];\n                    if (metaDataColumn) {\n                        formattedTickValues = MekkoColumnChartStrategy.formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn);\n                    }\n                    var xLabelMaxWidth;\n                    // Use category layout of labels if specified, otherwise use scalar layout of labels\n                    if (!isScalar && categoryThickness) {\n                        xLabelMaxWidth = Math.max(1, categoryThickness - visuals.CartesianChart.TickLabelPadding * 2);\n                    }\n                    else {\n                        // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan\n                        // When there is > 1 ticks then we need to +1 so that their widths don't overlap\n                        // Example: 2 ticks are drawn at 33.33% and 66.66%, their width needs to be 33.33% so they don't overlap.\n                        var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;\n                        xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan;\n                        xLabelMaxWidth = Math.max(1, xLabelMaxWidth - visuals.CartesianChart.TickLabelPadding * 2);\n                    }\n                    return {\n                        scale: scale,\n                        axis: axis,\n                        formatter: formatter,\n                        values: formattedTickValues,\n                        axisType: dataType,\n                        axisLabel: null,\n                        isCategoryAxis: isCategoryAxis,\n                        xLabelMaxWidth: xLabelMaxWidth,\n                        categoryThickness: categoryThickness,\n                        outerPadding: outerPadding,\n                        usingDefaultDomain: false,\n                        isLogScaleAllowed: isLogScaleAllowed\n                    };\n                };\n                MekkoColumnChartStrategy.prototype.getCategoryAxis = function (data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType) {\n                    var categoryThickness = layout.categoryThickness;\n                    var isScalar = layout.isScalar;\n                    var outerPaddingRatio = layout.outerPaddingRatio;\n                    var dw = new MekkoDataWrapper(data, isScalar);\n                    var domain = [];\n                    if (data.series &&\n                        (data.series.length > 0) &&\n                        data.series[0].data &&\n                        (data.series[0].data.length > 0)) {\n                        var domainDoubles = data.series[0].data.map(function (item) {\n                            return item.originalPosition + (item.value / 2);\n                        });\n                        domain = domainDoubles.filter(function (item, pos) {\n                            return domainDoubles.indexOf(item) === pos;\n                        });\n                    }\n                    var axisProperties = this.createAxis({\n                        pixelSpan: size,\n                        dataDomain: domain,\n                        metaDataColumn: data.categoryMetadata,\n                        formatStringProp: visuals.columnChartProps.general.formatString,\n                        outerPadding: categoryThickness * outerPaddingRatio,\n                        isCategoryAxis: true,\n                        isScalar: isScalar,\n                        isVertical: isVertical,\n                        categoryThickness: categoryThickness,\n                        useTickIntervalForDisplayUnits: true,\n                        getValueFn: function (index, type) {\n                            var domainIndex = domain.indexOf(index);\n                            var value = dw.lookupXValue(domainIndex, type);\n                            return value;\n                        },\n                        scaleType: axisScaleType,\n                        borderSettings: data.borderSettings\n                    });\n                    // intentionally updating the input layout by ref\n                    layout.categoryThickness = axisProperties.categoryThickness;\n                    return axisProperties;\n                };\n                MekkoColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType) {\n                    var width = this.width;\n                    var forcedXMin, forcedXMax;\n                    if (forcedXDomain && forcedXDomain.length === 2) {\n                        forcedXMin = forcedXDomain[0];\n                        forcedXMax = forcedXDomain[1];\n                    }\n                    var props = this.xProps = this.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax, axisScaleType);\n                    return props;\n                };\n                MekkoColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType) {\n                    var height = this.viewportHeight;\n                    var valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct);\n                    var valueDomainArr = [valueDomain.min, valueDomain.max];\n                    var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr);\n                    var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);\n                    var metadataColumn = this.data.valuesMetadata[0];\n                    var formatString = is100Pct ?\n                        this.graphicsContext.hostService.getLocalizedString('Percentage')\n                        : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);\n                    var mekkoMekkoCreateAxisOptions = {\n                        pixelSpan: height,\n                        dataDomain: combinedDomain,\n                        metaDataColumn: metadataColumn,\n                        formatString: formatString,\n                        outerPadding: 0,\n                        isScalar: true,\n                        isVertical: true,\n                        forcedTickCount: forcedTickCount,\n                        useTickIntervalForDisplayUnits: true,\n                        isCategoryAxis: false,\n                        scaleType: axisScaleType,\n                        axisDisplayUnits: 0,\n                        axisPrecision: 0,\n                        is100Pct: is100Pct,\n                        shouldClamp: shouldClamp,\n                        formatStringProp: undefined,\n                    };\n                    this.yProps = visuals.AxisHelper.createAxis(mekkoMekkoCreateAxisOptions);\n                    return this.yProps;\n                };\n                MekkoColumnChartStrategy.prototype.drawColumns = function (useAnimation) {\n                    var data = this.data;\n                    debug.assertValue(data, 'data should not be null or undefined');\n                    this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again\n                    var axisOptions = {\n                        columnWidth: 0,\n                        xScale: this.xProps.scale,\n                        yScale: this.yProps.scale,\n                        isScalar: this.categoryLayout.isScalar,\n                        margin: this.margin,\n                    };\n                    var stackedColumnLayout = this.layout = MekkoColumnChartStrategy.getLayout(data, axisOptions);\n                    //var dataLabelSettings = data.labelSettings;\n                    var labelDataPoints = this.createMekkoLabelDataPoints();\n                    var result;\n                    var shapes;\n                    var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);\n                    if (this.animator && useAnimation) {\n                        result = this.animator.animate({\n                            viewModel: data,\n                            series: series,\n                            layout: stackedColumnLayout,\n                            itemCS: MekkoColumnChartStrategy.classes.item,\n                            interactivityService: this.interactivityService,\n                            mainGraphicsContext: this.graphicsContext.mainGraphicsContext,\n                            viewPort: { height: this.height, width: this.width },\n                        });\n                        shapes = result.shapes;\n                    }\n                    if (!this.animator || !useAnimation || result.failed) {\n                        shapes = MekkoColumnChartStrategy.drawDefaultShapes(data, series, stackedColumnLayout, MekkoColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());\n                    }\n                    visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);\n                    return {\n                        shapesSelection: shapes,\n                        viewport: { height: this.height, width: this.width },\n                        axisOptions: axisOptions,\n                        labelDataPoints: labelDataPoints,\n                    };\n                };\n                MekkoColumnChartStrategy.drawDefaultShapes = function (data, series, layout, itemCS, filterZeros, hasSelection) {\n                    // We filter out invisible (0, null, etc.) values from the dataset\n                    // based on whether animations are enabled or not, Dashboard and\n                    // Exploration mode, respectively.\n                    var rectName = 'rect';\n                    filterZeros = false;\n                    var dataSelector;\n                    if (filterZeros) {\n                        dataSelector = function (d) {\n                            var filteredData = _.filter(d.data, function (datapoint) { return !!datapoint.value; });\n                            return filteredData;\n                        };\n                    }\n                    else {\n                        dataSelector = function (d) { return d.data; };\n                    }\n                    var shapeSelection = series.selectAll(itemCS.selector);\n                    var shapes = shapeSelection.data(dataSelector, function (d) { return d.key; });\n                    shapes.enter()\n                        .append(rectName)\n                        .attr(\"class\", function (d) { return itemCS.class.concat(d.highlight ? \" highlight\" : \"\"); });\n                    shapes\n                        .style(\"fill\", function (d) { return d.color; })\n                        .style(\"fill-opacity\", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights); })\n                        .attr(layout.shapeLayout);\n                    shapes\n                        .exit()\n                        .remove();\n                    var borderSelection = series.selectAll(MekkoColumnChart.BorderClass.selector);\n                    var borders = borderSelection.data(dataSelector, function (d) { return d.key; });\n                    var borderColor = MekkoColumnChart.getBorderColor(data.borderSettings);\n                    borders.enter()\n                        .append(rectName)\n                        .classed(MekkoColumnChart.BorderClass.class, true);\n                    borders\n                        .style(\"fill\", function (d) { return borderColor; })\n                        .style(\"fill-opacity\", function (d) {\n                        return data.hasHighlights ? visuals.ColumnUtil.DimmedOpacity : visuals.ColumnUtil.DefaultOpacity;\n                    })\n                        .attr(layout.shapeBorder);\n                    borders\n                        .exit()\n                        .remove();\n                    return shapes;\n                };\n                MekkoColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {\n                    visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, MekkoColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);\n                    this.moveHandle(selectedColumnIndex);\n                };\n                MekkoColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {\n                    return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());\n                };\n                /**\n                 * Get the chart's columns centers (x value).\n                 */\n                MekkoColumnChartStrategy.prototype.getColumnsCenters = function () {\n                    var _this = this;\n                    if (!this.columnsCenters) {\n                        var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);\n                        // use the axis scale and first series data to get category centers\n                        if (this.data.series.length > 0) {\n                            var xScaleOffset = 0;\n                            if (!this.categoryLayout.isScalar) {\n                                xScaleOffset = categoryWidth / 2;\n                            }\n                            var firstSeries = this.data.series[0];\n                            if (firstSeries &&\n                                firstSeries.data) {\n                                this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset; });\n                            }\n                        }\n                    }\n                    return this.columnsCenters;\n                };\n                MekkoColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {\n                    var columnCenters = this.getColumnsCenters();\n                    var x = columnCenters[selectedColumnIndex];\n                    if (!this.columnSelectionLineHandle) {\n                        var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');\n                        handle.append('line')\n                            .classed('interactive-hover-line', true)\n                            .attr({\n                            x1: x,\n                            x2: x,\n                            y1: 0,\n                            y2: this.height,\n                        });\n                        handle.append('circle')\n                            .attr({\n                            cx: x,\n                            cy: this.height,\n                            r: '6px',\n                        })\n                            .classed('drag-handle', true);\n                    }\n                    else {\n                        var handle = this.columnSelectionLineHandle;\n                        handle.select('line').attr({ x1: x, x2: x });\n                        handle.select('circle').attr({ cx: x });\n                    }\n                };\n                MekkoColumnChartStrategy.getLayout = function (data, axisOptions) {\n                    var xScale = axisOptions.xScale;\n                    var yScale = axisOptions.yScale;\n                    var scaledY0 = yScale(0);\n                    var scaledX0 = xScale(0);\n                    var borderWidth = MekkoColumnChart.getBorderWidth(data.borderSettings);\n                    var columnWidthScale = function (d) {\n                        var value = visuals.AxisHelper.diffScaled(xScale, d.value, 0);\n                        return value;\n                    };\n                    var columnStart = function (d) {\n                        var value = scaledX0 +\n                            visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) +\n                            borderWidth * d.categoryIndex;\n                        return value;\n                    };\n                    var borderStart = function (d) {\n                        var value = scaledX0 +\n                            visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) +\n                            visuals.AxisHelper.diffScaled(xScale, d.value, 0) +\n                            borderWidth * d.categoryIndex;\n                        return value;\n                    };\n                    return {\n                        shapeLayout: {\n                            width: columnWidthScale,\n                            x: columnStart,\n                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },\n                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.valueAbsolute); }\n                        },\n                        shapeBorder: {\n                            width: function (d) { return borderWidth; },\n                            x: borderStart,\n                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },\n                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.valueAbsolute); }\n                        },\n                        shapeLayoutWithoutHighlights: {\n                            width: columnWidthScale,\n                            x: columnStart,\n                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },\n                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.originalValueAbsolute); }\n                        },\n                        zeroShapeLayout: {\n                            width: columnWidthScale,\n                            x: columnStart,\n                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) + visuals.StackedUtil.getSize(yScale, d.valueAbsolute); },\n                            height: function (d) { return 0; }\n                        },\n                        shapeXAxis: {\n                            width: columnWidthScale,\n                            x: columnStart,\n                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },\n                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.valueAbsolute); }\n                        },\n                    };\n                };\n                MekkoColumnChartStrategy.prototype.createMekkoLabelDataPoints = function () {\n                    var labelDataPoints = [];\n                    var data = this.data;\n                    var series = data.series;\n                    var formattersCache = NewDataLabelUtils.createColumnFormatterCacheManager();\n                    var shapeLayout = this.layout.shapeLayout;\n                    for (var i = 0, ilen = series.length; i < ilen; i++) {\n                        var currentSeries = series[i];\n                        var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;\n                        if (!labelSettings.show) {\n                            continue;\n                        }\n                        if (!currentSeries.data) {\n                            continue;\n                        }\n                        var axisFormatter = NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);\n                        for (var j = 0; j < currentSeries.data.length; j++) {\n                            var dataPoint = currentSeries.data[j];\n                            if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {\n                                continue;\n                            }\n                            // Calculate parent rectangle\n                            var parentRect = {\n                                left: shapeLayout.x(dataPoint),\n                                top: shapeLayout.y(dataPoint),\n                                width: shapeLayout.width(dataPoint),\n                                height: shapeLayout.height(dataPoint),\n                            };\n                            // Calculate label text\n                            var formatString = null;\n                            var value = dataPoint.valueOriginal;\n                            if (!labelSettings.displayUnits) {\n                                formatString = NewDataLabelUtils.hundredPercentFormat;\n                                value = dataPoint.valueAbsolute;\n                            }\n                            var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);\n                            var text = NewDataLabelUtils.getLabelFormattedText(formatter.format(value));\n                            // Calculate text size\n                            var properties = {\n                                text: text,\n                                fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,\n                                fontSize: NewDataLabelUtils.LabelTextProperties.fontSize,\n                                fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight,\n                            };\n                            var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);\n                            var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);\n                            labelDataPoints.push({\n                                isPreferred: true,\n                                text: text,\n                                textSize: {\n                                    width: textWidth,\n                                    height: textHeight,\n                                },\n                                outsideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultLabelColor,\n                                insideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultInsideLabelColor,\n                                isParentRect: true,\n                                parentShape: {\n                                    rect: parentRect,\n                                    orientation: 1,\n                                    validPositions: MekkoColumnChartStrategy.validLabelPositions,\n                                },\n                                identity: dataPoint.identity,\n                                parentType: 1,\n                            });\n                        }\n                    }\n                    return labelDataPoints;\n                };\n                MekkoColumnChartStrategy.classes = {\n                    item: createClassAndSelector('column'),\n                    highlightItem: createClassAndSelector('highlightColumn')\n                };\n                MekkoColumnChartStrategy.validLabelPositions = [1];\n                return MekkoColumnChartStrategy;\n            }());\n            samples.MekkoColumnChartStrategy = MekkoColumnChartStrategy;\n            /**\n             * Renders a data series as a cartestian visual.\n             */\n            var MekkoChart = (function () {\n                function MekkoChart(options) {\n                    this.isScrollable = false;\n                    if (options) {\n                        this.type = options.chartType;\n                        if (options.isScrollable)\n                            this.isScrollable = options.isScrollable;\n                        this.animator = options.animator;\n                        if (options.cartesianSmallViewPortProperties) {\n                            this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;\n                        }\n                        if (options.behavior) {\n                            this.behavior = options.behavior;\n                        }\n                    }\n                    else {\n                        this.behavior = new MekkoChartBehavior([new visuals.ColumnChartWebBehavior()]);\n                    }\n                }\n                MekkoChart.getTextProperties = function (fontSize) {\n                    if (fontSize === void 0) { fontSize = MekkoChart.FontSize; }\n                    return {\n                        fontFamily: 'wf_segoe-ui_normal',\n                        fontSize: jsCommon.PixelConverter.toString(fontSize),\n                    };\n                };\n                MekkoChart.prototype.init = function (options) {\n                    this.visualInitOptions = options;\n                    this.layers = [];\n                    var element = this.element = options.element;\n                    var viewport = this.currentViewport = options.viewport;\n                    this.hostServices = options.host;\n                    this.brush = d3.svg.brush();\n                    element.addClass(MekkoChart.ClassName);\n                    this.margin = {\n                        top: 1,\n                        right: 1,\n                        bottom: 1,\n                        left: 1\n                    };\n                    this.yAxisOrientation = visuals.yAxisPosition.left;\n                    this.adjustMargins(viewport);\n                    this.sharedColorPalette = new visuals.SharedColorPalette(options.style.colorPalette.dataColors);\n                    var showLinesOnX = true;\n                    var showLinesOnY = true;\n                    var svg = this.svg = d3.select(element.get(0)).append('svg');\n                    svg.style('position', 'absolute');\n                    var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')\n                        .classed(MekkoChart.AxisGraphicsContextClassName, true);\n                    this.svgScrollable = svg.append('svg')\n                        .classed('svgScrollable', true)\n                        .style('overflow', 'hidden');\n                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')\n                        .classed(MekkoChart.AxisGraphicsContextClassName, true);\n                    this.labelGraphicsContextScrollable = this.svgScrollable.append('g')\n                        .classed(NewDataLabelUtils.labelGraphicsContextClass.class, true);\n                    if (this.behavior) {\n                        this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);\n                    }\n                    var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;\n                    this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');\n                    this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');\n                    this.y2AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');\n                    this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);\n                    this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);\n                    this.y2AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);\n                    this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);\n                    this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);\n                    this.y2AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);\n                    if (this.behavior) {\n                        this.interactivityService = visuals.createInteractivityService(this.hostServices);\n                    }\n                    this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, true);\n                };\n                MekkoChart.prototype.renderAxesLabels = function (options) {\n                    debug.assertValue(options, 'options');\n                    debug.assertValue(options.viewport, 'options.viewport');\n                    debug.assertValue(options.axisLabels, 'options.axisLabels');\n                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\n                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\n                    var margin = this.margin;\n                    var width = options.viewport.width - (margin.left + margin.right);\n                    var height = options.viewport.height;\n                    var fontSize = MekkoChart.FontSize;\n                    var heightOffset = fontSize;\n                    var showOnRight = this.yAxisOrientation === visuals.yAxisPosition.right;\n                    if (!options.hideXAxisTitle) {\n                        var xAxisLabel = this.axisGraphicsContext.append(\"text\")\n                            .style(\"text-anchor\", \"middle\")\n                            .text(options.axisLabels.x)\n                            .call(function (text) {\n                            text.each(function () {\n                                var text = d3.select(this);\n                                text.attr({\n                                    \"class\": \"xAxisLabel\",\n                                    \"transform\": visuals.SVGUtil.translate(width / 2, height - heightOffset)\n                                });\n                            });\n                        });\n                        xAxisLabel.style(\"fill\", options.xLabelColor ? options.xLabelColor.solid.color : null);\n                        xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);\n                    }\n                    if (!options.hideYAxisTitle) {\n                        var yAxisLabel = this.axisGraphicsContext.append(\"text\")\n                            .style(\"text-anchor\", \"middle\")\n                            .text(options.axisLabels.y)\n                            .call(function (text) {\n                            text.each(function () {\n                                var text = d3.select(this);\n                                text.attr({\n                                    \"class\": \"yAxisLabel\",\n                                    \"transform\": \"rotate(-90)\",\n                                    \"y\": showOnRight ? width + margin.right - fontSize : -margin.left,\n                                    \"x\": -((height - margin.top - options.legendMargin) / 2),\n                                    \"dy\": \"1em\"\n                                });\n                            });\n                        });\n                        yAxisLabel.style(\"fill\", options.yLabelColor ? options.yLabelColor.solid.color : null);\n                        yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);\n                    }\n                    if (!options.hideY2AxisTitle && options.axisLabels.y2) {\n                        var y2AxisLabel = this.axisGraphicsContext.append(\"text\")\n                            .style(\"text-anchor\", \"middle\")\n                            .text(options.axisLabels.y2)\n                            .call(function (text) {\n                            text.each(function () {\n                                var text = d3.select(this);\n                                text.attr({\n                                    \"class\": \"yAxisLabel\",\n                                    \"transform\": \"rotate(-90)\",\n                                    \"y\": showOnRight ? -margin.left : width + margin.right - fontSize,\n                                    \"x\": -((height - margin.top - options.legendMargin) / 2),\n                                    \"dy\": \"1em\"\n                                });\n                            });\n                        });\n                        y2AxisLabel.style(\"fill\", options.y2LabelColor ? options.y2LabelColor.solid.color : null);\n                        y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);\n                    }\n                };\n                MekkoChart.prototype.adjustMargins = function (viewport) {\n                    var margin = this.margin;\n                    var width = viewport.width - (margin.left + margin.right);\n                    var height = viewport.height - (margin.top + margin.bottom);\n                    // Adjust margins if ticks are not going to be shown on either axis\n                    var xAxis = this.element.find('.x.axis');\n                    if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0\n                        && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {\n                        this.margin = {\n                            top: 0,\n                            right: 0,\n                            bottom: 0,\n                            left: 0\n                        };\n                        xAxis.hide();\n                    }\n                    else {\n                        xAxis.show();\n                    }\n                };\n                MekkoChart.prototype.translateAxes = function (viewport) {\n                    this.adjustMargins(viewport);\n                    var margin = this.margin;\n                    var width = viewport.width - (margin.left + margin.right);\n                    var height = viewport.height - (margin.top + margin.bottom);\n                    var showY1OnRight = this.yAxisOrientation === visuals.yAxisPosition.right;\n                    this.xAxisGraphicsContext\n                        .attr('transform', visuals.SVGUtil.translate(0, height));\n                    this.y1AxisGraphicsContext\n                        .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0));\n                    this.y2AxisGraphicsContext\n                        .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0));\n                    this.svg.attr({\n                        'width': viewport.width,\n                        'height': viewport.height\n                    });\n                    this.svg.style('top', this.legend.isVisible() ? this.legend.getMargins().height + 'px' : 0);\n                    this.svgScrollable.attr({\n                        'width': viewport.width,\n                        'height': viewport.height\n                    });\n                    this.svgScrollable.attr({\n                        'x': 0\n                    });\n                    this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));\n                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));\n                    this.labelGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));\n                    if (this.isXScrollBarVisible) {\n                        this.svgScrollable.attr({\n                            'x': this.margin.left\n                        });\n                        this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));\n                        this.labelGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));\n                        this.svgScrollable.attr('width', width);\n                        this.svg.attr('width', viewport.width)\n                            .attr('height', viewport.height + MekkoChart.ScrollBarWidth);\n                    }\n                    else if (this.isYScrollBarVisible) {\n                        this.svgScrollable.attr('height', height + margin.top);\n                        this.svg.attr('width', viewport.width + MekkoChart.ScrollBarWidth)\n                            .attr('height', viewport.height);\n                    }\n                };\n                MekkoChart.getIsScalar = function (objects, propertyId, type) {\n                    var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);\n                    if (!objects || axisTypeValue === undefined) {\n                        // If we don't have anything set (Auto), show charts as Scalar if the category type is numeric or time.\n                        // If we have the property, it will override the type.\n                        return !visuals.AxisHelper.isOrdinal(type);\n                    }\n                    // also checking type here to be in sync with AxisHelper, which ignores scalar if the type is non-numeric.\n                    return (axisTypeValue === visuals.axisType.scalar) && !visuals.AxisHelper.isOrdinal(type);\n                };\n                MekkoChart.prototype.populateObjectProperties = function (dataViews) {\n                    if (dataViews && dataViews.length > 0) {\n                        var dataViewMetadata = dataViews[0].metadata;\n                        if (dataViewMetadata) {\n                            this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});\n                            this.borderObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'columnBorder', {});\n                        }\n                        else {\n                            this.legendObjectProperties = {};\n                            this.borderObjectProperties = {};\n                        }\n                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);\n                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);\n                        if (dataViewMetadata &&\n                            dataViewMetadata.objects) {\n                            var categoryAxis = dataViewMetadata.objects['categoryAxis'];\n                            var valueAxis = dataViewMetadata.objects['valueAxis'];\n                            if (categoryAxis) {\n                                this.categoryAxisProperties['showBorder'] = categoryAxis['showBorder'];\n                                this.categoryAxisProperties['fontSize'] = categoryAxis['fontSize'];\n                            }\n                            if (valueAxis) {\n                                this.valueAxisProperties['fontSize'] = valueAxis['fontSize'];\n                            }\n                        }\n                        var axisPosition = this.valueAxisProperties['position'];\n                        this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;\n                    }\n                };\n                MekkoChart.prototype.update = function (options) {\n                    debug.assertValue(options, 'options');\n                    var dataViews = this.dataViews = options.dataViews;\n                    this.currentViewport = options.viewport;\n                    if (!dataViews) {\n                        return;\n                    }\n                    if ((this.currentViewport.width < MekkoChart.MinWidth) ||\n                        (this.currentViewport.height < MekkoChart.MinHeight)) {\n                        return;\n                    }\n                    if (this.layers.length === 0) {\n                        // Lazily instantiate the chart layers on the first data load.\n                        this.layers = this.createAndInitLayers(dataViews);\n                        debug.assert(this.layers.length > 0, 'createAndInitLayers should update the layers.');\n                    }\n                    var layers = this.layers;\n                    if (dataViews && dataViews.length > 0) {\n                        var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);\n                        if (warnings && warnings.length > 0) {\n                            this.hostServices.setWarnings(warnings);\n                        }\n                        this.populateObjectProperties(dataViews);\n                    }\n                    this.sharedColorPalette.clearPreferredScale();\n                    for (var i = 0, len = layers.length; i < len; i++) {\n                        layers[i].setData(getLayerData(dataViews, i, len));\n                        if (len > 1) {\n                            this.sharedColorPalette.rotateScale();\n                        }\n                    }\n                    // Note: interactive legend shouldn't be rendered explicitly here\n                    // The interactive legend is being rendered in the render method of ICartesianVisual\n                    if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {\n                        this.renderLegend();\n                    }\n                    this.render(!this.hasSetData || options.suppressAnimations);\n                    this.hasSetData = this.hasSetData || (dataViews && dataViews.length > 0);\n                };\n                MekkoChart.parseLabelSettings = function (objects) {\n                    var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(true);\n                    var labelsObj = objects['labels'];\n                    var minPrecision = MekkoChart.DefaultSettings.labelSettings.minPrecision, maxPrecision = MekkoChart.DefaultSettings.labelSettings.maxPrecision;\n                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);\n                    if (labelSettings.precision < minPrecision) {\n                        labelSettings.precision = minPrecision;\n                    }\n                    if (labelSettings.precision > maxPrecision) {\n                        labelSettings.precision = maxPrecision;\n                    }\n                    return labelSettings;\n                };\n                MekkoChart.parseBorderSettings = function (objects) {\n                    var show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show);\n                    var color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color);\n                    var width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width);\n                    var maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;\n                    if (width > maxWidth) {\n                        width = maxWidth;\n                    }\n                    else if (width < 0) {\n                        width = 0;\n                    }\n                    if (!show) {\n                        width = 0;\n                    }\n                    return {\n                        show: show,\n                        color: color,\n                        width: width,\n                    };\n                };\n                MekkoChart.prototype.enumerateBorder = function (enumeration) {\n                    var objects = {\n                        columnBorder: this.borderObjectProperties\n                    };\n                    var show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show);\n                    var color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color);\n                    var width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width);\n                    var maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;\n                    if (width > maxWidth) {\n                        width = maxWidth;\n                    }\n                    else if (width < 0) {\n                        width = 0;\n                    }\n                    var instance = {\n                        objectName: 'columnBorder',\n                        selector: null,\n                        properties: {\n                            show: show,\n                            color: color,\n                            width: width,\n                        },\n                    };\n                    enumeration\n                        .pushInstance(instance);\n                };\n                MekkoChart.prototype.enumerateObjectInstances = function (options) {\n                    var enumeration = new visuals.ObjectEnumerationBuilder();\n                    var layersLength = this.layers ? this.layers.length : 0;\n                    if (options.objectName === 'columnBorder') {\n                        this.enumerateBorder(enumeration);\n                    }\n                    else if (options.objectName === 'legend') {\n                        if (!this.shouldShowLegendCard()) {\n                            return;\n                        }\n                        var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());\n                        var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);\n                        var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData && this.layerLegendData.title ? this.layerLegendData.title : '');\n                        var fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt);\n                        enumeration.pushInstance({\n                            selector: null,\n                            properties: {\n                                show: show,\n                                position: visuals.LegendPosition[this.legend.getOrientation()],\n                                showTitle: showTitle,\n                                titleText: titleText,\n                                fontSize: fontSize\n                            },\n                            objectName: options.objectName\n                        });\n                    }\n                    else if (options.objectName === 'categoryAxis' && this.hasCategoryAxis) {\n                        this.getCategoryAxisValues(enumeration);\n                    }\n                    else if (options.objectName === 'valueAxis') {\n                        this.getValueAxisValues(enumeration);\n                    }\n                    for (var i = 0, len = layersLength; i < len; i++) {\n                        var layer = this.layers[i];\n                        if (layer.enumerateObjectInstances) {\n                            layer.enumerateObjectInstances(enumeration, options);\n                        }\n                    }\n                    return enumeration.complete();\n                };\n                MekkoChart.prototype.shouldShowLegendCard = function () {\n                    var layers = this.layers;\n                    var dataViews = this.dataViews;\n                    if (layers && dataViews) {\n                        var layersLength = layers.length;\n                        var layersWithValuesCtr = 0;\n                        for (var i = 0; i < layersLength; i++) {\n                            if (layers[i].hasLegend()) {\n                                return true;\n                            }\n                            // if there are at least two layers with values legend card should be shown (even if each of the individual layers don't have legend)\n                            var dataView = dataViews[i];\n                            if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0) {\n                                layersWithValuesCtr++;\n                                if (layersWithValuesCtr > 1) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                };\n                MekkoChart.prototype.getCategoryAxisValues = function (enumeration) {\n                    var supportedType = visuals.axisType.both;\n                    var isScalar = false;\n                    var logPossible = !!this.axes.x.isLogScaleAllowed;\n                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options\n                    if (this.layers && this.layers[0].getSupportedCategoryAxisType) {\n                        supportedType = this.layers[0].getSupportedCategoryAxisType();\n                        if (supportedType === visuals.axisType.scalar) {\n                            isScalar = true;\n                        }\n                        else {\n                            isScalar = visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties);\n                        }\n                    }\n                    if (!isScalar) {\n                        if (this.categoryAxisProperties) {\n                            this.categoryAxisProperties['start'] = null;\n                            this.categoryAxisProperties['end'] = null;\n                        }\n                    }\n                    var instance = {\n                        selector: null,\n                        properties: {},\n                        objectName: 'categoryAxis',\n                        validValues: {\n                            axisScale: scaleOptions\n                        }\n                    };\n                    instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;\n                    if (this.yAxisIsCategorical)\n                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;\n                    if (supportedType === visuals.axisType.both) {\n                        instance.properties['axisType'] = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical;\n                    }\n                    if (isScalar) {\n                        instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : visuals.axisScale.linear;\n                        instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;\n                        instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;\n                    }\n                    instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;\n                    instance.properties['showBorder'] = this.categoryAxisProperties && this.categoryAxisProperties['showBorder'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;\n                    instance.properties['fontSize'] = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                    enumeration\n                        .pushInstance(instance)\n                        .pushInstance({\n                        selector: null,\n                        properties: {\n                            axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,\n                            labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null,\n                            fontSize: this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt\n                        },\n                        objectName: 'categoryAxis',\n                        validValues: {\n                            axisStyle: this.categoryAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly],\n                        }\n                    });\n                };\n                //todo: wrap all these object getters and other related stuff into an interface\n                MekkoChart.prototype.getValueAxisValues = function (enumeration) {\n                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options\n                    var logPossible = !!this.axes.y1.isLogScaleAllowed;\n                    //var secLogPossible = this.axes.y2 != null && this.axes.y2.isLogScaleAllowed;\n                    var instance = {\n                        selector: null,\n                        properties: {},\n                        objectName: 'valueAxis',\n                        validValues: {\n                            axisScale: scaleOptions,\n                            secAxisScale: scaleOptions\n                        }\n                    };\n                    instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;\n                    if (!this.yAxisIsCategorical) {\n                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;\n                    }\n                    instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : visuals.axisScale.linear;\n                    instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;\n                    instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;\n                    instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : false;\n                    instance.properties['fontSize'] = this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                    enumeration\n                        .pushInstance(instance)\n                        .pushInstance({\n                        selector: null,\n                        properties: {\n                            axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,\n                            labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null,\n                            fontSize: this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt\n                        },\n                        objectName: 'valueAxis',\n                        validValues: {\n                            axisStyle: this.valueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]\n                        },\n                    });\n                    if (this.layers.length === 2) {\n                        instance.properties['secShow'] = this.valueAxisProperties && this.valueAxisProperties['secShow'] != null ? this.valueAxisProperties['secShow'] : this.y2AxisExists;\n                        if (instance.properties['secShow']) {\n                            instance.properties['axisLabel'] = ''; //this.layers[0].getVisualType();//I will keep or remove this, depending on the decision made\n                        }\n                    }\n                };\n                MekkoChart.prototype.onClearSelection = function () {\n                    if (this.hasSetData) {\n                        for (var i = 0, len = this.layers.length; i < len; i++) {\n                            var layer = this.layers[i];\n                            layer.onClearSelection();\n                            layer.render(true /* suppressAnimations */);\n                        }\n                    }\n                };\n                MekkoChart.prototype.createAndInitLayers = function (dataViews) {\n                    var _this = this;\n                    var objects;\n                    if (dataViews && dataViews.length > 0) {\n                        var dataViewMetadata = dataViews[0].metadata;\n                        if (dataViewMetadata)\n                            objects = dataViewMetadata.objects;\n                    }\n                    // Create the layers\n                    var layers = createLayers(this.type, objects, this.interactivityService, this.animator, this.isScrollable);\n                    // Initialize the layers\n                    var cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);\n                    cartesianOptions.svg = this.axisGraphicsContextScrollable;\n                    cartesianOptions.cartesianHost = {\n                        updateLegend: function (data) { return _this.legend.drawLegend(data, _this.currentViewport); },\n                        getSharedColors: function () { return _this.sharedColorPalette; },\n                        triggerRender: undefined,\n                    };\n                    for (var i = 0, len = layers.length; i < len; i++) {\n                        layers[i].init(cartesianOptions);\n                    }\n                    return layers;\n                };\n                MekkoChart.prototype.renderLegend = function () {\n                    var layers = this.layers;\n                    var legendData = { title: \"\", dataPoints: [] };\n                    for (var i = 0, len = layers.length; i < len; i++) {\n                        this.layerLegendData = layers[i].calculateLegend();\n                        if (this.layerLegendData) {\n                            legendData.title = i === 0 ? this.layerLegendData.title || \"\"\n                                : legendData.title;\n                            legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);\n                            if (this.layerLegendData.grouped) {\n                                legendData.grouped = true;\n                            }\n                        }\n                    }\n                    var legendProperties = this.legendObjectProperties;\n                    if (legendProperties) {\n                        if (!legendProperties['fontSize']) {\n                            legendProperties['fontSize'] = NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                        }\n                        visuals.LegendData.update(legendData, legendProperties);\n                        var position = legendProperties[visuals.legendProps.position];\n                        if (position) {\n                            this.legend.changeOrientation(visuals.LegendPosition[position]);\n                        }\n                    }\n                    else {\n                        this.legend.changeOrientation(visuals.LegendPosition.Top);\n                    }\n                    if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {\n                        legendData.dataPoints = [];\n                    }\n                    this.legend.drawLegend(legendData, this.currentViewport);\n                };\n                MekkoChart.prototype.hideLegends = function () {\n                    if (this.cartesianSmallViewPortProperties) {\n                        if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                MekkoChart.prototype.addUnitTypeToAxisLabel = function (axes) {\n                    var unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.x; });\n                    if (axes.x.isCategoryAxis) {\n                        this.categoryAxisHasUnitType = unitType !== null;\n                    }\n                    else {\n                        this.valueAxisHasUnitType = unitType !== null;\n                    }\n                    if (axes.x.axisLabel && unitType) {\n                        if (axes.x.isCategoryAxis) {\n                            axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType);\n                        }\n                        else {\n                            axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType);\n                        }\n                    }\n                    unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.y1; });\n                    if (!axes.y1.isCategoryAxis) {\n                        this.valueAxisHasUnitType = unitType !== null;\n                    }\n                    else {\n                        this.categoryAxisHasUnitType = unitType !== null;\n                    }\n                    if (axes.y1.axisLabel && unitType) {\n                        if (!axes.y1.isCategoryAxis) {\n                            axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType);\n                        }\n                        else {\n                            axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType);\n                        }\n                    }\n                    if (axes.y2) {\n                        var unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.y2; });\n                        this.secValueAxisHasUnitType = unitType !== null;\n                        if (axes.y2.axisLabel && unitType) {\n                            if (this.valueAxisProperties && this.valueAxisProperties['secAxisStyle']) {\n                                if (this.valueAxisProperties['secAxisStyle'] === visuals.axisStyle.showBoth) {\n                                    axes.y2.axisLabel = axes.y2.axisLabel + ' (' + unitType + ')';\n                                }\n                                else if (this.valueAxisProperties['secAxisStyle'] === visuals.axisStyle.showUnitOnly) {\n                                    axes.y2.axisLabel = unitType;\n                                }\n                            }\n                        }\n                    }\n                };\n                MekkoChart.prototype.shouldRenderSecondaryAxis = function (axisProperties) {\n                    if (!axisProperties) {\n                        return false;\n                    }\n                    if (!this.valueAxisProperties || this.valueAxisProperties[\"secShow\"] == null || this.valueAxisProperties[\"secShow\"]) {\n                        return axisProperties.values && axisProperties.values.length > 0;\n                    }\n                    return false;\n                };\n                MekkoChart.prototype.shouldRenderAxis = function (axisProperties, propertyName) {\n                    if (propertyName === void 0) { propertyName = \"show\"; }\n                    if (!axisProperties) {\n                        return false;\n                    }\n                    else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {\n                        return axisProperties.values && axisProperties.values.length > 0;\n                    }\n                    else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {\n                        return axisProperties.values && axisProperties.values.length > 0;\n                    }\n                    return false;\n                };\n                MekkoChart.prototype.render = function (suppressAnimations) {\n                    var legendMargins = this.legendMargins = this.legend.getMargins();\n                    var viewport = {\n                        height: this.currentViewport.height - legendMargins.height,\n                        width: this.currentViewport.width - legendMargins.width\n                    };\n                    var maxMarginFactor = this.getMaxMarginFactor();\n                    var leftRightMarginLimit = this.leftRightMarginLimit = viewport.width * maxMarginFactor;\n                    this.bottomMarginLimit = Math.max(MekkoChart.MinBottomMargin, Math.ceil(viewport.height * maxMarginFactor));\n                    var xAxisTextProperties = MekkoChart.getTextProperties(parseFloat(this.categoryAxisProperties['fontSize']) || undefined);\n                    var y1AxisTextProperties = MekkoChart.getTextProperties(parseFloat(this.valueAxisProperties['fontSize']) || undefined);\n                    var margin = this.margin;\n                    // reset defaults\n                    margin.top = parseFloat(y1AxisTextProperties.fontSize) / 2;\n                    margin.bottom = MekkoChart.MinBottomMargin;\n                    margin.right = 0;\n                    var axes = this.axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);\n                    this.yAxisIsCategorical = axes.y1.isCategoryAxis;\n                    this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;\n                    var renderXAxis = this.shouldRenderAxis(axes.x);\n                    var renderY1Axis = this.shouldRenderAxis(axes.y1);\n                    var renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2);\n                    var width = viewport.width - (margin.left + margin.right);\n                    var isScalar = false;\n                    var mainAxisScale;\n                    var preferredViewport;\n                    this.isXScrollBarVisible = false;\n                    this.isYScrollBarVisible = false;\n                    var yAxisOrientation = this.yAxisOrientation;\n                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;\n                    if (this.layers) {\n                        if (this.layers[0].getVisualCategoryAxisIsScalar) {\n                            isScalar = this.layers[0].getVisualCategoryAxisIsScalar();\n                        }\n                        if (!isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea) {\n                            var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness;\n                            var categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;\n                            preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);\n                            if (this.scrollX && preferredViewport && preferredViewport.width > viewport.width) {\n                                this.isXScrollBarVisible = true;\n                                viewport.height -= MekkoChart.ScrollBarWidth;\n                            }\n                            if (this.scrollY && preferredViewport && preferredViewport.height > viewport.height) {\n                                this.isYScrollBarVisible = true;\n                                viewport.width -= MekkoChart.ScrollBarWidth;\n                                width = viewport.width - (margin.left + margin.right);\n                            }\n                        }\n                    }\n                    // Only create the g tag where there is a scrollbar\n                    if (this.isXScrollBarVisible || this.isYScrollBarVisible) {\n                        if (!this.brushGraphicsContext) {\n                            this.brushGraphicsContext = this.svg.append(\"g\")\n                                .classed('x brush', true);\n                        }\n                    }\n                    else {\n                        // clear any existing brush if no scrollbar is shown\n                        this.svg.selectAll('.brush').remove();\n                        this.brushGraphicsContext = undefined;\n                    }\n                    // Recalculate axes now that scrollbar visible variables have been set\n                    axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);\n                    // we need to make two passes because the margin changes affect the chosen tick values, which then affect the margins again.\n                    // after the second pass the margins are correct.\n                    var doneWithMargins = false, maxIterations = 2, numIterations = 0;\n                    var tickLabelMargins = undefined;\n                    var chartHasAxisLabels = undefined;\n                    var axisLabels = undefined;\n                    while (!doneWithMargins && numIterations < maxIterations) {\n                        numIterations++;\n                        tickLabelMargins = getTickLabelMargins({ width: width, height: viewport.height }, leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, this.bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, null, false, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);\n                        // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side\n                        var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = renderXAxis ? (tickLabelMargins.xMax / 1.8) : 0;\n                        maxMainYaxisSide += MekkoChart.LeftPadding;\n                        maxSecondYaxisSide += MekkoChart.RightPadding;\n                        xMax += MekkoChart.BottomPadding;\n                        if (this.hideAxisLabels(legendMargins)) {\n                            axes.x.axisLabel = null;\n                            axes.y1.axisLabel = null;\n                            if (axes.y2) {\n                                axes.y2.axisLabel = null;\n                            }\n                        }\n                        this.addUnitTypeToAxisLabel(axes);\n                        axisLabels = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };\n                        chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);\n                        if (axisLabels.x != null) {\n                            xMax += MekkoChart.XAxisLabelPadding;\n                        }\n                        if (axisLabels.y != null) {\n                            maxMainYaxisSide += MekkoChart.YAxisLabelPadding;\n                        }\n                        if (axisLabels.y2 != null) {\n                            maxSecondYaxisSide += MekkoChart.YAxisLabelPadding;\n                        }\n                        margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;\n                        margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;\n                        margin.bottom = xMax;\n                        this.margin = margin;\n                        width = viewport.width - (margin.left + margin.right);\n                        // re-calculate the axes with the new margins\n                        var previousTickCountY1 = axes.y1.values.length;\n                        var previousTickCountY2 = axes.y2 && axes.y2.values.length;\n                        axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, axes);\n                        // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again\n                        // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.\n                        if (axes.y1.values.length === previousTickCountY1 && (!axes.y2 || axes.y2.values.length === previousTickCountY2))\n                            doneWithMargins = true;\n                    }\n                    this.renderChart(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations);\n                };\n                MekkoChart.prototype.hideAxisLabels = function (legendMargins) {\n                    if (this.cartesianSmallViewPortProperties) {\n                        if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && ((this.currentViewport.height + legendMargins.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) && !this.visualInitOptions.interactivity.isInteractiveLegend) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                MekkoChart.getUnitType = function (axis, axisPropertiesLookup) {\n                    if (axisPropertiesLookup(axis).formatter &&\n                        axisPropertiesLookup(axis).formatter.displayUnit &&\n                        axisPropertiesLookup(axis).formatter.displayUnit.value > 1) {\n                        return axisPropertiesLookup(axis).formatter.displayUnit.title;\n                    }\n                    return null;\n                };\n                MekkoChart.prototype.getMaxMarginFactor = function () {\n                    return this.visualInitOptions.style.maxMarginFactor || MekkoChart.MaxMarginFactor;\n                };\n                MekkoChart.getChartViewport = function (viewport, margin) {\n                    return {\n                        width: viewport.width - margin.left - margin.right,\n                        height: viewport.height - margin.top - margin.bottom,\n                    };\n                };\n                MekkoChart.wordBreak = function (text, axisProperties, columnsWidth, maxHeight, borderWidth) {\n                    //var allowedLength = axisProperties.xLabelMaxWidth;\n                    text.each(function (data, index) {\n                        var width, allowedLength;\n                        var node = d3.select(this);\n                        if (columnsWidth.length >= index) {\n                            width = columnsWidth[index];\n                            allowedLength = axisProperties.scale(width);\n                        }\n                        else {\n                            allowedLength = axisProperties.xLabelMaxWidth;\n                        }\n                        // Reset style of text node\n                        node\n                            .style('text-anchor', 'middle')\n                            .attr({\n                            'dx': '0em',\n                            'dy': '1em',\n                            'transform': 'rotate(0)'\n                        });\n                        powerbi.TextMeasurementService.wordBreak(this, allowedLength, axisProperties.willLabelsWordBreak ? maxHeight : 0);\n                    });\n                };\n                MekkoChart.prototype.renderChart = function (mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations, scrollScale, extent) {\n                    var bottomMarginLimit = this.bottomMarginLimit;\n                    var leftRightMarginLimit = this.leftRightMarginLimit;\n                    var layers = this.layers;\n                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);\n                    var chartViewport = MekkoChart.getChartViewport(viewport, this.margin);\n                    debug.assertValue(layers, 'layers');\n                    var xLabelColor;\n                    var yLabelColor;\n                    var y2LabelColor;\n                    var xFontSize;\n                    var yFontSize;\n                    //hide show x-axis here\n                    if (this.shouldRenderAxis(axes.x)) {\n                        if (axes.x.isCategoryAxis) {\n                            xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;\n                            xFontSize = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                        }\n                        else {\n                            xLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;\n                            xFontSize = this.valueAxisProperties && this.valueAxisProperties['fontSize'] ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                        }\n                        axes.x.axis.orient(\"bottom\");\n                        if (!axes.x.willLabelsFit) {\n                            axes.x.axis.tickPadding(MekkoChart.TickPaddingRotatedX);\n                        }\n                        var xAxisGraphicsElement = this.xAxisGraphicsContext;\n                        if (duration) {\n                            xAxisGraphicsElement\n                                .transition()\n                                .duration(duration)\n                                .call(axes.x.axis);\n                        }\n                        else {\n                            xAxisGraphicsElement\n                                .call(axes.x.axis);\n                        }\n                        xAxisGraphicsElement\n                            .call(MekkoChart.darkenZeroLine)\n                            .call(MekkoChart.setAxisLabelColor, xLabelColor)\n                            .call(MekkoChart.setAxisLabelFontSize, xFontSize);\n                        var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');\n                        var columnWidth = [];\n                        var borderWidth = 0;\n                        if (this.layers && this.layers.length) {\n                            columnWidth = this.layers[0].getColumnsWidth();\n                            borderWidth = this.layers[0].getBorderWidth();\n                        }\n                        xAxisGraphicsElement\n                            .call(MekkoChart.moveBorder, axes.x.scale, borderWidth, xFontSize / 2 - 8);\n                        xAxisTextNodes\n                            .call(MekkoChart.wordBreak, axes.x, columnWidth, bottomMarginLimit, borderWidth);\n                    }\n                    else {\n                        this.xAxisGraphicsContext.selectAll('*').remove();\n                    }\n                    if (this.shouldRenderAxis(axes.y1)) {\n                        if (axes.y1.isCategoryAxis) {\n                            yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;\n                            yFontSize = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                        }\n                        else {\n                            yLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;\n                            yFontSize = this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                        }\n                        var yAxisOrientation = this.yAxisOrientation;\n                        var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;\n                        axes.y1.axis\n                            .tickSize(-width)\n                            .tickPadding(MekkoChart.TickPaddingY)\n                            .orient(yAxisOrientation.toLowerCase());\n                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;\n                        if (duration) {\n                            y1AxisGraphicsElement\n                                .transition()\n                                .duration(duration)\n                                .call(axes.y1.axis);\n                        }\n                        else {\n                            y1AxisGraphicsElement\n                                .call(axes.y1.axis);\n                        }\n                        y1AxisGraphicsElement\n                            .call(MekkoChart.darkenZeroLine)\n                            .call(MekkoChart.setAxisLabelColor, yLabelColor)\n                            .call(MekkoChart.setAxisLabelFontSize, yFontSize);\n                        if (tickLabelMargins.yLeft >= leftRightMarginLimit) {\n                            y1AxisGraphicsElement.selectAll('text')\n                                .call(visuals.AxisHelper.LabelLayoutStrategy.clip, \n                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations\n                            leftRightMarginLimit - MekkoChart.LeftPadding, powerbi.TextMeasurementService.svgEllipsis);\n                        }\n                        if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties['secShow'] == null || this.valueAxisProperties['secShow'])) {\n                            y2LabelColor = this.valueAxisProperties && this.valueAxisProperties['secLabelColor'] ? this.valueAxisProperties['secLabelColor'] : null;\n                            axes.y2.axis\n                                .tickPadding(MekkoChart.TickPaddingY)\n                                .orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase());\n                            if (duration) {\n                                this.y2AxisGraphicsContext\n                                    .transition()\n                                    .duration(duration)\n                                    .call(axes.y2.axis);\n                            }\n                            else {\n                                this.y2AxisGraphicsContext\n                                    .call(axes.y2.axis);\n                            }\n                            this.y2AxisGraphicsContext\n                                .call(MekkoChart.darkenZeroLine)\n                                .call(MekkoChart.setAxisLabelColor, y2LabelColor);\n                            if (tickLabelMargins.yRight >= leftRightMarginLimit) {\n                                this.y2AxisGraphicsContext.selectAll('text')\n                                    .call(visuals.AxisHelper.LabelLayoutStrategy.clip, \n                                // Can't use padding space to render text, so subtract that from available space for ellipses calculations\n                                leftRightMarginLimit - MekkoChart.RightPadding, powerbi.TextMeasurementService.svgEllipsis);\n                            }\n                        }\n                        else {\n                            this.y2AxisGraphicsContext.selectAll('*').remove();\n                        }\n                    }\n                    else {\n                        this.y1AxisGraphicsContext.selectAll('*').remove();\n                        this.y2AxisGraphicsContext.selectAll('*').remove();\n                    }\n                    // Axis labels\n                    if (chartHasAxisLabels) {\n                        var hideXAxisTitle = !this.shouldRenderAxis(axes.x, \"showAxisTitle\");\n                        var hideYAxisTitle = !this.shouldRenderAxis(axes.y1, \"showAxisTitle\");\n                        var hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties[\"secShowAxisTitle\"] != null && this.valueAxisProperties[\"secShowAxisTitle\"] === false;\n                        var renderAxisOptions = {\n                            axisLabels: axisLabels,\n                            legendMargin: this.legendMargins.height,\n                            viewport: viewport,\n                            hideXAxisTitle: hideXAxisTitle,\n                            hideYAxisTitle: hideYAxisTitle,\n                            hideY2AxisTitle: hideY2AxisTitle,\n                            xLabelColor: xLabelColor,\n                            yLabelColor: yLabelColor,\n                            y2LabelColor: y2LabelColor,\n                            margin: undefined,\n                        };\n                        this.renderAxesLabels(renderAxisOptions);\n                    }\n                    else {\n                        this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\n                        this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\n                    }\n                    this.translateAxes(viewport);\n                    var dataPoints = [];\n                    var layerBehaviorOptions = [];\n                    var labelDataPointsGroup = [];\n                    //Render chart columns\n                    if (this.behavior) {\n                        for (var i = 0, len = layers.length; i < len; i++) {\n                            var result = layers[i].render(suppressAnimations);\n                            if (result) {\n                                dataPoints = dataPoints.concat(result.dataPoints);\n                                layerBehaviorOptions.push(result.behaviorOptions);\n                                if (result.labelDataPointGroups) {\n                                    var resultLabelDataPointsGroups = result.labelDataPointGroups;\n                                    for (var j = 0, jlen = resultLabelDataPointsGroups.length; j < jlen; j++) {\n                                        var resultLabelDataPointsGroup = resultLabelDataPointsGroups[j];\n                                        labelDataPointsGroup.push({\n                                            labelDataPoints: resultLabelDataPointsGroup.labelDataPoints,\n                                            maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels,\n                                        });\n                                    }\n                                }\n                                else {\n                                    var resultsLabelDataPoints = result.labelDataPoints;\n                                    var reducedDataPoints = resultsLabelDataPoints;\n                                    labelDataPointsGroup.push({\n                                        labelDataPoints: reducedDataPoints,\n                                        maxNumberOfLabels: reducedDataPoints.length,\n                                    });\n                                }\n                            }\n                        }\n                        var labelLayoutOptions = {\n                            maximumOffset: NewDataLabelUtils.maxLabelOffset,\n                            startingOffset: NewDataLabelUtils.startingLabelOffset\n                        };\n                        var labelLayout = new powerbi.LabelLayout(labelLayoutOptions);\n                        var dataLabels = labelLayout.layout(labelDataPointsGroup, chartViewport);\n                        if (layers.length > 1) {\n                            NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContextScrollable, dataLabels, \"#FFFFFF\", 0.7);\n                        }\n                        if (this.animator && !suppressAnimations) {\n                            NewDataLabelUtils.animateDefaultLabels(this.labelGraphicsContextScrollable, dataLabels, this.animator.getDuration());\n                        }\n                        else {\n                            NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContextScrollable, dataLabels);\n                        }\n                        this.labelGraphicsContextScrollable.selectAll(\"text.label\").style(\"pointer-events\", \"none\");\n                        if (this.interactivityService) {\n                            var behaviorOptions = {\n                                layerOptions: layerBehaviorOptions,\n                                clearCatcher: this.clearCatcher,\n                            };\n                            this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);\n                        }\n                    }\n                };\n                /**\n                 * Within the context of the given selection (g), find the offset of\n                 * the zero tick using the d3 attached datum of g.tick elements.\n                 * 'Classed' is undefined for transition selections\n                 */\n                MekkoChart.darkenZeroLine = function (g) {\n                    var zeroTick = g.selectAll('g.tick').filter(function (data) { return data === 0; }).node();\n                    if (zeroTick) {\n                        d3.select(zeroTick).select('line').classed('zero-line', true);\n                    }\n                };\n                MekkoChart.setAxisLabelColor = function (g, fill) {\n                    g.selectAll('g.tick text').style('fill', fill ? fill.solid.color : null);\n                };\n                MekkoChart.setAxisLabelFontSize = function (g, fontSize) {\n                    var value = jsCommon.PixelConverter.toString(fontSize);\n                    g.selectAll('g.tick text').attr('font-size', value);\n                };\n                MekkoChart.moveBorder = function (g, scale, borderWidth, yOffset) {\n                    if (yOffset === void 0) { yOffset = 0; }\n                    g.selectAll('g.tick')\n                        .attr(\"transform\", function (value, index) {\n                        return visuals.SVGUtil.translate(scale(value) + (borderWidth * index), yOffset);\n                    });\n                };\n                MekkoChart.capabilities = {\n                    dataRoles: [\n                        {\n                            name: 'Category',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Category',\n                        }, {\n                            name: 'Series',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Series',\n                        }, {\n                            name: 'Y',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Y Axis',\n                        }, {\n                            name: 'Width',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Axis width',\n                        }\n                    ],\n                    objects: {\n                        columnBorder: {\n                            displayName: 'Column Border',\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                color: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                width: {\n                                    displayName: 'Width',\n                                    type: { numeric: true }\n                                },\n                            },\n                        },\n                        labels: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),\n                            description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                showSeries: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                color: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                labelDisplayUnits: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),\n                                    type: { formatting: { labelDisplayUnits: true } },\n                                    suppressFormatPainterCopy: true\n                                },\n                                labelPrecision: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),\n                                    placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),\n                                    type: { numeric: true },\n                                    suppressFormatPainterCopy: true\n                                },\n                                showAll: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_ShowAll'),\n                                    type: { bool: true }\n                                },\n                                fontSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { formatting: { fontSize: true } }\n                                },\n                            },\n                        },\n                        legend: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),\n                                    type: { formatting: { legendPosition: true } }\n                                },\n                                showTitle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),\n                                    type: { bool: true }\n                                },\n                                titleText: {\n                                    displayName: 'Title text',\n                                    type: { text: true }\n                                },\n                                fontSize: {\n                                    displayName: 'Text size',\n                                    type: { formatting: { fontSize: true } }\n                                },\n                            }\n                        },\n                        categoryAxis: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),\n                                    type: { formatting: { yAxisPosition: true } }\n                                },\n                                axisScale: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),\n                                    type: { formatting: { axisScale: true } }\n                                },\n                                /*start: {\n                                    displayName: data.createDisplayNameGetter('Visual_Axis_Start'),\n                                    type: { numeric: true }\n                                },\n                                end: {\n                                    displayName: data.createDisplayNameGetter('Visual_Axis_End'),\n                                    type: { numeric: true }\n                                },*/\n                                axisType: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),\n                                    type: { formatting: { axisType: true } }\n                                },\n                                showAxisTitle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),\n                                    type: { bool: true }\n                                },\n                                axisStyle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),\n                                    type: { formatting: { axisStyle: true } }\n                                },\n                                labelColor: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { formatting: { fontSize: true } }\n                                },\n                            }\n                        },\n                        valueAxis: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),\n                                    type: { formatting: { yAxisPosition: true } }\n                                },\n                                axisScale: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),\n                                    type: { formatting: { axisScale: true } }\n                                },\n                                /*start: {\n                                    displayName: data.createDisplayNameGetter('Visual_Axis_Start'),\n                                    type: { numeric: true }\n                                },\n                                end: {\n                                    displayName: data.createDisplayNameGetter('Visual_Axis_End'),\n                                    type: { numeric: true }\n                                },*/\n                                intersection: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Intersection'),\n                                    type: { numeric: true }\n                                },\n                                showAxisTitle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),\n                                    type: { bool: true }\n                                },\n                                axisStyle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),\n                                    type: { formatting: { axisStyle: true } }\n                                },\n                                labelColor: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { formatting: { fontSize: true } }\n                                },\n                            }\n                        },\n                        dataPoint: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),\n                            properties: {\n                                defaultColor: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                showAllDataPoints: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\n                                    type: { bool: true }\n                                },\n                                fill: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fillRule: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),\n                                    type: { fillRule: {} },\n                                    rule: {\n                                        inputRole: 'Gradient',\n                                        output: {\n                                            property: 'fill',\n                                            selector: ['Category'],\n                                        },\n                                    },\n                                }\n                            }\n                        },\n                    },\n                    dataViewMappings: [{\n                            conditions: [\n                                { 'Category': { min: 0, max: 1 }, 'Series': { min: 0, max: 1 }, 'Y': { min: 0, max: 1 }, 'Width': { min: 0, max: 1 } },\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Category' },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: {\n                                    group: {\n                                        by: 'Series',\n                                        select: [{ for: { in: 'Y' } }, { for: { in: 'Width' } }],\n                                        dataReductionAlgorithm: { top: {} }\n                                    }\n                                },\n                                rowCount: { preferred: { min: 1, max: 1 }, supported: { min: 0 } }\n                            },\n                        }],\n                    supportsHighlight: true,\n                    sorting: {\n                        default: {},\n                    },\n                    drilldown: {\n                        roles: ['Category']\n                    },\n                };\n                MekkoChart.properties = {\n                    general: {\n                        formatString: {\n                            objectName: \"general\",\n                            propertyName: \"formatString\"\n                        }\n                    },\n                    columnBorder: {\n                        show: { objectName: 'columnBorder', propertyName: 'show', },\n                        color: { objectName: 'columnBorder', propertyName: 'color' },\n                        width: { objectName: 'columnBorder', propertyName: 'width' },\n                    },\n                };\n                MekkoChart.DefaultSettings = {\n                    columnBorder: {\n                        show: true,\n                        color: '#fff',\n                        width: 2,\n                        maxWidth: 5,\n                    },\n                    labelSettings: {\n                        maxPrecision: 4,\n                        minPrecision: 0,\n                    }\n                };\n                MekkoChart.MinOrdinalRectThickness = 20;\n                MekkoChart.MinScalarRectThickness = 2;\n                MekkoChart.OuterPaddingRatio = 0.4;\n                MekkoChart.InnerPaddingRatio = 0.2;\n                MekkoChart.TickLabelPadding = 2;\n                MekkoChart.ClassName = 'cartesianChart';\n                MekkoChart.AxisGraphicsContextClassName = 'axisGraphicsContext';\n                MekkoChart.MaxMarginFactor = 0.25;\n                MekkoChart.MinBottomMargin = 50;\n                MekkoChart.LeftPadding = 10;\n                MekkoChart.RightPadding = 10;\n                MekkoChart.BottomPadding = 16;\n                MekkoChart.YAxisLabelPadding = 20;\n                MekkoChart.XAxisLabelPadding = 20;\n                MekkoChart.TickPaddingY = 10;\n                MekkoChart.TickPaddingRotatedX = 5;\n                MekkoChart.FontSize = 11;\n                MekkoChart.MaxNumberOfLabels = 100;\n                MekkoChart.MinWidth = 100;\n                MekkoChart.MinHeight = 100;\n                MekkoChart.ScrollBarWidth = 10;\n                return MekkoChart;\n            }());\n            samples.MekkoChart = MekkoChart;\n            function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, y2AxisTextProperties, enableOverflowCheck, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {\n                var XLabelMaxAllowedOverflow = 35;\n                debug.assertValue(axes, 'axes');\n                var xAxisProperties = axes.x;\n                var y1AxisProperties = axes.y1;\n                var y2AxisProperties = axes.y2;\n                debug.assertValue(viewport, 'viewport');\n                debug.assertValue(textWidthMeasurer, 'textWidthMeasurer');\n                debug.assertValue(textHeightMeasurer, 'textHeightMeasurer');\n                debug.assertValue(xAxisProperties, 'xAxis');\n                debug.assertValue(y1AxisProperties, 'yAxis');\n                var xLabels = xAxisProperties.values;\n                var y1Labels = y1AxisProperties.values;\n                var leftOverflow = 0;\n                var rightOverflow = 0;\n                var maxWidthY1 = 0;\n                var maxWidthY2 = 0;\n                var xMax = 0; // bottom margin\n                var ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0;\n                var scaleIsOrdinal = visuals.AxisHelper.isOrdinalScale(xAxisProperties.scale);\n                var xLabelOuterPadding = 0;\n                if (xAxisProperties.outerPadding !== undefined) {\n                    xLabelOuterPadding = xAxisProperties.outerPadding;\n                }\n                else if (xAxisProperties.xLabelMaxWidth !== undefined) {\n                    xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);\n                }\n                if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(viewport.width) !== 0\n                    || visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(viewport.height) !== 0) {\n                    var rotation;\n                    if (scrollbarVisible)\n                        rotation = visuals.AxisHelper.LabelLayoutStrategy.DefaultRotationWithScrollbar;\n                    else\n                        rotation = visuals.AxisHelper.LabelLayoutStrategy.DefaultRotation;\n                    if (renderY1Axis) {\n                        for (var i = 0, len = y1Labels.length; i < len; i++) {\n                            y1AxisTextProperties.text = y1Labels[i];\n                            maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(y1AxisTextProperties));\n                        }\n                    }\n                    if (y2AxisProperties && renderY2Axis) {\n                        var y2Labels = y2AxisProperties.values;\n                        for (var i = 0, len = y2Labels.length; i < len; i++) {\n                            y2AxisTextProperties.text = y2Labels[i];\n                            maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(y2AxisTextProperties));\n                        }\n                    }\n                    var textHeight = textHeightMeasurer(xAxisTextProperties);\n                    var maxNumLines = Math.floor(bottomMarginLimit / textHeight);\n                    var xScale = xAxisProperties.scale;\n                    var xDomain = xScale.domain();\n                    if (renderXAxis && xLabels.length > 0) {\n                        for (var i = 0, len = xLabels.length; i < len; i++) {\n                            // find the max height of the x-labels, perhaps rotated or wrapped\n                            var height;\n                            xAxisTextProperties.text = xLabels[i];\n                            var width = textWidthMeasurer(xAxisTextProperties);\n                            if (xAxisProperties.willLabelsWordBreak) {\n                                // Split label and count rows\n                                var wordBreaks = jsCommon.WordBreaker.splitByWidth(xAxisTextProperties.text, xAxisTextProperties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);\n                                height = wordBreaks.length * textHeight;\n                                // word wrapping will truncate at xLabelMaxWidth\n                                width = xAxisProperties.xLabelMaxWidth;\n                            }\n                            else if (!xAxisProperties.willLabelsFit && scaleIsOrdinal) {\n                                height = width * rotation.sine;\n                                width = width * rotation.cosine;\n                            }\n                            else {\n                                height = textHeight;\n                            }\n                            // calculate left and right overflow due to wide X labels\n                            // (Note: no right overflow when rotated)\n                            if (i === 0) {\n                                if (scaleIsOrdinal) {\n                                    if (!xAxisProperties.willLabelsFit /*rotated text*/)\n                                        leftOverflow = width - ordinalLabelOffset - xLabelOuterPadding;\n                                    else\n                                        leftOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;\n                                    leftOverflow = Math.max(leftOverflow, 0);\n                                }\n                                else if (xDomain.length > 1) {\n                                    // Scalar - do some math\n                                    var xPos = xScale(xDomain[0]);\n                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice\n                                    leftOverflow = (width / 2) - xPos;\n                                    leftOverflow = Math.max(leftOverflow, 0);\n                                }\n                            }\n                            else if (i === len - 1) {\n                                if (scaleIsOrdinal) {\n                                    // if we are rotating text (!willLabelsFit) there won't be any right overflow\n                                    if (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) {\n                                        // assume this label is placed near the edge\n                                        rightOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;\n                                        rightOverflow = Math.max(rightOverflow, 0);\n                                    }\n                                }\n                                else if (xDomain.length > 1) {\n                                    // Scalar - do some math\n                                    var xPos = xScale(xDomain[1]);\n                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice\n                                    rightOverflow = (width / 2) - (viewport.width - xPos);\n                                    rightOverflow = Math.max(rightOverflow, 0);\n                                }\n                            }\n                            xMax = Math.max(xMax, height);\n                        }\n                        // trim any actual overflow to the limit\n                        leftOverflow = enableOverflowCheck ? Math.min(leftOverflow, XLabelMaxAllowedOverflow) : 0;\n                        rightOverflow = enableOverflowCheck ? Math.min(rightOverflow, XLabelMaxAllowedOverflow) : 0;\n                    }\n                }\n                var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);\n                if (showOnRight) {\n                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit);\n                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit);\n                }\n                else {\n                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit);\n                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit);\n                }\n                return {\n                    xMax: Math.ceil(bottomMargin),\n                    yLeft: Math.ceil(leftMargin),\n                    yRight: Math.ceil(rightMargin),\n                };\n            }\n            function getLayerData(dataViews, currentIdx, totalLayers) {\n                if (totalLayers > 1) {\n                    if (dataViews && dataViews.length > currentIdx)\n                        return [dataViews[currentIdx]];\n                    return [];\n                }\n                return dataViews;\n            }\n            /**\n             * Returns a boolean, that indicates if y axis title should be displayed.\n             * @return True if y axis title should be displayed,\n             * otherwise false.\n             */\n            function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {\n                return ((layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties['showAxisTitle']) ||\n                    (layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties['secShowAxisTitle']));\n            }\n            /**\n             * Computes the Cartesian Chart axes from the set of layers.\n             */\n            function calculateAxes(layers, viewport, margin, categoryAxisProperties, valueAxisProperties, scrollbarVisible, existingAxisProperties) {\n                debug.assertValue(layers, 'layers');\n                var visualOptions = {\n                    viewport: viewport,\n                    margin: margin,\n                    forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],\n                    forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,\n                    showCategoryAxisLabel: false,\n                    showValueAxisLabel: false,\n                    categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? categoryAxisProperties['axisScale'] : visuals.axisScale.linear,\n                    valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? valueAxisProperties['axisScale'] : visuals.axisScale.linear,\n                    trimOrdinalDataOnOverflow: false\n                };\n                var yAxisWillMerge = false;\n                if (valueAxisProperties) {\n                    visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);\n                }\n                var result;\n                for (var layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {\n                    var currentlayer = layers[layerNumber];\n                    visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']); //here\n                    //visualOptions.showBorder = (!!categoryAxisProperties && !!categoryAxisProperties['showBorder']);//here\n                    visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);\n                    var axes = currentlayer.calculateAxesProperties(visualOptions);\n                    if (layerNumber === 0) {\n                        result = {\n                            x: axes[0],\n                            y1: axes[1]\n                        };\n                    }\n                    result.x.willLabelsFit = false;\n                    result.x.willLabelsWordBreak = false;\n                }\n                return result;\n            }\n            function createLayers(type, objects, interactivityService, animator, isScrollable) {\n                if (isScrollable === void 0) { isScrollable = true; }\n                var layers = [];\n                var cartesianOptions = {\n                    isScrollable: isScrollable,\n                    animator: animator,\n                    interactivityService: interactivityService\n                };\n                layers.push(createMekkoChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions));\n                return layers;\n            }\n            samples.createLayers = createLayers;\n            function createMekkoChartLayer(type, defaultOptions) {\n                var options = {\n                    animator: defaultOptions.animator,\n                    interactivityService: defaultOptions.interactivityService,\n                    isScrollable: defaultOptions.isScrollable,\n                    chartType: type\n                };\n                return new MekkoColumnChart(options);\n            }\n            var EnumExtensions = jsCommon.EnumExtensions;\n            var ArrayExtensions = jsCommon.ArrayExtensions;\n            var flagBar = 1 << 1;\n            //var flagColumn: number = 1 << 2;\n            var flagStacked = 1 << 4;\n            var RoleNames = {\n                category: 'Category',\n                series: 'Series',\n                y: 'Y',\n                width: 'Width'\n            };\n            var MekkoColumnChart = (function () {\n                function MekkoColumnChart(options) {\n                    debug.assertValue(options, 'options');\n                    var chartType = options.chartType;\n                    debug.assertValue(chartType, 'chartType');\n                    this.chartType = chartType;\n                    this.categoryAxisType = null;\n                    this.animator = options.animator;\n                    this.isScrollable = options.isScrollable;\n                    this.interactivityService = options.interactivityService;\n                }\n                MekkoColumnChart.prototype.init = function (options) {\n                    this.svg = options.svg;\n                    this.unclippedGraphicsContext = this.svg.append('g').classed('columnChartUnclippedGraphicsContext', true);\n                    this.mainGraphicsContext = this.unclippedGraphicsContext.append('svg').classed('columnChartMainGraphicsContext', true);\n                    this.labelGraphicsContext = this.svg.append('g').classed(NewDataLabelUtils.labelGraphicsContextClass.class, true);\n                    this.style = options.style;\n                    this.currentViewport = options.viewport;\n                    this.hostService = options.host;\n                    this.interactivity = options.interactivity;\n                    this.colors = this.style.colorPalette.dataColors;\n                    this.cartesianVisualHost = options.cartesianHost;\n                    this.options = options;\n                    this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);\n                    var element = this.element = options.element;\n                    element.addClass(MekkoColumnChart.ColumnChartClassName);\n                    this.columnChart = new MekkoColumnChartStrategy();\n                };\n                MekkoColumnChart.prototype.getCategoryLayout = function (numCategoryValues, options) {\n                    var availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right);\n                    var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;\n                    var categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);\n                    var isScalar = this.data ? this.data.scalarCategoryAxis : false;\n                    var domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);\n                    return visuals.CartesianChart.getLayout(this.data, {\n                        availableWidth: availableWidth,\n                        categoryCount: numCategoryValues,\n                        domain: domain,\n                        isScalar: isScalar,\n                        isScrollable: this.isScrollable,\n                        trimOrdinalDataOnOverflow: false\n                    });\n                };\n                MekkoColumnChart.getBorderWidth = function (border) {\n                    if (!border ||\n                        !border.show ||\n                        !border.width) {\n                        return 0;\n                    }\n                    var width = border.width;\n                    if (width < 0) {\n                        return 0;\n                    }\n                    if (width > border.maxWidth) {\n                        return border.maxWidth;\n                    }\n                    return width;\n                };\n                MekkoColumnChart.getBorderColor = function (border) {\n                    if (!border) {\n                        return MekkoChart.DefaultSettings.columnBorder.color;\n                    }\n                    return border.color;\n                };\n                MekkoColumnChart.converter = function (dataView, colors, is100PercentStacked, isScalar, supportsOverflow, dataViewMetadata, chartType) {\n                    if (is100PercentStacked === void 0) { is100PercentStacked = false; }\n                    if (isScalar === void 0) { isScalar = false; }\n                    if (supportsOverflow === void 0) { supportsOverflow = false; }\n                    if (dataViewMetadata === void 0) { dataViewMetadata = null; }\n                    debug.assertValue(dataView, 'dataView');\n                    debug.assertValue(colors, 'colors');\n                    var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);\n                    var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);\n                    isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);\n                    dataView = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);\n                    var converterStrategy = new ColumnChartConverterHelper(dataView);\n                    var categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, visuals.columnChartProps.general.formatString);\n                    var categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;\n                    //labelFormatString: string = dataView.values && dataView.values[0] ? valueFormatter.getFormatString(dataView.values[0].source, columnChartProps.general.formatString) : undefined;\n                    var borderSettings = MekkoChart.DefaultSettings.columnBorder;\n                    var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(true);\n                    var defaultDataPointColor = undefined;\n                    var showAllDataPoints = undefined;\n                    if (dataViewMetadata && dataViewMetadata.objects) {\n                        var objects = dataViewMetadata.objects;\n                        defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);\n                        showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);\n                        labelSettings = MekkoChart.parseLabelSettings(objects);\n                        borderSettings = MekkoChart.parseBorderSettings(objects);\n                    }\n                    // Allocate colors\n                    var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor);\n                    var legend = legendAndSeriesInfo.legend.dataPoints;\n                    var seriesSources = legendAndSeriesInfo.seriesSources;\n                    // Determine data points\n                    var result = MekkoColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata);\n                    var columnSeries = result.series;\n                    var valuesMetadata = [];\n                    for (var j = 0, jlen = legend.length; j < jlen; j++) {\n                        valuesMetadata.push(seriesSources[j]);\n                    }\n                    var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);\n                    return {\n                        categories: categories,\n                        categoriesWidth: result.categoriesWidth,\n                        categoryFormatter: categoryFormatter,\n                        series: columnSeries,\n                        valuesMetadata: valuesMetadata,\n                        legendData: legendAndSeriesInfo.legend,\n                        hasHighlights: result.hasHighlights,\n                        categoryMetadata: categoryMetadata,\n                        scalarCategoryAxis: isScalar,\n                        borderSettings: borderSettings,\n                        labelSettings: labelSettings,\n                        axesLabels: { x: labels.xAxisLabel, y: labels.yAxisLabel },\n                        hasDynamicSeries: result.hasDynamicSeries,\n                        defaultDataPointColor: defaultDataPointColor,\n                        showAllDataPoints: showAllDataPoints,\n                        isMultiMeasure: false,\n                    };\n                };\n                MekkoColumnChart.getStackedMultiplier = function (rawValues, rowIdx, seriesCount, categoryCount) {\n                    var pos = 0, neg = 0;\n                    for (var i = 0; i < seriesCount; i++) {\n                        var value = rawValues[i][rowIdx];\n                        value = visuals.AxisHelper.normalizeNonFiniteNumber(value);\n                        if (value > 0) {\n                            pos += value;\n                        }\n                        else if (value < 0) {\n                            neg -= value;\n                        }\n                    }\n                    var absTotal = pos + neg;\n                    return {\n                        pos: pos ? (pos / absTotal) / pos : 1,\n                        neg: neg ? (neg / absTotal) / neg : 1,\n                    };\n                };\n                MekkoColumnChart.createDataPoints = function (dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, supportsOverflow, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata) {\n                    if (is100PercentStacked === void 0) { is100PercentStacked = false; }\n                    if (isScalar === void 0) { isScalar = false; }\n                    if (supportsOverflow === void 0) { supportsOverflow = false; }\n                    var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;\n                    var categoryCount = categories.length;\n                    var seriesCount = legend.length;\n                    var columnSeries = [];\n                    if (seriesCount < 1 || categoryCount < 1 || categories[0] === null) {\n                        return { series: columnSeries,\n                            hasHighlights: false,\n                            hasDynamicSeries: false,\n                            categoriesWidth: [],\n                        };\n                    }\n                    var dvCategories = dataViewCat.categories;\n                    categoryMetadata = (dvCategories && dvCategories.length > 0)\n                        ? dvCategories[0].source\n                        : null;\n                    var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);\n                    var isDateTime = visuals.AxisHelper.isDateTime(categoryType);\n                    var baseValuesPos = [], baseValuesNeg = [];\n                    var rawValues = [];\n                    var rawHighlightValues = [];\n                    var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);\n                    var widthColumns = [];\n                    var widthIndex = -1;\n                    var seriesIndex = 0;\n                    var highlightsOverflow = false; // Overflow means the highlight larger than value or the signs being different\n                    var hasHighlights = converterStrategy.hasHighlightValues(0);\n                    for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {\n                        if (dataViewCat.values[seriesIndex].source.roles &&\n                            dataViewCat.values[seriesIndex].source.roles[RoleNames.width] &&\n                            !dataViewCat.values[seriesIndex].source.roles[RoleNames.y]) {\n                            widthIndex = seriesIndex;\n                            var widthValues = dataViewCat.values[seriesIndex].values;\n                            for (var i = 0, valuesLen = widthValues.length; i < valuesLen; i++) {\n                                widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);\n                            }\n                            continue;\n                        }\n                        var seriesValues = [];\n                        var seriesHighlightValues = [];\n                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {\n                            var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);\n                            seriesValues[categoryIndex] = value;\n                            if (hasHighlights) {\n                                var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);\n                                seriesHighlightValues[categoryIndex] = highlightValue;\n                                // There are two cases where we don't use overflow logic; if all are false, use overflow logic appropriate for the chart.\n                                if (!((value >= 0 && highlightValue >= 0 && value >= highlightValue) ||\n                                    (value <= 0 && highlightValue <= 0 && value <= highlightValue))) {\n                                    highlightsOverflow = true;\n                                }\n                            }\n                        }\n                        rawValues.push(seriesValues);\n                        if (hasHighlights) {\n                            rawHighlightValues.push(seriesHighlightValues);\n                        }\n                    }\n                    //console.log(dataViewCat);\n                    if (highlightsOverflow && !supportsOverflow) {\n                        highlightsOverflow = false;\n                        hasHighlights = false;\n                        rawValues = rawHighlightValues;\n                    }\n                    if (widthColumns.length < 1) {\n                        for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {\n                            if (dataViewCat.values[seriesIndex].source.roles &&\n                                dataViewCat.values[seriesIndex].source.roles[RoleNames.width]) {\n                                widthIndex = seriesIndex;\n                                var widthValues = dataViewCat.values[seriesIndex].values;\n                                for (var i = 0, valuesLen = widthValues.length; i < valuesLen; i++) {\n                                    widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);\n                                }\n                                continue;\n                            }\n                        }\n                    }\n                    if (widthColumns.length < 1) {\n                        for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {\n                            widthColumns.push(1);\n                        }\n                    }\n                    var totalSum = d3.sum(widthColumns);\n                    var linearScale = d3.scale.linear()\n                        .domain([0, totalSum])\n                        .range([0, 1]);\n                    var columnStartX = [0];\n                    var columnWidth = [];\n                    for (seriesIndex = 0; seriesIndex < (categoryCount - 1); seriesIndex++) {\n                        var stepWidth = columnStartX[columnStartX.length - 1] + (widthColumns[seriesIndex] || 0);\n                        columnStartX.push(stepWidth);\n                    }\n                    for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {\n                        columnStartX[seriesIndex] = linearScale(columnStartX[seriesIndex]);\n                        columnWidth[seriesIndex] = linearScale(widthColumns[seriesIndex]);\n                    }\n                    var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;\n                    for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\n                        var seriesDataPoints = [], legendItem = legend[seriesIndex], seriesLabelSettings;\n                        if (!hasDynamicSeries) {\n                            var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;\n                            var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;\n                            if (labelObjects) {\n                                seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings);\n                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);\n                            }\n                        }\n                        var series = {\n                            displayName: legendItem.label,\n                            key: 'series' + seriesIndex,\n                            index: seriesIndex,\n                            data: seriesDataPoints,\n                            identity: legendItem.identity,\n                            color: legendItem.color,\n                            labelSettings: seriesLabelSettings,\n                        };\n                        if (seriesCount > 1) {\n                            dataPointObjects = seriesObjectsList[seriesIndex];\n                        }\n                        var metadata = dataViewCat.values[seriesIndex].source;\n                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {\n                            if (seriesIndex === 0) {\n                                baseValuesPos.push(0);\n                                baseValuesNeg.push(0);\n                            }\n                            var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);\n                            if (value == null) {\n                                // Optimization: Ignore null dataPoints from the fabricated category/series combination in the self cross-join.\n                                // However, we must retain the first series because it is used to compute things like axis scales, and value lookups.\n                                if (seriesIndex > 0) {\n                                    continue;\n                                }\n                            }\n                            var originalValue = value;\n                            var categoryValue = categories[categoryIndex];\n                            if (isDateTime && categoryValue) {\n                                categoryValue = categoryValue.getTime();\n                            }\n                            if (isScalar && (categoryValue == null || isNaN(categoryValue))) {\n                                continue;\n                            }\n                            var multipliers;\n                            if (is100PercentStacked) {\n                                //multipliers = StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy);\n                                multipliers = MekkoColumnChart.getStackedMultiplier(rawValues, categoryIndex, seriesCount, categoryCount);\n                            }\n                            var unadjustedValue = value, isNegative = value < 0;\n                            if (multipliers) {\n                                if (isNegative) {\n                                    value *= multipliers.neg;\n                                }\n                                else {\n                                    value *= multipliers.pos;\n                                }\n                            }\n                            var valueAbsolute = Math.abs(value);\n                            var position;\n                            if (isNegative) {\n                                position = baseValuesNeg[categoryIndex];\n                                if (!isNaN(valueAbsolute)) {\n                                    baseValuesNeg[categoryIndex] -= valueAbsolute;\n                                }\n                            }\n                            else {\n                                if (!isNaN(valueAbsolute)) {\n                                    baseValuesPos[categoryIndex] += valueAbsolute;\n                                }\n                                position = baseValuesPos[categoryIndex];\n                            }\n                            var columnGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex] : null;\n                            var category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null;\n                            var identity = visuals.SelectionIdBuilder.builder()\n                                .withCategory(category, categoryIndex)\n                                .withSeries(dataViewCat.values, columnGroup)\n                                .withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex))\n                                .createSelectionId();\n                            var rawCategoryValue = categories[categoryIndex];\n                            var color = MekkoColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);\n                            var seriesData = [];\n                            if (columnGroup) {\n                                var seriesValueColumn = {\n                                    values: [],\n                                    source: dataViewCat.values.source,\n                                };\n                                seriesData.push({\n                                    value: columnGroup.name,\n                                    metadata: seriesValueColumn,\n                                });\n                                for (var columnIndex = 0; columnIndex < columnGroup.values.length; columnIndex++) {\n                                    var columnValues = columnGroup.values[columnIndex];\n                                    seriesData.push({\n                                        value: columnValues.values[categoryIndex],\n                                        metadata: columnValues,\n                                    });\n                                }\n                            }\n                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null /*dataViewCat*/, rawCategoryValue, originalValue, [category], seriesData, null /*seriesIndex*/, categoryIndex);\n                            var dataPointLabelSettings = (series && series.labelSettings) ? series.labelSettings : defaultLabelSettings;\n                            var labelColor = dataPointLabelSettings.labelColor;\n                            var lastValue = undefined;\n                            //Stacked column/bar label color is white by default (except last series)\n                            if ((EnumExtensions.hasFlag(chartType, flagStacked))) {\n                                lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);\n                                labelColor = (lastValue || (seriesIndex === seriesCount - 1 && !isNegative)) ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor;\n                            }\n                            value = columnWidth[categoryIndex];\n                            var originalPosition = columnStartX[categoryIndex];\n                            var dataPoint = {\n                                categoryValue: categoryValue,\n                                value: value,\n                                position: position,\n                                valueAbsolute: valueAbsolute,\n                                valueOriginal: unadjustedValue,\n                                seriesIndex: seriesIndex,\n                                labelSettings: dataPointLabelSettings,\n                                categoryIndex: categoryIndex,\n                                color: color,\n                                selected: false,\n                                originalValue: value,\n                                originalPosition: originalPosition,\n                                originalValueAbsolute: valueAbsolute,\n                                identity: identity,\n                                key: identity.getKey(),\n                                tooltipInfo: tooltipInfo,\n                                labelFill: labelColor,\n                                labelFormatString: metadata.format,\n                                lastSeries: lastValue,\n                                chartType: chartType,\n                            };\n                            seriesDataPoints.push(dataPoint);\n                            if (hasHighlights) {\n                                var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex];\n                                var unadjustedValueHighlight = valueHighlight;\n                                var highlightedTooltip = true;\n                                if (valueHighlight === null) {\n                                    valueHighlight = 0;\n                                    highlightedTooltip = false;\n                                }\n                                if (is100PercentStacked) {\n                                    valueHighlight *= multipliers.pos;\n                                }\n                                var absoluteValueHighlight = Math.abs(valueHighlight);\n                                var highlightPosition = position;\n                                if (valueHighlight > 0) {\n                                    highlightPosition -= valueAbsolute - absoluteValueHighlight;\n                                }\n                                else if (valueHighlight === 0 && value > 0) {\n                                    highlightPosition -= valueAbsolute;\n                                }\n                                var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);\n                                var rawCategoryValue = categories[categoryIndex];\n                                //var highlightedValue: number = highlightedTooltip ? valueHighlight : undefined;\n                                //var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue, originalValue, null, null, seriesIndex, categoryIndex, highlightedValue);\n                                if (highlightedTooltip) {\n                                    // Override non highlighted data point\n                                    dataPoint.tooltipInfo = tooltipInfo;\n                                }\n                                var highlightDataPoint = {\n                                    categoryValue: categoryValue,\n                                    value: value,\n                                    position: highlightPosition,\n                                    valueAbsolute: absoluteValueHighlight,\n                                    valueOriginal: unadjustedValueHighlight,\n                                    seriesIndex: seriesIndex,\n                                    labelSettings: dataPointLabelSettings,\n                                    categoryIndex: categoryIndex,\n                                    color: color,\n                                    selected: false,\n                                    highlight: true,\n                                    originalValue: value,\n                                    originalPosition: originalPosition,\n                                    originalValueAbsolute: valueAbsolute,\n                                    drawThinner: highlightsOverflow,\n                                    identity: highlightIdentity,\n                                    key: highlightIdentity.getKey(),\n                                    tooltipInfo: tooltipInfo,\n                                    labelFormatString: metadata.format,\n                                    labelFill: labelColor,\n                                    lastSeries: lastValue,\n                                    chartType: chartType,\n                                };\n                                seriesDataPoints.push(highlightDataPoint);\n                            }\n                        }\n                        columnSeries.push(series);\n                    }\n                    return {\n                        series: columnSeries,\n                        categoriesWidth: columnWidth,\n                        hasHighlights: hasHighlights,\n                        hasDynamicSeries: hasDynamicSeries,\n                    };\n                };\n                MekkoColumnChart.getDataPointColor = function (legendItem, categoryIndex, dataPointObjects) {\n                    debug.assertValue(legendItem, 'legendItem');\n                    debug.assertValue(categoryIndex, 'categoryIndex');\n                    debug.assertAnyValue(dataPointObjects, 'dataPointObjects');\n                    if (dataPointObjects) {\n                        var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);\n                        if (colorOverride) {\n                            return colorOverride;\n                        }\n                    }\n                    return legendItem.color;\n                };\n                MekkoColumnChart.getStackedLabelColor = function (isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {\n                    var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);\n                    //run for the next series and check if current series is last\n                    for (var i = seriesIndex + 1; i < seriesCount; i++) {\n                        var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);\n                        if ((nextValues !== null) && (((!isNegative || (isNegative && seriesIndex === 0)) && nextValues > 0) || (isNegative && seriesIndex !== 0))) {\n                            lastValue = false;\n                            break;\n                        }\n                    }\n                    return lastValue;\n                };\n                MekkoColumnChart.sliceSeries = function (series, endIndex, startIndex) {\n                    if (startIndex === void 0) { startIndex = 0; }\n                    var newSeries = [];\n                    if (series && series.length > 0) {\n                        for (var i = 0, len = series.length; i < len; i++) {\n                            var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);\n                            iNewSeries.data = series[i].data.filter(function (d) { return d.categoryIndex >= startIndex && d.categoryIndex < endIndex; });\n                        }\n                    }\n                    return newSeries;\n                };\n                MekkoColumnChart.getInteractiveColumnChartDomElement = function (element) {\n                    return element.children(\"svg\").get(0);\n                };\n                MekkoColumnChart.prototype.getColumnsWidth = function () {\n                    var data = this.data;\n                    if (!data ||\n                        !data.series ||\n                        !data.series[0] ||\n                        !data.series[0].data) {\n                        return [];\n                    }\n                    return data.categoriesWidth;\n                };\n                MekkoColumnChart.prototype.getBorderWidth = function () {\n                    return MekkoColumnChart.getBorderWidth(this.data.borderSettings);\n                };\n                MekkoColumnChart.prototype.setData = function (dataViews) {\n                    debug.assertValue(dataViews, \"dataViews\");\n                    var is100PctStacked = true;\n                    this.data = {\n                        categories: [],\n                        categoriesWidth: [],\n                        categoryFormatter: null,\n                        series: [],\n                        valuesMetadata: [],\n                        legendData: null,\n                        hasHighlights: false,\n                        categoryMetadata: null,\n                        scalarCategoryAxis: false,\n                        borderSettings: null,\n                        labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),\n                        axesLabels: { x: null, y: null },\n                        hasDynamicSeries: false,\n                        defaultDataPointColor: null,\n                        isMultiMeasure: false,\n                    };\n                    if (dataViews.length > 0) {\n                        var dataView = dataViews[0];\n                        if (dataView && dataView.categorical) {\n                            var dataViewCat = this.dataViewCat = dataView.categorical;\n                            /*\n                            var dvCategories = dataViewCat.categories;\n                            var categoryMetadata = (dvCategories && dvCategories.length > 0)\n                                ? dvCategories[0].source\n                                : null;\n                            var categoryType = AxisHelper.getCategoryValueType(categoryMetadata);\n                            */\n                            this.data = MekkoColumnChart.converter(dataViewCat, this.cartesianVisualHost.getSharedColors(), true, //s100PctStacked,\n                            false, //CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, columnChartProps.categoryAxis.axisType, categoryType),\n                            this.supportsOverflow, dataView.metadata, this.chartType);\n                            var series = this.data.series;\n                            for (var i = 0, ilen = series.length; i < ilen; i++) {\n                                var currentSeries = series[i];\n                                if (this.interactivityService) {\n                                    this.interactivityService.applySelectionStateToData(currentSeries.data);\n                                }\n                            }\n                        }\n                    }\n                };\n                MekkoColumnChart.prototype.calculateLegend = function () {\n                    // if we're in interactive mode, return the interactive legend\n                    if (this.interactivity && this.interactivity.isInteractiveLegend) {\n                        return this.createInteractiveMekkoLegendDataPoints(0);\n                    }\n                    var legendData = this.data ? this.data.legendData : null;\n                    var MekkoLegendDataPoints = legendData ? legendData.dataPoints : [];\n                    if (ArrayExtensions.isUndefinedOrEmpty(MekkoLegendDataPoints))\n                        return null;\n                    return legendData;\n                };\n                MekkoColumnChart.prototype.hasLegend = function () {\n                    return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));\n                };\n                MekkoColumnChart.prototype.enumerateObjectInstances = function (enumeration, options) {\n                    switch (options.objectName) {\n                        case 'dataPoint':\n                            if (!visuals.GradientUtils.hasGradientRole(this.dataViewCat))\n                                this.enumerateDataPoints(enumeration);\n                            break;\n                        case 'labels':\n                            this.enumerateDataLabels(enumeration);\n                            break;\n                    }\n                };\n                MekkoColumnChart.prototype.enumerateDataLabels = function (enumeration) {\n                    var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length;\n                    //Draw default settings\n                    visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, false));\n                    if (seriesCount === 0) {\n                        return;\n                    }\n                    //Draw series settings\n                    if (!data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata)) {\n                        for (var i = 0; i < seriesCount; i++) {\n                            var series = data.series[i], labelSettings = (series.labelSettings) ? series.labelSettings : this.data.labelSettings;\n                            //enumeration.pushContainer({ displayName: series.displayName });\n                            visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, true, series));\n                        }\n                    }\n                };\n                MekkoColumnChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings, isSeries, series) {\n                    var is100PctStacked = true;\n                    return {\n                        enumeration: enumeration,\n                        dataLabelsSettings: labelSettings,\n                        show: !isSeries,\n                        displayUnits: is100PctStacked,\n                        precision: true,\n                        selector: series && series.identity ? series.identity.getSelector() : null\n                    };\n                };\n                MekkoColumnChart.prototype.enumerateDataPoints = function (enumeration) {\n                    var data = this.data;\n                    if (!data || !data.series) {\n                        return;\n                    }\n                    var seriesCount = data.series.length;\n                    if (seriesCount === 0) {\n                        return;\n                    }\n                    if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) {\n                        for (var i = 0; i < seriesCount; i++) {\n                            var series = data.series[i];\n                            enumeration.pushInstance({\n                                objectName: 'dataPoint',\n                                displayName: series.displayName,\n                                selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),\n                                properties: {\n                                    fill: { solid: { color: series.color } }\n                                },\n                            });\n                        }\n                    }\n                    else {\n                        // For single-category, single-measure column charts, the user can color the individual bars.\n                        var singleSeriesData = data.series[0].data;\n                        var categoryFormatter = data.categoryFormatter;\n                        // Add default color and show all slices\n                        enumeration.pushInstance({\n                            objectName: 'dataPoint',\n                            selector: null,\n                            properties: {\n                                defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }\n                            }\n                        }).pushInstance({\n                            objectName: 'dataPoint',\n                            selector: null,\n                            properties: {\n                                showAllDataPoints: !!data.showAllDataPoints\n                            }\n                        });\n                        for (var i = 0; i < singleSeriesData.length; i++) {\n                            var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];\n                            enumeration.pushInstance({\n                                objectName: 'dataPoint',\n                                displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,\n                                selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),\n                                properties: {\n                                    fill: { solid: { color: singleSeriesDataPoints.color } }\n                                },\n                            });\n                        }\n                    }\n                };\n                MekkoColumnChart.prototype.calculateAxesProperties = function (options) {\n                    var data = this.data;\n                    this.currentViewport = options.viewport;\n                    var margin = this.margin = options.margin;\n                    var origCatgSize = (data && data.categories) ? data.categories.length : 0;\n                    var chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {\n                        categoryCount: 0,\n                        categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,\n                        outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,\n                        isScalar: false\n                    };\n                    this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null;\n                    this.columnChart.setData(data);\n                    var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);\n                    /* preferredPlotArea would be same as currentViewport width when there is no scrollbar.\n                     In that case we want to calculate the available plot area for the shapes by subtracting the margin from available viewport */\n                    if (preferredPlotArea.width === this.currentViewport.width) {\n                        preferredPlotArea.width -= (margin.left + margin.right);\n                    }\n                    preferredPlotArea.height -= (margin.top + margin.bottom);\n                    var is100Pct = true;\n                    // When the category axis is scrollable the height of the category axis and value axis will be different\n                    // The height of the value axis would be same as viewportHeight\n                    var chartContext = {\n                        height: preferredPlotArea.height,\n                        width: preferredPlotArea.width,\n                        duration: 0,\n                        hostService: this.hostService,\n                        unclippedGraphicsContext: this.unclippedGraphicsContext,\n                        mainGraphicsContext: this.mainGraphicsContext,\n                        labelGraphicsContext: this.labelGraphicsContext,\n                        margin: this.margin,\n                        layout: chartLayout,\n                        animator: this.animator,\n                        interactivityService: this.interactivityService,\n                        viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),\n                        viewportWidth: this.currentViewport.width - (margin.left + margin.right),\n                        is100Pct: is100Pct,\n                        isComboChart: true,\n                    };\n                    this.ApplyInteractivity(chartContext);\n                    this.columnChart.setupVisualProps(chartContext);\n                    var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);\n                    if (isBarChart) {\n                        var temp = options.forcedXDomain;\n                        options.forcedXDomain = options.forcedYDomain;\n                        options.forcedYDomain = temp;\n                    }\n                    this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType);\n                    this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType);\n                    if (options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis) {\n                        this.xAxisProperties.axisLabel = data.axesLabels.x;\n                    }\n                    else {\n                        this.xAxisProperties.axisLabel = null;\n                    }\n                    if (options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis) {\n                        this.yAxisProperties.axisLabel = data.axesLabels.y;\n                    }\n                    else {\n                        this.yAxisProperties.axisLabel = null;\n                    }\n                    return [this.xAxisProperties, this.yAxisProperties];\n                };\n                MekkoColumnChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {\n                    var viewport = {\n                        height: this.currentViewport.height,\n                        width: this.currentViewport.width\n                    };\n                    if (this.isScrollable && !isScalar) {\n                        var preferredWidth = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);\n                        if (EnumExtensions.hasFlag(this.chartType, flagBar)) {\n                            viewport.height = Math.max(preferredWidth, viewport.height);\n                        }\n                        else\n                            viewport.width = Math.max(preferredWidth, viewport.width);\n                    }\n                    return viewport;\n                };\n                MekkoColumnChart.prototype.ApplyInteractivity = function (chartContext) {\n                    var _this = this;\n                    var interactivity = this.interactivity;\n                    if (interactivity) {\n                        if (interactivity.dragDataPoint) {\n                            chartContext.onDragStart = function (datum) {\n                                if (!datum.identity)\n                                    return;\n                                _this.hostService.onDragStart({\n                                    event: d3.event,\n                                    data: {\n                                        data: datum.identity.getSelector()\n                                    }\n                                });\n                            };\n                        }\n                        if (interactivity.isInteractiveLegend) {\n                            var dragMove = function () {\n                                var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]); // get the x and y for the column area itself\n                                var x = mousePoint[0];\n                                var y = mousePoint[1];\n                                var index = _this.columnChart.getClosestColumnIndex(x, y);\n                                _this.selectColumn(index);\n                            };\n                            var ColumnChartSvg = visuals.ColumnChart.getInteractiveColumnChartDomElement(this.element);\n                            //set click interaction on the visual\n                            this.svg.on('click', dragMove);\n                            //set click interaction on the background\n                            d3.select(ColumnChartSvg).on('click', dragMove);\n                            var drag = d3.behavior.drag()\n                                .origin(Object)\n                                .on(\"drag\", dragMove);\n                            //set drag interaction on the visual\n                            this.svg.call(drag);\n                            //set drag interaction on the background\n                            d3.select(ColumnChartSvg).call(drag);\n                        }\n                    }\n                };\n                MekkoColumnChart.prototype.selectColumn = function (indexOfColumnSelected, force) {\n                    if (force === void 0) { force = false; }\n                    if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected)\n                        return; // same column, nothing to do here\n                    var legendData = this.createInteractiveMekkoLegendDataPoints(indexOfColumnSelected);\n                    var MekkoLegendDataPoints = legendData.dataPoints;\n                    this.cartesianVisualHost.updateLegend(legendData);\n                    if (MekkoLegendDataPoints.length > 0) {\n                        this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);\n                    }\n                    this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;\n                };\n                MekkoColumnChart.prototype.createInteractiveMekkoLegendDataPoints = function (columnIndex) {\n                    var data = this.data;\n                    if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) {\n                        return { dataPoints: [] };\n                    }\n                    var formatStringProp = visuals.columnChartProps.general.formatString;\n                    var MekkoLegendDataPoints = [];\n                    var category = data.categories && data.categories[columnIndex];\n                    var allSeries = data.series;\n                    var dataPoints = data.legendData && data.legendData.dataPoints;\n                    var converterStrategy = new ColumnChartConverterHelper(this.dataViewCat);\n                    for (var i = 0, len = allSeries.length; i < len; i++) {\n                        var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex);\n                        var valueMetadata = data.valuesMetadata[i];\n                        var formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);\n                        var dataPointColor;\n                        if (allSeries.length === 1) {\n                            var series = allSeries[0];\n                            dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;\n                        }\n                        else {\n                            dataPointColor = dataPoints.length > i && dataPoints[i].color;\n                        }\n                        MekkoLegendDataPoints.push({\n                            color: dataPointColor,\n                            icon: visuals.LegendIcon.Box,\n                            label: formattedLabel,\n                            category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,\n                            measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),\n                            identity: visuals.SelectionId.createNull(),\n                            selected: false,\n                        });\n                    }\n                    return { dataPoints: MekkoLegendDataPoints };\n                };\n                MekkoColumnChart.prototype.overrideXScale = function (xProperties) {\n                    this.xAxisProperties = xProperties;\n                };\n                MekkoColumnChart.prototype.render = function (suppressAnimations) {\n                    var MekkoColumnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations /* useAnimations */);\n                    var data = this.data;\n                    var margin = this.margin;\n                    var viewport = this.currentViewport;\n                    var height = viewport.height - (margin.top + margin.bottom);\n                    var width = viewport.width - (margin.left + margin.right);\n                    this.mainGraphicsContext\n                        .attr('height', height)\n                        .attr('width', width);\n                    visuals.TooltipManager.addTooltip(MekkoColumnChartDrawInfo.shapesSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });\n                    var allDataPoints = [];\n                    var behaviorOptions = undefined;\n                    if (this.interactivityService) {\n                        for (var i = 0, ilen = data.series.length; i < ilen; i++) {\n                            allDataPoints = allDataPoints.concat(data.series[i].data);\n                        }\n                        behaviorOptions = {\n                            datapoints: allDataPoints,\n                            bars: MekkoColumnChartDrawInfo.shapesSelection,\n                            hasHighlights: data.hasHighlights,\n                            eventGroup: this.mainGraphicsContext,\n                            mainGraphicsContext: this.mainGraphicsContext,\n                            viewport: MekkoColumnChartDrawInfo.viewport,\n                            axisOptions: MekkoColumnChartDrawInfo.axisOptions,\n                            showLabel: data.labelSettings.show\n                        };\n                    }\n                    if (this.interactivity && this.interactivity.isInteractiveLegend) {\n                        if (this.data.series.length > 0) {\n                            this.selectColumn(0, true); // start with the first column\n                        }\n                    }\n                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);\n                    return {\n                        dataPoints: allDataPoints,\n                        behaviorOptions: behaviorOptions,\n                        labelDataPoints: MekkoColumnChartDrawInfo.labelDataPoints,\n                        labelsAreNumeric: true\n                    };\n                };\n                MekkoColumnChart.prototype.onClearSelection = function () {\n                    if (this.interactivityService) {\n                        this.interactivityService.clearSelection();\n                    }\n                };\n                MekkoColumnChart.prototype.getVisualCategoryAxisIsScalar = function () {\n                    return this.data ? this.data.scalarCategoryAxis : false;\n                };\n                MekkoColumnChart.prototype.getSupportedCategoryAxisType = function () {\n                    var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;\n                    var valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);\n                    var isOrdinal = visuals.AxisHelper.isOrdinal(valueType);\n                    return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;\n                };\n                MekkoColumnChart.prototype.setFilteredData = function (startIndex, endIndex) {\n                    var data = powerbi.Prototype.inherit(this.data);\n                    data.series = visuals.ColumnChart.sliceSeries(data.series, endIndex, startIndex);\n                    data.categories = data.categories.slice(startIndex, endIndex);\n                    this.columnChart.setData(data);\n                    return data;\n                };\n                MekkoColumnChart.ColumnChartClassName = 'columnChart';\n                MekkoColumnChart.SeriesClasses = createClassAndSelector(\"series\");\n                MekkoColumnChart.BorderClass = createClassAndSelector(\"mekkoborder\");\n                return MekkoColumnChart;\n            }());\n            samples.MekkoColumnChart = MekkoColumnChart;\n            var ColumnChartConverterHelper = (function () {\n                function ColumnChartConverterHelper(dataView) {\n                    this.dataView = dataView;\n                }\n                ColumnChartConverterHelper.hasRole = function (column, name) {\n                    var roles = column.roles;\n                    return roles && roles[name];\n                };\n                ColumnChartConverterHelper.prototype.getLegend = function (colors, defaultColor) {\n                    var legend = [];\n                    var seriesSources = [];\n                    var seriesObjects = [];\n                    var grouped = false;\n                    var colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor);\n                    var legendTitle = undefined;\n                    if (this.dataView && this.dataView.values) {\n                        var allValues = this.dataView.values;\n                        var valueGroups = allValues.grouped();\n                        var hasDynamicSeries = !!(allValues && allValues.source);\n                        var formatStringProp = visuals.columnChartProps.general.formatString;\n                        for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {\n                            var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values;\n                            for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {\n                                var series = values[valueIndex];\n                                var source = series.source;\n                                // Gradient measures do not create series.\n                                if (ColumnChartConverterHelper.hasRole(source, 'Width') && !ColumnChartConverterHelper.hasRole(source, 'Y')) {\n                                    continue;\n                                }\n                                seriesSources.push(source);\n                                seriesObjects.push(series.objects);\n                                var selectionId = series.identity ?\n                                    visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) :\n                                    visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex));\n                                var label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);\n                                var color = hasDynamicSeries\n                                    ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName)\n                                    : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);\n                                legend.push({\n                                    icon: visuals.LegendIcon.Box,\n                                    color: color,\n                                    label: label,\n                                    identity: selectionId,\n                                    selected: false,\n                                });\n                                if (series.identity && source.groupName !== undefined) {\n                                    grouped = true;\n                                }\n                            }\n                        }\n                        var dvValues = this.dataView.values;\n                        legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : \"\";\n                    }\n                    var legendData = {\n                        title: legendTitle,\n                        dataPoints: legend,\n                        grouped: grouped,\n                    };\n                    return {\n                        legend: legendData,\n                        seriesSources: seriesSources,\n                        seriesObjects: seriesObjects,\n                    };\n                };\n                ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function (series, category) {\n                    return this.dataView.values[series].values[category];\n                };\n                ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function (index) {\n                    return this.dataView.values[index].source.queryName;\n                };\n                ColumnChartConverterHelper.prototype.hasHighlightValues = function (series) {\n                    var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;\n                    return column && !!column.highlights;\n                };\n                ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function (series, category) {\n                    return this.dataView.values[series].highlights[category];\n                };\n                return ColumnChartConverterHelper;\n            }());\n            var MekkoChartBehavior = (function () {\n                function MekkoChartBehavior(behaviors) {\n                    this.behaviors = behaviors;\n                }\n                MekkoChartBehavior.prototype.bindEvents = function (options, selectionHandler) {\n                    var behaviors = this.behaviors;\n                    for (var i = 0, ilen = behaviors.length; i < ilen; i++) {\n                        behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);\n                    }\n                    options.clearCatcher.on('click', function () {\n                        selectionHandler.handleClearSelection();\n                    });\n                };\n                MekkoChartBehavior.prototype.renderSelection = function (hasSelection) {\n                    for (var i = 0; i < this.behaviors.length; i++) {\n                        this.behaviors[i].renderSelection(hasSelection);\n                    }\n                };\n                return MekkoChartBehavior;\n            }());\n            samples.MekkoChartBehavior = MekkoChartBehavior;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var SelectionManager = visuals.utility.SelectionManager;\n            var ValueFormatter = powerbi.visuals.valueFormatter;\n            var SankeyDiagram = (function () {\n                function SankeyDiagram(constructorOptions) {\n                    this.margin = {\n                        top: 10,\n                        right: 10,\n                        bottom: 10,\n                        left: 10\n                    };\n                    this.nodeWidth = 21.5;\n                    this.curvatureOfLinks = 0.5;\n                    if (constructorOptions) {\n                        this.svg = constructorOptions.svg;\n                        this.margin = constructorOptions.margin || this.margin;\n                        this.curvatureOfLinks = constructorOptions.curvatureOfLinks || this.curvatureOfLinks;\n                    }\n                }\n                SankeyDiagram.getProperties = function (capabilities) {\n                    var result = {};\n                    for (var objectKey in capabilities.objects) {\n                        result[objectKey] = {};\n                        for (var propKey in capabilities.objects[objectKey].properties) {\n                            result[objectKey][propKey] = {\n                                objectName: objectKey,\n                                propertyName: propKey\n                            };\n                        }\n                    }\n                    return result;\n                };\n                Object.defineProperty(SankeyDiagram.prototype, \"textProperties\", {\n                    get: function () {\n                        return {\n                            fontFamily: this.root.style(\"font-family\"),\n                            fontSize: jsCommon.PixelConverter.fromPoint(this.dataView ? this.dataView.settings.fontSize : SankeyDiagram.DefaultSettings.fontSize)\n                        };\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                SankeyDiagram.prototype.init = function (visualsInitOptions) {\n                    if (this.svg) {\n                        this.root = this.svg;\n                    }\n                    else {\n                        this.root = d3.select(visualsInitOptions.element.get(0))\n                            .append(\"svg\");\n                    }\n                    this.selectionManager = new SelectionManager({ hostServices: visualsInitOptions.host });\n                    var style = visualsInitOptions.style;\n                    this.colours = style && style.colorPalette\n                        ? style.colorPalette.dataColors\n                        : new visuals.DataColorPalette();\n                    this.root.classed(SankeyDiagram.ClassName, true);\n                    this.main = this.root.append(\"g\");\n                    this.links = this.main\n                        .append(\"g\")\n                        .classed(SankeyDiagram.Links[\"class\"], true);\n                    this.nodes = this.main\n                        .append(\"g\")\n                        .classed(SankeyDiagram.Nodes[\"class\"], true);\n                };\n                SankeyDiagram.prototype.update = function (visualUpdateOptions) {\n                    if (!visualUpdateOptions ||\n                        !visualUpdateOptions.dataViews) {\n                        return;\n                    }\n                    var dataView = visualUpdateOptions.dataViews[0], sankeyDiagramDataView;\n                    this.updateViewport(visualUpdateOptions.viewport);\n                    sankeyDiagramDataView = this.converter(dataView);\n                    this.findNodePosition(sankeyDiagramDataView);\n                    this.dataView = sankeyDiagramDataView;\n                    this.render(sankeyDiagramDataView);\n                };\n                SankeyDiagram.prototype.updateViewport = function (viewport) {\n                    var height, width;\n                    height = this.getPositiveNumber(viewport.height);\n                    width = this.getPositiveNumber(viewport.width);\n                    this.viewport = {\n                        height: this.getPositiveNumber(height - this.margin.top - this.margin.bottom),\n                        width: this.getPositiveNumber(width - this.margin.left - this.margin.right)\n                    };\n                    this.updateElements(height, width);\n                };\n                SankeyDiagram.prototype.getPositiveNumber = function (value) {\n                    return value < 0 || isNaN(value) || value === Infinity || value === -Infinity\n                        ? 0\n                        : value;\n                };\n                SankeyDiagram.prototype.updateElements = function (height, width) {\n                    this.root.attr({\n                        \"height\": height,\n                        \"width\": width\n                    });\n                    this.main.attr(\"transform\", visuals.SVGUtil.translate(this.margin.left, this.margin.top));\n                };\n                SankeyDiagram.prototype.converter = function (dataView) {\n                    var _this = this;\n                    if (!dataView ||\n                        !dataView.categorical ||\n                        !dataView.categorical.categories ||\n                        !dataView.categorical.categories[0] ||\n                        !dataView.categorical.categories[1] ||\n                        !dataView.categorical.categories[0].values ||\n                        !dataView.categorical.categories[1].values) {\n                        return {\n                            nodes: [],\n                            links: [],\n                            settings: {\n                                scale: { x: 1, y: 1 },\n                                colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,\n                                fontSize: SankeyDiagram.DefaultSettings.fontSize\n                            }\n                        };\n                    }\n                    var nodes = [], links = [], dataPoints = [], categories = dataView.categorical.categories[0].values, secondCategories = dataView.categorical.categories[1].values, valuesColumn = dataView.categorical.values && dataView.categorical.values[0], weightValues = valuesColumn && valuesColumn.values && valuesColumn.values.map(function (x) { return x || 0; }) || [], allCategories, valueFormatterForCategories, formatOfWeigth = \"g\", valuesFormatterForWeigth, objects, linksObjects = dataView.categorical.categories[0].objects || [], labelColour, settings, shiftOfColour, identities = [];\n                    if (dataView.categorical.categories[0].identity) {\n                        identities = identities.concat(dataView.categorical.categories[0].identity);\n                    }\n                    if (dataView.categorical.categories[1].identity) {\n                        identities = identities.concat(dataView.categorical.categories[1].identity);\n                    }\n                    objects = this.getObjectsFromDataView(dataView);\n                    labelColour = this.getColour(SankeyDiagram.Properties[\"labels\"][\"fill\"], SankeyDiagram.DefaultSettings.colourOfLabels, objects);\n                    if (valuesColumn && valuesColumn.source) {\n                        formatOfWeigth = ValueFormatter.getFormatString(valuesColumn.source, SankeyDiagram.Properties[\"general\"][\"formatString\"]);\n                    }\n                    dataPoints = categories.map(function (item, index) {\n                        return {\n                            source: item,\n                            destination: secondCategories[index],\n                            weigth: valuesColumn ? Math.max(weightValues[index] || 0, 0) : 1\n                        };\n                    });\n                    allCategories = categories.concat(secondCategories);\n                    valueFormatterForCategories = ValueFormatter.create({\n                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, SankeyDiagram.Properties[\"general\"][\"formatString\"]),\n                        value: allCategories[0],\n                        value2: allCategories[allCategories.length - 1]\n                    });\n                    valuesFormatterForWeigth = ValueFormatter.create({\n                        format: formatOfWeigth,\n                        value: Math.max(d3.max(weightValues) || 1, 1),\n                    });\n                    allCategories.forEach(function (item, index) {\n                        if (!nodes.some(function (node) {\n                            if (item === node.label.name) {\n                                node.selectionIds.push(visuals.SelectionId.createWithId(identities[index]));\n                                return true;\n                            }\n                            return false;\n                        })) {\n                            var formattedValue = valueFormatterForCategories.format(item), label, selectionId, textProperties = {\n                                text: formattedValue,\n                                fontFamily: _this.textProperties.fontFamily,\n                                fontSize: _this.textProperties.fontSize\n                            };\n                            label = {\n                                name: item,\n                                formattedName: valueFormatterForCategories.format(item),\n                                width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),\n                                height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties),\n                                colour: labelColour\n                            };\n                            selectionId = visuals.SelectionId.createWithId(identities[index]);\n                            nodes.push({\n                                label: label,\n                                links: [],\n                                inputWeight: 0,\n                                outputWeight: 0,\n                                width: _this.nodeWidth,\n                                height: 0,\n                                colour: SankeyDiagram.DefaultColourOfNode,\n                                tooltipData: [],\n                                selectionIds: [selectionId]\n                            });\n                        }\n                    });\n                    shiftOfColour = this.colours.getAllColors().length / nodes.length;\n                    nodes.forEach(function (node, index) {\n                        node.colour = _this.colours.getColorByIndex(Math.floor(index * shiftOfColour)).value;\n                    });\n                    dataPoints.forEach(function (dataPoint, index) {\n                        var sourceNode, destinationNode, link, linkColour;\n                        if (dataPoint.source === dataPoint.destination) {\n                            return;\n                        }\n                        nodes.forEach(function (node) {\n                            if (node.label.name === dataPoint.source) {\n                                sourceNode = node;\n                            }\n                            if (node.label.name === dataPoint.destination) {\n                                destinationNode = node;\n                            }\n                        });\n                        linkColour = _this.getColour(SankeyDiagram.Properties[\"links\"][\"fill\"], SankeyDiagram.DefaultColourOfLink, linksObjects[index]);\n                        link = {\n                            source: sourceNode,\n                            destination: destinationNode,\n                            weigth: dataPoint.weigth,\n                            height: dataPoint.weigth,\n                            colour: linkColour,\n                            tooltipData: _this.getTooltipDataForLink(valuesFormatterForWeigth, sourceNode.label.formattedName, destinationNode.label.formattedName, dataPoint.weigth),\n                            selectionId: visuals.SelectionId.createWithId(identities[index])\n                        };\n                        links.push(link);\n                        sourceNode.links.push(link);\n                        destinationNode.links.push(link);\n                        _this.updateValueOfNode(sourceNode);\n                        _this.updateValueOfNode(destinationNode);\n                        sourceNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, sourceNode.label.formattedName, sourceNode.inputWeight ? sourceNode.inputWeight : sourceNode.outputWeight);\n                        destinationNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, destinationNode.label.formattedName, destinationNode.inputWeight ? destinationNode.inputWeight : destinationNode.outputWeight);\n                    });\n                    settings = this.parseSettings(objects);\n                    settings.colourOfLabels = labelColour;\n                    return {\n                        nodes: nodes,\n                        links: links,\n                        settings: settings\n                    };\n                };\n                SankeyDiagram.prototype.getObjectsFromDataView = function (dataView) {\n                    if (!dataView ||\n                        !dataView.metadata ||\n                        !dataView.metadata.columns ||\n                        !dataView.metadata.objects) {\n                        return null;\n                    }\n                    return dataView.metadata.objects;\n                };\n                SankeyDiagram.prototype.getColour = function (properties, defaultColor, objects) {\n                    var colorHelper;\n                    colorHelper = new visuals.ColorHelper(this.colours, properties, defaultColor);\n                    return colorHelper.getColorForMeasure(objects, \"\");\n                };\n                SankeyDiagram.prototype.getTooltipDataForLink = function (valueFormatter, sourceNodeName, destinationNodeName, linkWeight) {\n                    var formattedLinkWeight;\n                    if (valueFormatter && valueFormatter.format) {\n                        formattedLinkWeight = valueFormatter.format(linkWeight);\n                    }\n                    else {\n                        formattedLinkWeight = linkWeight.toString();\n                    }\n                    return [{\n                            displayName: SankeyDiagram.RoleNames.rows,\n                            value: sourceNodeName\n                        }, {\n                            displayName: SankeyDiagram.RoleNames.columns,\n                            value: destinationNodeName\n                        }, {\n                            displayName: SankeyDiagram.RoleNames.values,\n                            value: formattedLinkWeight\n                        }];\n                };\n                SankeyDiagram.prototype.updateValueOfNode = function (node) {\n                    node.inputWeight = node.links.reduce(function (previousValue, currentValue) {\n                        return previousValue + (currentValue.destination === node ? currentValue.weigth : 0);\n                    }, 0);\n                    node.outputWeight = node.links.reduce(function (previousValue, currentValue) {\n                        return previousValue + (currentValue.source === node ? currentValue.weigth : 0);\n                    }, 0);\n                };\n                SankeyDiagram.prototype.getTooltipForNode = function (valueFormatter, nodeName, nodeWeight) {\n                    var formattedNodeWeigth;\n                    if (valueFormatter && valueFormatter.format) {\n                        formattedNodeWeigth = valueFormatter.format(nodeWeight);\n                    }\n                    else {\n                        formattedNodeWeigth = nodeWeight.toString();\n                    }\n                    return [{\n                            displayName: \"Name\",\n                            value: nodeName\n                        }, {\n                            displayName: SankeyDiagram.RoleNames.values,\n                            value: formattedNodeWeigth\n                        }];\n                };\n                SankeyDiagram.prototype.parseSettings = function (objects) {\n                    var isVisibleLabels = false;\n                    isVisibleLabels = powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties[\"labels\"][\"show\"], SankeyDiagram.DefaultSettings.isVisibleLabels);\n                    return {\n                        isVisibleLabels: isVisibleLabels,\n                        scale: {\n                            x: SankeyDiagram.DefaultSettings.scale.x,\n                            y: SankeyDiagram.DefaultSettings.scale.y\n                        },\n                        colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,\n                        fontSize: powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties[\"labels\"][\"fontSize\"], SankeyDiagram.DefaultSettings.fontSize)\n                    };\n                };\n                SankeyDiagram.prototype.findNodePosition = function (sankeyDiagramDataView) {\n                    this.findNodePositionByX(sankeyDiagramDataView);\n                    this.findNodePositionByY(sankeyDiagramDataView);\n                };\n                SankeyDiagram.prototype.findNodePositionByX = function (sankeyDiagramDataView) {\n                    var nodes = sankeyDiagramDataView.nodes, nextNodes = [], previousNodes = [], x = 0, isRecursiveDependencies = false;\n                    while (nodes.length > 0) {\n                        nextNodes = [];\n                        nodes.forEach(function (node) {\n                            node.x = x;\n                            node.links.forEach(function (link) {\n                                if (node === link.source && node !== link.destination) {\n                                    if (nextNodes.every(function (item) {\n                                        return item !== link.destination;\n                                    })) {\n                                        nextNodes.push(link.destination);\n                                    }\n                                }\n                            });\n                        });\n                        isRecursiveDependencies = nextNodes.length === previousNodes.length &&\n                            previousNodes.every(function (previousNode) {\n                                return nextNodes.some(function (nextNode) {\n                                    return nextNode === previousNode;\n                                });\n                            });\n                        if (isRecursiveDependencies) {\n                            previousNodes.forEach(function (element) {\n                                element.x = x;\n                                x++;\n                            });\n                            nodes = [];\n                        }\n                        else {\n                            nodes = nextNodes;\n                            previousNodes = nodes;\n                            x++;\n                        }\n                    }\n                    sankeyDiagramDataView.settings.scale.x = this.getScaleByAxisX(x - 1);\n                    this.scaleByAxisX(sankeyDiagramDataView.nodes, sankeyDiagramDataView.settings.scale.x);\n                };\n                SankeyDiagram.prototype.scaleByAxisX = function (nodes, scale) {\n                    nodes.forEach(function (node) {\n                        node.x *= scale;\n                    });\n                };\n                SankeyDiagram.prototype.getScaleByAxisX = function (numberOfColumns) {\n                    if (numberOfColumns === void 0) { numberOfColumns = 1; }\n                    return this.getPositiveNumber((this.viewport.width - this.nodeWidth) / numberOfColumns);\n                };\n                SankeyDiagram.prototype.findNodePositionByY = function (sankeyDiagramDataView) {\n                    var nodes = sankeyDiagramDataView.nodes, links = sankeyDiagramDataView.links, currentX = 0, index = 0, maxIndex = 0, sumValueOfNodes = 0, maxValueOfNodes = 0;\n                    nodes = nodes.sort(function (firstNode, secondNode) {\n                        return firstNode.x - secondNode.x;\n                    });\n                    nodes.forEach(function (node) {\n                        if (currentX !== node.x) {\n                            index = 0;\n                            currentX = node.x;\n                            sumValueOfNodes = 0;\n                        }\n                        sumValueOfNodes += Math.max(node.inputWeight, node.outputWeight);\n                        if (sumValueOfNodes > maxValueOfNodes) {\n                            maxValueOfNodes = sumValueOfNodes;\n                        }\n                        if (index > maxIndex) {\n                            maxIndex = index;\n                        }\n                        index++;\n                    });\n                    sankeyDiagramDataView.settings.scale.y = this.getScaleByAxisY(maxIndex + 1, maxValueOfNodes);\n                    this.scaleByAxisY(nodes, links, sankeyDiagramDataView.settings.scale.y);\n                };\n                SankeyDiagram.prototype.getScaleByAxisY = function (numberOfRows, sumValueOfNodes) {\n                    return this.getPositiveNumber((this.viewport.height - numberOfRows * SankeyDiagram.NodePadding) / sumValueOfNodes);\n                };\n                SankeyDiagram.prototype.scaleByAxisY = function (nodes, links, scale) {\n                    var shiftByAxisY = 0, currentX = 0, index = 0;\n                    nodes.forEach(function (node) {\n                        if (currentX !== node.x) {\n                            currentX = node.x;\n                            shiftByAxisY = 0;\n                            index = 0;\n                        }\n                        node.height = Math.max(node.inputWeight, node.outputWeight) * scale;\n                        node.y = shiftByAxisY + SankeyDiagram.NodePadding * index;\n                        shiftByAxisY += node.height;\n                        index++;\n                    });\n                    nodes.forEach(function (node) {\n                        node.links = node.links.sort(function (firstLink, secondLink) {\n                            var firstY, secondY;\n                            firstY = firstLink.source === node\n                                ? firstLink.destination.y\n                                : firstLink.source.y;\n                            secondY = secondLink.source === node\n                                ? secondLink.destination.y\n                                : secondLink.source.y;\n                            return firstY - secondY;\n                        });\n                        var shiftByAxisYOfLeftLink = 0, shiftByAxisYOfRightLink = 0;\n                        node.links.forEach(function (link) {\n                            var shiftByAxisY = 0;\n                            link.height = link.weigth * scale;\n                            if (link.source.x < node.x || link.destination.x < node.x) {\n                                shiftByAxisY = shiftByAxisYOfLeftLink;\n                                shiftByAxisYOfLeftLink += link.height;\n                            }\n                            else if (link.source.x > node.x || link.destination.x > node.x) {\n                                shiftByAxisY = shiftByAxisYOfRightLink;\n                                shiftByAxisYOfRightLink += link.height;\n                            }\n                            if (link.source === node) {\n                                link.dySource = shiftByAxisY;\n                            }\n                            else if (link.destination === node) {\n                                link.dyDestination = shiftByAxisY;\n                            }\n                        });\n                    });\n                };\n                SankeyDiagram.prototype.render = function (sankeyDiagramDataView) {\n                    var nodesSelection, linksSelection;\n                    linksSelection = this.renderLinks(sankeyDiagramDataView);\n                    nodesSelection = this.renderNodes(sankeyDiagramDataView);\n                    this.bindSelectionHandler(sankeyDiagramDataView, nodesSelection, linksSelection);\n                };\n                SankeyDiagram.prototype.renderNodes = function (sankeyDiagramDataView) {\n                    var _this = this;\n                    var nodesEnterSelection, nodesSelection, nodeElements;\n                    nodeElements = this.main\n                        .select(SankeyDiagram.Nodes.selector)\n                        .selectAll(SankeyDiagram.Node.selector);\n                    nodesSelection = nodeElements.data(sankeyDiagramDataView.nodes.filter(function (x) { return x.height > 0; }));\n                    nodesEnterSelection = nodesSelection\n                        .enter()\n                        .append(\"g\");\n                    nodesSelection\n                        .attr(\"transform\", function (node) {\n                        return visuals.SVGUtil.translate(node.x, node.y);\n                    })\n                        .classed(SankeyDiagram.Node[\"class\"], true);\n                    nodesEnterSelection\n                        .append(\"rect\")\n                        .classed(SankeyDiagram.NodeRect[\"class\"], true);\n                    nodesEnterSelection\n                        .append(\"text\")\n                        .classed(SankeyDiagram.NodeLabel[\"class\"], true);\n                    nodesSelection\n                        .select(SankeyDiagram.NodeRect.selector)\n                        .style({\n                        \"fill\": function (node) { return node.colour; },\n                        \"stroke\": function (node) { return d3.rgb(node.colour).darker(1.5); }\n                    })\n                        .attr({\n                        x: 0,\n                        y: 0,\n                        height: function (node) { return node.height; },\n                        width: function (node) { return node.width; }\n                    });\n                    nodesSelection\n                        .select(SankeyDiagram.NodeLabel.selector)\n                        .attr({\n                        x: function (node) { return _this.getLabelPositionByAxisX(node); },\n                        y: function (node) { return node.height / 2; },\n                        dy: \"0.35em\"\n                    })\n                        .style(\"fill\", function (node) { return node.label.colour; })\n                        .style(\"font-size\", this.textProperties.fontSize)\n                        .style(\"display\", function (node) {\n                        var isNotVisibleLabel = false, labelPositionByAxisX = _this.getCurrentPositionOfLabelByAxisX(node);\n                        isNotVisibleLabel =\n                            labelPositionByAxisX >= _this.viewport.width ||\n                                labelPositionByAxisX <= 0 ||\n                                (node.height + SankeyDiagram.NodePadding) < node.label.height;\n                        if (isNotVisibleLabel || !sankeyDiagramDataView.settings.isVisibleLabels\n                            || sankeyDiagramDataView.settings.scale.x / 2 < SankeyDiagram.MinWidthOfLabel) {\n                            return \"none\";\n                        }\n                        return null;\n                    })\n                        .style(\"text-anchor\", function (node) {\n                        if (_this.isLabelLargerWidth(node)) {\n                            return \"end\";\n                        }\n                        return null;\n                    })\n                        .text(function (node) {\n                        var maxWidth = sankeyDiagramDataView.settings.scale.x / 2 - node.width - SankeyDiagram.NodePadding;\n                        if (_this.getCurrentPositionOfLabelByAxisX(node) > maxWidth) {\n                            return powerbi.TextMeasurementService.getTailoredTextOrDefault({\n                                text: node.label.formattedName,\n                                fontFamily: _this.textProperties.fontFamily,\n                                fontSize: _this.textProperties.fontSize\n                            }, maxWidth);\n                        }\n                        return node.label.formattedName;\n                    });\n                    nodesSelection\n                        .exit()\n                        .remove();\n                    this.renderTooltip(nodesSelection);\n                    return nodesSelection;\n                };\n                SankeyDiagram.prototype.getLabelPositionByAxisX = function (node) {\n                    if (this.isLabelLargerWidth(node)) {\n                        return -(SankeyDiagram.LabelPadding);\n                    }\n                    return node.width + SankeyDiagram.LabelPadding;\n                };\n                SankeyDiagram.prototype.isLabelLargerWidth = function (node) {\n                    var shiftByAxisX = node.x + node.width + SankeyDiagram.LabelPadding;\n                    return shiftByAxisX + node.label.width > this.viewport.width;\n                };\n                SankeyDiagram.prototype.getCurrentPositionOfLabelByAxisX = function (node) {\n                    var labelPositionByAxisX = this.getLabelPositionByAxisX(node);\n                    labelPositionByAxisX = labelPositionByAxisX > 0\n                        ? labelPositionByAxisX + node.x + node.label.width + node.width\n                        : node.x + labelPositionByAxisX - node.label.width - node.width;\n                    return labelPositionByAxisX;\n                };\n                SankeyDiagram.prototype.renderLinks = function (sankeyDiagramDataView) {\n                    var _this = this;\n                    var linksSelection, linksElements;\n                    linksElements = this.main\n                        .select(SankeyDiagram.Links.selector)\n                        .selectAll(SankeyDiagram.Link.selector);\n                    linksSelection = linksElements.data(sankeyDiagramDataView.links.filter(function (x) { return x.height > 0; }));\n                    linksSelection\n                        .enter()\n                        .append(\"path\")\n                        .classed(SankeyDiagram.Link[\"class\"], true);\n                    linksSelection\n                        .attr(\"d\", function (link) {\n                        return _this.getSvgPath(link);\n                    })\n                        .style({\n                        \"stroke-width\": function (link) { return link.height; },\n                        \"stroke\": function (link) { return link.colour; }\n                    });\n                    linksSelection\n                        .exit()\n                        .remove();\n                    this.renderTooltip(linksSelection);\n                    return linksSelection;\n                };\n                SankeyDiagram.prototype.getSvgPath = function (link) {\n                    var x0, x1, xi, x2, x3, y0, y1;\n                    if (link.destination.x < link.source.x) {\n                        x0 = link.source.x;\n                        x1 = link.destination.x + link.destination.width;\n                    }\n                    else {\n                        x0 = link.source.x + link.source.width;\n                        x1 = link.destination.x;\n                    }\n                    xi = d3.interpolateNumber(x0, x1);\n                    x2 = xi(this.curvatureOfLinks);\n                    x3 = xi(1 - this.curvatureOfLinks);\n                    y0 = link.source.y + link.dySource + link.height / 2;\n                    y1 = link.destination.y + link.dyDestination + link.height / 2;\n                    return \"M \" + x0 + \" \" + y0 + \" C \" + x2 + \" \" + y0 + \", \" + x3 + \" \" + y1 + \", \" + x1 + \" \" + y1;\n                };\n                SankeyDiagram.prototype.renderTooltip = function (selection) {\n                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {\n                        return tooltipEvent.data.tooltipData;\n                    });\n                };\n                SankeyDiagram.prototype.bindSelectionHandler = function (sankeyDiagramDataView, nodesSelection, linksSelection) {\n                    var _this = this;\n                    nodesSelection.on(\"click\", function (node) {\n                        var selectionIds = _.isEqual(node.selectionIds.map(function (x) { return x.getKey(); }), _this.selectionManager.getSelectionIds().map(function (x) { return x.getKey(); }))\n                            ? []\n                            : node.selectionIds;\n                        _this.selectMany(selectionIds, true).then(function () { return _this.setSelection(nodesSelection, linksSelection); });\n                        d3.event.stopPropagation();\n                    });\n                    linksSelection.on(\"click\", function (link) {\n                        _this.selectionManager.select(link.selectionId, d3.event.ctrlKey).then(function () {\n                            return _this.setSelection(nodesSelection, linksSelection);\n                        });\n                        d3.event.stopPropagation();\n                    });\n                    this.root.on(\"click\", function () {\n                        _this.selectionManager.clear().then(function () { return _this.setSelection(nodesSelection, linksSelection); });\n                    });\n                    this.setSelection(nodesSelection, linksSelection);\n                };\n                SankeyDiagram.prototype.selectMany = function (selectionIds, clear) {\n                    var _this = this;\n                    if (clear === void 0) { clear = false; }\n                    if (clear) {\n                        return this.selectionManager.clear().then(function () { return _this.selectMany(selectionIds, false); });\n                    }\n                    var selectionDeffered = selectionIds.map(function (id) { return _this.selectionManager.select(id, true); });\n                    return $.when.apply(null, selectionDeffered);\n                };\n                SankeyDiagram.prototype.setSelection = function (nodes, links) {\n                    var selectionIds = this.selectionManager.getSelectionIds();\n                    nodes.classed(\"selected\", selectionIds.length > 0);\n                    links.classed(\"selected\", false);\n                    if (selectionIds.length === 0) {\n                        return;\n                    }\n                    var selectedNodesSelection = nodes.filter(function (node) { return selectionIds\n                        .some(function (selectedId) { return node.selectionIds\n                        .some(function (x) { return x.getKey() === selectedId.getKey(); }); }); });\n                    var selectedLinksSelection = links.filter(function (link) {\n                        return selectionIds.some(function (selectionId) { return selectionId.getKey() === link.selectionId.getKey(); });\n                    });\n                    selectedNodesSelection.classed(\"selected\", false);\n                    selectedLinksSelection.classed(\"selected\", true);\n                };\n                SankeyDiagram.prototype.enumerateObjectInstances = function (options) {\n                    var enumeration = new visuals.ObjectEnumerationBuilder();\n                    if (!this.dataView) {\n                        return [];\n                    }\n                    switch (options.objectName) {\n                        case \"labels\": {\n                            this.enumerateLabels(enumeration);\n                            break;\n                        }\n                        case \"links\": {\n                            this.enumerateLinks(enumeration);\n                            break;\n                        }\n                    }\n                    return enumeration.complete();\n                };\n                SankeyDiagram.prototype.enumerateLabels = function (enumeration) {\n                    var settings = this.dataView.settings, labels;\n                    if (!settings) {\n                        return;\n                    }\n                    labels = {\n                        objectName: \"labels\",\n                        displayName: \"labels\",\n                        selector: null,\n                        properties: {\n                            show: settings.isVisibleLabels,\n                            fill: settings.colourOfLabels,\n                            fontSize: settings.fontSize\n                        }\n                    };\n                    enumeration.pushInstance(labels);\n                };\n                SankeyDiagram.prototype.enumerateLinks = function (enumeration) {\n                    var links = this.dataView.links;\n                    if (!links || !(links.length > 0)) {\n                        return;\n                    }\n                    links.forEach(function (link) {\n                        enumeration.pushInstance({\n                            objectName: \"links\",\n                            displayName: link.source.label.formattedName + \" - \" + link.destination.label.formattedName,\n                            selector: visuals.ColorHelper.normalizeSelector(link.selectionId.getSelector(), false),\n                            properties: {\n                                fill: { solid: { color: link.colour } }\n                            }\n                        });\n                    });\n                };\n                SankeyDiagram.ClassName = \"sankeyDiagram\";\n                SankeyDiagram.Nodes = {\n                    \"class\": \"nodes\",\n                    selector: \".nodes\"\n                };\n                SankeyDiagram.Node = {\n                    \"class\": \"node\",\n                    selector: \".node\"\n                };\n                SankeyDiagram.NodeRect = {\n                    \"class\": \"nodeRect\",\n                    selector: \".nodeRect\"\n                };\n                SankeyDiagram.NodeLabel = {\n                    \"class\": \"nodeLabel\",\n                    selector: \".nodeLabel\"\n                };\n                SankeyDiagram.Links = {\n                    \"class\": \"links\",\n                    selector: \".links\"\n                };\n                SankeyDiagram.Link = {\n                    \"class\": \"link\",\n                    selector: \".link\"\n                };\n                SankeyDiagram.DefaultColourOfNode = \"rgb(62, 187, 162)\";\n                SankeyDiagram.DefaultColourOfLink = \"black\";\n                SankeyDiagram.DefaultSettings = {\n                    isVisibleLabels: true,\n                    scale: { x: 1, y: 1 },\n                    colourOfLabels: \"black\",\n                    fontSize: 12\n                };\n                SankeyDiagram.MinWidthOfLabel = 35;\n                SankeyDiagram.NodePadding = 5;\n                SankeyDiagram.LabelPadding = 4;\n                SankeyDiagram.RoleNames = {\n                    rows: \"Source\",\n                    columns: \"Destination\",\n                    values: \"Weight\"\n                };\n                SankeyDiagram.capabilities = {\n                    dataRoles: [{\n                            name: SankeyDiagram.RoleNames.rows,\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: SankeyDiagram.RoleNames.rows\n                        }, {\n                            name: SankeyDiagram.RoleNames.columns,\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: SankeyDiagram.RoleNames.columns\n                        }, {\n                            name: SankeyDiagram.RoleNames.values,\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: SankeyDiagram.RoleNames.values\n                        }],\n                    dataViewMappings: [{\n                            conditions: [\n                                { \"Source\": { min: 0, max: 1 }, \"Destination\": { min: 0, max: 1 }, \"Weight\": { min: 0, max: 0 } },\n                                { \"Source\": { min: 0, max: 1 }, \"Destination\": { min: 0, max: 1 }, \"Weight\": { min: 1, max: 1 } }\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: { in: SankeyDiagram.RoleNames.rows },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: {\n                                    select: [\n                                        { bind: { to: SankeyDiagram.RoleNames.columns } },\n                                        { bind: { to: SankeyDiagram.RoleNames.values } }\n                                    ]\n                                }\n                            }\n                        }],\n                    objects: {\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter(\"Visual_General\"),\n                            properties: {\n                                formatString: { type: { formatting: { formatString: true } } }\n                            }\n                        },\n                        labels: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter(\"Visual_Show\"),\n                                    type: { bool: true }\n                                },\n                                fill: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { formatting: { fontSize: true } }\n                                }\n                            }\n                        },\n                        links: {\n                            displayName: \"Links\",\n                            properties: {\n                                fill: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        }\n                    }\n                };\n                SankeyDiagram.Properties = SankeyDiagram.getProperties(SankeyDiagram.capabilities);\n                return SankeyDiagram;\n            }());\n            samples.SankeyDiagram = SankeyDiagram;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var PixelConverter = jsCommon.PixelConverter;\n            samples.bulletChartProps = {\n                values: {\n                    targetValue: { objectName: 'values', propertyName: 'targetValue' },\n                    minimumPercent: { objectName: 'values', propertyName: 'minimumPercent' },\n                    needsImprovementPercent: { objectName: 'values', propertyName: 'needsImprovementPercent' },\n                    satisfactoryPercent: { objectName: 'values', propertyName: 'satisfactoryPercent' },\n                    goodPercent: { objectName: 'values', propertyName: 'goodPercent' },\n                    veryGoodPercent: { objectName: 'values', propertyName: 'veryGoodPercent' },\n                    maximumPercent: { objectName: 'values', propertyName: 'maximumPercent' },\n                    targetValue2: { objectName: 'values', propertyName: 'targetValue2' },\n                },\n                orientation: {\n                    orientation: { objectName: 'orientation', propertyName: 'orientation' },\n                },\n                colors: {\n                    badColor: { objectName: 'colors', propertyName: 'badColor' },\n                    needsImprovementColor: { objectName: 'colors', propertyName: 'needsImprovementColor' },\n                    satisfactoryColor: { objectName: 'colors', propertyName: 'satisfactoryColor' },\n                    goodColor: { objectName: 'colors', propertyName: 'goodColor' },\n                    veryGoodColor: { objectName: 'colors', propertyName: 'veryGoodColor' },\n                    bulletColor: { objectName: 'colors', propertyName: 'bulletColor' },\n                },\n                axis: {\n                    axis: { objectName: 'axis', propertyName: 'axis' },\n                    axisColor: { objectName: 'axis', propertyName: 'axisColor' },\n                    measureUnits: { objectName: 'axis', propertyName: 'measureUnits' },\n                    unitsColor: { objectName: 'axis', propertyName: 'unitsColor' },\n                },\n                formatString: { objectName: 'general', propertyName: 'formatString' },\n                labels: {\n                    fontSize: { objectName: 'labels', propertyName: 'fontSize' },\n                    show: { objectName: 'labels', propertyName: 'show' },\n                    labelColor: { objectName: 'labels', propertyName: 'labelColor' }\n                }\n            };\n            samples.bulletChartRoleNames = {\n                value: 'Value',\n                targetValue: 'TargetValue',\n                minValue: 'Minimum',\n                needsImprovementValue: 'NeedsImprovement',\n                satisfactoryValue: 'Satisfactory',\n                goodValue: 'Good',\n                veryGoodValue: 'VeryGood',\n                maxValue: 'Maximum',\n                targetValue2: 'TargetValue2',\n            };\n            var Orientation;\n            (function (Orientation) {\n                Orientation.HORIZONTALLEFT = 'Horizontal Left';\n                Orientation.HORIZONTALRIGHT = 'Horizontal Right';\n                Orientation.VERTICALTOP = 'Vertical Top';\n                Orientation.VERTICALBOTTOM = 'Vertical Bottom';\n                Orientation.type = powerbi.createEnumType([\n                    { value: Orientation.HORIZONTALLEFT, displayName: Orientation.HORIZONTALLEFT },\n                    { value: Orientation.HORIZONTALRIGHT, displayName: Orientation.HORIZONTALRIGHT },\n                    { value: Orientation.VERTICALTOP, displayName: Orientation.VERTICALTOP },\n                    { value: Orientation.VERTICALBOTTOM, displayName: Orientation.VERTICALBOTTOM }\n                ]);\n            })(Orientation || (Orientation = {}));\n            var BulletChart = (function () {\n                function BulletChart() {\n                    this.baselineDelta = 0;\n                }\n                Object.defineProperty(BulletChart.prototype, \"reverse\", {\n                    get: function () {\n                        return this.model.bulletChartSettings.orientation.reverse;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(BulletChart.prototype, \"vertical\", {\n                    get: function () {\n                        return this.model.bulletChartSettings.orientation.vertical;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                BulletChart.DefaultStyleProperties = function () {\n                    return {\n                        values: {\n                            targetValue: 0,\n                            targetValue2: 0,\n                            minimumPercent: 0,\n                            needsImprovementPercent: 25,\n                            satisfactoryPercent: 50,\n                            goodPercent: 100,\n                            veryGoodPercent: 125,\n                            maximumPercent: 200,\n                        },\n                        orientation: {\n                            orientation: Orientation.HORIZONTALLEFT,\n                            reverse: false,\n                            vertical: false\n                        },\n                        colors: {\n                            badColor: 'Darkred',\n                            needsImprovementColor: 'Red',\n                            satisfactoryColor: 'Yellow',\n                            goodColor: 'Green',\n                            veryGoodColor: 'Darkgreen',\n                            bulletColor: 'Black'\n                        },\n                        axis: {\n                            axis: true,\n                            axisColor: 'Grey',\n                            measureUnits: '',\n                            unitsColor: 'Grey',\n                        },\n                        labelSettings: {\n                            fontSize: 11,\n                            show: true,\n                            labelColor: 'Black',\n                        },\n                    };\n                };\n                Object.defineProperty(BulletChart.prototype, \"viewportIn\", {\n                    get: function () {\n                        return {\n                            width: this.viewport.width,\n                            height: this.viewport.height\n                        };\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(BulletChart.prototype, \"viewportScroll\", {\n                    get: function () {\n                        var viewportIn = this.viewportIn;\n                        return {\n                            width: viewportIn.width - BulletChart.ScrollBarSize,\n                            height: viewportIn.height - BulletChart.ScrollBarSize\n                        };\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                BulletChart.getTextProperties = function (text, fontSize) {\n                    return {\n                        fontFamily: BulletChart.FontFamily,\n                        fontSize: PixelConverter.fromPoint(fontSize),\n                        text: text,\n                    };\n                };\n                // Convert a DataView into a view model\n                BulletChart.converter = function (dataView, options) {\n                    var defaultSettings = BulletChart.DefaultStyleProperties();\n                    var bulletModel = {\n                        bulletValueFormatString: null,\n                        bulletChartSettings: defaultSettings,\n                        bars: [],\n                        barRects: [],\n                        valueRects: [],\n                        targetValues: [],\n                    };\n                    if (!dataView || !dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length === 0\n                        || !dataView.metadata || !dataView.metadata.columns || dataView.metadata.columns.length === 0) {\n                        return bulletModel;\n                    }\n                    var objects = dataView.metadata.objects;\n                    var settings = bulletModel.bulletChartSettings;\n                    if (objects) {\n                        settings.values.targetValue = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue, defaultSettings.values.targetValue);\n                        settings.values.targetValue2 = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue2, defaultSettings.values.targetValue2);\n                        settings.values.minimumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.minimumPercent, defaultSettings.values.minimumPercent);\n                        settings.values.needsImprovementPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.needsImprovementPercent, defaultSettings.values.needsImprovementPercent);\n                        settings.values.satisfactoryPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.satisfactoryPercent, defaultSettings.values.satisfactoryPercent);\n                        settings.values.goodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.goodPercent, defaultSettings.values.goodPercent);\n                        settings.values.veryGoodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.veryGoodPercent, defaultSettings.values.veryGoodPercent);\n                        settings.values.maximumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.maximumPercent, defaultSettings.values.maximumPercent);\n                        settings.orientation.orientation = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.orientation.orientation, defaultSettings.orientation.orientation);\n                        settings.colors.badColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.badColor, defaultSettings.colors.badColor);\n                        settings.colors.needsImprovementColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.needsImprovementColor, defaultSettings.colors.needsImprovementColor);\n                        settings.colors.satisfactoryColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.satisfactoryColor, defaultSettings.colors.satisfactoryColor);\n                        settings.colors.goodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.goodColor, defaultSettings.colors.goodColor);\n                        settings.colors.veryGoodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.veryGoodColor, defaultSettings.colors.veryGoodColor);\n                        settings.colors.bulletColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.bulletColor, defaultSettings.colors.bulletColor);\n                        settings.axis.axis = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.axis, defaultSettings.axis.axis);\n                        settings.axis.axisColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.axisColor, defaultSettings.axis.axisColor);\n                        settings.axis.measureUnits = powerbi.TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.measureUnits, defaultSettings.axis.measureUnits), BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxLabelWidth);\n                        settings.axis.unitsColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.unitsColor, defaultSettings.axis.unitsColor);\n                        settings.labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.fontSize, defaultSettings.labelSettings.fontSize);\n                        settings.labelSettings.show = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.show, defaultSettings.labelSettings.show);\n                        settings.labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.labels.labelColor, defaultSettings.labelSettings.labelColor);\n                    }\n                    if (settings.orientation.orientation === Orientation.HORIZONTALRIGHT || settings.orientation.orientation === Orientation.VERTICALBOTTOM)\n                        settings.orientation.reverse = true;\n                    if (settings.orientation.orientation === Orientation.VERTICALTOP || settings.orientation.orientation === Orientation.VERTICALBOTTOM)\n                        settings.orientation.vertical = true;\n                    var categories, categoryValues, categoryValuesLen = 1, categoryFormatString;\n                    if (dataView.categorical.categories) {\n                        categories = dataView.categorical.categories[0];\n                        categoryValues = categories.values;\n                        categoryValuesLen = categoryValues.length;\n                        categoryFormatString = visuals.valueFormatter.getFormatString(categories.source, samples.bulletChartProps.formatString);\n                    }\n                    bulletModel.bulletValueFormatString = visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, samples.bulletChartProps.formatString);\n                    for (var idx = 0; idx < categoryValuesLen; idx++) {\n                        var toolTipItems = [];\n                        var category = void 0, value = void 0, targetValue = void 0, targetValue2 = void 0, minimum = void 0, satisfactory = void 0, good = void 0, maximum = void 0, needsImprovement = void 0, veryGood = void 0;\n                        var highlight = false, categoryIdentity = void 0;\n                        if (categoryValues) {\n                            var categoryValue = categoryValues[idx];\n                            category = visuals.valueFormatter.format(categoryValue, categoryFormatString);\n                            categoryIdentity = categories.identity ? categories.identity[idx] : null;\n                            var textProperties = BulletChart.getTextProperties(category, settings.labelSettings.fontSize);\n                            category = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, BulletChart.MaxLabelWidth - BulletChart.StartMarginHorizontal);\n                            var labelWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);\n                            var labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);\n                            BulletChart.BiggestLabelWidth = Math.max(BulletChart.BiggestLabelWidth, labelWidth);\n                            BulletChart.BiggestLabelHeight = Math.max(BulletChart.BiggestLabelHeight, labelHeight);\n                        }\n                        var values = dataView.categorical.values;\n                        targetValue = settings.values.targetValue;\n                        targetValue2 = settings.values.targetValue2;\n                        for (var i = 0; i < values.length; i++) {\n                            var col = values[i].source;\n                            var currentVal = values[i].values[idx] || 0;\n                            if (col && col.roles) {\n                                if (col.roles[samples.bulletChartRoleNames.value]) {\n                                    if (values[i].highlights)\n                                        highlight = values[i].highlights[idx] !== null;\n                                    toolTipItems.push({ value: currentVal, metadata: values[i] });\n                                    value = currentVal;\n                                }\n                                else if (col.roles[samples.bulletChartRoleNames.targetValue]) {\n                                    toolTipItems.push({ value: currentVal, metadata: values[i] });\n                                    targetValue = currentVal;\n                                }\n                                else if (col.roles[samples.bulletChartRoleNames.targetValue2]) {\n                                    toolTipItems.push({ value: currentVal, metadata: values[i] });\n                                    targetValue2 = currentVal;\n                                }\n                                else if (col.roles[samples.bulletChartRoleNames.minValue])\n                                    minimum = currentVal;\n                                else if (col.roles[samples.bulletChartRoleNames.needsImprovementValue])\n                                    needsImprovement = currentVal;\n                                else if (col.roles[samples.bulletChartRoleNames.satisfactoryValue])\n                                    satisfactory = currentVal;\n                                else if (col.roles[samples.bulletChartRoleNames.goodValue])\n                                    good = currentVal;\n                                else if (col.roles[samples.bulletChartRoleNames.veryGoodValue])\n                                    veryGood = currentVal;\n                                else if (col.roles[samples.bulletChartRoleNames.maxValue])\n                                    maximum = currentVal;\n                            }\n                        }\n                        if (!minimum)\n                            minimum = settings.values.minimumPercent * targetValue / 100;\n                        if (!needsImprovement)\n                            needsImprovement = settings.values.needsImprovementPercent * targetValue / 100;\n                        if (!satisfactory)\n                            satisfactory = settings.values.satisfactoryPercent * targetValue / 100;\n                        if (!good)\n                            good = settings.values.goodPercent * targetValue / 100;\n                        if (!veryGood)\n                            veryGood = settings.values.veryGoodPercent * targetValue / 100;\n                        if (!maximum)\n                            maximum = settings.values.maximumPercent * targetValue / 100;\n                        var viewportLength = (settings.orientation.vertical ? (options.viewport.height - BulletChart.MaxLabelHeight) : (options.viewport.width - BulletChart.MaxLabelWidth)) -\n                            BulletChart.StartMarginHorizontal - BulletChart.ScrollBarSize;\n                        var sortedRanges = [minimum, needsImprovement, satisfactory, good, veryGood, maximum].sort(d3.descending);\n                        var scale = (d3.scale.linear()\n                            .clamp(true)\n                            .domain([minimum, Math.max(sortedRanges[0], targetValue, value)])\n                            .range(settings.orientation.vertical ? [viewportLength, 0] : [0, viewportLength]));\n                        // Scalles without\n                        var firstScale = scale(minimum);\n                        var secondScale = scale(needsImprovement);\n                        var thirdScale = scale(satisfactory);\n                        var fourthScale = scale(good);\n                        var fifthScale = scale(veryGood);\n                        var lastScale = scale(maximum);\n                        var valueScale = scale(value);\n                        var firstColor = settings.colors.badColor, secondColor = settings.colors.needsImprovementColor, thirdColor = settings.colors.satisfactoryColor, fourthColor = settings.colors.goodColor, lastColor = settings.colors.veryGoodColor;\n                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, firstScale, secondScale, firstColor, toolTipItems, categoryIdentity);\n                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, secondScale, thirdScale, secondColor, toolTipItems, categoryIdentity);\n                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, thirdScale, fourthScale, thirdColor, toolTipItems, categoryIdentity);\n                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, fourthScale, fifthScale, fourthColor, toolTipItems, categoryIdentity);\n                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, fifthScale, lastScale, lastColor, toolTipItems, categoryIdentity);\n                        BulletChart.addItemToBarArray(bulletModel.valueRects, idx, firstScale, valueScale, settings.colors.bulletColor, toolTipItems, categoryIdentity);\n                        // markerValue\n                        bulletModel.targetValues.push({\n                            barIndex: idx,\n                            value: scale(targetValue),\n                            fill: settings.colors.bulletColor,\n                            key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, scale(targetValue).toString()).getKey(),\n                            value2: scale(targetValue2),\n                        });\n                        var xAxis = null;\n                        if (settings.axis.axis) {\n                            xAxis = d3.svg.axis();\n                            xAxis.orient(settings.orientation.vertical ? \"left\" : \"bottom\");\n                            var minTickSize = Math.round(Math.max(3, viewportLength / 100));\n                            var axisValues = [value, targetValue, good, satisfactory, maximum, minimum, needsImprovement, veryGood]\n                                .filter(function (x) { return !isNaN(x); });\n                            xAxis.tickFormat(visuals.valueFormatter.create({\n                                format: bulletModel.bulletValueFormatString,\n                                value: axisValues.length ? Math.max.apply(null, axisValues) : 0\n                            }).format);\n                            xAxis.ticks(minTickSize);\n                            xAxis.scale(scale);\n                        }\n                        var bar = {\n                            scale: scale,\n                            barIndex: idx,\n                            categoryLabel: category,\n                            x: (settings.orientation.vertical) ? BulletChart.StartMarginVertical + BulletChart.SpaceRequiredForBarVertically * idx : BulletChart.StartMarginHorizontal,\n                            y: (settings.orientation.vertical) ? BulletChart.StartMarginVertical : BulletChart.StartMarginHorizontal + BulletChart.SpaceRequiredForBar * idx,\n                            axis: xAxis,\n                            key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, idx.toString()).getKey(),\n                        };\n                        bulletModel.bars.push(bar);\n                    }\n                    return bulletModel;\n                };\n                BulletChart.addItemToBarArray = function (collection, barIndex, start, end, fill, tooltipInfo, categoryIdentity) {\n                    collection.push({\n                        barIndex: barIndex,\n                        start: start,\n                        end: end,\n                        fill: fill,\n                        tooltipInfo: visuals.TooltipBuilder.createTooltipInfo(samples.bulletChartProps.formatString, null, null, null, null, tooltipInfo),\n                        selected: false,\n                        identity: visuals.SelectionId.createWithId(categoryIdentity),\n                        key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, start + \" \" + end).getKey(),\n                    });\n                };\n                /* One time setup*/\n                BulletChart.prototype.init = function (options) {\n                    var body = d3.select(options.element.get(0));\n                    this.hostService = options.host;\n                    this.bulletBody = body\n                        .append('div')\n                        .classed('bulletChart', true);\n                    this.scrollContainer = this.bulletBody.append('svg')\n                        .classed('bullet-scroll-region', true);\n                    this.clearCatcher = visuals.appendClearCatcher(this.scrollContainer);\n                    this.labelGraphicsContext = this.scrollContainer.append('g');\n                    this.bulletGraphicsContext = this.scrollContainer.append('g');\n                    this.behavior = new BulletWebBehavior();\n                    this.interactivityService = visuals.createInteractivityService(options.host);\n                };\n                /* Called for data, size, formatting changes*/\n                BulletChart.prototype.update = function (options) {\n                    if (!options.dataViews || !options.dataViews[0])\n                        return;\n                    BulletChart.BiggestLabelHeight = BulletChart.BiggestLabelWidth = 0;\n                    var dataView = options.dataViews[0];\n                    this.viewport = options.viewport;\n                    this.model = BulletChart.converter(dataView, options);\n                    //TODO: Calculating the baseline delta of the text. needs to be removed once the TExtMeasurementService.estimateSVGTextBaselineDelta is available.\n                    this.baselineDelta = TextMeasurementHelper.estimateSvgTextBaselineDelta(BulletChart.getTextProperties(\"1\", this.model.bulletChartSettings.labelSettings.fontSize));\n                    this.ClearViewport();\n                    if (!this.model) {\n                        return;\n                    }\n                    if (this.interactivityService) {\n                        this.interactivityService.applySelectionStateToData(this.model.barRects);\n                    }\n                    this.bulletBody.style({\n                        'height': this.viewportIn.height + 'px',\n                        'width': this.viewportIn.width + 'px',\n                    });\n                    if (this.vertical) {\n                        this.scrollContainer.attr({\n                            width: (this.model.bars.length * BulletChart.SpaceRequiredForBarVertically) + 'px',\n                            height: this.viewportScroll.height + 'px'\n                        });\n                    }\n                    else {\n                        this.scrollContainer.attr({\n                            height: (this.model.bars.length * BulletChart.SpaceRequiredForBar) + 'px',\n                            width: this.viewportScroll.width + 'px'\n                        });\n                    }\n                    if (this.vertical)\n                        this.setUpBulletsVertically(this.bulletBody, this.model, this.reverse);\n                    else\n                        this.setUpBulletsHorizontally(this.bulletBody, this.model, this.reverse);\n                };\n                BulletChart.prototype.ClearViewport = function () {\n                    this.labelGraphicsContext.selectAll(\"text\").remove();\n                    this.bulletGraphicsContext.selectAll(\"rect\").remove();\n                    this.bulletGraphicsContext.selectAll('axis').remove();\n                    this.bulletGraphicsContext.selectAll('path').remove();\n                    this.bulletGraphicsContext.selectAll('line').remove();\n                    this.bulletGraphicsContext.selectAll('tick').remove();\n                    this.bulletGraphicsContext.selectAll('g').remove();\n                };\n                BulletChart.prototype.calculateLabelWidth = function (barData, bar, reversed) {\n                    if (reversed)\n                        return BulletChart.StartMarginHorizontal + ((bar) ? bar.start : 0);\n                    var textSize = powerbi.TextMeasurementService.measureSvgTextWidth(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));\n                    if (textSize > BulletChart.BiggestLabelWidth)\n                        return barData.x + BulletChart.MaxLabelWidth + ((bar) ? bar.start : 0);\n                    return barData.x + BulletChart.BiggestLabelWidth + BulletChart.BarMargin + ((bar) ? bar.start : 0);\n                };\n                BulletChart.prototype.calculateLabelHeight = function (barData, bar, reversed) {\n                    if (reversed)\n                        return BulletChart.StartMarginVertical + ((bar) ? bar.end : 0);\n                    var textSize = powerbi.TextMeasurementService.measureSvgTextHeight(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));\n                    if (textSize > BulletChart.BiggestLabelHeight)\n                        return barData.y + BulletChart.MaxLabelHeight + ((bar) ? bar.end : 0);\n                    return barData.y + textSize + BulletChart.BarMargin + ((bar) ? bar.end : 0);\n                };\n                BulletChart.prototype.setUpBulletsHorizontally = function (bulletBody, model, reveresed) {\n                    var _this = this;\n                    var bars = model.bars;\n                    var rects = model.barRects;\n                    var valueRects = model.valueRects;\n                    var targetValues = model.targetValues;\n                    var barSelection = this.labelGraphicsContext.selectAll('text').data(bars, function (d) { return d.key; });\n                    var rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, function (d) { return d.key; });\n                    // Draw bullets\n                    var bullets = rectSelection.enter().append('rect').attr({\n                        'x': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),\n                        'y': (function (d) { return bars[d.barIndex].y - BulletChart.BulletSize / 2; }),\n                        'width': (function (d) { return d.end - d.start; }),\n                        'height': BulletChart.BulletSize,\n                    }).classed('range', true).style({\n                        'fill': (function (d) { return d.fill; })\n                    });\n                    rectSelection.exit();\n                    // Draw value rects\n                    var valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, function (d) { return d.key; });\n                    valueSelection.enter().append('rect').attr({\n                        'x': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),\n                        'y': (function (d) { return bars[d.barIndex].y - BulletChart.BulletSize / 8; }),\n                        'width': (function (d) { return d.end - d.start; }),\n                        'height': BulletChart.BulletSize * 1 / 4,\n                    }).classed('value', true).style({\n                        'fill': (function (d) { return d.fill; }),\n                    });\n                    valueSelection.exit();\n                    // Draw markers\n                    var markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, function (d) { return d.key; });\n                    markerSelection.enter().append('line').attr({\n                        'x1': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),\n                        'x2': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),\n                        'y1': (function (d) { return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal; }),\n                        'y2': (function (d) { return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal; }),\n                    }).style({\n                        'stroke': (function (d) { return d.fill; }),\n                        'stroke-width': 2,\n                    });\n                    markerSelection.enter().append('line').attr({\n                        'x1': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\n                        'x2': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\n                        'y1': (function (d) { return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal; }),\n                        'y2': (function (d) { return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal; }),\n                    }).style({\n                        'stroke': (function (d) { return d.fill; }),\n                        'stroke-width': 2,\n                        'transform': 'rotate(45deg)',\n                        'transform-origin': '50% 50% 0',\n                    });\n                    markerSelection.enter().append('line').attr({\n                        'x1': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\n                        'x2': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\n                        'y1': (function (d) { return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal; }),\n                        'y2': (function (d) { return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal; }),\n                    }).style({\n                        'stroke': (function (d) { return d.fill; }),\n                        'stroke-width': 2,\n                        'transform': 'rotate(315deg)',\n                        'transform-origin': '50% 50% 0',\n                    });\n                    markerSelection.exit();\n                    // Draw axes\n                    if (model.bulletChartSettings.axis.axis) {\n                        // Using var instead of let since you can't pass let parameters to functions inside loops.\n                        // needs to be changed to let when typescript 1.8 comes out.\n                        for (var idx = 0; idx < bars.length; idx++) {\n                            var bar = bars[idx];\n                            this.bulletGraphicsContext.append(\"g\").attr({\n                                'transform': function () {\n                                    var xLocation = _this.calculateLabelWidth(bar, null, reveresed);\n                                    var yLocation = bar.y + BulletChart.BulletSize / 2;\n                                    return 'translate(' + xLocation + ',' + yLocation + ')';\n                                },\n                            }).classed(\"axis\", true).call(bar.axis.scale(bar.scale)).style({\n                                'fill': model.bulletChartSettings.axis.axisColor,\n                                'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)\n                            }).selectAll('line').style({\n                                'stroke': model.bulletChartSettings.axis.axisColor,\n                            });\n                        }\n                    }\n                    // Draw Labels\n                    if (model.bulletChartSettings.labelSettings.show) {\n                        barSelection.enter().append('text').classed(\"title\", true).attr({\n                            'x': (function (d) {\n                                if (reveresed)\n                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().width + BulletChart.StartMarginHorizontal;\n                                return d.x;\n                            }),\n                            'y': (function (d) { return d.y + _this.baselineDelta; }),\n                            'fill': model.bulletChartSettings.labelSettings.labelColor,\n                            'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),\n                        }).text(function (d) { return d.categoryLabel; });\n                    }\n                    // Draw measure label\n                    if (model.bulletChartSettings.axis.measureUnits) {\n                        barSelection.enter().append('text').attr({\n                            'x': (function (d) {\n                                if (reveresed)\n                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().width - BulletChart.StartMarginHorizontal + BulletChart.SubtitleMargin;\n                                return d.x - BulletChart.SubtitleMargin;\n                            }),\n                            'y': (function (d) { return d.y + BulletChart.BulletSize; }),\n                            'fill': model.bulletChartSettings.axis.unitsColor,\n                            'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)\n                        }).text(model.bulletChartSettings.axis.measureUnits);\n                    }\n                    if (this.interactivityService) {\n                        var behaviorOptions = {\n                            rects: bullets,\n                            valueRects: valueSelection,\n                            clearCatcher: this.clearCatcher,\n                            interactivityService: this.interactivityService,\n                            bulletChartSettings: this.model.bulletChartSettings,\n                            hasHighlights: false,\n                        };\n                        var targetCollection = this.model.barRects.concat(this.model.valueRects);\n                        this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);\n                    }\n                    barSelection.exit();\n                    visuals.TooltipManager.addTooltip(valueSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);\n                    visuals.TooltipManager.addTooltip(rectSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);\n                };\n                BulletChart.prototype.setUpBulletsVertically = function (bulletBody, model, reveresed) {\n                    var _this = this;\n                    var bars = model.bars;\n                    var rects = model.barRects;\n                    var valueRects = model.valueRects;\n                    var targetValues = model.targetValues;\n                    var barSelection = this.labelGraphicsContext.selectAll('text').data(bars, function (d) { return d.key; });\n                    var rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, function (d) { return d.key; });\n                    // Draw bullets\n                    var bullets = rectSelection.enter().append('rect').attr({\n                        'x': (function (d) { return bars[d.barIndex].x; }),\n                        'y': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),\n                        'height': (function (d) { return d.start - d.end; }),\n                        'width': BulletChart.BulletSize,\n                    }).classed('range', true).style({\n                        'fill': (function (d) { return d.fill; })\n                    });\n                    rectSelection.exit();\n                    // Draw value rects\n                    var valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, function (d) { return d.key; });\n                    valueSelection.enter().append('rect').attr({\n                        'x': (function (d) { return bars[d.barIndex].x + BulletChart.BulletSize / 3; }),\n                        'y': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),\n                        'height': (function (d) { return d.start - d.end; }),\n                        'width': BulletChart.BulletSize * 1 / 4,\n                    }).classed('value', true).style({\n                        'fill': (function (d) { return d.fill; }),\n                    });\n                    valueSelection.exit();\n                    // Draw markers\n                    var markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, function (d) { return d.key; });\n                    markerSelection.enter().append('line').attr({\n                        'x2': (function (d) { return bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3); }),\n                        'x1': (function (d) { return bars[d.barIndex].x + BulletChart.MarkerMarginVertical; }),\n                        'y2': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),\n                        'y1': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),\n                    }).style({\n                        'stroke': (function (d) { return d.fill; }),\n                        'stroke-width': 2,\n                    });\n                    markerSelection.enter().append('line').attr({\n                        'y1': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\n                        'y2': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\n                        'x1': (function (d) { return bars[d.barIndex].x + BulletChart.MarkerMarginVertical; }),\n                        'x2': (function (d) { return bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3); }),\n                    }).style({\n                        'stroke': (function (d) { return d.fill; }),\n                        'stroke-width': 2,\n                        'transform': 'rotate(45deg)',\n                        'transform-origin': '50% 50% 0',\n                    });\n                    markerSelection.enter().append('line').attr({\n                        'y1': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\n                        'y2': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\n                        'x1': (function (d) { return bars[d.barIndex].x + BulletChart.MarkerMarginVertical; }),\n                        'x2': (function (d) { return bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3); }),\n                    }).style({\n                        'stroke': (function (d) { return d.fill; }),\n                        'stroke-width': 2,\n                        'transform': 'rotate(315deg)',\n                        'transform-origin': '50% 50% 0',\n                    });\n                    markerSelection.exit();\n                    // // Draw axes\n                    if (model.bulletChartSettings.axis.axis) {\n                        // Using var instead of let since you can't pass let parameters to functions inside loops.\n                        // needs to be changed to let when typescript 1.8 comes out.\n                        for (var idx = 0; idx < bars.length; idx++) {\n                            var bar = bars[idx];\n                            this.bulletGraphicsContext.append(\"g\").attr({\n                                'transform': function () {\n                                    var xLocation = bar.x;\n                                    var yLocation = _this.calculateLabelHeight(bar, null, reveresed);\n                                    // let yLocation = bar.y + BulletChart.BulletSize / 2;\n                                    return 'translate(' + xLocation + ',' + yLocation + ')';\n                                },\n                            }).classed(\"axis\", true).call(bar.axis.scale(bar.scale)).style({\n                                'fill': model.bulletChartSettings.axis.axisColor,\n                                'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt),\n                            }).selectAll('line').style({\n                                'stroke': model.bulletChartSettings.axis.axisColor,\n                            });\n                        }\n                    }\n                    // Draw Labels\n                    if (model.bulletChartSettings.labelSettings.show) {\n                        barSelection.enter().append('text').classed(\"title\", true).attr({\n                            'x': (function (d) { return d.x; }),\n                            'y': (function (d) {\n                                if (reveresed)\n                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.BulletSize;\n                                return d.y + powerbi.TextMeasurementService.estimateSvgTextHeight(BulletChart.getTextProperties(d.categoryLabel, model.bulletChartSettings.labelSettings.fontSize)) / 2;\n                            }),\n                            'fill': model.bulletChartSettings.labelSettings.labelColor,\n                            'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),\n                        }).text(function (d) { return d.categoryLabel; });\n                    }\n                    // Draw measure label\n                    if (model.bulletChartSettings.axis.measureUnits) {\n                        barSelection.enter().append('text').attr({\n                            'x': (function (d) { return d.x + BulletChart.BulletSize; }),\n                            'y': (function (d) {\n                                if (reveresed)\n                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;\n                                return d.y + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;\n                            }),\n                            'fill': model.bulletChartSettings.axis.unitsColor,\n                            'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)\n                        }).text(model.bulletChartSettings.axis.measureUnits);\n                    }\n                    if (this.interactivityService) {\n                        var behaviorOptions = {\n                            rects: bullets,\n                            valueRects: valueSelection,\n                            clearCatcher: this.clearCatcher,\n                            interactivityService: this.interactivityService,\n                            bulletChartSettings: this.model.bulletChartSettings,\n                            hasHighlights: false,\n                        };\n                        var targetCollection = this.model.barRects.concat(this.model.valueRects);\n                        this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);\n                    }\n                    barSelection.exit();\n                    visuals.TooltipManager.addTooltip(valueSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);\n                    visuals.TooltipManager.addTooltip(rectSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);\n                };\n                /*About to remove your visual, do clean up here */\n                BulletChart.prototype.destroy = function () { };\n                BulletChart.prototype.enumerateObjectInstances = function (options) {\n                    var data = this.model;\n                    if (!data) {\n                        return;\n                    }\n                    var objectName = options.objectName;\n                    switch (objectName) {\n                        case 'labels':\n                            return this.enumerateLabels(data);\n                        case 'values':\n                            return this.enumerateValues(data);\n                        case 'orientation':\n                            return this.enumerateOrientation(data);\n                        case 'axis':\n                            return this.enumerateAxis(data);\n                        case 'colors':\n                            return this.enumerateColors(data);\n                    }\n                };\n                BulletChart.prototype.enumerateLabels = function (data) {\n                    return [{\n                            selector: null,\n                            objectName: 'labels',\n                            properties: {\n                                show: this.model.bulletChartSettings.labelSettings.show,\n                                labelColor: this.model.bulletChartSettings.labelSettings.labelColor,\n                                fontSize: this.model.bulletChartSettings.labelSettings.fontSize,\n                            }\n                        }];\n                };\n                BulletChart.prototype.enumerateValues = function (data) {\n                    return [{\n                            selector: null,\n                            objectName: 'values',\n                            properties: {\n                                targetValue: this.model.bulletChartSettings.values.targetValue,\n                                targetValue2: this.model.bulletChartSettings.values.targetValue2,\n                                minimumPercent: this.model.bulletChartSettings.values.minimumPercent,\n                                needsImprovementPercent: this.model.bulletChartSettings.values.needsImprovementPercent,\n                                satisfactoryPercent: this.model.bulletChartSettings.values.satisfactoryPercent,\n                                goodPercent: this.model.bulletChartSettings.values.goodPercent,\n                                veryGoodPercent: this.model.bulletChartSettings.values.veryGoodPercent,\n                                maximumPercent: this.model.bulletChartSettings.values.maximumPercent,\n                            }\n                        }];\n                };\n                BulletChart.prototype.enumerateOrientation = function (data) {\n                    return [{\n                            selector: null,\n                            objectName: 'orientation',\n                            properties: {\n                                orientation: this.model.bulletChartSettings.orientation.orientation\n                            }\n                        }];\n                };\n                BulletChart.prototype.enumerateAxis = function (data) {\n                    return [{\n                            selector: null,\n                            objectName: 'axis',\n                            properties: {\n                                axis: this.model.bulletChartSettings.axis.axis,\n                                axisColor: this.model.bulletChartSettings.axis.axisColor,\n                                measureUnits: this.model.bulletChartSettings.axis.measureUnits,\n                                unitsColor: this.model.bulletChartSettings.axis.unitsColor,\n                            }\n                        }];\n                };\n                BulletChart.prototype.enumerateColors = function (data) {\n                    return [{\n                            selector: null,\n                            objectName: 'colors',\n                            properties: {\n                                badColor: this.model.bulletChartSettings.colors.badColor,\n                                needsImprovementColor: this.model.bulletChartSettings.colors.needsImprovementColor,\n                                satisfactoryColor: this.model.bulletChartSettings.colors.satisfactoryColor,\n                                goodColor: this.model.bulletChartSettings.colors.goodColor,\n                                veryGoodColor: this.model.bulletChartSettings.colors.veryGoodColor,\n                                bulletColor: this.model.bulletChartSettings.colors.bulletColor,\n                            }\n                        }];\n                };\n                BulletChart.ScrollBarSize = 13;\n                BulletChart.SpaceRequiredForBar = 60;\n                BulletChart.SpaceRequiredForBarVertically = 100;\n                BulletChart.StartMarginHorizontal = 30;\n                BulletChart.StartMarginVertical = 50;\n                BulletChart.BulletSize = 25;\n                BulletChart.DefaultSubtitleFontSizeInPt = 9;\n                BulletChart.BarMargin = 10;\n                BulletChart.MaxLabelWidth = 80;\n                BulletChart.MaxLabelHeight = 60;\n                BulletChart.SubtitleMargin = 10;\n                BulletChart.AxisFontSizeInPt = 8;\n                BulletChart.BiggestLabelWidth = 0;\n                BulletChart.BiggestLabelHeight = 0;\n                BulletChart.MarkerMarginHorizontal = BulletChart.BulletSize / 3;\n                BulletChart.MarkerMarginVertical = BulletChart.BulletSize / 4;\n                BulletChart.FontFamily = \"Segoe UI\";\n                BulletChart.capabilities = {\n                    dataRoles: [\n                        {\n                            name: 'Category',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Category',\n                        }, {\n                            name: 'Value',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Value',\n                        }, {\n                            name: 'TargetValue',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Target Value',\n                        }, {\n                            name: 'Minimum',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Minimum',\n                        }, {\n                            name: 'NeedsImprovement',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Needs Improvement',\n                        }, {\n                            name: 'Satisfactory',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Satisfactory',\n                        }, {\n                            name: 'Good',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Good',\n                        }, {\n                            name: 'VeryGood',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Very Good',\n                        }, {\n                            name: 'Maximum',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Maximum',\n                        }, {\n                            name: 'TargetValue2',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Target Value 2'\n                        }\n                    ],\n                    objects: {\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),\n                            properties: {\n                                formatString: {\n                                    type: { formatting: { formatString: true } },\n                                },\n                            },\n                        },\n                        values: {\n                            displayName: 'Data values',\n                            properties: {\n                                targetValue: {\n                                    displayName: 'Target Value',\n                                    type: { numeric: true }\n                                },\n                                targetValue2: {\n                                    displayName: 'Target Value 2',\n                                    type: { numeric: true },\n                                },\n                                minimumPercent: {\n                                    displayName: 'Minimum %',\n                                    type: { numeric: true }\n                                },\n                                needsImprovementPercent: {\n                                    displayName: 'Needs Improvement %',\n                                    type: { numeric: true },\n                                },\n                                satisfactoryPercent: {\n                                    displayName: 'Satisfactory %',\n                                    type: { numeric: true }\n                                },\n                                goodPercent: {\n                                    displayName: 'Good %',\n                                    type: { numeric: true }\n                                },\n                                veryGoodPercent: {\n                                    displayName: 'Very Good %',\n                                    type: { numeric: true },\n                                },\n                                maximumPercent: {\n                                    displayName: 'Maximum %',\n                                    type: { numeric: true }\n                                },\n                            }\n                        },\n                        labels: {\n                            displayName: 'Category labels',\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true },\n                                },\n                                labelColor: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { formatting: { fontSize: true } },\n                                },\n                            },\n                        },\n                        orientation: {\n                            displayName: 'Orientation',\n                            properties: {\n                                orientation: {\n                                    displayName: 'Orientation',\n                                    type: { enumeration: Orientation.type }\n                                }\n                            }\n                        },\n                        colors: {\n                            displayName: 'Colors',\n                            properties: {\n                                badColor: {\n                                    type: { fill: { solid: { color: true } } },\n                                    displayName: 'Bad Color'\n                                },\n                                needsImprovementColor: {\n                                    type: { fill: { solid: { color: true } } },\n                                    displayName: 'Needs Improvement Color',\n                                },\n                                satisfactoryColor: {\n                                    type: { fill: { solid: { color: true } } },\n                                    displayName: 'Satisfactory Color'\n                                },\n                                goodColor: {\n                                    type: { fill: { solid: { color: true } } },\n                                    displayName: 'Good Color'\n                                },\n                                veryGoodColor: {\n                                    type: { fill: { solid: { color: true } } },\n                                    displayName: 'Very Good Color',\n                                },\n                                bulletColor: {\n                                    type: { fill: { solid: { color: true } } },\n                                    displayName: 'Bullet Color'\n                                }\n                            },\n                        },\n                        axis: {\n                            displayName: 'Axis',\n                            properties: {\n                                axis: {\n                                    displayName: 'Axis',\n                                    type: { bool: true }\n                                },\n                                axisColor: {\n                                    type: { fill: { solid: { color: true } } },\n                                    displayName: 'Axis Color'\n                                },\n                                measureUnits: {\n                                    type: { text: true },\n                                    displayName: 'Measure Units '\n                                },\n                                unitsColor: {\n                                    type: { fill: { solid: { color: true } } },\n                                    displayName: 'Units Color'\n                                },\n                            }\n                        }\n                    },\n                    dataViewMappings: [{\n                            conditions: [\n                                {\n                                    'Category': { max: 1 }, 'Value': { max: 1 }, 'TargetValue': { max: 1 }, 'Minimum': { max: 1 }, 'NeedsImprovement': { max: 1 },\n                                    'Satisfactory': { max: 1 }, 'Good': { max: 1 }, 'VeryGood': { max: 1 }, 'Maximum': { max: 1 }, 'TargetValue2': { max: 1 },\n                                },\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Category' },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: {\n                                    select: [\n                                        { bind: { to: 'Value' } },\n                                        { bind: { to: 'TargetValue' } },\n                                        { bind: { to: 'TargetValue2' } },\n                                        { bind: { to: 'Minimum' } },\n                                        { bind: { to: 'NeedsImprovement' } },\n                                        { bind: { to: 'Satisfactory' } },\n                                        { bind: { to: 'Good' } },\n                                        { bind: { to: 'VeryGood' } },\n                                        { bind: { to: 'Maximum' } },\n                                    ]\n                                },\n                            },\n                        }],\n                    supportsHighlight: true,\n                    sorting: {\n                        default: {},\n                    },\n                    drilldown: {\n                        roles: ['Category']\n                    }\n                };\n                return BulletChart;\n            }());\n            samples.BulletChart = BulletChart;\n            //TODO: This module should be removed once TextMeasruementService exports the \"estimateSvgTextBaselineDelta\" function.\n            var TextMeasurementHelper;\n            (function (TextMeasurementHelper) {\n                var spanElement;\n                var svgTextElement;\n                var canvasCtx;\n                function estimateSvgTextBaselineDelta(textProperties) {\n                    var rect = estimateSvgTextRect(textProperties);\n                    return rect.y + rect.height;\n                }\n                TextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;\n                function ensureDOM() {\n                    if (spanElement)\n                        return;\n                    spanElement = $('<span/>');\n                    $('body').append(spanElement);\n                    //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.\n                    svgTextElement = d3.select($('body').get(0))\n                        .append('svg')\n                        .style({\n                        'height': '0px',\n                        'width': '0px',\n                        'position': 'absolute'\n                    })\n                        .append('text');\n                    canvasCtx = $('<canvas/>').get(0).getContext(\"2d\");\n                }\n                function measureSvgTextRect(textProperties) {\n                    debug.assertValue(textProperties, 'textProperties');\n                    ensureDOM();\n                    svgTextElement.style(null);\n                    svgTextElement\n                        .text(textProperties.text)\n                        .attr({\n                        'visibility': 'hidden',\n                        'font-family': textProperties.fontFamily,\n                        'font-size': textProperties.fontSize,\n                        'font-weight': textProperties.fontWeight,\n                        'font-style': textProperties.fontStyle,\n                        'white-space': textProperties.whiteSpace || 'nowrap'\n                    });\n                    // We're expecting the browser to give a synchronous measurement here\n                    // We're using SVGTextElement because it works across all browsers \n                    return svgTextElement.node().getBBox();\n                }\n                function estimateSvgTextRect(textProperties) {\n                    debug.assertValue(textProperties, 'textProperties');\n                    var estimatedTextProperties = {\n                        fontFamily: textProperties.fontFamily,\n                        fontSize: textProperties.fontSize,\n                        text: \"M\",\n                    };\n                    var rect = measureSvgTextRect(estimatedTextProperties);\n                    return rect;\n                }\n            })(TextMeasurementHelper = samples.TextMeasurementHelper || (samples.TextMeasurementHelper = {}));\n            var BulletWebBehavior = (function () {\n                function BulletWebBehavior() {\n                }\n                BulletWebBehavior.prototype.bindEvents = function (options, selectionHandler) {\n                    this.options = options;\n                    var clearCatcher = options.clearCatcher;\n                    options.valueRects.on('click', function (d, i) {\n                        d3.event.stopPropagation();\n                        selectionHandler.handleSelection(d, d3.event.ctrlKey);\n                    });\n                    options.rects.on('click', function (d, i) {\n                        d3.event.stopPropagation();\n                        selectionHandler.handleSelection(d, d3.event.ctrlKey);\n                    });\n                    clearCatcher.on('click', function () {\n                        selectionHandler.handleClearSelection();\n                    });\n                };\n                BulletWebBehavior.prototype.renderSelection = function (hasSelection) {\n                    var options = this.options;\n                    options.valueRects.style(\"opacity\", function (d) {\n                        return hasSelection ? (d.selected ? '1' : '0.4') : '1';\n                    });\n                    options.rects.style(\"opacity\", function (d) {\n                        return hasSelection ? (d.selected ? '1' : '0.4') : '1';\n                    });\n                };\n                return BulletWebBehavior;\n            }());\n            samples.BulletWebBehavior = BulletWebBehavior;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/ https://github.com/jasondavies/d3-cloud\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var ValueFormatter = powerbi.visuals.valueFormatter;\n            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;\n            (function (WordCloudScaleType) {\n                WordCloudScaleType[WordCloudScaleType[\"logn\"] = 0] = \"logn\";\n                WordCloudScaleType[WordCloudScaleType[\"sqrt\"] = 1] = \"sqrt\";\n                WordCloudScaleType[WordCloudScaleType[\"value\"] = 2] = \"value\";\n            })(samples.WordCloudScaleType || (samples.WordCloudScaleType = {}));\n            var WordCloudScaleType = samples.WordCloudScaleType;\n            ;\n            var VisualLayout = (function () {\n                function VisualLayout(defaultViewport, defaultMargin) {\n                    this.defaultViewport = defaultViewport || { width: 0, height: 0 };\n                    this.defaultMargin = defaultMargin || { top: 0, bottom: 0, right: 0, left: 0 };\n                }\n                Object.defineProperty(VisualLayout.prototype, \"margin\", {\n                    get: function () {\n                        return this.marginValue || (this.margin = this.defaultMargin);\n                    },\n                    set: function (value) {\n                        this.marginValue = VisualLayout.restrictToMinMax(value);\n                        this.update();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(VisualLayout.prototype, \"viewport\", {\n                    get: function () {\n                        return this.viewportValue || (this.viewportValue = this.defaultViewport);\n                    },\n                    set: function (value) {\n                        this.viewportValue = VisualLayout.restrictToMinMax(value);\n                        this.update();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(VisualLayout.prototype, \"viewportIn\", {\n                    get: function () {\n                        return this.viewportInValue || this.viewport;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(VisualLayout.prototype, \"viewportInIsZero\", {\n                    get: function () {\n                        return this.viewportIn.width === 0 || this.viewportIn.height === 0;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                VisualLayout.prototype.update = function () {\n                    this.viewportInValue = VisualLayout.restrictToMinMax({\n                        width: this.viewport.width - (this.margin.left + this.margin.right),\n                        height: this.viewport.height - (this.margin.top + this.margin.bottom)\n                    });\n                };\n                VisualLayout.restrictToMinMax = function (value) {\n                    var result = $.extend({}, value);\n                    d3.keys(value).forEach(function (x) { return result[x] = Math.max(0, value[x]); });\n                    return result;\n                };\n                return VisualLayout;\n            }());\n            var WordCloud = (function () {\n                function WordCloud(options) {\n                    this.durationAnimations = 500;\n                    this.fakeViewport = {\n                        width: 1500,\n                        height: 1000\n                    };\n                    this.canvasViewport = {\n                        width: 128,\n                        height: 2048\n                    };\n                    if (options) {\n                        this.svg = options.svg || this.svg;\n                        this.layout = new VisualLayout(null, options.margin || WordCloud.DefaultMargin);\n                        if (options.animator)\n                            this.animator = options.animator;\n                    }\n                }\n                WordCloud.prototype.init = function (options) {\n                    var _this = this;\n                    if (this.svg)\n                        this.root = this.svg;\n                    else\n                        this.root = d3.select(options.element.get(0)).append(\"svg\");\n                    WordCloud.colors = options.style.colorPalette.dataColors;\n                    this.hostService = options.host;\n                    this.selectionManager = new visuals.utility.SelectionManager({ hostServices: this.hostService });\n                    if (!this.layout)\n                        this.layout = new VisualLayout(null, WordCloud.DefaultMargin);\n                    this.root.classed(WordCloud.ClassName, true);\n                    this.root.on(\"click\", function () {\n                        _this.selectionManager.clear();\n                        _this.setSelection(_this.wordsSelection);\n                    });\n                    this.fontFamily = this.root.style(\"font-family\");\n                    this.main = this.root.append(\"g\");\n                    this.wordsContainerSelection = this.main\n                        .append(\"g\")\n                        .classed(WordCloud.Words[\"class\"], true);\n                    this.canvas = document.createElement(\"canvas\");\n                };\n                WordCloud.prototype.converter = function (dataView) {\n                    var _this = this;\n                    if (!dataView ||\n                        !dataView.categorical ||\n                        !dataView.categorical.categories ||\n                        !dataView.categorical.categories[0] ||\n                        !dataView.categorical.categories[0].values ||\n                        !dataView.categorical.categories[0].values.length ||\n                        !(dataView.categorical.categories[0].values.length > 0))\n                        return null;\n                    var categories = dataView.categorical.categories[0].values, settings = WordCloud.parseSettings(dataView, categories[0]), frequencies, texts;\n                    if (!settings)\n                        return null;\n                    if (!_.isEmpty(dataView.categorical.values) &&\n                        !_.isEmpty(dataView.categorical.values[0]) &&\n                        !_.isEmpty(dataView.categorical.values[0].values))\n                        frequencies = dataView.categorical.values[0].values;\n                    texts = categories.map(function (item, index) {\n                        var color, categoryObject = dataView.categorical.categories[0];\n                        if (categoryObject.objects && categoryObject.objects[index])\n                            color = _this.getColor(WordCloud.Properties.dataPoint.fill, explore.util.getRandomColor(), categoryObject.objects[index]);\n                        else {\n                            if (_this.wordCloudTexts && _this.wordCloudTexts[index])\n                                color = _this.wordCloudTexts[index].color;\n                            else\n                                color = explore.util.getRandomColor();\n                        }\n                        return {\n                            text: item,\n                            count: (frequencies && frequencies[index] && !isNaN(frequencies[index])) ? frequencies[index] : 1,\n                            index: index,\n                            selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[index]),\n                            color: color,\n                        };\n                    });\n                    return {\n                        settings: settings,\n                        texts: texts\n                    };\n                };\n                WordCloud.prototype.getColor = function (properties, defaultColor, objects) {\n                    var colorHelper;\n                    colorHelper = new visuals.ColorHelper(WordCloud.colors, properties, defaultColor);\n                    return explore.util.hexToRgb(colorHelper.getColorForMeasure(objects, \"\"));\n                };\n                WordCloud.parseSettings = function (dataView, value) {\n                    if (!dataView ||\n                        !dataView.metadata ||\n                        !dataView.metadata.columns ||\n                        !dataView.metadata.columns[0])\n                        return null;\n                    var objects = dataView.metadata.objects, valueFormatter, minFontSize, maxFontSize, minAngle, maxAngle, maxNumberOfOrientations, isRotateText = false, isBrokenText = true, isRemoveStopWords = true, stopWords, stopWordsArray, isDefaultStopWords = false, maxNumberOfWords;\n                    maxNumberOfWords = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords);\n                    minFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.minFontSize, WordCloud.DefaultSettings.minFontSize);\n                    maxFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxFontSize, WordCloud.DefaultSettings.maxFontSize);\n                    minAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.minAngle, WordCloud.DefaultSettings.minAngle);\n                    maxAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxAngle, WordCloud.DefaultSettings.maxAngle);\n                    isRotateText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.rotateText.show, WordCloud.DefaultSettings.isRotateText);\n                    maxNumberOfOrientations = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxNumberOfOrientations, WordCloud.DefaultSettings.maxNumberOfOrientations);\n                    valueFormatter = ValueFormatter.create({\n                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, WordCloud.Properties.general.formatString),\n                        value: value\n                    });\n                    isBrokenText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.general.isBrokenText, WordCloud.DefaultSettings.isBrokenText);\n                    isRemoveStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.show, WordCloud.DefaultSettings.isRemoveStopWords);\n                    stopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.words, WordCloud.DefaultSettings.stopWords);\n                    if (typeof stopWords === \"string\")\n                        stopWordsArray = stopWords.split(WordCloud.StopWordsDelemiter);\n                    else\n                        stopWordsArray = WordCloud.DefaultSettings.stopWordsArray;\n                    isDefaultStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.isDefaultStopWords, WordCloud.DefaultSettings.isDefaultStopWords);\n                    return {\n                        minFontSize: minFontSize,\n                        maxFontSize: maxFontSize,\n                        minAngle: minAngle,\n                        maxAngle: maxAngle,\n                        maxNumberOfOrientations: maxNumberOfOrientations,\n                        valueFormatter: valueFormatter,\n                        isRotateText: isRotateText,\n                        isBrokenText: isBrokenText,\n                        isRemoveStopWords: isRemoveStopWords,\n                        stopWords: stopWords,\n                        stopWordsArray: stopWordsArray,\n                        isDefaultStopWords: isDefaultStopWords,\n                        maxNumberOfWords: maxNumberOfWords\n                    };\n                };\n                WordCloud.getNumberFromObjects = function (objects, properties, defaultValue) {\n                    return objects ? powerbi.DataViewObjects.getValue(objects, properties, defaultValue) : defaultValue;\n                };\n                WordCloud.prototype.parseNumber = function (value, defaultValue, minValue, maxValue) {\n                    if (defaultValue === void 0) { defaultValue = 0; }\n                    if (minValue === void 0) { minValue = -Number.MAX_VALUE; }\n                    if (maxValue === void 0) { maxValue = Number.MAX_VALUE; }\n                    var parsedValue = Number(value);\n                    if (isNaN(parsedValue) || (typeof value === \"string\" && value.length === 0))\n                        return defaultValue;\n                    if (parsedValue < minValue)\n                        return minValue;\n                    if (parsedValue > maxValue)\n                        return maxValue;\n                    return parsedValue;\n                };\n                WordCloud.prototype.computePositions = function (words, onPositionsComputed) {\n                    var _this = this;\n                    var context = this.getCanvasContext(), surface = [], borders = null, maxNumberOfWords;\n                    if (!words || !(words.length > 0))\n                        return null;\n                    maxNumberOfWords = Math.abs(this.parseNumber(this.settings.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords, words.length * -1, words.length));\n                    if (words.length > maxNumberOfWords)\n                        words = words.slice(0, maxNumberOfWords);\n                    for (var i = void 0; i < (this.specialViewport.width >> 5) * this.specialViewport.height; i++) {\n                        surface[i] = 0;\n                    }\n                    setTimeout(function () { return _this.computeCycle(words, context, surface, borders, onPositionsComputed, [], 0); }, 0);\n                };\n                WordCloud.prototype.computeCycle = function (words, context, surface, borders, onPositionsComputed, wordsForDraw, index) {\n                    if (wordsForDraw === void 0) { wordsForDraw = []; }\n                    if (index === void 0) { index = 0; }\n                    var word = words[index], ratio = 1;\n                    if (words.length <= 10)\n                        ratio = 5;\n                    else if (words.length <= 25)\n                        ratio = 3;\n                    else if (words.length <= 75)\n                        ratio = 1.5;\n                    else if (words.length <= 100)\n                        ratio = 1.25;\n                    word.x = (this.specialViewport.width / ratio * (Math.random() + 0.5)) >> 1;\n                    word.y = (this.specialViewport.height / ratio * (Math.random() + 0.5)) >> 1;\n                    this.generateSprites(context, word, words, index);\n                    if (word.sprite && this.findPosition(surface, word, borders)) {\n                        wordsForDraw.push(word);\n                        borders = this.updateBorders(word, borders);\n                        word.x -= this.specialViewport.width >> 1;\n                        word.y -= this.specialViewport.height >> 1;\n                    }\n                    if (++index < words.length && this.root)\n                        this.computeCycle(words, context, surface, borders, onPositionsComputed, wordsForDraw, index);\n                    else {\n                        onPositionsComputed({\n                            data: wordsForDraw,\n                            leftBorder: borders && borders[0],\n                            rightBorder: borders && borders[1]\n                        });\n                    }\n                };\n                WordCloud.prototype.updateBorders = function (word, borders) {\n                    if (borders && borders.length === 2) {\n                        var leftBorder = borders[0], rightBorder = borders[1];\n                        if (word.x + word.x0 < leftBorder.x)\n                            leftBorder.x = word.x + word.x0;\n                        if (word.y + word.y0 < leftBorder.y)\n                            leftBorder.y = word.y + word.y0;\n                        if (word.x + word.x1 > rightBorder.x)\n                            rightBorder.x = word.x + word.x1;\n                        if (word.y + word.y1 > rightBorder.y)\n                            rightBorder.y = word.y + word.y1;\n                    }\n                    else {\n                        borders = [\n                            {\n                                x: word.x + word.x0,\n                                y: word.y + word.y0\n                            }, {\n                                x: word.x + word.x1,\n                                y: word.y + word.y1\n                            }\n                        ];\n                    }\n                    return borders;\n                };\n                WordCloud.prototype.generateSprites = function (context, currentWord, words, index) {\n                    if (currentWord.sprite)\n                        return;\n                    context.clearRect(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height);\n                    var x = 0, y = 0, maxHeight = 0, quantityOfWords = words.length, pixels, sprite = [];\n                    for (var i = index; i < quantityOfWords; i++) {\n                        var currentWordData = words[i], widthOfWord = 0, heightOfWord = 0;\n                        context.save();\n                        context.font = \"normal normal \" + (currentWordData.size + 1) + WordCloud.Size + \" \" + this.fontFamily;\n                        widthOfWord = context.measureText(currentWordData.text + \"m\").width;\n                        heightOfWord = currentWordData.size << 1;\n                        if (currentWordData.rotate) {\n                            var sr = Math.sin(currentWordData.rotate * WordCloud.Radians), cr = Math.cos(currentWordData.rotate * WordCloud.Radians), widthCr = widthOfWord * cr, widthSr = widthOfWord * sr, heightCr = heightOfWord * cr, heightSr = heightOfWord * sr;\n                            widthOfWord = (Math.max(Math.abs(widthCr + heightSr), Math.abs(widthCr - heightSr)) + 31) >> 5 << 5;\n                            heightOfWord = Math.floor(Math.max(Math.abs(widthSr + heightCr), Math.abs(widthSr - heightCr)));\n                        }\n                        else\n                            widthOfWord = (widthOfWord + 31) >> 5 << 5;\n                        if (heightOfWord > maxHeight)\n                            maxHeight = heightOfWord;\n                        if (x + widthOfWord >= (this.canvasViewport.width << 5)) {\n                            x = 0;\n                            y += maxHeight;\n                            maxHeight = 0;\n                        }\n                        context.translate((x + (widthOfWord >> 1)), (y + (heightOfWord >> 1)));\n                        if (currentWordData.rotate)\n                            context.rotate(currentWordData.rotate * WordCloud.Radians);\n                        context.fillText(currentWordData.text, 0, 0);\n                        if (currentWordData.padding) {\n                            context.lineWidth = 2 * currentWordData.padding;\n                            context.strokeText(currentWordData.text, 0, 0);\n                        }\n                        context.restore();\n                        currentWordData.width = widthOfWord;\n                        currentWordData.height = heightOfWord;\n                        currentWordData.xOff = x;\n                        currentWordData.yOff = y;\n                        currentWordData.x1 = widthOfWord >> 1;\n                        currentWordData.y1 = heightOfWord >> 1;\n                        currentWordData.x0 = -currentWordData.x1;\n                        currentWordData.y0 = -currentWordData.y1;\n                        x += widthOfWord;\n                    }\n                    pixels = context.getImageData(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height).data;\n                    sprite = [];\n                    for (var i = quantityOfWords - 1; i >= 0; i--) {\n                        var currentWordData = words[i], width = currentWordData.width, width32 = width >> 5, height = currentWordData.y1 - currentWordData.y0, x_1 = 0, y_1 = 0, seen = 0, seenRow = 0;\n                        if (currentWordData.xOff + width >= (this.canvasViewport.width << 5) ||\n                            currentWordData.yOff + height >= this.canvasViewport.height) {\n                            currentWordData.sprite = null;\n                            continue;\n                        }\n                        for (var j = 0; j < height * width32; j++) {\n                            sprite[j] = 0;\n                        }\n                        if (currentWordData.xOff !== null)\n                            x_1 = currentWordData.xOff;\n                        else\n                            return;\n                        y_1 = currentWordData.yOff;\n                        seen = 0;\n                        seenRow = -1;\n                        for (var j = 0; j < height; j++) {\n                            for (var k = 0; k < width; k++) {\n                                var l = width32 * j + (k >> 5), index_1 = ((y_1 + j) * (this.canvasViewport.width << 5) + (x_1 + k)) << 2, m = pixels[index_1]\n                                    ? 1 << (31 - (k % 32))\n                                    : 0;\n                                sprite[l] |= m;\n                                seen |= m;\n                            }\n                            if (seen)\n                                seenRow = j;\n                            else {\n                                currentWordData.y0++;\n                                height--;\n                                j--;\n                                y_1++;\n                            }\n                        }\n                        currentWordData.y1 = currentWordData.y0 + seenRow;\n                        currentWordData.sprite = sprite.slice(0, (currentWordData.y1 - currentWordData.y0) * width32);\n                    }\n                };\n                WordCloud.prototype.findPosition = function (surface, word, borders) {\n                    var startPoint = { x: word.x, y: word.y }, delta = Math.sqrt(this.specialViewport.width * this.specialViewport.width + this.specialViewport.height * this.specialViewport.height), point, dt = Math.random() < 0.5 ? 1 : -1, shift = -dt, dx, dy;\n                    while (true) {\n                        shift += dt;\n                        point = this.archimedeanSpiral(shift);\n                        dx = Math.floor(point.x);\n                        dy = Math.floor(point.y);\n                        if (Math.min(Math.abs(dx), Math.abs(dy)) >= delta)\n                            break;\n                        word.x = startPoint.x + dx;\n                        word.y = startPoint.y + dy;\n                        if (word.x + word.x0 < 0 ||\n                            word.y + word.y0 < 0 ||\n                            word.x + word.x1 > this.specialViewport.width ||\n                            word.y + word.y1 > this.specialViewport.height)\n                            continue;\n                        if (!borders || !this.checkIntersect(word, surface)) {\n                            if (!borders || this.checkIntersectOfRectangles(word, borders[0], borders[1])) {\n                                var sprite = word.sprite, width = word.width >> 5, shiftWidth = this.specialViewport.width >> 5, lx = word.x - (width << 4), sx = lx & 127, msx = 32 - sx, height = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5);\n                                for (var i = 0; i < height; i++) {\n                                    var lastSprite = 0;\n                                    for (var j = 0; j <= width; j++) {\n                                        var leftMask = lastSprite << msx, rightMask = void 0;\n                                        if (j < width)\n                                            lastSprite = sprite[i * width + j];\n                                        rightMask = j < width\n                                            ? lastSprite >>> sx\n                                            : 0;\n                                        surface[x + j] |= leftMask | rightMask;\n                                    }\n                                    x += shiftWidth;\n                                }\n                                word.sprite = null;\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                };\n                WordCloud.prototype.archimedeanSpiral = function (value) {\n                    var ratio = this.specialViewport.width / this.specialViewport.height;\n                    value = value * 0.1;\n                    return {\n                        x: ratio * value * Math.cos(value),\n                        y: value * Math.sin(value)\n                    };\n                };\n                WordCloud.prototype.checkIntersect = function (word, surface) {\n                    var shiftWidth = this.specialViewport.width >> 5, sprite = word.sprite, widthOfWord = word.width >> 5, lx = word.x - (widthOfWord << 4), sx = lx & 127, msx = 32 - sx, heightOfWord = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5);\n                    for (var i = 0; i < heightOfWord; i++) {\n                        var lastSprite = 0;\n                        for (var j = 0; j <= widthOfWord; j++) {\n                            var mask = 0, leftMask = void 0, intersectMask = 0;\n                            leftMask = lastSprite << msx;\n                            if (j < widthOfWord)\n                                lastSprite = sprite[i * widthOfWord + j];\n                            mask = j < widthOfWord\n                                ? lastSprite >>> sx\n                                : 0;\n                            intersectMask = (leftMask | mask) & surface[x + j];\n                            if (intersectMask)\n                                return true;\n                        }\n                        x += shiftWidth;\n                    }\n                    return false;\n                };\n                WordCloud.prototype.checkIntersectOfRectangles = function (word, leftBorder, rightBorder) {\n                    return (word.x + word.x1) > leftBorder.x &&\n                        (word.x + word.x0) < rightBorder.x &&\n                        (word.y + word.y1) > leftBorder.y &&\n                        (word.y + word.y0) < rightBorder.y;\n                };\n                WordCloud.prototype.getCanvasContext = function () {\n                    if (!this.canvasViewport)\n                        return null;\n                    this.canvas.width = 1;\n                    this.canvas.height = 1;\n                    var context = this.canvas.getContext(\"2d\");\n                    this.canvas.width = this.canvasViewport.width << 5;\n                    this.canvas.height = this.canvasViewport.height;\n                    context = this.canvas.getContext(\"2d\");\n                    context.fillStyle = context.strokeStyle = \"red\";\n                    context.textAlign = \"center\";\n                    return context;\n                };\n                WordCloud.prototype.getReducedText = function (texts) {\n                    var brokenStrings = [];\n                    brokenStrings = this.getBrokenWords(texts);\n                    return brokenStrings.reduce(function (previousValue, currentValue) {\n                        if (!previousValue.some(function (value) {\n                            if (value.index !== currentValue.index && value.text === currentValue.text) {\n                                value.count += currentValue.count;\n                                return true;\n                            }\n                            return false;\n                        })) {\n                            previousValue.push(currentValue);\n                        }\n                        return previousValue;\n                    }, []);\n                };\n                WordCloud.prototype.getBrokenWords = function (words) {\n                    var _this = this;\n                    var brokenStrings = [], whiteSpaceRegExp = /\\s/, punctuatuinRegExp;\n                    if (!this.settings.isBrokenText)\n                        return words;\n                    punctuatuinRegExp = new RegExp(\"[\" + WordCloud.Punctuation.join(\"\\\\\") + \"]\", \"gim\");\n                    words.forEach(function (item) {\n                        if (typeof item.text === \"string\") {\n                            var words_1;\n                            words_1 = item.text.replace(punctuatuinRegExp, \" \").split(whiteSpaceRegExp);\n                            if (_this.settings.isRemoveStopWords) {\n                                var stopWords_1 = _this.settings.stopWordsArray;\n                                if (_this.settings.isDefaultStopWords)\n                                    stopWords_1 = stopWords_1.concat(WordCloud.StopWords);\n                                words_1 = words_1.filter(function (value) {\n                                    return value.length > 0 && !stopWords_1.some(function (removeWord) {\n                                        return value.toLocaleLowerCase() === removeWord.toLocaleLowerCase();\n                                    });\n                                });\n                            }\n                            words_1.forEach(function (element) {\n                                if (element.length > 0 && !whiteSpaceRegExp.test(element)) {\n                                    brokenStrings.push({\n                                        text: element,\n                                        count: item.count,\n                                        index: item.index,\n                                        selectionId: item.selectionId,\n                                        color: item.color\n                                    });\n                                }\n                            });\n                        }\n                        else\n                            brokenStrings.push(item);\n                    });\n                    return brokenStrings;\n                };\n                WordCloud.prototype.getWords = function (values) {\n                    var _this = this;\n                    var sortedValues, minValue = 0, maxValue = 0, valueFormatter = this.settings.valueFormatter;\n                    if (!values || !(values.length >= 1))\n                        return [];\n                    sortedValues = values.sort(function (a, b) {\n                        return b.count - a.count;\n                    });\n                    minValue = sortedValues[sortedValues.length - 1].count;\n                    maxValue = sortedValues[0].count;\n                    var returnValues = values.map(function (value) {\n                        return {\n                            text: valueFormatter.format(value.text),\n                            size: _this.getFontSize(value.count, minValue, maxValue),\n                            x: 0,\n                            y: 0,\n                            rotate: _this.getAngle(),\n                            padding: 1,\n                            width: 0,\n                            height: 0,\n                            xOff: 0,\n                            yOff: 0,\n                            x0: 0,\n                            y0: 0,\n                            x1: 0,\n                            y1: 0,\n                            color: value.color,\n                            selectionId: value.selectionId,\n                            wordIndex: value.index\n                        };\n                    });\n                    this.dataBeforeRender = returnValues;\n                    return returnValues;\n                };\n                WordCloud.prototype.getFontSize = function (value, minValue, maxValue, scaleType) {\n                    if (scaleType === void 0) { scaleType = WordCloudScaleType.value; }\n                    var weight, fontSize, maxFontSize, minFontSize;\n                    minFontSize = Math.abs(this.parseNumber(this.settings.minFontSize, WordCloud.DefaultSettings.minFontSize));\n                    maxFontSize = Math.abs(this.parseNumber(this.settings.maxFontSize, WordCloud.DefaultSettings.maxFontSize));\n                    if (minFontSize > maxFontSize) {\n                        var buffer = minFontSize;\n                        minFontSize = maxFontSize;\n                        maxFontSize = buffer;\n                    }\n                    switch (scaleType) {\n                        case WordCloudScaleType.logn: {\n                            weight = Math.log(value);\n                        }\n                        case WordCloudScaleType.sqrt: {\n                            weight = Math.sqrt(value);\n                        }\n                        case WordCloudScaleType.value: {\n                            weight = value;\n                        }\n                    }\n                    fontSize = weight > minValue\n                        ? (maxFontSize * (weight - minValue)) / (maxValue - minValue)\n                        : 0;\n                    fontSize = (fontSize * 100) / maxFontSize;\n                    fontSize = (fontSize * (maxFontSize - minFontSize)) / 100 + minFontSize;\n                    return fontSize;\n                };\n                WordCloud.prototype.getAngle = function () {\n                    if (!this.settings ||\n                        !this.settings.isRotateText)\n                        return 0;\n                    var minAngle, maxAngle, maxNumberOfOrientations, angle;\n                    maxNumberOfOrientations = Math.abs(this.parseNumber(this.settings.maxNumberOfOrientations, 0));\n                    minAngle = this.parseNumber(this.settings.minAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle);\n                    maxAngle = this.parseNumber(this.settings.maxAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle);\n                    if (minAngle > maxAngle) {\n                        var buffer = minAngle;\n                        minAngle = maxAngle;\n                        maxAngle = buffer;\n                    }\n                    angle = Math.abs(((maxAngle - minAngle) / maxNumberOfOrientations) * Math.floor(Math.random() * maxNumberOfOrientations));\n                    return maxNumberOfOrientations !== 0 ? minAngle + angle : 0;\n                };\n                WordCloud.prototype.update = function (visualUpdateOptions) {\n                    var _this = this;\n                    if (!visualUpdateOptions ||\n                        !visualUpdateOptions.viewport ||\n                        !visualUpdateOptions.dataViews ||\n                        !visualUpdateOptions.dataViews[0] ||\n                        !visualUpdateOptions.viewport ||\n                        !(visualUpdateOptions.viewport.height >= 0) ||\n                        !(visualUpdateOptions.viewport.width >= 0))\n                        return;\n                    this.visualUpdateOptions = visualUpdateOptions;\n                    this.layout.viewport = this.visualUpdateOptions.viewport;\n                    var dataView = visualUpdateOptions.dataViews[0];\n                    if (this.layout.viewportInIsZero)\n                        return;\n                    this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);\n                    this.UpdateSize();\n                    this.data = this.converter(dataView);\n                    if (!this.data)\n                        return;\n                    this.settings = this.data.settings;\n                    this.wordCloudTexts = this.data.texts;\n                    this.computePositions(this.getWords(this.getReducedText(this.data.texts)), function (wordCloudDataView) { return _this.render(wordCloudDataView); });\n                    if (visualUpdateOptions !== this.visualUpdateOptions)\n                        this.update(this.visualUpdateOptions);\n                };\n                WordCloud.prototype.UpdateSize = function () {\n                    var fakeWidth, fakeHeight, ratio;\n                    ratio = Math.sqrt((this.fakeViewport.width * this.fakeViewport.height)\n                        / (this.layout.viewportIn.width * this.layout.viewportIn.height));\n                    if (isNaN(ratio))\n                        fakeHeight = fakeWidth = 1;\n                    else {\n                        fakeHeight = this.layout.viewportIn.height * ratio;\n                        fakeWidth = this.layout.viewportIn.width * ratio;\n                    }\n                    this.specialViewport = {\n                        height: fakeHeight,\n                        width: fakeWidth\n                    };\n                    this.root.attr({\n                        \"height\": this.layout.viewport.height,\n                        \"width\": this.layout.viewport.width\n                    });\n                };\n                WordCloud.prototype.render = function (wordCloudDataView) {\n                    var _this = this;\n                    if (!wordCloudDataView ||\n                        !wordCloudDataView.data)\n                        return;\n                    this.wordCloudDataView = wordCloudDataView;\n                    var animatedWordSelection, wordElements = this.main\n                        .select(WordCloud.Words.selector)\n                        .selectAll(WordCloud.Word.selector);\n                    this.wordsSelection = wordElements.data(wordCloudDataView.data);\n                    this.animation(this.wordsSelection, this.durationAnimations)\n                        .attr(\"transform\", function (item) { return (visuals.SVGUtil.translate(item.x, item.y) + \"rotate(\" + item.rotate + \")\"); })\n                        .style({\n                        \"font-size\": (function (item) { return (\"\" + item.size + WordCloud.Size); }),\n                        \"fill\": (function (item) { return item.color; }),\n                    });\n                    animatedWordSelection = this.wordsSelection\n                        .enter()\n                        .append(\"svg:text\")\n                        .attr(\"transform\", function (item) { return (visuals.SVGUtil.translate(item.x, item.y) + \"rotate(\" + item.rotate + \")\"); })\n                        .style(\"font-size\", \"1px\");\n                    this.wordsSelection.on(\"click\", function (item) {\n                        _this.selectionManager\n                            .select(item.selectionId, d3.event.ctrlKey)\n                            .then(function () { return _this.setSelection(_this.wordsSelection); });\n                        d3.event.stopPropagation();\n                    });\n                    this.animation(animatedWordSelection, this.durationAnimations)\n                        .style({\n                        \"font-size\": (function (item) { return (\"\" + item.size + WordCloud.Size); }),\n                        \"fill\": (function (item) { return item.color; }),\n                    });\n                    this.wordsSelection\n                        .text(function (item) { return item.text; })\n                        .classed(WordCloud.Word[\"class\"], true);\n                    this.wordsSelection.exit().remove();\n                    this.setSelection(this.wordsSelection);\n                    setTimeout(function () {\n                        if (_this.root)\n                            _this.scaleMainView(wordCloudDataView, wordElements[0].length && _this.durationAnimations);\n                    }, this.durationAnimations + WordCloud.RenderDelay);\n                };\n                WordCloud.prototype.setSelection = function (selection) {\n                    var selectionIds = this.selectionManager.getSelectionIds();\n                    if (selectionIds.some(function (x) { return !selection.data().some(function (d) { return d.selectionId.getKey() === x.getKey(); }); })) {\n                        this.selectionManager.clear();\n                        selectionIds = [];\n                    }\n                    if (!selectionIds.length) {\n                        this.setOpacity(selection, WordCloud.MaxOpacity, true);\n                        return;\n                    }\n                    var selectedColumns = selection.filter(function (x) {\n                        return selectionIds.some(function (y) { return y.getKey() === x.selectionId.getKey(); });\n                    });\n                    this.setOpacity(selection, WordCloud.MinOpacity);\n                    this.setOpacity(selectedColumns, WordCloud.MaxOpacity);\n                };\n                WordCloud.prototype.setOpacity = function (element, opacityValue, disableAnimation) {\n                    if (disableAnimation === void 0) { disableAnimation = false; }\n                    var elementAnimation = disableAnimation ? element : this.animation(element);\n                    elementAnimation.style(\"fill-opacity\", opacityValue);\n                };\n                WordCloud.prototype.scaleMainView = function (wordCloudDataView, durationAnimation) {\n                    if (durationAnimation === void 0) { durationAnimation = 0; }\n                    if (!wordCloudDataView ||\n                        !wordCloudDataView.leftBorder ||\n                        !wordCloudDataView.rightBorder)\n                        return;\n                    var scale = 1, mainSVGRect = this.main.node()[\"getBBox\"](), leftBorder = wordCloudDataView.leftBorder, rightBorder = wordCloudDataView.rightBorder, width2, height2, scaleByX, scaleByY;\n                    scaleByX = this.layout.viewportIn.width / Math.abs(leftBorder.x - rightBorder.x);\n                    scaleByY = this.layout.viewportIn.height / Math.abs(leftBorder.y - rightBorder.y);\n                    scale = Math.min(scaleByX, scaleByY);\n                    width2 = this.layout.margin.left + (mainSVGRect.x * scale * -1)\n                        + (this.layout.viewportIn.width - (mainSVGRect.width * scale)) / 2;\n                    height2 = this.layout.margin.top + (mainSVGRect.y * scale * -1)\n                        + (this.layout.viewportIn.height - (mainSVGRect.height * scale)) / 2;\n                    this.animation(this.main, durationAnimation)\n                        .attr(\"transform\", visuals.SVGUtil.translate(width2, height2) + \"scale(\" + scale + \")\");\n                };\n                WordCloud.prototype.enumerateObjectInstances = function (options) {\n                    var _this = this;\n                    var instances = [];\n                    if (!this.settings)\n                        return instances;\n                    switch (options.objectName) {\n                        case \"general\": {\n                            var general = {\n                                objectName: \"general\",\n                                displayName: \"general\",\n                                selector: null,\n                                properties: {\n                                    maxNumberOfWords: this.settings.maxNumberOfWords,\n                                    minFontSize: this.settings.minFontSize,\n                                    maxFontSize: this.settings.maxFontSize,\n                                    isBrokenText: this.settings.isBrokenText\n                                }\n                            };\n                            instances.push(general);\n                            break;\n                        }\n                        case \"dataPoint\": {\n                            if (!this.wordCloudDataView ||\n                                !this.wordCloudDataView.data)\n                                return;\n                            var dataPoints = this.dataBeforeRender;\n                            var wordCategoriesIndex_1 = [];\n                            dataPoints.forEach(function (item) {\n                                if (wordCategoriesIndex_1.indexOf(item.wordIndex) === -1) {\n                                    wordCategoriesIndex_1.push(item.wordIndex);\n                                    instances.push({\n                                        objectName: \"dataPoint\",\n                                        displayName: _this.data.texts[item.wordIndex].text,\n                                        selector: visuals.ColorHelper.normalizeSelector(item.selectionId.getSelector(), false),\n                                        properties: {\n                                            fill: { solid: { color: item.color } }\n                                        }\n                                    });\n                                }\n                            });\n                            break;\n                        }\n                        case \"rotateText\": {\n                            var rotateText = {\n                                objectName: \"rotateText\",\n                                displayName: \"Rotate Text\",\n                                selector: null,\n                                properties: {\n                                    show: this.settings.isRotateText,\n                                    minAngle: this.settings.minAngle,\n                                    maxAngle: this.settings.maxAngle,\n                                    maxNumberOfOrientations: this.settings.maxNumberOfOrientations\n                                }\n                            };\n                            instances.push(rotateText);\n                            break;\n                        }\n                        case \"stopWords\": {\n                            var stopWords = {\n                                objectName: \"stopWords\",\n                                displayName: \"Stop Words\",\n                                selector: null,\n                                properties: {\n                                    show: this.settings.isRemoveStopWords,\n                                    isDefaultStopWords: this.settings.isDefaultStopWords,\n                                    words: this.settings.stopWords ||\n                                        this.settings.stopWordsArray.join(WordCloud.StopWordsDelemiter)\n                                }\n                            };\n                            instances.push(stopWords);\n                            break;\n                        }\n                    }\n                    return instances;\n                };\n                WordCloud.prototype.animation = function (element, duration, callback) {\n                    if (duration === void 0) { duration = 0; }\n                    return element\n                        .transition()\n                        .duration(duration)\n                        .each(\"end\", callback);\n                };\n                WordCloud.prototype.destroy = function () {\n                    this.root = null;\n                    this.canvas = null;\n                };\n                WordCloud.ClassName = \"wordCloud\";\n                WordCloud.Properties = {\n                    general: {\n                        formatString: {\n                            objectName: \"general\",\n                            propertyName: \"formatString\"\n                        },\n                        maxNumberOfWords: {\n                            objectName: \"general\",\n                            propertyName: \"maxNumberOfWords\"\n                        },\n                        minFontSize: {\n                            objectName: \"general\",\n                            propertyName: \"minFontSize\"\n                        },\n                        maxFontSize: {\n                            objectName: \"general\",\n                            propertyName: \"maxFontSize\"\n                        },\n                        isBrokenText: {\n                            objectName: \"general\",\n                            propertyName: \"isBrokenText\"\n                        },\n                    },\n                    dataPoint: {\n                        fill: {\n                            objectName: \"dataPoint\",\n                            propertyName: \"fill\"\n                        }\n                    },\n                    stopWords: {\n                        show: {\n                            objectName: \"stopWords\",\n                            propertyName: \"show\"\n                        },\n                        isDefaultStopWords: {\n                            objectName: \"stopWords\",\n                            propertyName: \"isDefaultStopWords\"\n                        },\n                        words: {\n                            objectName: \"stopWords\",\n                            propertyName: \"words\"\n                        },\n                    },\n                    rotateText: {\n                        show: {\n                            objectName: \"rotateText\",\n                            propertyName: \"show\"\n                        },\n                        minAngle: {\n                            objectName: \"rotateText\",\n                            propertyName: \"minAngle\"\n                        },\n                        maxAngle: {\n                            objectName: \"rotateText\",\n                            propertyName: \"maxAngle\"\n                        },\n                        maxNumberOfOrientations: {\n                            objectName: \"rotateText\",\n                            propertyName: \"maxNumberOfOrientations\"\n                        }\n                    }\n                };\n                WordCloud.Words = {\n                    \"class\": \"words\",\n                    selector: \".words\"\n                };\n                WordCloud.Word = {\n                    \"class\": \"word\",\n                    selector: \".word\"\n                };\n                WordCloud.Size = \"px\";\n                WordCloud.StopWordsDelemiter = \" \";\n                WordCloud.Radians = Math.PI / 180;\n                WordCloud.MinAngle = -180;\n                WordCloud.MaxAngle = 180;\n                WordCloud.MaxNumberOfWords = 2500;\n                WordCloud.MinOpacity = 0.2;\n                WordCloud.MaxOpacity = 1;\n                WordCloud.capabilities = {\n                    dataRoles: [{\n                            name: \"Category\",\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: \"Category\"\n                        }, {\n                            name: \"Values\",\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: \"Values\"\n                        }],\n                    dataViewMappings: [{\n                            conditions: [{\n                                    \"Category\": {\n                                        min: 1,\n                                        max: 1\n                                    },\n                                    \"Values\": {\n                                        min: 0,\n                                        max: 1\n                                    }\n                                }],\n                            categorical: {\n                                categories: {\n                                    for: { in: \"Category\" },\n                                    dataReductionAlgorithm: { top: { count: WordCloud.MaxNumberOfWords } }\n                                },\n                                values: {\n                                    for: { in: \"Values\" }\n                                }\n                            }\n                        }],\n                    sorting: {\n                        implicit: {\n                            clauses: [{\n                                    role: \"Values\",\n                                    direction: 2 /*SortDirection.Descending*/ //Constant SortDirection.Descending currently is not supported on the msit\n                                }]\n                        }\n                    },\n                    objects: {\n                        general: {\n                            displayName: \"General\",\n                            properties: {\n                                formatString: {\n                                    type: {\n                                        formatting: {\n                                            formatString: true\n                                        }\n                                    }\n                                },\n                                maxNumberOfWords: {\n                                    displayName: \"Max number of words\",\n                                    type: { numeric: true }\n                                },\n                                minFontSize: {\n                                    displayName: \"Min Font\",\n                                    type: { numeric: true }\n                                },\n                                maxFontSize: {\n                                    displayName: \"Max Font\",\n                                    type: { numeric: true }\n                                },\n                                isBrokenText: {\n                                    displayName: \"Word-breaking\",\n                                    type: { bool: true }\n                                },\n                                isRemoveStopWords: {\n                                    displayName: \"Stop Words\",\n                                    type: { bool: true }\n                                }\n                            }\n                        },\n                        dataPoint: {\n                            displayName: \"Data colors\",\n                            properties: {\n                                fill: {\n                                    displayName: \"Fill\",\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        stopWords: {\n                            displayName: \"Stop Words\",\n                            properties: {\n                                show: {\n                                    displayName: \"Show\",\n                                    type: { bool: true }\n                                },\n                                isDefaultStopWords: {\n                                    displayName: \"Default Stop Words\",\n                                    type: { bool: true }\n                                },\n                                words: {\n                                    displayName: \"Words\",\n                                    type: { text: true }\n                                }\n                            }\n                        },\n                        rotateText: {\n                            displayName: \"Rotate Text\",\n                            properties: {\n                                show: {\n                                    displayName: \"Show\",\n                                    type: { bool: true }\n                                },\n                                minAngle: {\n                                    displayName: \"Min Angle\",\n                                    type: { numeric: true }\n                                },\n                                maxAngle: {\n                                    displayName: \"Max Angle\",\n                                    type: { numeric: true }\n                                },\n                                maxNumberOfOrientations: {\n                                    displayName: \"Max number of orientations\",\n                                    type: { numeric: true }\n                                }\n                            }\n                        }\n                    }\n                };\n                WordCloud.Punctuation = [\n                    \"!\", \".\", \":\", \"'\", \";\", \",\", \"!\",\n                    \"@\", \"#\", \"$\", \"%\", \"^\", \"&\", \"*\",\n                    \"(\", \")\", \"[\", \"]\", \"\\\"\", \"\\\\\", \"/\",\n                    \"-\", \"_\", \"+\", \"=\"\n                ];\n                WordCloud.StopWords = [\n                    \"a\", \"able\", \"about\", \"across\", \"after\", \"all\", \"almost\", \"also\", \"am\", \"among\", \"an\",\n                    \"and\", \"any\", \"are\", \"as\", \"at\", \"be\", \"because\", \"been\", \"but\", \"by\", \"can\", \"cannot\",\n                    \"could\", \"did\", \"do\", \"does\", \"either\", \"else\", \"ever\", \"every\", \"for\", \"from\", \"get\",\n                    \"got\", \"had\", \"has\", \"have\", \"he\", \"her\", \"hers\", \"him\", \"his\", \"how\", \"however\", \"i\",\n                    \"if\", \"in\", \"into\", \"is\", \"it\", \"its\", \"just\", \"least\", \"let\", \"like\", \"likely\", \"may\",\n                    \"me\", \"might\", \"most\", \"must\", \"my\", \"neither\", \"no\", \"nor\", \"not\", \"of\", \"off\", \"often\",\n                    \"on\", \"only\", \"or\", \"other\", \"our\", \"own\", \"rather\", \"said\", \"say\", \"says\", \"she\", \"should\",\n                    \"since\", \"so\", \"some\", \"than\", \"that\", \"the\", \"their\", \"them\", \"then\", \"there\", \"these\",\n                    \"they\", \"this\", \"tis\", \"to\", \"too\", \"twas\", \"us\", \"wants\", \"was\", \"we\", \"were\", \"what\",\n                    \"when\", \"where\", \"which\", \"while\", \"who\", \"whom\", \"why\", \"will\", \"with\", \"would\", \"yet\",\n                    \"you\", \"your\"\n                ];\n                WordCloud.DefaultSettings = {\n                    minFontSize: 20,\n                    maxFontSize: 100,\n                    minAngle: -60,\n                    maxAngle: 90,\n                    maxNumberOfOrientations: 2,\n                    isRotateText: false,\n                    isBrokenText: true,\n                    isRemoveStopWords: false,\n                    stopWordsArray: [],\n                    stopWords: undefined,\n                    isDefaultStopWords: false,\n                    maxNumberOfWords: 200\n                };\n                WordCloud.RenderDelay = 50;\n                WordCloud.DefaultMargin = {\n                    top: 10,\n                    right: 10,\n                    bottom: 10,\n                    left: 10\n                };\n                return WordCloud;\n            }());\n            samples.WordCloud = WordCloud;\n            var explore;\n            (function (explore) {\n                var util;\n                (function (util) {\n                    function hexToRgb(hex) {\n                        // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n                        var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n                        hex = hex.replace(shorthandRegex, function (m, r, g, b) {\n                            return r + r + g + g + b + b;\n                        });\n                        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n                        return result ? \"rgb(\" + parseInt(result[1], 16) + \",\" + parseInt(result[2], 16) + \",\" + parseInt(result[3], 16) + \")\" : null;\n                    }\n                    util.hexToRgb = hexToRgb;\n                    function getRandomColor() {\n                        var red = Math.floor(Math.random() * 255), green = Math.floor(Math.random() * 255), blue = Math.floor(Math.random() * 255);\n                        return \"rgb(\" + red + \",\" + green + \",\" + blue + \")\";\n                    }\n                    util.getRandomColor = getRandomColor;\n                })(util = explore.util || (explore.util = {}));\n            })(explore || (explore = {}));\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n            var PixelConverter = jsCommon.PixelConverter;\n            var TableViewFactory;\n            (function (TableViewFactory) {\n                function createTableView(options) {\n                    return new TableView(options);\n                }\n                TableViewFactory.createTableView = createTableView;\n            })(TableViewFactory = samples.TableViewFactory || (samples.TableViewFactory = {}));\n            /**\n             * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.\n             * It can create lists containing either HTML or SVG elements.\n             */\n            var TableView = (function () {\n                function TableView(options) {\n                    // make a copy of options so that it is not modified later by caller\n                    this.options = $.extend(true, {}, options);\n                    this.options.baseContainer\n                        .style('overflow-y', 'auto')\n                        .attr('drag-resize-disabled', true);\n                    this.scrollContainer = options.baseContainer\n                        .append('div')\n                        .attr('class', 'scrollRegion');\n                    this.visibleGroupContainer = this.scrollContainer\n                        .append('div')\n                        .attr('class', 'visibleGroup');\n                    TableView.SetDefaultOptions(options);\n                }\n                TableView.SetDefaultOptions = function (options) {\n                    options.rowHeight = options.rowHeight || TableView.defaultRowHeight;\n                };\n                TableView.prototype.rowHeight = function (rowHeight) {\n                    this.options.rowHeight = Math.ceil(rowHeight);\n                    return this;\n                };\n                TableView.prototype.columnWidth = function (columnWidth) {\n                    this.options.columnWidth = Math.ceil(columnWidth);\n                    return this;\n                };\n                TableView.prototype.orientation = function (orientation) {\n                    this.options.orientation = orientation;\n                    return this;\n                };\n                TableView.prototype.rows = function (rows) {\n                    this.options.rows = Math.ceil(rows);\n                    return this;\n                };\n                TableView.prototype.columns = function (columns) {\n                    this.options.columns = Math.ceil(columns);\n                    return this;\n                };\n                TableView.prototype.data = function (data, getDatumIndex, dataReset) {\n                    if (dataReset === void 0) { dataReset = false; }\n                    this._data = data;\n                    this.getDatumIndex = getDatumIndex;\n                    this.setTotalRows();\n                    if (dataReset) {\n                        $(this.options.baseContainer.node()).scrollTop(0);\n                    }\n                    return this;\n                };\n                TableView.prototype.viewport = function (viewport) {\n                    this.options.viewport = viewport;\n                    return this;\n                };\n                TableView.prototype.empty = function () {\n                    this._data = [];\n                    this.render();\n                };\n                TableView.prototype.setTotalRows = function () {\n                    var count = this._data.length;\n                    var rows = Math.min(this.options.rows, count);\n                    var columns = Math.min(this.options.columns, count);\n                    if ((columns > 0) && (rows > 0)) {\n                        this._totalColumns = columns;\n                        this._totalRows = rows;\n                    }\n                    else if (rows > 0) {\n                        this._totalRows = rows;\n                        this._totalColumns = Math.ceil(count / rows);\n                    }\n                    else if (columns > 0) {\n                        this._totalColumns = columns;\n                        this._totalRows = Math.ceil(count / columns);\n                    }\n                    else {\n                        this._totalColumns = TableView.defaultColumns;\n                        this._totalRows = Math.ceil(count / TableView.defaultColumns);\n                    }\n                };\n                TableView.prototype.render = function () {\n                    var options = this.options;\n                    var visibleGroupContainer = this.visibleGroupContainer;\n                    var rowHeight = options.rowHeight || TableView.defaultRowHeight;\n                    var groupedData = [];\n                    var totalRows = options.rows;\n                    var totalColumns = options.columns;\n                    var totalItems = this._data.length;\n                    var totalRows = options.rows > totalItems ? totalItems : options.rows;\n                    var totalColumns = options.columns > totalItems ? totalItems : options.columns;\n                    if (totalColumns === 0 && totalRows === 0) {\n                        if (options.orientation === Orientation.HORIZONTAL) {\n                            totalColumns = totalItems;\n                            totalRows = 1;\n                        }\n                        else {\n                            totalColumns = 1;\n                            totalRows = totalItems;\n                        }\n                    }\n                    else if (totalColumns === 0 && totalRows > 0)\n                        totalColumns = Math.ceil(totalItems / totalRows);\n                    else if (totalColumns > 0 && totalRows === 0)\n                        totalRows = Math.ceil(totalItems / totalColumns);\n                    if (this.options.orientation === Orientation.VERTICAL) {\n                        var n = totalRows;\n                        totalRows = totalColumns;\n                        totalColumns = n;\n                    }\n                    else if (this.options.orientation === Orientation.HORIZONTAL) {\n                        if (totalRows === 0)\n                            totalRows = this._totalRows;\n                        if (totalColumns === 0)\n                            totalColumns = this._totalColumns;\n                    }\n                    var m = 0;\n                    var k = 0;\n                    for (var i = 0; i < totalRows; i++) {\n                        if (this.options.orientation === Orientation.VERTICAL && options.rows === 0 && totalItems % options.columns > 0 && options.columns <= totalItems) {\n                            if (totalItems % options.columns > i) {\n                                m = i * Math.ceil(totalItems / options.columns);\n                                k = m + Math.ceil(totalItems / options.columns);\n                                groupedData.push(this._data.slice(m, k));\n                            }\n                            else {\n                                groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.columns)));\n                                k = k + Math.floor(totalItems / options.columns);\n                            }\n                        }\n                        else if (this.options.orientation === Orientation.HORIZONTAL && options.columns === 0 && totalItems % options.rows > 0 && options.rows <= totalItems) {\n                            if (totalItems % options.rows > i) {\n                                m = i * Math.ceil(totalItems / options.rows);\n                                k = m + Math.ceil(totalItems / options.rows);\n                                groupedData.push(this._data.slice(m, k));\n                            }\n                            else {\n                                groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.rows)));\n                                k = k + Math.floor(totalItems / options.rows);\n                            }\n                        }\n                        else {\n                            var k = i * totalColumns;\n                            groupedData.push(this._data.slice(k, k + totalColumns));\n                        }\n                    }\n                    visibleGroupContainer.selectAll(\".row\").remove();\n                    var cellSelection = visibleGroupContainer.selectAll(\".row\")\n                        .data(groupedData)\n                        .enter()\n                        .append(\"div\")\n                        .classed('row', true)\n                        .selectAll(\".cell\")\n                        .data(function (d) { return d; });\n                    cellSelection\n                        .enter()\n                        .append('div')\n                        .classed('cell', true)\n                        .call(function (d) { return options.enter(d); });\n                    cellSelection.order();\n                    var cellUpdateSelection = visibleGroupContainer.selectAll('.cell:not(.transitioning)');\n                    cellUpdateSelection.call(function (d) { return options.update(d); });\n                    cellUpdateSelection.style({ 'height': (rowHeight > 0) ? rowHeight + 'px' : 'auto' });\n                    if (this.options.orientation === Orientation.VERTICAL) {\n                        var realColumnNumber = 0;\n                        for (var i = 0; i < groupedData.length; i++) {\n                            if (groupedData[i].length !== 0)\n                                realColumnNumber = i + 1;\n                        }\n                        cellUpdateSelection.style({ 'width': '100%' });\n                        var rowUpdateSelection = visibleGroupContainer.selectAll('div.row');\n                        rowUpdateSelection.style({ 'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / realColumnNumber) + '%' });\n                    }\n                    else\n                        cellUpdateSelection.style({\n                            'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / totalColumns) + '%'\n                        });\n                    cellSelection\n                        .exit()\n                        .call(function (d) { return options.exit(d); })\n                        .remove();\n                };\n                TableView.defaultRowHeight = 0;\n                TableView.defaultColumns = 1;\n                return TableView;\n            }());\n            // TODO: Generate these from above, defining twice just introduces potential for error\n            samples.chicletSlicerProps = {\n                general: {\n                    orientation: { objectName: 'general', propertyName: 'orientation' },\n                    columns: { objectName: 'general', propertyName: 'columns' },\n                    rows: { objectName: 'general', propertyName: 'rows' },\n                    showDisabled: { objectName: 'general', propertyName: 'showDisabled' },\n                    multiselect: { objectName: 'general', propertyName: 'multiselect' },\n                    selection: { objectName: 'general', propertyName: 'selection' },\n                },\n                header: {\n                    show: { objectName: 'header', propertyName: 'show' },\n                    title: { objectName: 'header', propertyName: 'title' },\n                    fontColor: { objectName: 'header', propertyName: 'fontColor' },\n                    background: { objectName: 'header', propertyName: 'background' },\n                    outline: { objectName: 'header', propertyName: 'outline' },\n                    textSize: { objectName: 'header', propertyName: 'textSize' },\n                    outlineColor: { objectName: 'header', propertyName: 'outlineColor' },\n                    outlineWeight: { objectName: 'header', propertyName: 'outlineWeight' }\n                },\n                rows: {\n                    fontColor: { objectName: 'rows', propertyName: 'fontColor' },\n                    textSize: { objectName: 'rows', propertyName: 'textSize' },\n                    height: { objectName: 'rows', propertyName: 'height' },\n                    width: { objectName: 'rows', propertyName: 'width' },\n                    background: { objectName: 'rows', propertyName: 'background' },\n                    transparency: { objectName: 'rows', propertyName: 'transparency' },\n                    selectedColor: { objectName: 'rows', propertyName: 'selectedColor' },\n                    unselectedColor: { objectName: 'rows', propertyName: 'unselectedColor' },\n                    disabledColor: { objectName: 'rows', propertyName: 'disabledColor' },\n                    outline: { objectName: 'rows', propertyName: 'outline' },\n                    outlineColor: { objectName: 'rows', propertyName: 'outlineColor' },\n                    outlineWeight: { objectName: 'rows', propertyName: 'outlineWeight' },\n                    borderStyle: { objectName: 'rows', propertyName: 'borderStyle' },\n                },\n                images: {\n                    imageSplit: { objectName: 'images', propertyName: 'imageSplit' },\n                    stretchImage: { objectName: 'images', propertyName: 'stretchImage' },\n                    bottomImage: { objectName: 'images', propertyName: 'bottomImage' },\n                },\n                selectedPropertyIdentifier: { objectName: 'general', propertyName: 'selected' },\n                filterPropertyIdentifier: { objectName: 'general', propertyName: 'filter' },\n                formatString: { objectName: 'general', propertyName: 'formatString' },\n                hasSavedSelection: true,\n            };\n            var ChicletBorderStyle;\n            (function (ChicletBorderStyle) {\n                ChicletBorderStyle.ROUNDED = 'Rounded';\n                ChicletBorderStyle.CUT = 'Cut';\n                ChicletBorderStyle.SQUARE = 'Square';\n                ChicletBorderStyle.type = powerbi.createEnumType([\n                    { value: ChicletBorderStyle.ROUNDED, displayName: ChicletBorderStyle.ROUNDED },\n                    { value: ChicletBorderStyle.CUT, displayName: ChicletBorderStyle.CUT },\n                    { value: ChicletBorderStyle.SQUARE, displayName: ChicletBorderStyle.SQUARE },\n                ]);\n            })(ChicletBorderStyle || (ChicletBorderStyle = {}));\n            var ChicletSlicerShowDisabled;\n            (function (ChicletSlicerShowDisabled) {\n                ChicletSlicerShowDisabled.INPLACE = 'Inplace';\n                ChicletSlicerShowDisabled.BOTTOM = 'Bottom';\n                ChicletSlicerShowDisabled.HIDE = 'Hide';\n                ChicletSlicerShowDisabled.type = powerbi.createEnumType([\n                    { value: ChicletSlicerShowDisabled.INPLACE, displayName: ChicletSlicerShowDisabled.INPLACE },\n                    { value: ChicletSlicerShowDisabled.BOTTOM, displayName: ChicletSlicerShowDisabled.BOTTOM },\n                    { value: ChicletSlicerShowDisabled.HIDE, displayName: ChicletSlicerShowDisabled.HIDE },\n                ]);\n            })(ChicletSlicerShowDisabled || (ChicletSlicerShowDisabled = {}));\n            var Orientation;\n            (function (Orientation) {\n                Orientation.HORIZONTAL = 'Horizontal';\n                Orientation.VERTICAL = 'Vertical';\n                Orientation.type = powerbi.createEnumType([\n                    { value: Orientation.HORIZONTAL, displayName: Orientation.HORIZONTAL },\n                    { value: Orientation.VERTICAL, displayName: Orientation.VERTICAL }\n                ]);\n            })(Orientation || (Orientation = {}));\n            var ChicletSlicer = (function () {\n                function ChicletSlicer(options) {\n                    if (options) {\n                        if (options.behavior) {\n                            this.behavior = options.behavior;\n                        }\n                    }\n                    if (!this.behavior) {\n                        this.behavior = new ChicletSlicerWebBehavior();\n                    }\n                }\n                ChicletSlicer.DefaultStyleProperties = function () {\n                    return {\n                        general: {\n                            orientation: Orientation.VERTICAL,\n                            columns: 3,\n                            rows: 0,\n                            multiselect: true,\n                            showDisabled: ChicletSlicerShowDisabled.INPLACE,\n                            selection: null,\n                        },\n                        margin: {\n                            top: 50,\n                            bottom: 50,\n                            right: 50,\n                            left: 50\n                        },\n                        header: {\n                            borderBottomWidth: 1,\n                            show: true,\n                            outline: 'BottomOnly',\n                            fontColor: '#a6a6a6',\n                            background: null,\n                            textSize: 10,\n                            outlineColor: '#a6a6a6',\n                            outlineWeight: 1,\n                            title: '',\n                        },\n                        headerText: {\n                            marginLeft: 8,\n                            marginTop: 0\n                        },\n                        slicerText: {\n                            textSize: 10,\n                            height: 0,\n                            width: 0,\n                            fontColor: '#666666',\n                            hoverColor: '#212121',\n                            selectedColor: '#BDD7EE',\n                            unselectedColor: '#ffffff',\n                            disabledColor: 'grey',\n                            marginLeft: 8,\n                            outline: 'Frame',\n                            background: null,\n                            transparency: 0,\n                            outlineColor: '#000000',\n                            outlineWeight: 1,\n                            borderStyle: 'Cut',\n                        },\n                        slicerItemContainer: {\n                            // The margin is assigned in the less file. This is needed for the height calculations.\n                            marginTop: 5,\n                            marginLeft: 0,\n                        },\n                        images: {\n                            imageSplit: 50,\n                            stretchImage: false,\n                            bottomImage: false\n                        }\n                    };\n                };\n                ChicletSlicer.converter = function (dataView, localizedSelectAllText, interactivityService) {\n                    if (!dataView ||\n                        !dataView.categorical ||\n                        !dataView.categorical.categories ||\n                        !dataView.categorical.categories[0] ||\n                        !dataView.categorical.categories[0].values ||\n                        !(dataView.categorical.categories[0].values.length > 0)) {\n                        return;\n                    }\n                    var converter = new ChicletSlicerChartConversion.ChicletSlicerConverter(dataView, interactivityService);\n                    converter.convert();\n                    var slicerData;\n                    var defaultSettings = this.DefaultStyleProperties();\n                    var objects = dataView.metadata.objects;\n                    if (objects) {\n                        defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.orientation, defaultSettings.general.orientation);\n                        defaultSettings.general.columns = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.columns, defaultSettings.general.columns);\n                        defaultSettings.general.rows = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.rows, defaultSettings.general.rows);\n                        defaultSettings.general.multiselect = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.multiselect, defaultSettings.general.multiselect);\n                        defaultSettings.general.showDisabled = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.showDisabled, defaultSettings.general.showDisabled);\n                        defaultSettings.general.selection = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.chicletSlicerProps.general.selection, defaultSettings.general.selection);\n                        defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.show, defaultSettings.header.show);\n                        defaultSettings.header.title = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.title, defaultSettings.header.title);\n                        defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.fontColor, defaultSettings.header.fontColor);\n                        defaultSettings.header.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.background, defaultSettings.header.background);\n                        defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.textSize, defaultSettings.header.textSize);\n                        defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outline, defaultSettings.header.outline);\n                        defaultSettings.header.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.outlineColor, defaultSettings.header.outlineColor);\n                        defaultSettings.header.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outlineWeight, defaultSettings.header.outlineWeight);\n                        defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.textSize, defaultSettings.slicerText.textSize);\n                        defaultSettings.slicerText.height = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.height, defaultSettings.slicerText.height);\n                        defaultSettings.slicerText.width = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.width, defaultSettings.slicerText.width);\n                        defaultSettings.slicerText.selectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.selectedColor, defaultSettings.slicerText.selectedColor);\n                        defaultSettings.slicerText.unselectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.unselectedColor, defaultSettings.slicerText.unselectedColor);\n                        defaultSettings.slicerText.disabledColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.disabledColor, defaultSettings.slicerText.disabledColor);\n                        defaultSettings.slicerText.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.background, defaultSettings.slicerText.background);\n                        defaultSettings.slicerText.transparency = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.transparency, defaultSettings.slicerText.transparency);\n                        defaultSettings.slicerText.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.fontColor, defaultSettings.slicerText.fontColor);\n                        defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outline, defaultSettings.slicerText.outline);\n                        defaultSettings.slicerText.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.outlineColor, defaultSettings.slicerText.outlineColor);\n                        defaultSettings.slicerText.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outlineWeight, defaultSettings.slicerText.outlineWeight);\n                        defaultSettings.slicerText.borderStyle = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.borderStyle, defaultSettings.slicerText.borderStyle);\n                        defaultSettings.images.imageSplit = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.imageSplit, defaultSettings.images.imageSplit);\n                        defaultSettings.images.stretchImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.stretchImage, defaultSettings.images.stretchImage);\n                        defaultSettings.images.bottomImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.bottomImage, defaultSettings.images.bottomImage);\n                    }\n                    var categories = dataView.categorical.categories[0];\n                    slicerData = {\n                        categorySourceName: categories.source.displayName,\n                        formatString: visuals.valueFormatter.getFormatString(categories.source, samples.chicletSlicerProps.formatString),\n                        slicerSettings: defaultSettings,\n                        slicerDataPoints: converter.dataPoints,\n                    };\n                    // Override hasSelection if a objects contained more scopeIds than selections we found in the data\n                    slicerData.hasSelectionOverride = converter.hasSelectionOverride;\n                    return slicerData;\n                };\n                ChicletSlicer.prototype.init = function (options) {\n                    this.element = options.element;\n                    this.currentViewport = options.viewport;\n                    if (this.behavior) {\n                        this.interactivityService = visuals.createInteractivityService(options.host);\n                    }\n                    this.hostServices = options.host;\n                    this.settings = ChicletSlicer.DefaultStyleProperties();\n                    this.initContainer();\n                };\n                ChicletSlicer.prototype.update = function (options) {\n                    if (!options ||\n                        !options.dataViews ||\n                        !options.dataViews[0] ||\n                        !options.viewport) {\n                        return;\n                    }\n                    var existingDataView = this.dataView;\n                    this.dataView = options.dataViews[0];\n                    var resetScrollbarPosition = true;\n                    if (existingDataView) {\n                        resetScrollbarPosition = !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);\n                    }\n                    if (options.viewport.height === this.currentViewport.height\n                        && options.viewport.width === this.currentViewport.width) {\n                        this.waitingForData = false;\n                    }\n                    else {\n                        this.currentViewport = options.viewport;\n                    }\n                    this.updateInternal(resetScrollbarPosition);\n                };\n                ChicletSlicer.prototype.onResizing = function (finalViewport) {\n                    this.currentViewport = finalViewport;\n                    this.updateInternal(false /* resetScrollbarPosition */);\n                };\n                ChicletSlicer.prototype.enumerateObjectInstances = function (options) {\n                    var data = this.slicerData;\n                    if (!data) {\n                        return;\n                    }\n                    var objectName = options.objectName;\n                    switch (objectName) {\n                        case 'rows':\n                            return this.enumerateRows(data);\n                        case 'header':\n                            return this.enumerateHeader(data);\n                        case 'general':\n                            return this.enumerateGeneral(data);\n                        case 'images':\n                            return this.enumerateImages(data);\n                    }\n                };\n                ChicletSlicer.prototype.enumerateHeader = function (data) {\n                    var slicerSettings = this.settings;\n                    return [{\n                            selector: null,\n                            objectName: 'header',\n                            properties: {\n                                show: slicerSettings.header.show,\n                                title: slicerSettings.header.title,\n                                fontColor: slicerSettings.header.fontColor,\n                                background: slicerSettings.header.background,\n                                textSize: slicerSettings.header.textSize,\n                                outline: slicerSettings.header.outline,\n                                outlineColor: slicerSettings.header.outlineColor,\n                                outlineWeight: slicerSettings.header.outlineWeight\n                            }\n                        }];\n                };\n                ChicletSlicer.prototype.enumerateRows = function (data) {\n                    var slicerSettings = this.settings;\n                    return [{\n                            selector: null,\n                            objectName: 'rows',\n                            properties: {\n                                textSize: slicerSettings.slicerText.textSize,\n                                height: slicerSettings.slicerText.height,\n                                width: slicerSettings.slicerText.width,\n                                background: slicerSettings.slicerText.background,\n                                transparency: slicerSettings.slicerText.transparency,\n                                selectedColor: slicerSettings.slicerText.selectedColor,\n                                unselectedColor: slicerSettings.slicerText.unselectedColor,\n                                disabledColor: slicerSettings.slicerText.disabledColor,\n                                outline: slicerSettings.slicerText.outline,\n                                outlineColor: slicerSettings.slicerText.outlineColor,\n                                outlineWeight: slicerSettings.slicerText.outlineWeight,\n                                fontColor: slicerSettings.slicerText.fontColor,\n                                borderStyle: slicerSettings.slicerText.borderStyle,\n                            }\n                        }];\n                };\n                ChicletSlicer.prototype.enumerateGeneral = function (data) {\n                    var slicerSettings = this.settings;\n                    return [{\n                            selector: null,\n                            objectName: 'general',\n                            properties: {\n                                orientation: slicerSettings.general.orientation,\n                                columns: slicerSettings.general.columns,\n                                rows: slicerSettings.general.rows,\n                                showDisabled: slicerSettings.general.showDisabled,\n                                multiselect: slicerSettings.general.multiselect,\n                            }\n                        }];\n                };\n                ChicletSlicer.prototype.enumerateImages = function (data) {\n                    var slicerSettings = this.settings;\n                    return [{\n                            selector: null,\n                            objectName: 'images',\n                            properties: {\n                                imageSplit: slicerSettings.images.imageSplit,\n                                stretchImage: slicerSettings.images.stretchImage,\n                                bottomImage: slicerSettings.images.bottomImage,\n                            }\n                        }];\n                };\n                ChicletSlicer.prototype.updateInternal = function (resetScrollbarPosition) {\n                    var _this = this;\n                    this.updateSlicerBodyDimensions();\n                    var localizedSelectAllText = 'Select All';\n                    var data = ChicletSlicer.converter(this.dataView, localizedSelectAllText, this.interactivityService);\n                    if (!data) {\n                        this.tableView.empty();\n                        return;\n                    }\n                    if (this.interactivityService) {\n                        this.interactivityService.applySelectionStateToData(data.slicerDataPoints);\n                    }\n                    data.slicerSettings.header.outlineWeight = data.slicerSettings.header.outlineWeight < 0 ? 0 : data.slicerSettings.header.outlineWeight;\n                    data.slicerSettings.slicerText.outlineWeight = data.slicerSettings.slicerText.outlineWeight < 0 ? 0 : data.slicerSettings.slicerText.outlineWeight;\n                    data.slicerSettings.general.getSavedSelection = function () {\n                        try {\n                            return JSON.parse(_this.slicerData.slicerSettings.general.selection) || [];\n                        }\n                        catch (ex) {\n                            return [];\n                        }\n                    };\n                    data.slicerSettings.general.setSavedSelection = function (selectionIds) {\n                        _this.isSelectionSaved = true;\n                        _this.hostServices.persistProperties({\n                            merge: [{\n                                    objectName: \"general\",\n                                    selector: null,\n                                    properties: { selection: selectionIds && JSON.stringify(selectionIds) || \"\" }\n                                }] });\n                    };\n                    if (this.slicerData) {\n                        if (this.isSelectionSaved) {\n                            this.isSelectionLoaded = true;\n                        }\n                        else {\n                            this.isSelectionLoaded = this.slicerData.slicerSettings.general.selection === data.slicerSettings.general.selection;\n                        }\n                    }\n                    else {\n                        this.isSelectionLoaded = false;\n                    }\n                    this.slicerData = data;\n                    this.settings = this.slicerData.slicerSettings;\n                    if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.BOTTOM) {\n                        data.slicerDataPoints.sort(function (a, b) {\n                            if (a.selectable === b.selectable) {\n                                return 0;\n                            }\n                            else if (a.selectable && !b.selectable) {\n                                return -1;\n                            }\n                            else {\n                                return 1;\n                            }\n                        });\n                    }\n                    else if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.HIDE) {\n                        data.slicerDataPoints = data.slicerDataPoints.filter(function (x) { return x.selectable; });\n                    }\n                    var height = this.settings.slicerText.height;\n                    if (height === 0) {\n                        var extraSpaceForCell = ChicletSlicer.cellTotalInnerPaddings + ChicletSlicer.cellTotalInnerBorders;\n                        var textProperties = ChicletSlicer.getChicletTextProperties(this.settings.slicerText.textSize);\n                        height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) + powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties) + extraSpaceForCell;\n                        var hasImage = _.any(data.slicerDataPoints, function (x) { return x.imageURL !== '' && typeof x.imageURL !== \"undefined\"; });\n                        if (hasImage)\n                            height += 100;\n                    }\n                    this.tableView\n                        .rowHeight(height)\n                        .columnWidth(this.settings.slicerText.width)\n                        .orientation(this.settings.general.orientation)\n                        .rows(this.settings.general.rows)\n                        .columns(this.settings.general.columns)\n                        .data(data.slicerDataPoints, function (d) { return $.inArray(d, data.slicerDataPoints); }, resetScrollbarPosition)\n                        .viewport(this.getSlicerBodyViewport(this.currentViewport))\n                        .render();\n                    // if(!selectedItems.length  &&  String(savedSelection).length && this.slicerData && this.slicerData.hasSelectionOverride){\n                    //     var arrSelection = String(savedSelection).split('&');\n                    //     var arrSelected = jQuery.map(data.slicerDataPoints, function (d, index) { \n                    //         if (arrSelection.indexOf(d.category) > -1) return d; \n                    //     });\n                    //     data.slicerDataPoints.forEach(function (d, index) { \n                    //         if (arrSelection.indexOf(d.category) > -1){\n                    //             d.selected = true;\n                    //             // console.error('>>>>@@@', d, index);\n                    //         }\n                    //     });\n                    //     if(!arrSelection.length){\n                    //         this.slicerData.hasSelectionOverride = false\n                    //     }\n                    //     // console.error('>>> 2', 'RESTORE',   savedSelection,     arrSelected,     data.slicerDataPoints )\n                    // }\n                };\n                ChicletSlicer.prototype.initContainer = function () {\n                    var _this = this;\n                    var settings = this.settings;\n                    var slicerBodyViewport = this.getSlicerBodyViewport(this.currentViewport);\n                    var slicerContainer = d3.select(this.element.get(0))\n                        .append('div')\n                        .classed(ChicletSlicer.Container.class, true);\n                    this.slicerHeader = slicerContainer\n                        .append('div')\n                        .classed(ChicletSlicer.Header.class, true);\n                    this.slicerHeader\n                        .append('span')\n                        .classed(ChicletSlicer.Clear.class, true)\n                        .attr('title', 'Clear');\n                    this.slicerHeader\n                        .append('div')\n                        .classed(ChicletSlicer.HeaderText.class, true)\n                        .style({\n                        'margin-left': PixelConverter.toString(settings.headerText.marginLeft),\n                        'margin-top': PixelConverter.toString(settings.headerText.marginTop),\n                        'border-style': this.getBorderStyle(settings.header.outline),\n                        'border-color': settings.header.outlineColor,\n                        'border-width': this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),\n                        'font-size': PixelConverter.fromPoint(settings.header.textSize),\n                    });\n                    this.slicerBody = slicerContainer\n                        .append('div').classed(ChicletSlicer.Body.class, true)\n                        .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)\n                        .classed('slicerBody-vertical', settings.general.orientation === Orientation.VERTICAL)\n                        .style({\n                        'height': PixelConverter.toString(slicerBodyViewport.height),\n                        'width': '100%',\n                    });\n                    var rowEnter = function (rowSelection) {\n                        var settings = _this.settings;\n                        var listItemElement = rowSelection.append('li')\n                            .classed(ChicletSlicer.ItemContainer.class, true)\n                            .style({\n                            'margin-left': PixelConverter.toString(settings.slicerItemContainer.marginLeft),\n                        });\n                        listItemElement.append('div')\n                            .classed('slicer-img-wrapper', true);\n                        listItemElement.append('div')\n                            .classed('slicer-text-wrapper', true)\n                            .append('span')\n                            .classed(ChicletSlicer.LabelText.class, true)\n                            .style({\n                            'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),\n                        });\n                    };\n                    var rowUpdate = function (rowSelection) {\n                        var settings = _this.settings;\n                        var data = _this.slicerData;\n                        if (data && settings) {\n                            _this.slicerHeader.classed('hidden', !settings.header.show);\n                            _this.slicerHeader.select(ChicletSlicer.HeaderText.selector)\n                                .text(settings.header.title.trim() !== \"\" ? settings.header.title.trim() : _this.slicerData.categorySourceName)\n                                .style({\n                                'border-style': _this.getBorderStyle(settings.header.outline),\n                                'border-color': settings.header.outlineColor,\n                                'border-width': _this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),\n                                'color': settings.header.fontColor,\n                                'background-color': settings.header.background,\n                                'font-size': PixelConverter.fromPoint(settings.header.textSize),\n                            });\n                            _this.slicerBody\n                                .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)\n                                .classed('slicerBody-vertical', settings.general.orientation === Orientation.VERTICAL);\n                            var slicerText = rowSelection.selectAll(ChicletSlicer.LabelText.selector);\n                            var textProperties = ChicletSlicer.getChicletTextProperties(settings.slicerText.textSize);\n                            var formatString = data.formatString;\n                            slicerText.text(function (d) {\n                                var text = visuals.valueFormatter.format(d.category, formatString);\n                                textProperties.text = text;\n                                if (_this.settings.slicerText.width === 0)\n                                    return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, (_this.currentViewport.width / _this.settings.general.columns) - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);\n                                else\n                                    return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, _this.settings.slicerText.width - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);\n                            });\n                            var slicerImg = rowSelection.selectAll('.slicer-img-wrapper');\n                            slicerImg\n                                .style('height', settings.images.imageSplit + '%')\n                                .classed('hidden', function (d) {\n                                if (!(d.imageURL)) {\n                                    return true;\n                                }\n                                if (settings.images.imageSplit < 10) {\n                                    return true;\n                                }\n                            })\n                                .style('display', function (d) { return (d.imageURL) ? 'flex' : 'none'; })\n                                .classed('stretchImage', settings.images.stretchImage)\n                                .classed('bottomImage', settings.images.bottomImage)\n                                .style('background-image', function (d) {\n                                return d.imageURL ? \"url(\" + d.imageURL + \")\" : '';\n                            });\n                            rowSelection.selectAll('.slicer-text-wrapper')\n                                .style('height', function (d) {\n                                return d.imageURL ? (100 - settings.images.imageSplit) + '%' : '100%';\n                            })\n                                .classed('hidden', function (d) {\n                                if (settings.images.imageSplit > 90) {\n                                    return true;\n                                }\n                            });\n                            rowSelection.selectAll('.slicerItemContainer').style({\n                                'color': settings.slicerText.fontColor,\n                                'border-style': _this.getBorderStyle(settings.slicerText.outline),\n                                'border-color': settings.slicerText.outlineColor,\n                                'border-width': _this.getBorderWidth(settings.slicerText.outline, settings.slicerText.outlineWeight),\n                                'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),\n                                'border-radius': _this.getBorderRadius(settings.slicerText.borderStyle),\n                            });\n                            if (settings.slicerText.background)\n                                _this.slicerBody.style('background-color', explore.util.hexToRGBString(settings.slicerText.background, (100 - settings.slicerText.transparency) / 100));\n                            else\n                                _this.slicerBody.style('background-color', null);\n                            if (_this.interactivityService && _this.slicerBody) {\n                                var slicerBody = _this.slicerBody.attr('width', _this.currentViewport.width);\n                                var slicerItemContainers = slicerBody.selectAll(ChicletSlicer.ItemContainer.selector);\n                                var slicerItemLabels = slicerBody.selectAll(ChicletSlicer.LabelText.selector);\n                                var slicerItemInputs = slicerBody.selectAll(ChicletSlicer.Input.selector);\n                                var slicerClear = _this.slicerHeader.select(ChicletSlicer.Clear.selector);\n                                var behaviorOptions = {\n                                    dataPoints: data.slicerDataPoints,\n                                    slicerItemContainers: slicerItemContainers,\n                                    slicerItemLabels: slicerItemLabels,\n                                    slicerItemInputs: slicerItemInputs,\n                                    slicerClear: slicerClear,\n                                    interactivityService: _this.interactivityService,\n                                    slicerSettings: data.slicerSettings,\n                                    isSelectionLoaded: _this.isSelectionLoaded\n                                };\n                                _this.interactivityService.bind(data.slicerDataPoints, _this.behavior, behaviorOptions, {\n                                    overrideSelectionFromData: true,\n                                    hasSelectionOverride: data.hasSelectionOverride,\n                                });\n                                _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), _this.interactivityService.hasSelection());\n                            }\n                            else {\n                                _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), false);\n                            }\n                        }\n                    };\n                    var rowExit = function (rowSelection) {\n                        rowSelection.remove();\n                    };\n                    var tableViewOptions = {\n                        rowHeight: this.getRowHeight(),\n                        columnWidth: this.settings.slicerText.width,\n                        orientation: this.settings.general.orientation,\n                        rows: this.settings.general.rows,\n                        columns: this.settings.general.columns,\n                        enter: rowEnter,\n                        exit: rowExit,\n                        update: rowUpdate,\n                        loadMoreData: function () { return _this.onLoadMoreData(); },\n                        scrollEnabled: true,\n                        viewport: this.getSlicerBodyViewport(this.currentViewport),\n                        baseContainer: this.slicerBody,\n                    };\n                    this.tableView = TableViewFactory.createTableView(tableViewOptions);\n                };\n                ChicletSlicer.prototype.onLoadMoreData = function () {\n                    if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {\n                        this.hostServices.loadMoreData();\n                        this.waitingForData = true;\n                    }\n                };\n                ChicletSlicer.prototype.getSlicerBodyViewport = function (currentViewport) {\n                    var settings = this.settings;\n                    var headerHeight = (settings.header.show) ? this.getHeaderHeight() : 0;\n                    var slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);\n                    return {\n                        height: slicerBodyHeight,\n                        width: currentViewport.width\n                    };\n                };\n                ChicletSlicer.prototype.updateSlicerBodyDimensions = function () {\n                    var slicerViewport = this.getSlicerBodyViewport(this.currentViewport);\n                    this.slicerBody\n                        .style({\n                        'height': PixelConverter.toString(slicerViewport.height),\n                        'width': '100%',\n                    });\n                };\n                ChicletSlicer.getChicletTextProperties = function (textSize) {\n                    return {\n                        fontFamily: ChicletSlicer.DefaultFontFamily,\n                        fontSize: PixelConverter.fromPoint(textSize || ChicletSlicer.DefaultFontSizeInPt),\n                    };\n                };\n                ChicletSlicer.prototype.getHeaderHeight = function () {\n                    return powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(this.settings.header.textSize));\n                };\n                ChicletSlicer.prototype.getRowHeight = function () {\n                    var textSettings = this.settings.slicerText;\n                    return textSettings.height !== 0\n                        ? textSettings.height\n                        : powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(textSettings.textSize));\n                };\n                ChicletSlicer.prototype.getBorderStyle = function (outlineElement) {\n                    return outlineElement === '0px' ? 'none' : 'solid';\n                };\n                ChicletSlicer.prototype.getBorderWidth = function (outlineElement, outlineWeight) {\n                    switch (outlineElement) {\n                        case 'None':\n                            return '0px';\n                        case 'BottomOnly':\n                            return '0px 0px ' + outlineWeight + 'px 0px';\n                        case 'TopOnly':\n                            return outlineWeight + 'px 0px 0px 0px';\n                        case 'TopBottom':\n                            return outlineWeight + 'px 0px ' + outlineWeight + 'px 0px';\n                        case 'LeftRight':\n                            return '0px ' + outlineWeight + 'px 0px ' + outlineWeight + 'px';\n                        case 'Frame':\n                            return outlineWeight + 'px';\n                        default:\n                            return outlineElement.replace(\"1\", outlineWeight.toString());\n                    }\n                };\n                ChicletSlicer.prototype.getBorderRadius = function (borderType) {\n                    switch (borderType) {\n                        case ChicletBorderStyle.ROUNDED:\n                            return \"10px\";\n                        case ChicletBorderStyle.SQUARE:\n                            return \"0px\";\n                        default:\n                            return \"5px\";\n                    }\n                };\n                ChicletSlicer.capabilities = {\n                    dataRoles: [\n                        {\n                            name: 'Category',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Field'),\n                        },\n                        {\n                            name: 'Values',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),\n                        },\n                        {\n                            name: 'Image',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Image',\n                        },\n                    ],\n                    objects: {\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),\n                            properties: {\n                                selection: {\n                                    displayName: \"Selection\",\n                                    type: { text: true }\n                                },\n                                orientation: {\n                                    displayName: 'Orientation',\n                                    type: { enumeration: Orientation.type }\n                                },\n                                columns: {\n                                    displayName: 'Columns',\n                                    type: { numeric: true }\n                                },\n                                rows: {\n                                    displayName: 'Rows',\n                                    type: { numeric: true }\n                                },\n                                showDisabled: {\n                                    displayName: 'Show Disabled',\n                                    type: { enumeration: ChicletSlicerShowDisabled.type }\n                                },\n                                multiselect: {\n                                    displayName: 'Multiple selection',\n                                    type: { bool: true }\n                                },\n                                selected: {\n                                    type: { bool: true }\n                                },\n                                filter: {\n                                    type: { filter: {} },\n                                    rule: {\n                                        output: {\n                                            property: 'selected',\n                                            selector: ['Category'],\n                                        }\n                                    }\n                                },\n                                formatString: {\n                                    type: { formatting: { formatString: true } },\n                                },\n                            },\n                        },\n                        header: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_Header'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                title: {\n                                    displayName: 'Title',\n                                    type: { text: true }\n                                },\n                                fontColor: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_FontColor'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                background: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                outline: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),\n                                    type: { formatting: { outline: true } }\n                                },\n                                textSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { numeric: true }\n                                },\n                                outlineColor: {\n                                    displayName: 'Outline Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                outlineWeight: {\n                                    displayName: 'Outline Weight',\n                                    type: { numeric: true }\n                                }\n                            }\n                        },\n                        rows: {\n                            displayName: 'Chiclets',\n                            properties: {\n                                fontColor: {\n                                    displayName: 'Text color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                textSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { numeric: true }\n                                },\n                                height: {\n                                    displayName: 'Height',\n                                    type: { numeric: true }\n                                },\n                                width: {\n                                    displayName: 'Width',\n                                    type: { numeric: true }\n                                },\n                                selectedColor: {\n                                    displayName: 'Selected Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                unselectedColor: {\n                                    displayName: 'Unselected Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                disabledColor: {\n                                    displayName: 'Disabled Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                background: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                transparency: {\n                                    displayName: \"Transparency\",\n                                    description: \"Set transparency for background color\",\n                                    type: { numeric: true }\n                                },\n                                outline: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),\n                                    type: { formatting: { outline: true } }\n                                },\n                                outlineColor: {\n                                    displayName: 'Outline Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                outlineWeight: {\n                                    displayName: 'Outline Weight',\n                                    type: { numeric: true }\n                                },\n                                borderStyle: {\n                                    displayName: 'Outline Style',\n                                    type: { enumeration: ChicletBorderStyle.type }\n                                },\n                            }\n                        },\n                        images: {\n                            displayName: 'Images',\n                            properties: {\n                                imageSplit: {\n                                    displayName: 'Image Split',\n                                    type: { numeric: true }\n                                },\n                                stretchImage: {\n                                    displayName: 'Stretch image',\n                                    type: { bool: true }\n                                },\n                                bottomImage: {\n                                    displayName: 'Bottom image',\n                                    type: { bool: true }\n                                },\n                            }\n                        },\n                    },\n                    dataViewMappings: [{\n                            conditions: [\n                                { 'Category': { max: 1 }, 'Image': { min: 0, max: 1 }, 'Values': { min: 0, max: 1 } }],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Category' },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: {\n                                    group: {\n                                        by: 'Image',\n                                        select: [{ bind: { to: 'Values' } },\n                                        ],\n                                        dataReductionAlgorithm: { top: {} }\n                                    }\n                                },\n                                includeEmptyGroups: true\n                            }\n                        }],\n                    supportsHighlight: true,\n                    sorting: {\n                        default: {},\n                    },\n                    suppressDefaultTitle: true,\n                };\n                ChicletSlicer.DefaultFontFamily = 'Segoe UI, Tahoma, Verdana, Geneva, sans-serif';\n                ChicletSlicer.DefaultFontSizeInPt = 11;\n                ChicletSlicer.cellTotalInnerPaddings = 8;\n                ChicletSlicer.cellTotalInnerBorders = 2;\n                ChicletSlicer.chicletTotalInnerRightLeftPaddings = 14;\n                ChicletSlicer.ItemContainer = createClassAndSelector('slicerItemContainer');\n                ChicletSlicer.HeaderText = createClassAndSelector('headerText');\n                ChicletSlicer.Container = createClassAndSelector('chicletSlicer');\n                ChicletSlicer.LabelText = createClassAndSelector('slicerText');\n                ChicletSlicer.Header = createClassAndSelector('slicerHeader');\n                ChicletSlicer.Input = createClassAndSelector('slicerCheckbox');\n                ChicletSlicer.Clear = createClassAndSelector('clear');\n                ChicletSlicer.Body = createClassAndSelector('slicerBody');\n                return ChicletSlicer;\n            }());\n            samples.ChicletSlicer = ChicletSlicer;\n            var ChicletSlicerChartConversion;\n            (function (ChicletSlicerChartConversion) {\n                var ChicletSlicerConverter = (function () {\n                    function ChicletSlicerConverter(dataView, interactivityService) {\n                        var dataViewCategorical = dataView.categorical;\n                        this.dataViewCategorical = dataViewCategorical;\n                        this.dataViewMetadata = dataView.metadata;\n                        if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {\n                            this.category = dataViewCategorical.categories[0];\n                            this.categoryIdentities = this.category.identity;\n                            this.categoryValues = this.category.values;\n                            this.categoryColumnRef = this.category.identityFields;\n                            this.categoryFormatString = visuals.valueFormatter.getFormatString(this.category.source, samples.chicletSlicerProps.formatString);\n                        }\n                        this.dataPoints = [];\n                        this.interactivityService = interactivityService;\n                        this.hasSelectionOverride = false;\n                    }\n                    ChicletSlicerConverter.prototype.convert = function () {\n                        this.dataPoints = [];\n                        this.numberOfCategoriesSelectedInData = 0;\n                        // If category exists, we render labels using category values. If not, we render labels\n                        // using measure labels.\n                        if (this.categoryValues) {\n                            var objects = this.dataViewMetadata ? this.dataViewMetadata.objects : undefined;\n                            var isInvertedSelectionMode = undefined;\n                            var numberOfScopeIds;\n                            if (objects && objects.general && objects.general.filter) {\n                                if (!this.categoryColumnRef)\n                                    return;\n                                var filter = objects.general.filter;\n                                var scopeIds = powerbi.data.SQExprConverter.asScopeIdsContainer(filter, this.categoryColumnRef);\n                                if (scopeIds) {\n                                    isInvertedSelectionMode = scopeIds.isNot;\n                                    numberOfScopeIds = scopeIds.scopeIds ? scopeIds.scopeIds.length : 0;\n                                }\n                                else {\n                                    isInvertedSelectionMode = false;\n                                }\n                            }\n                            if (this.interactivityService) {\n                                if (isInvertedSelectionMode === undefined) {\n                                    // The selection state is read from the Interactivity service in case of SelectAll or Clear when query doesn't update the visual\n                                    isInvertedSelectionMode = this.interactivityService.isSelectionModeInverted();\n                                }\n                                else {\n                                    this.interactivityService.setSelectionModeInverted(isInvertedSelectionMode);\n                                }\n                            }\n                            var hasSelection = undefined;\n                            for (var idx = 0; idx < this.categoryValues.length; idx++) {\n                                var selected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, idx);\n                                if (selected != null) {\n                                    hasSelection = selected;\n                                    break;\n                                }\n                            }\n                            var dataViewCategorical = this.dataViewCategorical;\n                            var formatStringProp = samples.chicletSlicerProps.formatString;\n                            var value = -Infinity;\n                            var imageURL = '';\n                            for (var categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {\n                                var categoryIdentity = this.category.identity ? this.category.identity[categoryIndex] : null;\n                                var categoryIsSelected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, categoryIndex);\n                                var selectable = true;\n                                if (hasSelection != null) {\n                                    if (isInvertedSelectionMode) {\n                                        if (this.category.objects == null)\n                                            categoryIsSelected = undefined;\n                                        if (categoryIsSelected != null) {\n                                            categoryIsSelected = hasSelection;\n                                        }\n                                        else if (categoryIsSelected == null)\n                                            categoryIsSelected = !hasSelection;\n                                    }\n                                    else {\n                                        if (categoryIsSelected == null) {\n                                            categoryIsSelected = !hasSelection;\n                                        }\n                                    }\n                                }\n                                if (categoryIsSelected) {\n                                    this.numberOfCategoriesSelectedInData++;\n                                }\n                                var categoryValue = this.categoryValues[categoryIndex];\n                                var categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);\n                                if (this.dataViewCategorical.values) {\n                                    // Series are either measures in the multi-measure case, or the single series otherwise\n                                    for (var seriesIndex = 0; seriesIndex < this.dataViewCategorical.values.length; seriesIndex++) {\n                                        var seriesData = dataViewCategorical.values[seriesIndex];\n                                        if (seriesData.values[categoryIndex] != null) {\n                                            value = seriesData.values[categoryIndex];\n                                            if (seriesData.highlights) {\n                                                selectable = !(seriesData.highlights[categoryIndex] === null);\n                                            }\n                                            if (seriesData.source.groupName && seriesData.source.groupName !== '') {\n                                                imageURL = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);\n                                                if (!/^(ftp|http|https):\\/\\/[^ \"]+$/.test(imageURL)) {\n                                                    imageURL = undefined;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                this.dataPoints.push({\n                                    identity: visuals.SelectionId.createWithId(categoryIdentity),\n                                    category: categoryLabel,\n                                    imageURL: imageURL,\n                                    value: value,\n                                    selected: categoryIsSelected,\n                                    selectable: selectable\n                                });\n                            }\n                            if (numberOfScopeIds != null && numberOfScopeIds > this.numberOfCategoriesSelectedInData) {\n                                this.hasSelectionOverride = true;\n                            }\n                        }\n                    };\n                    return ChicletSlicerConverter;\n                }());\n                ChicletSlicerChartConversion.ChicletSlicerConverter = ChicletSlicerConverter;\n            })(ChicletSlicerChartConversion || (ChicletSlicerChartConversion = {}));\n            //TODO: This module should be removed once TextMeasruementService exports the \"estimateSvgTextBaselineDelta\" function.\n            var ChicletSlicerTextMeasurementHelper;\n            (function (ChicletSlicerTextMeasurementHelper) {\n                var spanElement;\n                var svgTextElement;\n                var canvasCtx;\n                function estimateSvgTextBaselineDelta(textProperties) {\n                    var rect = estimateSvgTextRect(textProperties);\n                    return rect.y + rect.height;\n                }\n                ChicletSlicerTextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;\n                function ensureDOM() {\n                    if (spanElement)\n                        return;\n                    spanElement = $('<span/>');\n                    $('body').append(spanElement);\n                    //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.\n                    svgTextElement = d3.select($('body').get(0))\n                        .append('svg')\n                        .style({\n                        'height': '0px',\n                        'width': '0px',\n                        'position': 'absolute'\n                    })\n                        .append('text');\n                    canvasCtx = $('<canvas/>').get(0).getContext(\"2d\");\n                }\n                function measureSvgTextRect(textProperties) {\n                    debug.assertValue(textProperties, 'textProperties');\n                    ensureDOM();\n                    svgTextElement.style(null);\n                    svgTextElement\n                        .text(textProperties.text)\n                        .attr({\n                        'visibility': 'hidden',\n                        'font-family': textProperties.fontFamily,\n                        'font-size': textProperties.fontSize,\n                        'font-weight': textProperties.fontWeight,\n                        'font-style': textProperties.fontStyle,\n                        'white-space': textProperties.whiteSpace || 'nowrap'\n                    });\n                    // We're expecting the browser to give a synchronous measurement here\n                    // We're using SVGTextElement because it works across all browsers \n                    return svgTextElement.node().getBBox();\n                }\n                function estimateSvgTextRect(textProperties) {\n                    debug.assertValue(textProperties, 'textProperties');\n                    var estimatedTextProperties = {\n                        fontFamily: textProperties.fontFamily,\n                        fontSize: textProperties.fontSize,\n                        text: \"M\",\n                    };\n                    var rect = measureSvgTextRect(estimatedTextProperties);\n                    return rect;\n                }\n            })(ChicletSlicerTextMeasurementHelper = samples.ChicletSlicerTextMeasurementHelper || (samples.ChicletSlicerTextMeasurementHelper = {}));\n            var ChicletSlicerWebBehavior = (function () {\n                function ChicletSlicerWebBehavior() {\n                }\n                ChicletSlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {\n                    var _this = this;\n                    var filterPropertyId = samples.chicletSlicerProps.filterPropertyIdentifier;\n                    var slicers = this.slicers = options.slicerItemContainers;\n                    this.slicerItemLabels = options.slicerItemLabels;\n                    this.slicerItemInputs = options.slicerItemInputs;\n                    var slicerClear = options.slicerClear;\n                    this.dataPoints = options.dataPoints;\n                    this.interactivityService = options.interactivityService;\n                    this.slicerSettings = options.slicerSettings;\n                    this.options = options;\n                    if (!this.options.isSelectionLoaded) {\n                        this.loadSelection(selectionHandler);\n                    }\n                    slicers.on(\"mouseover\", function (d) {\n                        if (d.selectable) {\n                            d.mouseOver = true;\n                            d.mouseOut = false;\n                            _this.renderMouseover();\n                        }\n                    });\n                    slicers.on(\"mouseout\", function (d) {\n                        if (d.selectable) {\n                            d.mouseOver = false;\n                            d.mouseOut = true;\n                            _this.renderMouseover();\n                        }\n                    });\n                    slicers.on(\"click\", function (d, index) {\n                        if (!d.selectable) {\n                            return;\n                        }\n                        var settings = _this.slicerSettings;\n                        d3.event.preventDefault();\n                        if (d3.event.altKey && settings.general.multiselect) {\n                            var selectedIndexes = jQuery.map(_this.dataPoints, function (d, index) { if (d.selected)\n                                return index; });\n                            var selIndex = selectedIndexes.length > 0 ? (selectedIndexes[selectedIndexes.length - 1]) : 0;\n                            if (selIndex > index) {\n                                var temp = index;\n                                index = selIndex;\n                                selIndex = temp;\n                            }\n                            selectionHandler.handleClearSelection();\n                            for (var i = selIndex; i <= index; i++) {\n                                selectionHandler.handleSelection(_this.dataPoints[i], true /* isMultiSelect */);\n                            }\n                        }\n                        else if (d3.event.ctrlKey && settings.general.multiselect) {\n                            selectionHandler.handleSelection(d, true /* isMultiSelect */);\n                        }\n                        else {\n                            selectionHandler.handleSelection(d, false /* isMultiSelect */);\n                        }\n                        selectionHandler.persistSelectionFilter(filterPropertyId);\n                        _this.saveSelection(selectionHandler);\n                    });\n                    slicerClear.on(\"click\", function (d) {\n                        selectionHandler.handleClearSelection();\n                        selectionHandler.persistSelectionFilter(filterPropertyId);\n                        _this.saveSelection(selectionHandler);\n                    });\n                };\n                ChicletSlicerWebBehavior.prototype.loadSelection = function (selectionHandler) {\n                    selectionHandler.handleClearSelection();\n                    var savedSelectionIds = this.slicerSettings.general.getSavedSelection();\n                    if (savedSelectionIds.length) {\n                        var selectedDataPoints = this.dataPoints.filter(function (d) { return savedSelectionIds.some(function (x) { return d.identity.getKey() === x; }); });\n                        selectedDataPoints.forEach(function (x) { return selectionHandler.handleSelection(x, true); });\n                        selectionHandler.persistSelectionFilter(samples.chicletSlicerProps.filterPropertyIdentifier);\n                    }\n                };\n                ChicletSlicerWebBehavior.prototype.saveSelection = function (selectionHandler) {\n                    var selectionIdKeys = selectionHandler.selectedIds.map(function (x) { return x.getKey(); });\n                    this.slicerSettings.general.setSavedSelection(selectionIdKeys);\n                };\n                ChicletSlicerWebBehavior.prototype.renderSelection = function (hasSelection) {\n                    if (!hasSelection && !this.interactivityService.isSelectionModeInverted()) {\n                        this.slicers.style('background', this.slicerSettings.slicerText.unselectedColor);\n                    }\n                    else {\n                        this.styleSlicerInputs(this.slicers, hasSelection);\n                    }\n                };\n                ChicletSlicerWebBehavior.prototype.renderMouseover = function () {\n                    var _this = this;\n                    this.slicerItemLabels.style({\n                        'color': function (d) {\n                            if (d.mouseOver)\n                                return _this.slicerSettings.slicerText.hoverColor;\n                            if (d.mouseOut) {\n                                if (d.selected)\n                                    return _this.slicerSettings.slicerText.fontColor;\n                                else\n                                    return _this.slicerSettings.slicerText.fontColor;\n                            }\n                        }\n                    });\n                };\n                ChicletSlicerWebBehavior.prototype.styleSlicerInputs = function (slicers, hasSelection) {\n                    var settings = this.slicerSettings;\n                    var selectedItems = [];\n                    slicers.each(function (d) {\n                        // get selected items\n                        if (d.selectable && d.selected) {\n                            selectedItems.push(d);\n                        }\n                        d3.select(this).style({\n                            'background': d.selectable ? (d.selected ? settings.slicerText.selectedColor : settings.slicerText.unselectedColor)\n                                : settings.slicerText.disabledColor\n                        });\n                        d3.select(this).classed('slicerItem-disabled', !d.selectable);\n                    });\n                };\n                return ChicletSlicerWebBehavior;\n            }());\n            samples.ChicletSlicerWebBehavior = ChicletSlicerWebBehavior;\n            var explore;\n            (function (explore) {\n                var util;\n                (function (util) {\n                    function hexToRGBString(hex, transparency) {\n                        // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n                        var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n                        hex = hex.replace(shorthandRegex, function (m, r, g, b) {\n                            return r + r + g + g + b + b;\n                        });\n                        // Hex format which return the format r-g-b\n                        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n                        var rgb = result ? {\n                            r: parseInt(result[1], 16),\n                            g: parseInt(result[2], 16),\n                            b: parseInt(result[3], 16)\n                        } : null;\n                        // Wrong input\n                        if (rgb === null) {\n                            return '';\n                        }\n                        if (!transparency && transparency !== 0) {\n                            return \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \")\";\n                        }\n                        else {\n                            return \"rgba(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \",\" + transparency + \")\";\n                        }\n                    }\n                    util.hexToRGBString = hexToRGBString;\n                })(util = explore.util || (explore.util = {}));\n            })(explore || (explore = {}));\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var ChordChart = (function () {\n                function ChordChart() {\n                }\n                /* Convert a DataView into a view model */\n                ChordChart.converter = function (dataView, colors, prevAxisVisible) {\n                    var catDv = dataView.categorical;\n                    var defaultDataPointColor = ChordChart.getDefaultDataPointColor(dataView).solid.color;\n                    var labelColor = ChordChart.getLabelsColor(dataView);\n                    var labelFontSize = ChordChart.getLabelsFontSize(dataView);\n                    if (catDv && catDv.categories && catDv.categories.length > 0 && catDv.values && catDv.categories[0].values && catDv.categories[0].values[0]) {\n                        var cat = catDv.categories[0];\n                        var catValues = cat.values;\n                        var values = catDv.values;\n                        var dataMatrix = [];\n                        var legendData = {\n                            dataPoints: [],\n                            title: values[0] && values[0].source ? values[0].source.displayName : \"\",\n                        };\n                        var toolTipData = [];\n                        var sliceTooltipData = [];\n                        var max = 1000;\n                        var seriesName = []; /* series name array */\n                        var seriesIndex = []; /* series index array */\n                        var catIndex = []; /* index array for category names */\n                        var isDiffFromTo = false; /* boolean variable indicates that From and To are different */\n                        var labelData = []; /* label data: !important */\n                        var colorHelper = new visuals.ColorHelper(colors, ChordChart.chordChartProps.dataPoint.fill, defaultDataPointColor);\n                        for (var i = 0, iLen = catValues.length; i < iLen; i++) {\n                            catIndex[catValues[i]] = i;\n                        }\n                        for (var i = 0, iLen = values.length; i < iLen; i++) {\n                            var seriesNameStr = visuals.converterHelper.getSeriesName(values[i].source);\n                            seriesName.push(seriesNameStr);\n                            seriesIndex[seriesNameStr] = i;\n                        }\n                        var totalFields = this.union_arrays(catValues, seriesName);\n                        if (ChordChart.getValidArrayLength(totalFields) ===\n                            ChordChart.getValidArrayLength(catValues) + ChordChart.getValidArrayLength(seriesName)) {\n                            isDiffFromTo = true;\n                        }\n                        var formatStringProp = ChordChart.chordChartProps.general.formatString;\n                        var categorySourceFormatString = visuals.valueFormatter.getFormatString(cat.source, formatStringProp);\n                        for (var i = 0, iLen = totalFields.length; i < iLen; i++) {\n                            var id = null;\n                            var color = '';\n                            var isCategory = false;\n                            if (catIndex[totalFields[i]] !== undefined) {\n                                var index = catIndex[totalFields[i]];\n                                id = visuals.SelectionIdBuilder\n                                    .builder()\n                                    .withCategory(cat, catIndex[totalFields[i]])\n                                    .createSelectionId();\n                                isCategory = true;\n                                var thisCategoryObjects = cat.objects ? cat.objects[index] : undefined;\n                                color = colorHelper.getColorForSeriesValue(thisCategoryObjects, /* cat.identityFields */ undefined, catValues[index]);\n                            }\n                            else if (seriesIndex[totalFields[i]] !== undefined) {\n                                var index = seriesIndex[totalFields[i]];\n                                var seriesData = values[index];\n                                var seriesObjects = seriesData && seriesData.objects && seriesData.objects[0];\n                                var seriesNameStr = visuals.converterHelper.getSeriesName(seriesData.source);\n                                id = visuals.SelectionId.createWithId(seriesData.identity);\n                                isCategory = false;\n                                color = colorHelper.getColorForSeriesValue(seriesObjects, /* values.identityFields */ undefined, seriesNameStr);\n                            }\n                            labelData.push({\n                                label: totalFields[i],\n                                labelColor: labelColor,\n                                barColor: color,\n                                isCategory: isCategory,\n                                identity: id,\n                                selected: false\n                            });\n                            dataMatrix.push([]);\n                            toolTipData.push([]);\n                            var formattedCategoryValue = visuals.valueFormatter.format(catValues[i], categorySourceFormatString);\n                            for (var j = 0, jLen = totalFields.length; j < jLen; j++) {\n                                var elementValue = 0;\n                                var tooltipInfo = [];\n                                if (catIndex[totalFields[i]] !== undefined &&\n                                    seriesIndex[totalFields[j]] !== undefined) {\n                                    var row = catIndex[totalFields[i]];\n                                    var col = seriesIndex[totalFields[j]];\n                                    if (values[col].values[row] !== null) {\n                                        elementValue = values[col].values[row];\n                                        if (elementValue > max)\n                                            max = elementValue;\n                                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, elementValue, null, null, col, row);\n                                    }\n                                }\n                                else if (isDiffFromTo && catIndex[totalFields[j]] !== undefined &&\n                                    seriesIndex[totalFields[i]] !== undefined) {\n                                    var row = catIndex[totalFields[j]];\n                                    var col = seriesIndex[totalFields[i]];\n                                    if (values[col].values[row] !== null) {\n                                        elementValue = values[col].values[row];\n                                    }\n                                }\n                                dataMatrix[i].push(elementValue);\n                                toolTipData[i].push({\n                                    tooltipInfo: tooltipInfo\n                                });\n                            }\n                            var totalSum = d3.sum(dataMatrix[i]);\n                            sliceTooltipData.push({\n                                tooltipInfo: [{\n                                        displayName: totalFields[i],\n                                        value: (ChordChart.isInt(totalSum)) ? totalSum.toFixed(0) : totalSum.toFixed(2)\n                                    }]\n                            });\n                        }\n                        var chordLayout = d3.layout.chord()\n                            .padding(0.1)\n                            .matrix(dataMatrix);\n                        var unitLength = Math.round(max / 5).toString().length - 1;\n                        return {\n                            dataMatrix: dataMatrix,\n                            labelDataPoints: ChordChart.convertToChordArcDescriptor(chordLayout.groups(), labelData),\n                            legendData: legendData,\n                            tooltipData: toolTipData,\n                            sliceTooltipData: sliceTooltipData,\n                            tickUnit: Math.pow(10, unitLength),\n                            differentFromTo: isDiffFromTo,\n                            defaultDataPointColor: defaultDataPointColor,\n                            prevAxisVisible: prevAxisVisible,\n                            showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),\n                            showLabels: ChordChart.getLabelsShow(dataView),\n                            showAxis: ChordChart.getAxisShow(dataView),\n                            labelFontSize: labelFontSize,\n                        };\n                    }\n                    else {\n                        return {\n                            dataMatrix: [],\n                            labelDataPoints: [],\n                            legendData: null,\n                            tooltipData: [],\n                            sliceTooltipData: [],\n                            tickUnit: 1000,\n                            differentFromTo: false,\n                            defaultDataPointColor: defaultDataPointColor,\n                            prevAxisVisible: prevAxisVisible,\n                            showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),\n                            showLabels: ChordChart.getLabelsShow(dataView),\n                            showAxis: ChordChart.getAxisShow(dataView),\n                            labelFontSize: labelFontSize,\n                        };\n                    }\n                };\n                /* Check every element of the array and returns the count of elements which are valid(not undefined) */\n                ChordChart.getValidArrayLength = function (array) {\n                    var len = 0;\n                    for (var i = 0, iLen = array.length; i < iLen; i++) {\n                        if (array[i] !== undefined) {\n                            len++;\n                        }\n                    }\n                    return len;\n                };\n                /* Convert ChordLayout to ChordArcDescriptor */\n                ChordChart.convertToChordArcDescriptor = function (groups, datum) {\n                    var labelDataPoints = [];\n                    for (var i = 0, iLen = groups.length; i < iLen; i++) {\n                        var labelDataPoint = groups[i];\n                        labelDataPoint.data = datum[i];\n                        labelDataPoints.push(labelDataPoint);\n                    }\n                    return labelDataPoints;\n                };\n                /* Calculate radius */\n                ChordChart.prototype.calculateRadius = function (viewport) {\n                    if (this.data && this.data.showLabels) {\n                        // if we have category or data labels, use a sigmoid to blend the desired denominator from 2 to 3.\n                        // if we are taller than we are wide, we need to use a larger denominator to leave horizontal room for the labels.\n                        var hw = viewport.height / viewport.width;\n                        var denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));\n                        return Math.min(viewport.height, viewport.width) / denom;\n                    }\n                    // no labels\n                    return Math.min(viewport.height, viewport.width) / 2;\n                };\n                /* Draw category labels */\n                ChordChart.drawDefaultCategoryLabels = function (graphicsContext, chordData, radius, viewport) {\n                    /** Multiplier to place the end point of the reference line at 0.05 * radius away from the outer edge of the chord/pie. */\n                    var arc = d3.svg.arc()\n                        .innerRadius(0)\n                        .outerRadius(radius * ChordChart.InnerArcRadiusRatio);\n                    var outerArc = d3.svg.arc()\n                        .innerRadius(radius * ChordChart.OuterArcRadiusRatio)\n                        .outerRadius(radius * ChordChart.OuterArcRadiusRatio);\n                    if (chordData.showLabels) {\n                        var labelLayout = ChordChart.getChordChartLabelLayout(radius, outerArc, viewport, chordData.labelFontSize);\n                        ChordChart.drawDefaultLabelsForChordChart(chordData.labelDataPoints, graphicsContext, labelLayout, viewport, radius, arc, outerArc);\n                    }\n                    else\n                        visuals.dataLabelUtils.cleanDataLabels(graphicsContext, true);\n                };\n                /* One time setup*/\n                ChordChart.prototype.init = function (options) {\n                    var element = this.element = options.element;\n                    this.selectionManager = new visuals.utility.SelectionManager({ hostServices: options.host });\n                    this.svg = d3.select(element.get(0))\n                        .append('svg')\n                        .style('position', 'absolute')\n                        .classed(ChordChart.VisualClassName, true);\n                    this.mainGraphicsContext = this.svg\n                        .append('g');\n                    this.mainGraphicsContext\n                        .append('g')\n                        .classed('slices', true);\n                    this.mainGraphicsContext\n                        .append('g')\n                        .classed('ticks', true);\n                    this.mainGraphicsContext\n                        .append('g')\n                        .classed('chords', true);\n                    this.colors = options.style.colorPalette.dataColors;\n                };\n                /* Called for data, size, formatting changes*/\n                ChordChart.prototype.update = function (options) {\n                    var _this = this;\n                    // assert dataView           \n                    if (!options.dataViews || !options.dataViews[0])\n                        return;\n                    // get animation duration\n                    var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;\n                    var dataView = this.dataView = options.dataViews[0];\n                    var prevAxisShow = (this.data) ? this.data.showAxis : !ChordChart.getAxisShow(dataView);\n                    var data = this.data = ChordChart.converter(dataView, this.colors, prevAxisShow);\n                    var viewport = options.viewport;\n                    var chordLayout = this.chordLayout = d3.layout.chord()\n                        .padding(0.1)\n                        .matrix(data.dataMatrix);\n                    var width = viewport.width;\n                    var height = viewport.height;\n                    var radius = this.calculateRadius(viewport);\n                    var sm = this.selectionManager;\n                    var innerRadius = radius;\n                    var outerRadius = radius * ChordChart.InnerArcRadiusRatio;\n                    var arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius);\n                    this.svg\n                        .attr({\n                        'width': width,\n                        'height': height\n                    });\n                    var mainGraphicsContext = this.mainGraphicsContext\n                        .attr('transform', visuals.SVGUtil.translate(width / 2, height / 2));\n                    var sliceShapes = this.svg.select('.slices')\n                        .selectAll('path' + ChordChart.sliceClass.selector)\n                        .data(chordLayout.groups);\n                    sliceShapes.enter()\n                        .insert(\"path\")\n                        .classed(ChordChart.sliceClass.class, true);\n                    sliceShapes.style('fill', function (d, i) { return data.labelDataPoints[i].data.barColor; })\n                        .style(\"stroke\", function (d, i) { return data.labelDataPoints[i].data.barColor; })\n                        .on('click', function (d, i) {\n                        var _this = this;\n                        sm.select(data.labelDataPoints[i].data.identity).then(function (ids) {\n                            if (ids.length > 0) {\n                                mainGraphicsContext.selectAll(\".chords path.chord\")\n                                    .style(\"opacity\", 1);\n                                mainGraphicsContext.selectAll(\".slices path.slice\")\n                                    .style('opacity', 0.3);\n                                mainGraphicsContext.selectAll(\".chords path.chord\")\n                                    .filter(function (d) { return d.source.index !== i && d.target.index !== i; })\n                                    .style(\"opacity\", 0.3);\n                                d3.select(_this).style('opacity', 1);\n                            }\n                            else {\n                                sliceShapes.style('opacity', 1);\n                                mainGraphicsContext.selectAll(\".chords path.chord\")\n                                    .filter(function (d) { return d.source.index !== i && d.target.index !== i; })\n                                    .style(\"opacity\", 1);\n                            }\n                        });\n                        d3.event.stopPropagation();\n                    })\n                        .transition()\n                        .duration(duration)\n                        .attr(\"d\", arc);\n                    sliceShapes.exit()\n                        .remove();\n                    visuals.TooltipManager.addTooltip(sliceShapes, function (tooltipEvent) {\n                        return data.sliceTooltipData[tooltipEvent.data.index].tooltipInfo;\n                    });\n                    var chordShapes = this.svg.select('.chords')\n                        .selectAll('path' + ChordChart.chordClass.selector)\n                        .data(chordLayout.chords);\n                    chordShapes\n                        .enter().insert(\"path\")\n                        .classed(ChordChart.chordClass.class, true);\n                    chordShapes.style(\"fill\", function (d, i) { return data.labelDataPoints[d.target.index].data.barColor; })\n                        .style(\"opacity\", 1)\n                        .transition()\n                        .duration(duration)\n                        .attr(\"d\", d3.svg.chord().radius(innerRadius));\n                    chordShapes.exit()\n                        .remove();\n                    this.svg\n                        .on('click', function () { return _this.selectionManager.clear().then(function () {\n                        sliceShapes.style('opacity', 1);\n                        chordShapes.style('opacity', 1);\n                    }); });\n                    ChordChart.drawTicks(this.mainGraphicsContext, data, chordLayout, outerRadius, duration, viewport);\n                    ChordChart.drawDefaultCategoryLabels(this.mainGraphicsContext, data, radius, viewport);\n                    visuals.TooltipManager.addTooltip(chordShapes, function (tooltipEvent) {\n                        var tooltipInfo = [];\n                        if (data.differentFromTo) {\n                            tooltipInfo = data.tooltipData[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex]\n                                .tooltipInfo;\n                        }\n                        else {\n                            tooltipInfo.push({\n                                displayName: data.labelDataPoints[tooltipEvent.data.source.index].data.label\n                                    + '->' + data.labelDataPoints[tooltipEvent.data.source.subindex].data.label,\n                                value: data.dataMatrix[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].toString()\n                            });\n                            tooltipInfo.push({\n                                displayName: data.labelDataPoints[tooltipEvent.data.target.index].data.label\n                                    + '->' + data.labelDataPoints[tooltipEvent.data.target.subindex].data.label,\n                                value: data.dataMatrix[tooltipEvent.data.target.index][tooltipEvent.data.target.subindex].toString()\n                            });\n                        }\n                        return tooltipInfo;\n                    });\n                };\n                /*About to remove your visual, do clean up here */\n                ChordChart.prototype.destroy = function () {\n                };\n                /* Clean ticks */\n                ChordChart.cleanTicks = function (context) {\n                    var empty = [];\n                    var tickLines = context.selectAll(ChordChart.tickLineClass.selector).data(empty);\n                    tickLines.exit().remove();\n                    var tickTexts = context.selectAll(ChordChart.tickTextClass.selector).data(empty);\n                    tickTexts.exit().remove();\n                    context.selectAll(ChordChart.tickPairClass.selector).remove();\n                    context.selectAll(ChordChart.sliceTicksClass.selector).remove();\n                };\n                /* Draw axis(ticks) around the arc */\n                ChordChart.drawTicks = function (graphicsContext, chordData, chordLayout, outerRadius, duration, viewport) {\n                    if (chordData.showAxis) {\n                        var tickShapes = graphicsContext.select('.ticks')\n                            .selectAll('g' + ChordChart.sliceTicksClass.selector)\n                            .data(chordLayout.groups);\n                        var animDuration = (chordData.prevAxisVisible === chordData.showAxis) ? duration : 0;\n                        tickShapes.enter().insert('g')\n                            .classed(ChordChart.sliceTicksClass.class, true);\n                        var tickPairs = tickShapes.selectAll('g' + ChordChart.tickPairClass.selector)\n                            .data(function (d) {\n                            var k = (d.endAngle - d.startAngle) / d.value;\n                            var range = d3.range(0, d.value, d.value - 1 < 0.15 ? 0.15 : d.value - 1);\n                            var retval = range.map(function (v, i) {\n                                var divider = 1000;\n                                var unitStr = 'k';\n                                if (chordData.tickUnit >= 1000 * 1000) {\n                                    divider = 1000 * 1000;\n                                    unitStr = 'm';\n                                }\n                                else if (chordData.tickUnit >= 1000) {\n                                    divider = 1000;\n                                    unitStr = 'k';\n                                }\n                                else {\n                                    divider = 1;\n                                    unitStr = '';\n                                }\n                                var retv = {\n                                    angle: v * k + d.startAngle,\n                                    label: Math.floor(v / divider) + unitStr\n                                };\n                                return retv;\n                            });\n                            return retval;\n                        });\n                        tickPairs.enter().insert('g')\n                            .classed(ChordChart.tickPairClass.class, true);\n                        tickPairs.transition()\n                            .duration(animDuration)\n                            .attr('transform', function (d) {\n                            return 'rotate(' + (d.angle * 180 / Math.PI - 90) + ')'\n                                + 'translate(' + outerRadius + ',0)';\n                        });\n                        tickPairs.selectAll('line' + ChordChart.tickLineClass.selector)\n                            .data(function (d) { return [d]; })\n                            .enter().insert('line')\n                            .classed(ChordChart.tickLineClass.class, true)\n                            .style(\"stroke\", \"#000\")\n                            .attr(\"x1\", 1)\n                            .attr(\"y1\", 0)\n                            .attr(\"x2\", 5)\n                            .attr(\"y2\", 0);\n                        tickPairs.selectAll('text' + ChordChart.tickTextClass.selector)\n                            .data(function (d) { return [d]; })\n                            .enter().insert('text')\n                            .classed(ChordChart.tickTextClass.class, true)\n                            .style(\"text-anchor\", function (d) { return d.angle > Math.PI ? \"end\" : null; })\n                            .text(function (d) { return d.label; })\n                            .attr(\"transform\", function (d) { return d.angle > Math.PI ? \"rotate(180)translate(-16)\" : null; })\n                            .attr(\"x\", 8)\n                            .attr(\"dy\", \".35em\");\n                        tickPairs.exit()\n                            .remove();\n                        tickShapes.exit()\n                            .remove();\n                    }\n                    else {\n                        ChordChart.cleanTicks(graphicsContext);\n                    }\n                };\n                /* Get format parameter axis whether it determines show ticks or not. Default value is true */\n                ChordChart.getAxisShow = function (dataView) {\n                    if (dataView && dataView.metadata) {\n                        var objects = dataView.metadata.objects;\n                        if (objects) {\n                            var axis = objects['axis'];\n                            if (axis && axis.hasOwnProperty('show')) {\n                                return axis['show'];\n                            }\n                        }\n                    }\n                    return true;\n                };\n                /* Get format parameter labels whether it determines show labels or not. Default value is true */\n                ChordChart.getLabelsShow = function (dataView) {\n                    if (dataView && dataView.metadata) {\n                        var objects = dataView.metadata.objects;\n                        if (objects) {\n                            var labels = objects['labels'];\n                            if (labels && labels.hasOwnProperty('show')) {\n                                return labels['show'];\n                            }\n                        }\n                    }\n                    return true;\n                };\n                /* Get format parameter labels whether it determines show labels or not. Default value is true */\n                ChordChart.getLabelsColor = function (dataView) {\n                    if (dataView && dataView.metadata) {\n                        var objects = dataView.metadata.objects;\n                        if (objects) {\n                            var labels = objects['labels'];\n                            if (labels && labels.hasOwnProperty('color'))\n                                return labels['color'].solid.color;\n                        }\n                    }\n                    return ChordChart.DefaultLabelColor;\n                };\n                ChordChart.getLabelsFontSize = function (dataView) {\n                    if (dataView && dataView.metadata) {\n                        var objects = dataView.metadata.objects;\n                        if (objects) {\n                            var labels = objects['labels'];\n                            if (labels && labels.hasOwnProperty('fontSize'))\n                                return labels['fontSize'];\n                        }\n                    }\n                    return ChordChart.DefaultLabelsFontSize;\n                };\n                /* Select labels */\n                ChordChart.selectLabels = function (filteredData, context, isDonut, forAnimation) {\n                    if (isDonut === void 0) { isDonut = false; }\n                    if (forAnimation === void 0) { forAnimation = false; }\n                    // Check for a case where resizing leaves no labels - then we need to remove the labels 'g'\n                    if (filteredData.length === 0) {\n                        visuals.dataLabelUtils.cleanDataLabels(context, true);\n                        return null;\n                    }\n                    if (context.select(ChordChart.labelGraphicsContextClass.selector).empty())\n                        context.append('g').classed(ChordChart.labelGraphicsContextClass.class, true);\n                    // line chart ViewModel has a special 'key' property for point identification since the 'identity' field is set to the series identity\n                    var hasKey = filteredData[0].key !== null;\n                    var hasDataPointIdentity = filteredData[0].identity !== null;\n                    var getIdentifier = hasKey ?\n                        function (d) { return d.key; }\n                        : hasDataPointIdentity ?\n                            function (d) { return d.identity.getKey(); }\n                            : undefined;\n                    var labels = isDonut ?\n                        context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, function (d) { return d.data.identity.getKey(); })\n                        : getIdentifier !== null ?\n                            context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, getIdentifier)\n                            : context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData);\n                    var newLabels = labels.enter()\n                        .append('text')\n                        .classed(ChordChart.labelsClass.class, true);\n                    if (forAnimation)\n                        newLabels.style('opacity', 0);\n                    return labels;\n                };\n                /* Draw labels */\n                ChordChart.drawDefaultLabelsForChordChart = function (data, context, layout, viewport, radius, arc, outerArc) {\n                    // Hide and reposition labels that overlap\n                    var dataLabelManager = new powerbi.DataLabelManager();\n                    var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, /* addTransform */ true);\n                    var labels = ChordChart.selectLabels(filteredData, context, true);\n                    if (!labels) {\n                        return;\n                    }\n                    labels\n                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; }, dy: '.35em' })\n                        .text(function (d) { return d.labeltext; })\n                        .style(layout.style);\n                    labels\n                        .exit()\n                        .remove();\n                    if (context.select(ChordChart.linesGraphicsContextClass.selector).empty()) {\n                        context\n                            .append('g')\n                            .classed(ChordChart.linesGraphicsContextClass.class, true);\n                    }\n                    var lines = context.select(ChordChart.linesGraphicsContextClass.selector).selectAll('polyline')\n                        .data(filteredData, function (d) { return d.data.identity.getKey(); });\n                    var innerLinePointMultiplier = 2.05;\n                    var midAngle = function (d) {\n                        return d.startAngle + (d.endAngle - d.startAngle) / 2;\n                    };\n                    lines.enter()\n                        .append('polyline')\n                        .classed(ChordChart.lineClass.class, true);\n                    lines\n                        .attr('points', function (d) {\n                        var textPoint = outerArc.centroid(d);\n                        textPoint[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);\n                        var midPoint = outerArc.centroid(d);\n                        var chartPoint = arc.centroid(d);\n                        chartPoint[0] *= innerLinePointMultiplier;\n                        chartPoint[1] *= innerLinePointMultiplier;\n                        return [chartPoint, midPoint, textPoint];\n                    }).\n                        style({\n                        'opacity': function (d) { return ChordChart.PolylineOpacity; },\n                        'stroke': function (d) { return d.data.labelColor; },\n                    });\n                    lines\n                        .exit()\n                        .remove();\n                };\n                /* Get label layout */\n                ChordChart.getChordChartLabelLayout = function (radius, outerArc, viewport, labelFontSize) {\n                    var midAngle = function (d) {\n                        return d.startAngle + (d.endAngle - d.startAngle) / 2;\n                    };\n                    var spaceAvaliableForLabels = viewport.width / 2 - radius;\n                    var minAvailableSpace = Math.min(spaceAvaliableForLabels, visuals.dataLabelUtils.maxLabelWidth);\n                    var PixelConverter = jsCommon.PixelConverter;\n                    return {\n                        labelText: function (d) {\n                            // show only category label\n                            return visuals.dataLabelUtils.getLabelFormattedText({\n                                label: d.data.label,\n                                maxWidth: minAvailableSpace,\n                                fontSize: labelFontSize,\n                            });\n                        },\n                        labelLayout: {\n                            x: function (d) {\n                                return radius * (midAngle(d) < Math.PI ? 1 : -1);\n                            },\n                            y: function (d) {\n                                var pos = outerArc.centroid(d);\n                                return pos[1];\n                            },\n                        },\n                        filter: function (d) { return (d !== null && d.data !== null && d.data.label !== null); },\n                        style: {\n                            'fill': function (d) { return d.data.labelColor; },\n                            'text-anchor': function (d) { return midAngle(d) < Math.PI ? 'start' : 'end'; },\n                            'font-size': function (d) { return PixelConverter.fromPointToPixel(labelFontSize); },\n                        },\n                    };\n                };\n                /* Get Default Datapoint color */\n                ChordChart.getDefaultDataPointColor = function (dataView, defaultValue) {\n                    if (dataView && dataView.metadata) {\n                        var objects = dataView.metadata.objects;\n                        if (objects) {\n                            var dataPoint = objects['dataPoint'];\n                            if (dataPoint && dataPoint.hasOwnProperty('defaultColor')) {\n                                var defaultColor = dataPoint['defaultColor'];\n                                if (defaultColor) {\n                                    return defaultColor;\n                                }\n                            }\n                        }\n                    }\n                    return { solid: { color: defaultValue } };\n                };\n                /* Get format paramter value (showAllDataPoints)  */\n                ChordChart.getShowAllDataPoints = function (dataView) {\n                    if (!dataView || !dataView.metadata || !dataView.metadata.objects)\n                        return false;\n                    var objects = dataView.metadata.objects;\n                    var dataPoint = objects['dataPoint'];\n                    if (dataPoint && dataPoint.hasOwnProperty('showAllDataPoints')) {\n                        return dataPoint['showAllDataPoints'];\n                    }\n                    return false;\n                };\n                /* Enumerate format values */\n                ChordChart.prototype.enumerateObjectInstances = function (options) {\n                    var instances = [];\n                    var axis;\n                    switch (options.objectName) {\n                        case 'axis':\n                            axis = {\n                                objectName: 'axis',\n                                displayName: 'Axis',\n                                selector: null,\n                                properties: {\n                                    show: ChordChart.getAxisShow(this.dataView)\n                                }\n                            };\n                            instances.push(axis);\n                            break;\n                        case 'labels':\n                            axis = {\n                                objectName: 'labels',\n                                displayName: 'Labels',\n                                selector: null,\n                                properties: {\n                                    show: ChordChart.getLabelsShow(this.dataView),\n                                    color: ChordChart.getLabelsColor(this.dataView),\n                                    fontSize: ChordChart.getLabelsFontSize(this.dataView),\n                                }\n                            };\n                            instances.push(axis);\n                            break;\n                        case 'dataPoint':\n                            var defaultColor = {\n                                objectName: 'dataPoint',\n                                selector: null,\n                                properties: {\n                                    defaultColor: {\n                                        solid: { color: (this.data && this.data.defaultDataPointColor) ? this.data.defaultDataPointColor : this.colors.getColorByIndex(0).value }\n                                    }\n                                }\n                            };\n                            instances.push(defaultColor);\n                            var showAllDataPoints = {\n                                objectName: 'dataPoint',\n                                selector: null,\n                                properties: {\n                                    showAllDataPoints: this.data ? !!this.data.showAllDataPoints : false,\n                                }\n                            };\n                            instances.push(showAllDataPoints);\n                            if (this.data && this.data.labelDataPoints) {\n                                for (var i = 0, iLen = this.data.labelDataPoints.length; i < iLen; i++) {\n                                    var labelDataPoint = this.data.labelDataPoints[i].data;\n                                    if (labelDataPoint.isCategory) {\n                                        var colorInstance = {\n                                            objectName: 'dataPoint',\n                                            displayName: labelDataPoint.label,\n                                            selector: visuals.ColorHelper.normalizeSelector(labelDataPoint.identity.getSelector()),\n                                            properties: {\n                                                fill: { solid: { color: labelDataPoint.barColor } }\n                                            }\n                                        };\n                                        instances.push(colorInstance);\n                                    }\n                                }\n                            }\n                            break;\n                    }\n                    return instances;\n                };\n                /* Utility function for checking if it is integer or float */\n                ChordChart.isInt = function (n) {\n                    return n % 1 === 0;\n                };\n                /* Utility function for union two arrays without duplicates */\n                ChordChart.union_arrays = function (x, y) {\n                    var obj = {};\n                    for (var i = 0; i < x.length; i++) {\n                        obj[x[i]] = x[i];\n                    }\n                    for (var i = 0; i < y.length; i++) {\n                        obj[y[i]] = y[i];\n                    }\n                    var res = [];\n                    for (var k in obj) {\n                        if (obj.hasOwnProperty(k)) {\n                            res.push(obj[k]);\n                        }\n                    }\n                    return res;\n                };\n                ChordChart.capabilities = {\n                    dataRoles: [\n                        {\n                            name: 'Category',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'From',\n                        }, {\n                            name: 'Series',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'To',\n                        }, {\n                            name: 'Y',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),\n                        }\n                    ],\n                    dataViewMappings: [{\n                            conditions: [\n                                { 'Category': { max: 1 }, 'Series': { max: 0 } },\n                                { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },\n                                { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 } },\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Category' },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: {\n                                    group: {\n                                        by: 'Series',\n                                        select: [{ bind: { to: 'Y' } }],\n                                        dataReductionAlgorithm: { top: {} }\n                                    },\n                                },\n                                rowCount: { preferred: { min: 2 }, supported: { min: 1 } }\n                            },\n                        }],\n                    objects: {\n                        dataPoint: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),\n                            properties: {\n                                defaultColor: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                showAllDataPoints: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\n                                    type: { bool: true }\n                                },\n                                fill: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                            },\n                        },\n                        axis: {\n                            displayName: 'Axis',\n                            properties: {\n                                show: {\n                                    type: { bool: true }\n                                },\n                            },\n                        },\n                        labels: {\n                            displayName: 'Labels',\n                            properties: {\n                                show: {\n                                    type: { bool: true }\n                                },\n                                color: {\n                                    displayName: powerbi.data.createDisplayNameGetter(\"Visual_Reference_Line_Data_Label_Color\"),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { formatting: { fontSize: true } },\n                                },\n                            },\n                        }\n                    }\n                };\n                ChordChart.chordChartProps = {\n                    general: {\n                        formatString: { objectName: 'general', propertyName: 'formatString' },\n                    },\n                    dataPoint: {\n                        defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },\n                        fill: { objectName: 'dataPoint', propertyName: 'fill' },\n                        showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },\n                    },\n                    axis: {\n                        show: { objectName: 'axis', propertyName: 'show' },\n                    },\n                    labels: {\n                        show: { objectName: 'labels', propertyName: 'show' },\n                        color: { objectName: 'labels', propertyName: 'color' },\n                        fontSize: { objectName: 'labels', propertyName: 'fontSize' },\n                    },\n                };\n                ChordChart.PolylineOpacity = 0.5;\n                ChordChart.OuterArcRadiusRatio = 0.9;\n                ChordChart.InnerArcRadiusRatio = 0.8;\n                ChordChart.DefaultLabelColor = \"#777777\";\n                ChordChart.DefaultLabelsFontSize = 12;\n                ChordChart.VisualClassName = 'chordChart';\n                ChordChart.sliceClass = {\n                    class: 'slice',\n                    selector: '.slice',\n                };\n                ChordChart.chordClass = {\n                    class: 'chord',\n                    selector: '.chord',\n                };\n                ChordChart.sliceTicksClass = {\n                    class: 'slice-ticks',\n                    selector: '.slice-ticks'\n                };\n                ChordChart.tickPairClass = {\n                    class: 'tick-pair',\n                    selector: '.tick-pair'\n                };\n                ChordChart.tickLineClass = {\n                    class: 'tick-line',\n                    selector: '.tick-line'\n                };\n                ChordChart.tickTextClass = {\n                    class: 'tick-text',\n                    selector: '.tick-text'\n                };\n                ChordChart.labelGraphicsContextClass = {\n                    class: 'labels',\n                    selector: '.labels',\n                };\n                ChordChart.labelsClass = {\n                    class: 'data-labels',\n                    selector: '.data-labels',\n                };\n                ChordChart.linesGraphicsContextClass = {\n                    class: 'lines',\n                    selector: '.lines',\n                };\n                ChordChart.lineClass = {\n                    class: 'line-label',\n                    selector: '.line-label',\n                };\n                return ChordChart;\n            }());\n            samples.ChordChart = ChordChart;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var DataRoleHelper = powerbi.data.DataRoleHelper;\n            var EnhancedScatterChart = (function () {\n                function EnhancedScatterChart() {\n                    this.AxisGraphicsContextClassName = 'axisGraphicsContext';\n                    this.ScrollBarWidth = 10;\n                    this.textProperties = {\n                        fontFamily: 'wf_segoe-ui_normal',\n                        fontSize: jsCommon.PixelConverter.toString(EnhancedScatterChart.AxisFontSize),\n                    };\n                }\n                Object.defineProperty(EnhancedScatterChart.prototype, \"margin\", {\n                    get: function () {\n                        return this._margin || { left: 0, right: 0, top: 0, bottom: 0 };\n                    },\n                    set: function (value) {\n                        this._margin = $.extend({}, value);\n                        this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(EnhancedScatterChart.prototype, \"viewport\", {\n                    get: function () {\n                        return this._viewport || { width: 0, height: 0 };\n                    },\n                    set: function (value) {\n                        this._viewport = $.extend({}, value);\n                        this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(EnhancedScatterChart.prototype, \"viewportIn\", {\n                    get: function () {\n                        return this._viewportIn || this.viewport;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(EnhancedScatterChart.prototype, \"legendViewport\", {\n                    get: function () {\n                        return this.legend.getMargins();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                EnhancedScatterChart.substractMargin = function (viewport, margin) {\n                    return {\n                        width: Math.max(viewport.width - (margin.left + margin.right), 0),\n                        height: Math.max(viewport.height - (margin.top + margin.bottom), 0)\n                    };\n                };\n                EnhancedScatterChart.getCustomSymbolType = function (shape) {\n                    var customSymbolTypes = d3.map({\n                        \"circle\": function (size) {\n                            var r = Math.sqrt(size / Math.PI);\n                            return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + (-r) + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\n                        },\n                        \"cross\": function (size) {\n                            var r = Math.sqrt(size / 5) / 2;\n                            return \"M\" + -3 * r + \",\" + -r\n                                + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\n                        },\n                        \"diamond\": function (size) {\n                            var ry = Math.sqrt(size / (2 * Math.tan(Math.PI / 6))), rx = ry * Math.tan(Math.PI / 6);\n                            return \"M0,\" + -ry\n                                + \"L\" + rx + \",0\"\n                                + \" 0,\" + ry\n                                + \" \" + -rx + \",0\"\n                                + \"Z\";\n                        },\n                        \"square\": function (size) {\n                            var r = Math.sqrt(size) / 2;\n                            return \"M\" + -r + \",\" + -r\n                                + \"L\" + r + \",\" + -r\n                                + \" \" + r + \",\" + r\n                                + \" \" + -r + \",\" + r\n                                + \"Z\";\n                        },\n                        \"triangle-up\": function (size) {\n                            var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;\n                            return \"M0,\" + -ry\n                                + \"L\" + rx + \",\" + ry\n                                + \" \" + -rx + \",\" + ry\n                                + \"Z\";\n                        },\n                        \"triangle-down\": function (size) {\n                            var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;\n                            return \"M0,\" + ry\n                                + \"L\" + rx + \",\" + -ry\n                                + \" \" + -rx + \",\" + -ry\n                                + \"Z\";\n                        },\n                        'star': function (size) {\n                            var outerRadius = Math.sqrt(size / 2);\n                            var innerRadius = Math.sqrt(size / 10);\n                            var results = \"\";\n                            var angle = Math.PI / 5;\n                            for (var i = 0; i < 10; i++) {\n                                // Use outer or inner radius depending on what iteration we are in.\n                                var r = (i & 1) === 0 ? outerRadius : innerRadius;\n                                var currX = Math.cos(i * angle) * r;\n                                var currY = Math.sin(i * angle) * r;\n                                // Our first time we simply append the coordinates, subsequet times\n                                // we append a \", \" to distinguish each coordinate pair.\n                                if (i === 0) {\n                                    results = \"M\" + currX + \",\" + currY + \"L\";\n                                }\n                                else {\n                                    results += \" \" + currX + \",\" + currY;\n                                }\n                            }\n                            return results + \"Z\";\n                        },\n                        'hexagon': function (size) {\n                            var r = Math.sqrt(size / (6 * Math.sqrt(3)));\n                            var r2 = Math.sqrt(size / (2 * Math.sqrt(3)));\n                            return \"M0,\" + (2 * r) + \"L\" + (-r2) + \",\" + r + \" \" + (-r2) + \",\" + (-r) + \" 0,\" + (-2 * r) + \" \" + r2 + \",\" + (-r) + \" \" + r2 + \",\" + r + \"Z\";\n                        },\n                        'x': function (size) {\n                            var r = Math.sqrt(size / 10);\n                            return \"M0,\" + r + \"L\" + (-r) + \",\" + 2 * r + \" \" + (-2 * r) + \",\" + r + \" \" + (-r) + \",0 \" + (-2 * r) + \",\" + (-r) + \" \" + (-r) + \",\" + (-2 * r) + \" 0,\" + (-r) + \" \" + r + \",\" + (-2 * r) + \" \" + (2 * r) + \",\" + (-r) + \" \" + r + \",0 \" + (2 * r) + \",\" + r + \" \" + r + \",\" + (2 * r) + \"Z\";\n                        },\n                        'uparrow': function (size) {\n                            var r = Math.sqrt(size / 12);\n                            return \"M\" + r + \",\" + (3 * r) + \"L\" + (-r) + \",\" + (3 * r) + \" \" + (-r) + \",\" + (-r) + \" \" + (-2 * r) + \",\" + (-r) + \" 0,\" + (-3 * r) + \" \" + (2 * r) + \",\" + (-r) + \" \" + r + \",\" + (-r) + \"Z\";\n                        },\n                        'downarrow': function (size) {\n                            var r = Math.sqrt(size / 12);\n                            return \"M0,\" + (3 * r) + \"L\" + (-2 * r) + \",\" + r + \" \" + (-r) + \",\" + r + \" \" + (-r) + \",\" + (-3 * r) + \" \" + r + \",\" + (-3 * r) + \" \" + r + \",\" + r + \" \" + (2 * r) + \",\" + r + \"Z\";\n                        }\n                    });\n                    var defaultValue = customSymbolTypes.entries()[0].value;\n                    if (!shape) {\n                        return defaultValue;\n                    }\n                    else if (isNaN(shape)) {\n                        return customSymbolTypes[shape && shape.toString().toLowerCase()] || defaultValue;\n                    }\n                    else {\n                        var result = customSymbolTypes.entries()[Math.floor(shape)];\n                        return result ? result.value : defaultValue;\n                    }\n                };\n                EnhancedScatterChart.prototype.init = function (options) {\n                    this.options = options;\n                    this.animator = new visuals.BaseAnimator();\n                    this.behavior = new visuals.CartesianChartBehavior([new visuals.ScatterChartWebBehavior()]);\n                    var element = this.element = options.element;\n                    this.viewport = _.clone(options.viewport);\n                    this.style = options.style;\n                    this.hostServices = options.host;\n                    this.colors = this.style.colorPalette.dataColors;\n                    this.interactivity = options.interactivity;\n                    this.margin = {\n                        top: 1,\n                        right: 1,\n                        bottom: 1,\n                        left: 1\n                    };\n                    this.yAxisOrientation = visuals.yAxisPosition.left;\n                    this.adjustMargins();\n                    var showLinesOnX = this.scrollY = true;\n                    var showLinesOnY = this.scrollX = true;\n                    var svg = this.svg = d3.select(element.get(0))\n                        .append('svg')\n                        .style('position', 'absolute')\n                        .classed(EnhancedScatterChart.ClassName, true);\n                    var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')\n                        .classed(this.AxisGraphicsContextClassName, true);\n                    this.svgScrollable = svg.append('svg')\n                        .classed('svgScrollable', true)\n                        .style('overflow', 'hidden');\n                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')\n                        .classed(this.AxisGraphicsContextClassName, true);\n                    this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);\n                    var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;\n                    this.backgroundGraphicsContext = axisGraphicsContext.append('svg:image');\n                    this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');\n                    this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');\n                    this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);\n                    this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);\n                    this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);\n                    this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);\n                    this.interactivityService = visuals.createInteractivityService(this.hostServices);\n                    this.legend = visuals.createLegend(element, this.interactivity && this.interactivity.isInteractiveLegend, this.interactivityService, true);\n                    this.mainGraphicsG = this.axisGraphicsContextScrollable.append('g')\n                        .classed(EnhancedScatterChart.MainGraphicsContextClassName, true);\n                    this.mainGraphicsContext = this.mainGraphicsG.append('svg');\n                    this.svgDefaultImage = \"http://svg-edit.googlecode.com/svn-history/r1771/trunk/clipart/sun.svg\";\n                    this.keyArray = [];\n                };\n                EnhancedScatterChart.prototype.adjustMargins = function () {\n                    // Adjust margins if ticks are not going to be shown on either axis\n                    var xAxis = this.element.find('.x.axis');\n                    if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(this.viewportIn.width) === 0\n                        && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(this.viewportIn.height) === 0) {\n                        this.margin = {\n                            top: 0,\n                            right: 0,\n                            bottom: 0,\n                            left: 0\n                        };\n                        xAxis.hide();\n                    }\n                    else {\n                        xAxis.show();\n                    }\n                };\n                EnhancedScatterChart.prototype.getValueAxisProperties = function (dataViewMetadata, axisTitleOnByDefault) {\n                    var toReturn = {};\n                    if (!dataViewMetadata)\n                        return toReturn;\n                    var objects = dataViewMetadata.objects;\n                    if (objects) {\n                        var valueAxisObject = objects['valueAxis'];\n                        if (valueAxisObject) {\n                            toReturn = {\n                                show: valueAxisObject['show'],\n                                position: valueAxisObject['position'],\n                                axisScale: valueAxisObject['axisScale'],\n                                start: valueAxisObject['start'],\n                                end: valueAxisObject['end'],\n                                showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],\n                                axisStyle: valueAxisObject['axisStyle'],\n                                axisColor: valueAxisObject['axisColor'],\n                                secShow: valueAxisObject['secShow'],\n                                secPosition: valueAxisObject['secPosition'],\n                                secAxisScale: valueAxisObject['secAxisScale'],\n                                secStart: valueAxisObject['secStart'],\n                                secEnd: valueAxisObject['secEnd'],\n                                secShowAxisTitle: valueAxisObject['secShowAxisTitle'],\n                                secAxisStyle: valueAxisObject['secAxisStyle'],\n                                labelDisplayUnits: valueAxisObject['labelDisplayUnits'],\n                            };\n                        }\n                    }\n                    return toReturn;\n                };\n                EnhancedScatterChart.prototype.getCategoryAxisProperties = function (dataViewMetadata, axisTitleOnByDefault) {\n                    var toReturn = {};\n                    if (!dataViewMetadata)\n                        return toReturn;\n                    var objects = dataViewMetadata.objects;\n                    if (objects) {\n                        var categoryAxisObject = objects['categoryAxis'];\n                        if (categoryAxisObject) {\n                            toReturn = {\n                                show: categoryAxisObject['show'],\n                                axisType: categoryAxisObject['axisType'],\n                                axisScale: categoryAxisObject['axisScale'],\n                                axisColor: categoryAxisObject['axisColor'],\n                                start: categoryAxisObject['start'],\n                                end: categoryAxisObject['end'],\n                                showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],\n                                axisStyle: categoryAxisObject['axisStyle'],\n                                labelDisplayUnits: categoryAxisObject['labelDisplayUnits']\n                            };\n                        }\n                    }\n                    return toReturn;\n                };\n                EnhancedScatterChart.converter = function (dataView, currentViewport, colorPalette, interactivityService, categoryAxisProperties, valueAxisProperties) {\n                    var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName;\n                    var dataViewCategorical = dataView.categorical;\n                    var dataViewMetadata = dataView.metadata;\n                    if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {\n                        categoryValues = dataViewCategorical.categories[0].values;\n                        categoryFormatter = visuals.valueFormatter.create({ format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString), value: categoryValues[0], value2: categoryValues[categoryValues.length - 1] });\n                        categoryIdentities = dataViewCategorical.categories[0].identity;\n                        categoryObjects = dataViewCategorical.categories[0].objects;\n                        categoryQueryName = dataViewCategorical.categories[0].source.queryName;\n                    }\n                    else {\n                        categoryValues = [null];\n                        // creating default formatter for null value (to get the right string of empty value from the locale)\n                        categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null);\n                    }\n                    var categories = dataViewCategorical.categories;\n                    var dataValues = dataViewCategorical.values;\n                    var hasDynamicSeries = !!dataValues.source;\n                    var grouped = dataValues.grouped();\n                    var useShape = (!!(DataRoleHelper.getMeasureIndexOfRole(grouped, 'Image') >= 0)) ? false : true;\n                    var useCustomColor = (!!(DataRoleHelper.getMeasureIndexOfRole(grouped, 'ColorFill') >= 0)) ? true : false;\n                    var dvSource = dataValues.source;\n                    var scatterMetadata = EnhancedScatterChart.getMetadata(grouped, dvSource);\n                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();\n                    var fillPoint = false;\n                    var backdrop = { show: false, url: \"\" };\n                    var crosshair = false;\n                    var outline = false;\n                    var defaultDataPointColor = \"\";\n                    var showAllDataPoints = true;\n                    if (dataViewMetadata && dataViewMetadata.objects) {\n                        var objects = dataViewMetadata.objects;\n                        defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);\n                        showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);\n                        /*if(objects['dataPoint']){\n                            let shapeObj = objects['dataPoint'];\n                            if(shapeObj['useShape']){\n                                shape = <boolean>shapeObj['useShape'];\n                            }\n                        }*/\n                        var labelsObj = objects['categoryLabels'];\n                        if (labelsObj) {\n                            dataLabelsSettings.show = (labelsObj['show'] !== undefined) ? labelsObj['show'] : dataLabelsSettings.show;\n                            dataLabelsSettings.fontSize = (labelsObj['fontSize'] !== undefined) ? labelsObj['fontSize'] : dataLabelsSettings.fontSize;\n                            if (labelsObj['color'] !== undefined) {\n                                dataLabelsSettings.labelColor = labelsObj['color'].solid.color;\n                            }\n                        }\n                        fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, fillPoint);\n                        var backdropObject = objects['backdrop'];\n                        if (backdropObject !== undefined) {\n                            backdrop.show = backdropObject['show'];\n                            if (backdrop.show) {\n                                backdrop.url = backdropObject['url'];\n                            }\n                        }\n                        var crosshairObject = objects['crosshair'];\n                        if (crosshairObject !== undefined) {\n                            crosshair = crosshairObject['show'];\n                        }\n                        var outlineObject = objects['outline'];\n                        if (outlineObject !== undefined) {\n                            outline = outlineObject['show'];\n                        }\n                    }\n                    var dataPoints = EnhancedScatterChart.createDataPoints(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, dataLabelsSettings, defaultDataPointColor, categoryQueryName);\n                    if (interactivityService) {\n                        interactivityService.applySelectionStateToData(dataPoints);\n                    }\n                    var legendItems = hasDynamicSeries\n                        ? EnhancedScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), defaultDataPointColor)\n                        : [];\n                    var legendTitle = dataValues && dvSource ? dvSource.displayName : \"\";\n                    if (!legendTitle) {\n                        legendTitle = categories && categories[0].source.displayName ? categories[0].source.displayName : \"\";\n                    }\n                    var legendData = { title: legendTitle, dataPoints: legendItems };\n                    var sizeRange = EnhancedScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);\n                    if (categoryAxisProperties && categoryAxisProperties[\"showAxisTitle\"] !== null && categoryAxisProperties[\"showAxisTitle\"] === false) {\n                        scatterMetadata.axesLabels.x = null;\n                    }\n                    if (valueAxisProperties && valueAxisProperties[\"showAxisTitle\"] !== null && valueAxisProperties[\"showAxisTitle\"] === false) {\n                        scatterMetadata.axesLabels.y = null;\n                    }\n                    if (dataPoints && dataPoints[0]) {\n                        var point = dataPoints[0];\n                        if (point.backdrop != null) {\n                            backdrop.show = true;\n                            backdrop.url = point.backdrop;\n                        }\n                        if (point.xStart != null) {\n                            categoryAxisProperties['start'] = point.xStart;\n                        }\n                        if (point.xEnd != null) {\n                            categoryAxisProperties['end'] = point.xEnd;\n                        }\n                        if (point.yStart != null) {\n                            valueAxisProperties['start'] = point.yStart;\n                        }\n                        if (point.yEnd != null) {\n                            valueAxisProperties['end'] = point.yEnd;\n                        }\n                    }\n                    return {\n                        xCol: scatterMetadata.cols.x,\n                        yCol: scatterMetadata.cols.y,\n                        dataPoints: dataPoints,\n                        legendData: legendData,\n                        axesLabels: scatterMetadata.axesLabels,\n                        selectedIds: [],\n                        size: scatterMetadata.cols.size,\n                        sizeRange: sizeRange,\n                        dataLabelsSettings: dataLabelsSettings,\n                        defaultDataPointColor: defaultDataPointColor,\n                        hasDynamicSeries: hasDynamicSeries,\n                        showAllDataPoints: showAllDataPoints,\n                        fillPoint: fillPoint,\n                        useShape: useShape,\n                        useCustomColor: useCustomColor,\n                        backdrop: backdrop,\n                        crosshair: crosshair,\n                        outline: outline\n                    };\n                };\n                EnhancedScatterChart.createSeriesLegend = function (dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {\n                    var grouped = dataValues.grouped();\n                    var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);\n                    var legendItems = [];\n                    for (var i = 0, len = grouped.length; i < len; i++) {\n                        var grouping = grouped[i];\n                        var color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);\n                        legendItems.push({\n                            color: color,\n                            icon: visuals.LegendIcon.Circle,\n                            label: visuals.valueFormatter.format(grouping.name, formatString),\n                            identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),\n                            selected: false,\n                        });\n                    }\n                    return legendItems;\n                };\n                EnhancedScatterChart.getSizeRangeForGroups = function (dataViewValueGroups, sizeColumnIndex) {\n                    var result = {};\n                    if (dataViewValueGroups) {\n                        dataViewValueGroups.forEach(function (group) {\n                            var sizeColumn = visuals.ScatterChart.getMeasureValue(sizeColumnIndex, group.values);\n                            var currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);\n                            if (result.min == null || result.min > currentRange.min) {\n                                result.min = currentRange.min;\n                            }\n                            if (result.max == null || result.max < currentRange.max) {\n                                result.max = currentRange.max;\n                            }\n                        });\n                    }\n                    return result;\n                };\n                EnhancedScatterChart.getMetadata = function (grouped, source) {\n                    var xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X');\n                    var yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y');\n                    var sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Size');\n                    var gradientIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Gradient');\n                    var colorFillIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'ColorFill');\n                    var shapeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Shape');\n                    var imageIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Image');\n                    var rotationIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Rotation');\n                    var backdropIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Backdrop');\n                    var xStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X Start');\n                    var xEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X End');\n                    var yStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y Start');\n                    var yEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y End');\n                    var xCol;\n                    var yCol;\n                    var sizeCol;\n                    var colorFillCol;\n                    var shapeCol;\n                    var imageCol;\n                    var rotationCol;\n                    var backdropCol;\n                    var xStartCol;\n                    var xEndCol;\n                    var yStartCol;\n                    var yEndCol;\n                    var xAxisLabel = \"\";\n                    var yAxisLabel = \"\";\n                    if (grouped && grouped.length) {\n                        var firstGroup = grouped[0], measureCount = firstGroup.values.length;\n                        if (!(xIndex >= 0))\n                            xIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                        if (!(yIndex >= 0))\n                            yIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                        if (!(sizeIndex >= 0))\n                            sizeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                        if (!(colorFillIndex >= 0))\n                            colorFillIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                        if (!(shapeIndex >= 0))\n                            shapeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                        if (!(imageIndex >= 0)) {\n                            imageIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                        }\n                        if (!(rotationIndex >= 0))\n                            rotationIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                        if (!(backdropIndex >= 0))\n                            backdropIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                        if (!(xStartIndex >= 0))\n                            xStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xEndIndex, yStartIndex, yEndIndex]);\n                        if (!(xEndIndex >= 0))\n                            xEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, yStartIndex, yEndIndex]);\n                        if (!(yStartIndex >= 0))\n                            yStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yEndIndex]);\n                        if (!(yEndIndex >= 0))\n                            yEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex]);\n                        if (xIndex >= 0) {\n                            xCol = firstGroup.values[xIndex].source;\n                            xAxisLabel = firstGroup.values[xIndex].source.displayName;\n                        }\n                        if (yIndex >= 0) {\n                            yCol = firstGroup.values[yIndex].source;\n                            yAxisLabel = firstGroup.values[yIndex].source.displayName;\n                        }\n                        if (sizeIndex >= 0) {\n                            sizeCol = firstGroup.values[sizeIndex].source;\n                        }\n                        if (colorFillIndex >= 0) {\n                            colorFillCol = firstGroup.values[colorFillIndex].source;\n                        }\n                        if (shapeIndex >= 0) {\n                            shapeCol = firstGroup.values[shapeIndex].source;\n                        }\n                        if (imageIndex >= 0) {\n                            imageCol = firstGroup.values[imageIndex].source;\n                        }\n                        if (rotationIndex >= 0) {\n                            rotationCol = firstGroup.values[rotationIndex].source;\n                        }\n                        if (backdropIndex >= 0) {\n                            backdropCol = firstGroup.values[backdropIndex].source;\n                        }\n                        if (xStartIndex >= 0) {\n                            xStartCol = firstGroup.values[xStartIndex].source;\n                        }\n                        if (xEndIndex >= 0) {\n                            xEndCol = firstGroup.values[xEndIndex].source;\n                        }\n                        if (yStartIndex >= 0) {\n                            yStartCol = firstGroup.values[yStartIndex].source;\n                        }\n                        if (yEndIndex >= 0) {\n                            yEndCol = firstGroup.values[yEndIndex].source;\n                        }\n                    }\n                    return {\n                        idx: {\n                            x: xIndex,\n                            y: yIndex,\n                            size: sizeIndex,\n                            colorFill: colorFillIndex,\n                            shape: shapeIndex,\n                            image: imageIndex,\n                            rotation: rotationIndex,\n                            backdrop: backdropIndex,\n                            xStart: xStartIndex,\n                            xEnd: xEndIndex,\n                            yStart: yStartIndex,\n                            yEnd: yEndIndex,\n                        },\n                        cols: {\n                            x: xCol,\n                            y: yCol,\n                            size: sizeCol,\n                            colorFill: colorFillCol,\n                            shape: shapeCol,\n                            image: imageCol,\n                            rotation: rotationCol,\n                            backdrop: backdropCol,\n                            xStart: xStartCol,\n                            xEnd: xEndCol,\n                            yStart: yStartCol,\n                            yEnd: yEndCol,\n                        },\n                        axesLabels: {\n                            x: xAxisLabel,\n                            y: yAxisLabel\n                        }\n                    };\n                };\n                EnhancedScatterChart.getDefaultMeasureIndex = function (count, usedIndexes) {\n                    for (var i = 0; i < count; i++) {\n                        var found = true;\n                        for (var j = 0; j < usedIndexes.length; j++) {\n                            if (i === usedIndexes[j]) {\n                                found = false;\n                                break;\n                            }\n                        }\n                        if (found === true) {\n                            return i;\n                        }\n                    }\n                    return -1;\n                };\n                EnhancedScatterChart.createLazyFormattedCategory = function (formatter, value) {\n                    return new jsCommon.Lazy(function () { return formatter.format(value); });\n                };\n                EnhancedScatterChart.createDataPoints = function (dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, labelSettings, defaultDataPointColor, categoryQueryName) {\n                    var dataPoints = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped();\n                    var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);\n                    for (var categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) {\n                        var categoryValue = categoryValues[categoryIdx];\n                        for (var seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {\n                            var grouping = grouped[seriesIdx];\n                            var seriesValues = grouping.values;\n                            var measureX = visuals.ScatterChart.getMeasureValue(indicies.x, seriesValues);\n                            var measureY = visuals.ScatterChart.getMeasureValue(indicies.y, seriesValues);\n                            var measureSize = visuals.ScatterChart.getMeasureValue(indicies.size, seriesValues);\n                            var measureColorFill = visuals.ScatterChart.getMeasureValue(indicies.colorFill, seriesValues);\n                            var measureShape = visuals.ScatterChart.getMeasureValue(indicies.shape, seriesValues);\n                            var measureImage = visuals.ScatterChart.getMeasureValue(indicies.image, seriesValues);\n                            var measureRotation = visuals.ScatterChart.getMeasureValue(indicies.rotation, seriesValues);\n                            var measureBackdrop = visuals.ScatterChart.getMeasureValue(indicies.backdrop, seriesValues);\n                            var measureXStart = visuals.ScatterChart.getMeasureValue(indicies.xStart, seriesValues);\n                            var measureXEnd = visuals.ScatterChart.getMeasureValue(indicies.xEnd, seriesValues);\n                            var measureYStart = visuals.ScatterChart.getMeasureValue(indicies.yStart, seriesValues);\n                            var measureYEnd = visuals.ScatterChart.getMeasureValue(indicies.yEnd, seriesValues);\n                            var xVal = measureX && measureX.values && !isNaN(measureX.values[categoryIdx]) ? measureX.values[categoryIdx] : null;\n                            var yVal = measureY && measureY.values && !isNaN(measureY.values[categoryIdx]) ? measureY.values[categoryIdx] : 0;\n                            var size = measureSize && measureSize.values ? measureSize.values[categoryIdx] : null;\n                            var colorFill = measureColorFill && measureColorFill.values ? measureColorFill.values[categoryIdx] : null;\n                            var shapeSymbolType = EnhancedScatterChart.getCustomSymbolType(measureShape && measureShape.values && measureShape.values[categoryIdx]);\n                            var image = measureImage && measureImage.values ? measureImage.values[categoryIdx] : null;\n                            var rotation = measureRotation && measureRotation.values ? measureRotation.values[categoryIdx] : 0;\n                            var backdrop = measureBackdrop && measureBackdrop.values ? measureBackdrop.values[categoryIdx] : null;\n                            var xStart = measureXStart && measureXStart.values ? measureXStart.values[categoryIdx] : null;\n                            var xEnd = measureXEnd && measureXEnd.values ? measureXEnd.values[categoryIdx] : null;\n                            var yStart = measureYStart && measureYStart.values ? measureYStart.values[categoryIdx] : null;\n                            var yEnd = measureYEnd && measureYEnd.values ? measureYEnd.values[categoryIdx] : null;\n                            var hasNullValue = (xVal == null) || (yVal == null);\n                            if (hasNullValue)\n                                continue;\n                            var color = void 0;\n                            if (hasDynamicSeries) {\n                                color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);\n                            }\n                            else {\n                                // If we have no Size measure then use a blank query name\n                                var measureSource = (measureSize != null)\n                                    ? measureSize.source.queryName\n                                    : '';\n                                color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);\n                            }\n                            var category = categories && categories.length > 0 ? categories[0] : null;\n                            var identity = visuals.SelectionIdBuilder.builder()\n                                .withCategory(category, categoryIdx)\n                                .withSeries(dataValues, grouping)\n                                .createSelectionId();\n                            var seriesData = [];\n                            if (dataValueSource) {\n                                // Dynamic series\n                                seriesData.push({ value: grouping.name, metadata: { source: dataValueSource, values: [] } });\n                            }\n                            if (measureX) {\n                                seriesData.push({ value: xVal, metadata: measureX });\n                            }\n                            if (measureY) {\n                                seriesData.push({ value: yVal, metadata: measureY });\n                            }\n                            if (measureSize && measureSize.values && measureSize.values.length > 0) {\n                                seriesData.push({ value: measureSize.values[categoryIdx], metadata: measureSize });\n                            }\n                            if (measureColorFill && measureColorFill.values && measureColorFill.values.length > 0) {\n                                seriesData.push({ value: measureColorFill.values[categoryIdx], metadata: measureColorFill });\n                            }\n                            if (measureShape && measureShape.values && measureShape.values.length > 0) {\n                                seriesData.push({ value: measureShape.values[categoryIdx], metadata: measureShape });\n                            }\n                            if (measureImage && measureImage.values && measureImage.values.length > 0) {\n                                seriesData.push({ value: measureImage.values[categoryIdx], metadata: measureImage });\n                            }\n                            if (measureRotation && measureRotation.values && measureRotation.values.length > 0) {\n                                seriesData.push({ value: measureRotation.values[categoryIdx], metadata: measureRotation });\n                            }\n                            if (measureBackdrop && measureBackdrop.values && measureBackdrop.values.length > 0) {\n                                seriesData.push({ value: measureBackdrop.values[categoryIdx], metadata: measureBackdrop });\n                            }\n                            if (measureXStart && measureXStart.values && measureXStart.values.length > 0) {\n                                seriesData.push({ value: measureXStart.values[categoryIdx], metadata: measureXStart });\n                            }\n                            if (measureXEnd && measureXEnd.values && measureXEnd.values.length > 0) {\n                                seriesData.push({ value: measureXEnd.values[categoryIdx], metadata: measureXEnd });\n                            }\n                            if (measureYStart && measureYStart.values && measureYStart.values.length > 0) {\n                                seriesData.push({ value: measureYStart.values[categoryIdx], metadata: measureYStart });\n                            }\n                            if (measureYEnd && measureYEnd.values && measureYEnd.values.length > 0) {\n                                seriesData.push({ value: measureYEnd.values[categoryIdx], metadata: measureYEnd });\n                            }\n                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, categoryValue, null, categories, seriesData);\n                            var dataPoint = {\n                                x: xVal,\n                                y: yVal,\n                                size: size,\n                                radius: { sizeMeasure: measureSize, index: categoryIdx },\n                                fill: color,\n                                formattedCategory: this.createLazyFormattedCategory(categoryFormatter, categoryValue),\n                                selected: false,\n                                identity: identity,\n                                tooltipInfo: tooltipInfo,\n                                labelFill: labelSettings.labelColor,\n                                labelFontSize: labelSettings.fontSize,\n                                colorFill: colorFill,\n                                shapeSymbolType: shapeSymbolType,\n                                svgurl: image,\n                                rotation: rotation,\n                                backdrop: backdrop,\n                                xStart: xStart,\n                                xEnd: xEnd,\n                                yStart: yStart,\n                                yEnd: yEnd\n                            };\n                            dataPoints.push(dataPoint);\n                        }\n                    }\n                    return dataPoints;\n                };\n                EnhancedScatterChart.prototype.setData = function (dataViews) {\n                    this.data = {\n                        xCol: undefined,\n                        yCol: undefined,\n                        dataPoints: [],\n                        legendData: { dataPoints: [] },\n                        axesLabels: { x: '', y: '' },\n                        selectedIds: [],\n                        sizeRange: [],\n                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),\n                        defaultDataPointColor: null,\n                        hasDynamicSeries: false,\n                        useShape: true,\n                        useCustomColor: false,\n                    };\n                    if (dataViews.length > 0) {\n                        var dataView = dataViews[0];\n                        if (dataView) {\n                            this.categoryAxisProperties = this.getCategoryAxisProperties(dataView.metadata, true);\n                            this.valueAxisProperties = this.getValueAxisProperties(dataView.metadata, true);\n                            this.dataView = dataView;\n                            if (dataView.categorical && dataView.categorical.values) {\n                                this.data = EnhancedScatterChart.converter(dataView, this.viewport, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties);\n                            }\n                        }\n                    }\n                };\n                EnhancedScatterChart.prototype.update = function (options) {\n                    debug.assertValue(options, 'options');\n                    var dataViews = this.dataViews = options.dataViews;\n                    this.viewport = _.clone(options.viewport);\n                    if (!dataViews)\n                        return;\n                    if (dataViews && dataViews.length > 0) {\n                        var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);\n                        if (warnings && warnings.length > 0)\n                            this.hostServices.setWarnings(warnings);\n                        this.populateObjectProperties(dataViews);\n                    }\n                    this.setData(dataViews);\n                    // Note: interactive legend shouldn't be rendered explicitly here\n                    // The interactive legend is being rendered in the render method of ICartesianVisual\n                    if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend)) {\n                        this.renderLegend();\n                    }\n                    this.render(options.suppressAnimations);\n                };\n                EnhancedScatterChart.prototype.populateObjectProperties = function (dataViews) {\n                    if (dataViews && dataViews.length > 0) {\n                        var dataViewMetadata = dataViews[0].metadata;\n                        if (dataViewMetadata) {\n                            this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});\n                        }\n                        else {\n                            this.legendObjectProperties = {};\n                        }\n                        this.categoryAxisProperties = this.getCategoryAxisProperties(dataViewMetadata);\n                        this.valueAxisProperties = this.getValueAxisProperties(dataViewMetadata);\n                        var axisPosition = this.valueAxisProperties['position'];\n                        this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;\n                    }\n                };\n                EnhancedScatterChart.prototype.renderLegend = function () {\n                    var legendData = { title: \"\", dataPoints: [] };\n                    var legend = this.legend;\n                    this.layerLegendData = this.data.legendData;\n                    if (this.layerLegendData) {\n                        legendData.title = this.layerLegendData.title || \"\";\n                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);\n                        legendData.fontSize = this.legendLabelFontSize ? this.legendLabelFontSize : EnhancedScatterChart.LegendLabelFontSizeDefault;\n                        if (this.layerLegendData.grouped) {\n                            legendData.grouped = true;\n                        }\n                    }\n                    var legendProperties = this.legendObjectProperties;\n                    if (legendProperties) {\n                        visuals.LegendData.update(legendData, legendProperties);\n                        var position = legendProperties[visuals.legendProps.position];\n                        if (position)\n                            legend.changeOrientation(visuals.LegendPosition[position]);\n                    }\n                    else {\n                        legend.changeOrientation(visuals.LegendPosition.Top);\n                    }\n                    if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {\n                        legendData.dataPoints = [];\n                    }\n                    var viewport = this.viewport;\n                    legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });\n                    visuals.Legend.positionChartArea(this.svg, legend);\n                };\n                EnhancedScatterChart.prototype.hideLegends = function () {\n                    if (this.cartesianSmallViewPortProperties) {\n                        if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.viewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                EnhancedScatterChart.prototype.shouldRenderAxis = function (axisProperties, propertyName) {\n                    if (propertyName === void 0) { propertyName = \"show\"; }\n                    if (!axisProperties) {\n                        return false;\n                    }\n                    else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {\n                        return axisProperties.values && axisProperties.values.length > 0;\n                    }\n                    else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {\n                        return axisProperties.values && axisProperties.values.length > 0;\n                    }\n                    return false;\n                };\n                EnhancedScatterChart.prototype.getMaxMarginFactor = function () {\n                    return this.options.style.maxMarginFactor || 0.25;\n                };\n                EnhancedScatterChart.prototype.adjustViewportbyBackdrop = function () {\n                    var img = new Image();\n                    var that = this;\n                    img.src = this.data.backdrop.url;\n                    img.onload = function () {\n                        if (that.oldBackdrop !== this.src) {\n                            that.render(true);\n                            that.oldBackdrop = this.src;\n                        }\n                    };\n                    if (img.width > 0 && img.height > 0) {\n                        if (img.width * this.viewportIn.height < this.viewportIn.width * img.height) {\n                            var deltaWidth = this.viewportIn.width - this.viewportIn.height * img.width / img.height;\n                            this.viewport = { width: this.viewport.width - deltaWidth, height: this.viewport.height };\n                        }\n                        else {\n                            var deltaHeight = this.viewportIn.height - this.viewportIn.width * img.height / img.width;\n                            this.viewport = { width: this.viewport.width, height: this.viewport.height - deltaHeight };\n                        }\n                    }\n                };\n                EnhancedScatterChart.prototype.render = function (suppressAnimations) {\n                    this.viewport.height -= this.legendViewport.height;\n                    this.viewport.width -= this.legendViewport.width;\n                    if (this.viewportIn.width === 0 || this.viewportIn.height === 0) {\n                        return;\n                    }\n                    var maxMarginFactor = this.getMaxMarginFactor();\n                    this.leftRightMarginLimit = this.viewport.width * maxMarginFactor;\n                    var bottomMarginLimit = this.bottomMarginLimit = Math.max(25, Math.ceil(this.viewport.height * maxMarginFactor));\n                    // reset defaults\n                    this.margin.top = 8;\n                    this.margin.bottom = bottomMarginLimit;\n                    this.margin.right = 0;\n                    this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\n                    this.yAxisIsCategorical = this.yAxisProperties.isCategoryAxis;\n                    this.hasCategoryAxis = this.yAxisIsCategorical ? this.yAxisProperties && this.yAxisProperties.values.length > 0 : this.xAxisProperties && this.xAxisProperties.values.length > 0;\n                    var renderXAxis = this.shouldRenderAxis(this.xAxisProperties);\n                    var renderY1Axis = this.shouldRenderAxis(this.yAxisProperties);\n                    var mainAxisScale;\n                    this.isXScrollBarVisible = false;\n                    this.isYScrollBarVisible = false;\n                    var tickLabelMargins;\n                    var axisLabels;\n                    var chartHasAxisLabels;\n                    var yAxisOrientation = this.yAxisOrientation;\n                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;\n                    this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\n                    var doneWithMargins = false, maxIterations = 2, numIterations = 0;\n                    while (!doneWithMargins && numIterations < maxIterations) {\n                        numIterations++;\n                        tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({ width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, false);\n                        // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side\n                        var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;\n                        maxMainYaxisSide += 10;\n                        maxSecondYaxisSide += 10;\n                        xMax += 12;\n                        if (showY1OnRight && renderY1Axis) {\n                            maxSecondYaxisSide += 20;\n                        }\n                        if (!showY1OnRight && renderY1Axis) {\n                            maxMainYaxisSide += 20;\n                        }\n                        if (this.hideAxisLabels()) {\n                            this.xAxisProperties.axisLabel = null;\n                            this.yAxisProperties.axisLabel = null;\n                        }\n                        this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);\n                        axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };\n                        chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);\n                        if (axisLabels.x != null)\n                            xMax += 18;\n                        if (axisLabels.y != null)\n                            maxMainYaxisSide += 20;\n                        if (axisLabels.y2 != null)\n                            maxSecondYaxisSide += 20;\n                        this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;\n                        this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;\n                        this.margin.bottom = xMax;\n                        // re-calculate the axes with the new margins\n                        var previousTickCountY1 = this.yAxisProperties.values.length;\n                        this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\n                        // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again\n                        // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.\n                        if (this.yAxisProperties.values.length === previousTickCountY1)\n                            doneWithMargins = true;\n                    }\n                    // we have to do the above process again since changes are made to viewport.\n                    if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {\n                        this.adjustViewportbyBackdrop();\n                        doneWithMargins = false;\n                        maxIterations = 2;\n                        numIterations = 0;\n                        while (!doneWithMargins && numIterations < maxIterations) {\n                            numIterations++;\n                            tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({ width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, false);\n                            // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side\n                            var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;\n                            maxMainYaxisSide += 10;\n                            if (showY1OnRight && renderY1Axis)\n                                maxSecondYaxisSide += 15;\n                            xMax += 12;\n                            if (this.hideAxisLabels()) {\n                                this.xAxisProperties.axisLabel = null;\n                                this.yAxisProperties.axisLabel = null;\n                            }\n                            this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);\n                            axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };\n                            chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);\n                            if (axisLabels.x != null)\n                                xMax += 18;\n                            if (axisLabels.y != null)\n                                maxMainYaxisSide += 20;\n                            if (axisLabels.y2 != null)\n                                maxSecondYaxisSide += 20;\n                            this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;\n                            this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;\n                            this.margin.bottom = xMax;\n                            // re-calculate the axes with the new margins\n                            var previousTickCountY1 = this.yAxisProperties.values.length;\n                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\n                            // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again\n                            // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.\n                            if (this.yAxisProperties.values.length === previousTickCountY1)\n                                doneWithMargins = true;\n                        }\n                    }\n                    this.renderChart(mainAxisScale, this.xAxisProperties, this.yAxisProperties, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations);\n                    this.updateAxis();\n                    if (!this.data)\n                        return;\n                    var data = this.data;\n                    var dataPoints = this.data.dataPoints;\n                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();\n                    this.mainGraphicsContext.attr('width', this.viewportIn.width)\n                        .attr('height', this.viewportIn.height);\n                    var sortedData = dataPoints.sort(function (a, b) {\n                        return b.radius.sizeMeasure ? (b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index]) : 0;\n                    });\n                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);\n                    var scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration);\n                    var dataLabelsSettings = this.data.dataLabelsSettings;\n                    if (dataLabelsSettings.show) {\n                        var layout = this.getEnhanchedScatterChartLabelLayout(dataLabelsSettings, this.viewportIn, data.sizeRange);\n                        var clonedDataPoints = this.cloneDataPoints(dataPoints);\n                        //fix bug 3863: drawDefaultLabelsForDataPointChart add to datapoints[xxx].size = object , which causes when\n                        //category labels is on and Fill Points option off to fill the points when mouse click occures because of default size\n                        //is set to datapoints.\n                        visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(clonedDataPoints, this.mainGraphicsG, layout, this.viewportIn);\n                        var offset = dataLabelsSettings.fontSize * EnhancedScatterChart.DataLabelsOffset;\n                        this.mainGraphicsG.select('.labels').attr('transform', visuals.SVGUtil.translate(offset, 0));\n                    }\n                    else {\n                        visuals.dataLabelUtils.cleanDataLabels(this.mainGraphicsG);\n                    }\n                    var behaviorOptions = undefined;\n                    if (this.interactivityService) {\n                        behaviorOptions = {\n                            dataPointsSelection: scatterMarkers,\n                            data: this.data,\n                            plotContext: this.mainGraphicsContext,\n                        };\n                    }\n                    visuals.TooltipManager.addTooltip(scatterMarkers, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });\n                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);\n                    if (this.behavior) {\n                        var layerBehaviorOptions = [];\n                        layerBehaviorOptions.push(behaviorOptions);\n                        if (this.interactivityService) {\n                            var cbehaviorOptions = {\n                                layerOptions: layerBehaviorOptions,\n                                clearCatcher: this.clearCatcher,\n                            };\n                            this.interactivityService.bind(dataPoints, this.behavior, cbehaviorOptions);\n                        }\n                    }\n                };\n                EnhancedScatterChart.prototype.cloneDataPoints = function (dataPoints) {\n                    var clonedDataPoints = new Array();\n                    for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {\n                        var dataPoint = dataPoints_1[_i];\n                        var clonedDataPoint = _.clone(dataPoint);\n                        clonedDataPoints.push(clonedDataPoint);\n                    }\n                    return clonedDataPoints;\n                };\n                EnhancedScatterChart.prototype.darkenZeroLine = function (g) {\n                    var zeroTick = g.selectAll('g.tick').filter(function (data) { return data === 0; }).node();\n                    if (zeroTick) {\n                        d3.select(zeroTick).select('line').classed('zero-line', true);\n                    }\n                };\n                EnhancedScatterChart.prototype.getCategoryAxisFill = function () {\n                    if (this.dataView && this.dataView.metadata.objects) {\n                        var label = this.dataView.metadata.objects['categoryAxis'];\n                        if (label) {\n                            return label['axisColor'];\n                        }\n                    }\n                    return { solid: { color: '#333' } };\n                };\n                EnhancedScatterChart.prototype.getEnhanchedScatterChartLabelLayout = function (labelSettings, viewport, sizeRange) {\n                    var xScale = this.xAxisProperties.scale;\n                    var yScale = this.yAxisProperties.scale;\n                    var fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize);\n                    var offset = labelSettings.fontSize * EnhancedScatterChart.DataLabelsOffset;\n                    return {\n                        labelText: function (d) {\n                            return visuals.dataLabelUtils.getLabelFormattedText({\n                                label: d.formattedCategory.getValue(),\n                                fontSize: labelSettings.fontSize,\n                                maxWidth: viewport.width,\n                            });\n                        },\n                        labelLayout: {\n                            x: function (d) { return xScale(d.x) - offset; },\n                            y: function (d) {\n                                var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + visuals.dataLabelUtils.labelMargin;\n                                return labelSettings.position === 0 /* Above */ ? yScale(d.y) - margin : yScale(d.y) + margin;\n                            },\n                        },\n                        filter: function (d) {\n                            return (d != null && d.formattedCategory.getValue() != null);\n                        },\n                        style: {\n                            'fill': function (d) { return d.labelFill; },\n                            'font-size': fontSizeInPx,\n                        },\n                    };\n                };\n                EnhancedScatterChart.prototype.getValueAxisFill = function () {\n                    if (this.dataView && this.dataView.metadata.objects) {\n                        var label = this.dataView.metadata.objects['valueAxis'];\n                        if (label)\n                            return label['axisColor'];\n                    }\n                    return { solid: { color: '#333' } };\n                };\n                EnhancedScatterChart.prototype.renderCrossHair = function () {\n                    var _this = this;\n                    var xScale = this.xAxisProperties.scale;\n                    var yScale = this.yAxisProperties.scale;\n                    var mainGraphicsContext = this.mainGraphicsContext;\n                    mainGraphicsContext.selectAll(\".crosshairCanvas\").remove();\n                    if (this.data.crosshair) {\n                        var canvas = mainGraphicsContext.append(\"g\").attr(\"class\", \"crosshairCanvas\").attr(\"id\", \"crosshairCanvas\");\n                        var crossHair = canvas.append(\"g\").attr(\"class\", \"crosshair\");\n                        var hLine_1 = crossHair.append(\"line\").attr(\"id\", \"h_crosshair\") // horizontal cross hair\n                            .attr(\"x1\", 0)\n                            .attr(\"y1\", 0)\n                            .attr(\"x2\", 0)\n                            .attr(\"y2\", 0)\n                            .style(\"stroke\", \"gray\")\n                            .style(\"stroke-width\", \"1px\")\n                            .style(\"stroke-dasharray\", \"5,5\")\n                            .style(\"display\", \"none\");\n                        var vLine_1 = crossHair.append(\"line\").attr(\"id\", \"v_crosshair\") // vertical cross hair\n                            .attr(\"x1\", 0)\n                            .attr(\"y1\", 0)\n                            .attr(\"x2\", 0)\n                            .attr(\"y2\", 0)\n                            .style(\"stroke\", \"gray\")\n                            .style(\"stroke-width\", \"1px\")\n                            .style(\"stroke-dasharray\", \"5,5\")\n                            .style(\"display\", \"none\");\n                        var text_1 = crossHair.append(\"text\").attr(\"id\", \"crosshair_text\") // text label for cross hair\n                            .style(\"font-size\", \"10px\")\n                            .style(\"stroke\", \"gray\")\n                            .style(\"stroke-width\", \"0.5px\");\n                        var addCrossHair_1 = function (xCoord, yCoord) {\n                            // Update horizontal cross hair\n                            hLine_1.attr(\"x1\", 0)\n                                .attr(\"y1\", yCoord)\n                                .attr(\"x2\", _this.viewportIn.width)\n                                .attr(\"y2\", yCoord)\n                                .style(\"display\", \"block\");\n                            // Update vertical cross hair\n                            vLine_1.attr(\"x1\", xCoord)\n                                .attr(\"y1\", 0)\n                                .attr(\"x2\", xCoord)\n                                .attr(\"y2\", _this.viewportIn.height)\n                                .style(\"display\", \"block\");\n                            // Update text label\n                            text_1.attr(\"transform\", \"translate(\" + (xCoord + 5) + \",\" + (yCoord - 5) + \")\")\n                                .text(\"(\" + Math.round(xScale.invert(xCoord) * 100) / 100 + \" , \" + Math.round(yScale.invert(yCoord) * 100) / 100 + \")\");\n                        };\n                        this.axisGraphicsContextScrollable.on(\"mousemove\", function () {\n                            var coordinates = d3.mouse(this);\n                            var svgNode = this.viewportElement;\n                            var scaledRect = svgNode.getBoundingClientRect();\n                            var domRect = svgNode.getBBox();\n                            var ratioX = scaledRect.width / domRect.width;\n                            var ratioY = scaledRect.height / domRect.height;\n                            if (domRect.width > 0 && !powerbi.Double.equalWithPrecision(ratioX, 1.0, 0.00001)) {\n                                coordinates[0] = coordinates[0] / ratioX;\n                            }\n                            if (domRect.height > 0 && !powerbi.Double.equalWithPrecision(ratioY, 1.0, 0.00001)) {\n                                coordinates[1] = coordinates[1] / ratioY;\n                            }\n                            addCrossHair_1(coordinates[0], coordinates[1]);\n                        })\n                            .on(\"mouseover\", function () {\n                            d3.selectAll(\".crosshair\").style(\"display\", \"block\");\n                        })\n                            .on(\"mouseout\", function () {\n                            d3.selectAll(\".crosshair\").style(\"display\", \"none\");\n                        });\n                    }\n                };\n                EnhancedScatterChart.prototype.renderBackground = function () {\n                    if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {\n                        this.backgroundGraphicsContext\n                            .attr(\"xlink:href\", this.data.backdrop.url)\n                            .attr('x', 0)\n                            .attr('y', 0)\n                            .attr('width', this.viewportIn.width)\n                            .attr('height', this.viewportIn.height);\n                    }\n                    else {\n                        this.backgroundGraphicsContext\n                            .attr('width', 0)\n                            .attr('height', 0);\n                    }\n                };\n                EnhancedScatterChart.prototype.renderChart = function (mainAxisScale, xAxis, yAxis, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations, scrollScale, extent) {\n                    var bottomMarginLimit = this.bottomMarginLimit;\n                    var leftRightMarginLimit = this.leftRightMarginLimit;\n                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);\n                    this.renderBackground();\n                    //hide show x-axis here\n                    if (this.shouldRenderAxis(xAxis)) {\n                        xAxis.axis.orient(\"bottom\");\n                        if (!xAxis.willLabelsFit)\n                            xAxis.axis.tickPadding(5);\n                        var xAxisGraphicsElement = this.xAxisGraphicsContext;\n                        if (duration) {\n                            xAxisGraphicsElement\n                                .transition()\n                                .duration(duration)\n                                .call(xAxis.axis)\n                                .call(this.darkenZeroLine);\n                        }\n                        else {\n                            xAxisGraphicsElement\n                                .call(xAxis.axis)\n                                .call(this.darkenZeroLine);\n                        }\n                        var xZeroTick = xAxisGraphicsElement.selectAll('g.tick').filter(function (data) { return data === 0; });\n                        if (xZeroTick) {\n                            var xZeroColor = this.getValueAxisFill();\n                            if (xZeroColor)\n                                xZeroTick.selectAll('line').style({ 'stroke': xZeroColor.solid.color });\n                        }\n                        var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');\n                        if (xAxis.willLabelsWordBreak) {\n                            xAxisTextNodes\n                                .call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, xAxis, bottomMarginLimit);\n                        }\n                        else {\n                            xAxisTextNodes\n                                .call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.getTailoredTextOrDefault, visuals.CartesianChart.AxisTextProperties, !xAxis.willLabelsFit, bottomMarginLimit === tickLabelMargins.xMax, xAxis, this.margin, this.isXScrollBarVisible || this.isYScrollBarVisible);\n                        }\n                    }\n                    else {\n                        this.xAxisGraphicsContext.selectAll('*').remove();\n                    }\n                    if (this.shouldRenderAxis(yAxis)) {\n                        var yAxisOrientation = this.yAxisOrientation;\n                        yAxis.axis\n                            .tickSize(-this.viewportIn.width)\n                            .tickPadding(10)\n                            .orient(yAxisOrientation.toLowerCase());\n                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;\n                        if (duration) {\n                            y1AxisGraphicsElement\n                                .transition()\n                                .duration(duration)\n                                .call(yAxis.axis)\n                                .call(this.darkenZeroLine);\n                        }\n                        else {\n                            y1AxisGraphicsElement\n                                .call(yAxis.axis)\n                                .call(this.darkenZeroLine);\n                        }\n                        var yZeroTick = y1AxisGraphicsElement.selectAll('g.tick').filter(function (data) { return data === 0; });\n                        if (yZeroTick) {\n                            var yZeroColor = this.getCategoryAxisFill();\n                            if (yZeroColor) {\n                                yZeroTick.selectAll('line').style({ 'stroke': yZeroColor.solid.color });\n                            }\n                        }\n                        if (tickLabelMargins.yLeft >= leftRightMarginLimit) {\n                            y1AxisGraphicsElement.selectAll('text')\n                                .call(visuals.AxisHelper.LabelLayoutStrategy.clip, \n                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations\n                            leftRightMarginLimit - 10, powerbi.TextMeasurementService.svgEllipsis);\n                        }\n                    }\n                    else {\n                        this.y1AxisGraphicsContext.selectAll('*').remove();\n                    }\n                    // Axis labels\n                    //TODO: Add label for second Y axis for combo chart\n                    if (chartHasAxisLabels) {\n                        var hideXAxisTitle = !this.shouldRenderAxis(xAxis, \"showAxisTitle\");\n                        var hideYAxisTitle = !this.shouldRenderAxis(yAxis, \"showAxisTitle\");\n                        var hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties[\"secShowAxisTitle\"] != null && this.valueAxisProperties[\"secShowAxisTitle\"] === false;\n                        this.renderAxesLabels(axisLabels, this.legendViewport.height, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);\n                    }\n                    else {\n                        this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\n                        this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\n                    }\n                    this.renderCrossHair();\n                };\n                EnhancedScatterChart.prototype.renderAxesLabels = function (axisLabels, legendMargin, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle) {\n                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\n                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\n                    var margin = this.margin;\n                    var width = this.viewportIn.width;\n                    var height = this.viewport.height;\n                    var fontSize = EnhancedScatterChart.AxisFontSize;\n                    var yAxisOrientation = this.yAxisOrientation;\n                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;\n                    if (!hideXAxisTitle) {\n                        var xAxisLabel = this.axisGraphicsContext.append(\"text\")\n                            .style(\"text-anchor\", \"middle\")\n                            .text(axisLabels.x)\n                            .call(function (text) {\n                            text.each(function () {\n                                var text = d3.select(this);\n                                text.attr({\n                                    \"class\": \"xAxisLabel\",\n                                    \"transform\": visuals.SVGUtil.translate(width / 2, height - fontSize - 2)\n                                });\n                            });\n                        });\n                        xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);\n                    }\n                    if (!hideYAxisTitle) {\n                        var yAxisLabel = this.axisGraphicsContext.append(\"text\")\n                            .style(\"text-anchor\", \"middle\")\n                            .text(axisLabels.y)\n                            .call(function (text) {\n                            text.each(function () {\n                                var text = d3.select(this);\n                                text.attr({\n                                    \"class\": \"yAxisLabel\",\n                                    \"transform\": \"rotate(-90)\",\n                                    \"y\": showY1OnRight ? width + margin.right - fontSize : -margin.left,\n                                    \"x\": -((height - margin.top - legendMargin) / 2),\n                                    \"dy\": \"1em\"\n                                });\n                            });\n                        });\n                        yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);\n                    }\n                    if (!hideY2AxisTitle && axisLabels.y2) {\n                        var y2AxisLabel = this.axisGraphicsContext.append(\"text\")\n                            .style(\"text-anchor\", \"middle\")\n                            .text(axisLabels.y2)\n                            .call(function (text) {\n                            text.each(function () {\n                                var text = d3.select(this);\n                                text.attr({\n                                    \"class\": \"yAxisLabel\",\n                                    \"transform\": \"rotate(-90)\",\n                                    \"y\": showY1OnRight ? -margin.left : width + margin.right - fontSize,\n                                    \"x\": -((height - margin.top - legendMargin) / 2),\n                                    \"dy\": \"1em\"\n                                });\n                            });\n                        });\n                        y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);\n                    }\n                };\n                EnhancedScatterChart.prototype.updateAxis = function () {\n                    this.adjustMargins();\n                    var yAxisOrientation = this.yAxisOrientation;\n                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;\n                    this.xAxisGraphicsContext\n                        .attr('transform', visuals.SVGUtil.translate(0, this.viewportIn.height));\n                    this.y1AxisGraphicsContext\n                        .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? this.viewportIn.width : 0, 0));\n                    this.svg.attr({\n                        'width': this.viewport.width,\n                        'height': this.viewport.height\n                    });\n                    this.svgScrollable.attr({\n                        'width': this.viewport.width,\n                        'height': this.viewport.height\n                    });\n                    this.svgScrollable.attr({\n                        'x': 0\n                    });\n                    var left = this.margin.left;\n                    var top = this.margin.top;\n                    this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(left, top));\n                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(left, top));\n                    this.clearCatcher.attr('transform', visuals.SVGUtil.translate(-left, -top));\n                    if (this.isXScrollBarVisible) {\n                        this.svgScrollable.attr({\n                            'x': left\n                        });\n                        this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, top));\n                        this.svgScrollable.attr('width', this.viewportIn.width);\n                        this.svg.attr('width', this.viewport.width)\n                            .attr('height', this.viewport.height + this.ScrollBarWidth);\n                    }\n                    else if (this.isYScrollBarVisible) {\n                        this.svgScrollable.attr('height', this.viewportIn.height + top);\n                        this.svg.attr('width', this.viewport.width + this.ScrollBarWidth)\n                            .attr('height', this.viewport.height);\n                    }\n                };\n                EnhancedScatterChart.prototype.getUnitType = function (xAxis) {\n                    if (xAxis.formatter &&\n                        xAxis.formatter.displayUnit &&\n                        xAxis.formatter.displayUnit.value > 1)\n                        return xAxis.formatter.displayUnit.title;\n                    return null;\n                };\n                EnhancedScatterChart.prototype.addUnitTypeToAxisLabel = function (xAxis, yAxis) {\n                    var unitType = this.getUnitType(xAxis);\n                    if (xAxis.isCategoryAxis) {\n                        this.categoryAxisHasUnitType = unitType !== null;\n                    }\n                    else {\n                        this.valueAxisHasUnitType = unitType !== null;\n                    }\n                    if (xAxis.axisLabel && unitType) {\n                        if (xAxis.isCategoryAxis) {\n                            xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, xAxis.axisLabel, unitType);\n                        }\n                        else {\n                            xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, xAxis.axisLabel, unitType);\n                        }\n                    }\n                    unitType = this.getUnitType(yAxis);\n                    if (!yAxis.isCategoryAxis) {\n                        this.valueAxisHasUnitType = unitType !== null;\n                    }\n                    else {\n                        this.categoryAxisHasUnitType = unitType !== null;\n                    }\n                    if (yAxis.axisLabel && unitType) {\n                        if (!yAxis.isCategoryAxis) {\n                            yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, yAxis.axisLabel, unitType);\n                        }\n                        else {\n                            yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, yAxis.axisLabel, unitType);\n                        }\n                    }\n                };\n                EnhancedScatterChart.prototype.hideAxisLabels = function () {\n                    if (this.cartesianSmallViewPortProperties) {\n                        if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort\n                            && ((this.viewport.height + this.legendViewport.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible)\n                            && !this.options.interactivity.isInteractiveLegend) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                EnhancedScatterChart.prototype.drawScatterMarkers = function (scatterData, hasSelection, sizeRange, duration) {\n                    var _this = this;\n                    var xScale = this.xAxisProperties.scale;\n                    var yScale = this.yAxisProperties.scale;\n                    var shouldEnableFill = (!sizeRange || !sizeRange.min) && this.data.fillPoint;\n                    var markers;\n                    var useCustomColor = this.data.useCustomColor;\n                    if (this.data.useShape) {\n                        this.mainGraphicsContext.selectAll(EnhancedScatterChart.ImageClasses.selector).remove();\n                        markers = this.mainGraphicsContext.classed('ScatterMarkers', true).selectAll(EnhancedScatterChart.DotClasses.selector).data(scatterData, function (d) { return d.identity.getKey(); });\n                        markers.enter()\n                            .append('path')\n                            .classed(EnhancedScatterChart.DotClasses.class, true).attr('id', 'markershape');\n                        markers\n                            .style({\n                            'stroke-opacity': function (d) { return visuals.ScatterChart.getBubbleOpacity(d, hasSelection); },\n                            'stroke-width': '1px',\n                            'stroke': function (d) {\n                                var color = useCustomColor ? d.colorFill : d.fill;\n                                if (_this.data.outline) {\n                                    return d3.rgb(color).darker();\n                                }\n                                else {\n                                    return d3.rgb(color);\n                                }\n                            },\n                            'fill': function (d) { return d3.rgb(useCustomColor ? d.colorFill : d.fill); },\n                            'fill-opacity': function (d) { return (d.size != null || shouldEnableFill) ? visuals.ScatterChart.getBubbleOpacity(d, hasSelection) : 0; },\n                        })\n                            .attr(\"d\", function (d) {\n                            var r = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);\n                            var area = 4 * r * r;\n                            return d.shapeSymbolType(area);\n                        })\n                            .transition()\n                            .duration(function (d) {\n                            if (_this.keyArray.indexOf(d.identity.getKey()) >= 0) {\n                                return duration;\n                            }\n                            else {\n                                return 0;\n                            }\n                        })\n                            .attr(\"transform\", function (d) { return \"translate(\" + xScale(d.x) + \",\" + yScale(d.y) + \") rotate(\" + d.rotation + \")\"; });\n                    }\n                    else {\n                        this.mainGraphicsContext.selectAll(EnhancedScatterChart.DotClasses.selector).remove();\n                        markers = this.mainGraphicsContext.classed('ScatterMarkers', true).selectAll(EnhancedScatterChart.ImageClasses.selector).data(scatterData, function (d) { return d.identity.getKey(); });\n                        markers.enter().append(\"svg:image\")\n                            .classed(EnhancedScatterChart.ImageClasses.class, true).attr('id', 'markerimage');\n                        markers\n                            .attr(\"xlink:href\", function (d) {\n                            if (d.svgurl !== undefined && d.svgurl != null && d.svgurl !== \"\") {\n                                return d.svgurl;\n                            }\n                            else {\n                                return _this.svgDefaultImage;\n                            }\n                        })\n                            .attr(\"width\", function (d) {\n                            return visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport) * 2;\n                        })\n                            .attr(\"height\", function (d) {\n                            return visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport) * 2;\n                        })\n                            .transition()\n                            .duration(function (d) {\n                            if (_this.keyArray.indexOf(d.identity.getKey()) >= 0) {\n                                return duration;\n                            }\n                            else {\n                                return 0;\n                            }\n                        })\n                            .attr(\"transform\", function (d) {\n                            var radius = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);\n                            return \"translate(\" + (xScale(d.x) - radius) + \",\" + (yScale(d.y) - radius) + \") rotate(\" + d.rotation + \",\" + radius + \",\" + radius + \")\";\n                        });\n                    }\n                    markers.exit().remove();\n                    this.keyArray = [];\n                    for (var i = 0; i < scatterData.length; i++) {\n                        this.keyArray.push(scatterData[i].identity.getKey());\n                    }\n                    return markers;\n                };\n                EnhancedScatterChart.prototype.calculateAxes = function (categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible) {\n                    var visualOptions = {\n                        viewport: this.viewport,\n                        margin: this.margin,\n                        forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],\n                        forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,\n                        showCategoryAxisLabel: false,\n                        showValueAxisLabel: false,\n                        categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? categoryAxisProperties['axisScale'] : null,\n                        valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? valueAxisProperties['axisScale'] : null,\n                        valueAxisDisplayUnits: valueAxisProperties && valueAxisProperties['labelDisplayUnits'] != null ? valueAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault,\n                        categoryAxisDisplayUnits: categoryAxisProperties && categoryAxisProperties['labelDisplayUnits'] != null ? categoryAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault,\n                        trimOrdinalDataOnOverflow: false\n                    };\n                    if (valueAxisProperties) {\n                        visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);\n                    }\n                    visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']);\n                    visualOptions.showValueAxisLabel = true;\n                    var width = this.viewport.width - (this.margin.left + this.margin.right);\n                    var axes = this.calculateAxesProperties(visualOptions);\n                    axes[0].willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes[0], width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);\n                    // If labels do not fit and we are not scrolling, try word breaking\n                    axes[0].willLabelsWordBreak = (!axes[0].willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes[0], this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);\n                    return axes;\n                };\n                EnhancedScatterChart.prototype.calculateAxesProperties = function (options) {\n                    var data = this.data;\n                    var dataPoints = data.dataPoints;\n                    this.margin = options.margin;\n                    this.viewport = options.viewport;\n                    var minY = 0, maxY = 10, minX = 0, maxX = 10;\n                    if (dataPoints.length > 0) {\n                        minY = d3.min(dataPoints, function (d) { return d.y; });\n                        maxY = d3.max(dataPoints, function (d) { return d.y; });\n                        minX = d3.min(dataPoints, function (d) { return d.x; });\n                        maxX = d3.max(dataPoints, function (d) { return d.x; });\n                    }\n                    var xDomain = [minX, maxX];\n                    var combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain);\n                    this.xAxisProperties = visuals.AxisHelper.createAxis({\n                        pixelSpan: this.viewportIn.width,\n                        dataDomain: combinedXDomain,\n                        metaDataColumn: data.xCol,\n                        formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),\n                        outerPadding: 0,\n                        isScalar: true,\n                        isVertical: false,\n                        forcedTickCount: options.forcedTickCount,\n                        useTickIntervalForDisplayUnits: true,\n                        isCategoryAxis: true,\n                        scaleType: options.categoryAxisScaleType,\n                        axisDisplayUnits: options.categoryAxisDisplayUnits\n                    });\n                    this.xAxisProperties.axis.tickSize(-this.viewportIn.height, 0);\n                    this.xAxisProperties.axisLabel = this.data.axesLabels.x;\n                    var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [minY, maxY]);\n                    this.yAxisProperties = visuals.AxisHelper.createAxis({\n                        pixelSpan: this.viewportIn.height,\n                        dataDomain: combinedDomain,\n                        metaDataColumn: data.yCol,\n                        formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),\n                        outerPadding: 0,\n                        isScalar: true,\n                        isVertical: true,\n                        forcedTickCount: options.forcedTickCount,\n                        useTickIntervalForDisplayUnits: true,\n                        isCategoryAxis: false,\n                        scaleType: options.valueAxisScaleType,\n                        axisDisplayUnits: options.valueAxisDisplayUnits\n                    });\n                    this.yAxisProperties.axisLabel = this.data.axesLabels.y;\n                    return [this.xAxisProperties, this.yAxisProperties];\n                };\n                EnhancedScatterChart.prototype.enumerateDataPoints = function (enumeration) {\n                    var data = this.data;\n                    if (!data)\n                        return;\n                    var seriesCount = data.dataPoints.length;\n                    if (!data.hasDynamicSeries) {\n                        // Add default color and show all slices\n                        enumeration.pushInstance({\n                            objectName: 'dataPoint',\n                            selector: null,\n                            properties: {\n                                defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }\n                            }\n                        }).pushInstance({\n                            objectName: 'dataPoint',\n                            selector: null,\n                            properties: {\n                                showAllDataPoints: !!data.showAllDataPoints\n                            }\n                        });\n                        for (var i = 0; i < seriesCount; i++) {\n                            var seriesDataPoints = data.dataPoints[i];\n                            enumeration.pushInstance({\n                                objectName: 'dataPoint',\n                                displayName: seriesDataPoints.formattedCategory.getValue(),\n                                selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),\n                                properties: {\n                                    fill: { solid: { color: seriesDataPoints.fill } }\n                                },\n                            });\n                        }\n                    }\n                    else {\n                        var legendDataPointLength = data.legendData.dataPoints.length;\n                        for (var i = 0; i < legendDataPointLength; i++) {\n                            var series = data.legendData.dataPoints[i];\n                            enumeration.pushInstance({\n                                objectName: 'dataPoint',\n                                displayName: series.label,\n                                selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),\n                                properties: {\n                                    fill: { solid: { color: series.color } }\n                                },\n                            });\n                        }\n                    }\n                };\n                EnhancedScatterChart.prototype.enumerateObjectInstances = function (options) {\n                    var enumeration = new visuals.ObjectEnumerationBuilder();\n                    switch (options.objectName) {\n                        case 'dataPoint':\n                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;\n                            if (!visuals.GradientUtils.hasGradientRole(categoricalDataView))\n                                this.enumerateDataPoints(enumeration);\n                            break;\n                        case 'categoryAxis':\n                            this.getCategoryAxisValues(enumeration);\n                            break;\n                        case 'valueAxis':\n                            this.getValueAxisValues(enumeration);\n                            break;\n                        case 'categoryLabels':\n                            if (this.data)\n                                visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, true);\n                            else\n                                visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, true);\n                            break;\n                        case 'fillPoint':\n                            var sizeRange = this.data.sizeRange;\n                            // Check if the card should be shown or not\n                            if (sizeRange && sizeRange.min)\n                                break;\n                            enumeration.pushInstance({\n                                objectName: 'fillPoint',\n                                selector: null,\n                                properties: {\n                                    show: this.data.fillPoint,\n                                },\n                            });\n                            break;\n                        case 'backdrop':\n                            enumeration.pushInstance({\n                                objectName: 'backdrop',\n                                displayName: 'Backdrop',\n                                selector: null,\n                                properties: {\n                                    show: this.data.backdrop ? this.data.backdrop.show : false,\n                                    url: this.data.backdrop ? this.data.backdrop.url : null\n                                },\n                            });\n                            break;\n                        case 'crosshair':\n                            enumeration.pushInstance({\n                                objectName: 'crosshair',\n                                selector: null,\n                                properties: {\n                                    show: this.data.crosshair\n                                },\n                            });\n                            break;\n                        case 'outline':\n                            enumeration.pushInstance({\n                                objectName: 'outline',\n                                selector: null,\n                                properties: {\n                                    show: this.data.outline\n                                },\n                            });\n                            break;\n                        case 'legend':\n                            this.getLegendValue(enumeration);\n                            break;\n                    }\n                    return enumeration.complete();\n                };\n                EnhancedScatterChart.prototype.hasLegend = function () {\n                    return this.data && this.data.hasDynamicSeries;\n                };\n                EnhancedScatterChart.prototype.getLegendValue = function (enumeration) {\n                    if (!this.hasLegend())\n                        return;\n                    var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());\n                    var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);\n                    var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : '');\n                    var legendLabelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);\n                    this.legendLabelFontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, EnhancedScatterChart.LegendLabelFontSizeDefault);\n                    enumeration.pushInstance({\n                        selector: null,\n                        properties: {\n                            show: show,\n                            position: visuals.LegendPosition[this.legend.getOrientation()],\n                            showTitle: showTitle,\n                            titleText: titleText,\n                            labelColor: legendLabelColor,\n                            fontSize: this.legendLabelFontSize,\n                        },\n                        objectName: 'legend'\n                    });\n                };\n                EnhancedScatterChart.prototype.getCategoryAxisValues = function (enumeration) {\n                    var supportedType = visuals.axisType.both;\n                    var isScalar = true;\n                    var logPossible = false;\n                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options\n                    if (!isScalar) {\n                        if (this.categoryAxisProperties) {\n                            this.categoryAxisProperties['start'] = null;\n                            this.categoryAxisProperties['end'] = null;\n                        }\n                    }\n                    var instance = {\n                        selector: null,\n                        properties: {},\n                        objectName: 'categoryAxis',\n                        validValues: {\n                            axisScale: scaleOptions\n                        }\n                    };\n                    instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;\n                    if (this.yAxisIsCategorical)\n                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;\n                    if (supportedType === visuals.axisType.both) {\n                        instance.properties['axisType'] = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical;\n                    }\n                    if (isScalar) {\n                        instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : visuals.axisScale.linear;\n                        instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;\n                        instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;\n                        instance.properties['labelDisplayUnits'] = this.categoryAxisProperties && this.categoryAxisProperties['labelDisplayUnits'] != null ? this.categoryAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault;\n                    }\n                    instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : true;\n                    enumeration\n                        .pushInstance(instance)\n                        .pushInstance({\n                        selector: null,\n                        properties: {\n                            axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,\n                            labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null\n                        },\n                        objectName: 'categoryAxis',\n                        validValues: {\n                            axisStyle: this.categoryAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]\n                        }\n                    });\n                };\n                //todo: wrap all these object getters and other related stuff into an interface\n                EnhancedScatterChart.prototype.getValueAxisValues = function (enumeration) {\n                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options\n                    var logPossible = false;\n                    var instance = {\n                        selector: null,\n                        properties: {},\n                        objectName: 'valueAxis',\n                        validValues: {\n                            axisScale: scaleOptions,\n                            secAxisScale: scaleOptions\n                        }\n                    };\n                    instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;\n                    if (!this.yAxisIsCategorical) {\n                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;\n                    }\n                    instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : visuals.axisScale.linear;\n                    instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;\n                    instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;\n                    instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : true;\n                    instance.properties['labelDisplayUnits'] = this.valueAxisProperties && this.valueAxisProperties['labelDisplayUnits'] != null ? this.valueAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault;\n                    enumeration\n                        .pushInstance(instance)\n                        .pushInstance({\n                        selector: null,\n                        properties: {\n                            axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,\n                            labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null\n                        },\n                        objectName: 'valueAxis',\n                        validValues: {\n                            axisStyle: this.valueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]\n                        },\n                    });\n                };\n                EnhancedScatterChart.prototype.onClearSelection = function () {\n                    if (this.interactivityService)\n                        this.interactivityService.clearSelection();\n                };\n                EnhancedScatterChart.DefaultBubbleOpacity = 0.85;\n                EnhancedScatterChart.DimmedBubbleOpacity = 0.4;\n                EnhancedScatterChart.DataLabelsOffset = 5;\n                EnhancedScatterChart.ClassName = 'enhancedScatterChart';\n                EnhancedScatterChart.MainGraphicsContextClassName = 'mainGraphicsContext';\n                EnhancedScatterChart.LegendLabelFontSizeDefault = 9;\n                EnhancedScatterChart.LabelDisplayUnitsDefault = 0;\n                EnhancedScatterChart.AxisFontSize = 11;\n                EnhancedScatterChart.DotClasses = {\n                    class: 'dot',\n                    selector: '.dot'\n                };\n                EnhancedScatterChart.ImageClasses = {\n                    class: 'img',\n                    selector: '.img'\n                };\n                EnhancedScatterChart.capabilities = {\n                    dataRoles: [\n                        {\n                            name: 'Category',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),\n                        }, {\n                            name: 'Series',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),\n                        }, {\n                            name: 'X',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_X'),\n                        }, {\n                            name: 'Y',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),\n                        }, {\n                            name: 'Size',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Size'),\n                        }, {\n                            name: 'Gradient',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),\n                        }, {\n                            name: 'ColorFill',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Customized Color',\n                        }, {\n                            name: 'Shape',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Shape',\n                        }, {\n                            name: 'Image',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Image',\n                        }, {\n                            name: 'Rotation',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Rotation',\n                        }, {\n                            name: 'Backdrop',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Backdrop',\n                        }, {\n                            name: 'X Start',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'X Start',\n                        }, {\n                            name: 'X End',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'X End',\n                        }, {\n                            name: 'Y Start',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Y Start',\n                        }, {\n                            name: 'Y End',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Y End',\n                        }\n                    ],\n                    dataViewMappings: [{\n                            conditions: [{\n                                    'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 },\n                                    'Size': { max: 1 }, 'Gradient': { max: 0 }, 'ColorFill': { max: 1 }, 'Shape': { max: 1 },\n                                    'Image': { max: 0 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\n                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\n                                }, {\n                                    'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 },\n                                    'Size': { max: 1 }, 'Gradient': { max: 1 }, 'ColorFill': { max: 1 }, 'Shape': { max: 1 },\n                                    'Image': { max: 0 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\n                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\n                                }, {\n                                    'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 },\n                                    'Size': { max: 1 }, 'Gradient': { max: 0 }, 'ColorFill': { max: 0 }, 'Shape': { max: 0 },\n                                    'Image': { max: 1 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\n                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\n                                }, {\n                                    'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 },\n                                    'Size': { max: 1 }, 'Gradient': { max: 1 }, 'ColorFill': { max: 0 }, 'Shape': { max: 0 },\n                                    'Image': { max: 1 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\n                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\n                                }],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Category' },\n                                    dataReductionAlgorithm: { sample: {} }\n                                },\n                                values: {\n                                    group: {\n                                        by: 'Series',\n                                        select: [\n                                            { bind: { to: 'X' } },\n                                            { bind: { to: 'Y' } },\n                                            { bind: { to: 'Size' } },\n                                            { bind: { to: 'Gradient' } },\n                                            { bind: { to: 'ColorFill' } },\n                                            { bind: { to: 'Shape' } },\n                                            { bind: { to: 'Image' } },\n                                            { bind: { to: 'Rotation' } },\n                                            { bind: { to: 'Backdrop' } },\n                                            { bind: { to: 'X Start' } },\n                                            { bind: { to: 'X End' } },\n                                            { bind: { to: 'Y Start' } },\n                                            { bind: { to: 'Y End' } },\n                                        ],\n                                        dataReductionAlgorithm: { top: {} }\n                                    }\n                                },\n                                rowCount: { preferred: { min: 2 } }\n                            },\n                        }],\n                    objects: {\n                        dataPoint: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),\n                            properties: {\n                                defaultColor: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                showAllDataPoints: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\n                                    type: { bool: true }\n                                },\n                                useShape: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_UseImage'),\n                                    type: { bool: true }\n                                },\n                                fill: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fillRule: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),\n                                    type: { fillRule: {} },\n                                    rule: {\n                                        inputRole: 'Gradient',\n                                        output: {\n                                            property: 'fill',\n                                            selector: ['Category'],\n                                        },\n                                    }\n                                }\n                            }\n                        },\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),\n                            properties: {\n                                formatString: {\n                                    type: { formatting: { formatString: true } },\n                                },\n                            },\n                        },\n                        categoryAxis: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                axisScale: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),\n                                    type: { formatting: { axisScale: true } }\n                                },\n                                start: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),\n                                    type: { numeric: true }\n                                },\n                                end: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),\n                                    type: { numeric: true }\n                                },\n                                showAxisTitle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),\n                                    type: { bool: true }\n                                },\n                                axisStyle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),\n                                    type: { formatting: { axisStyle: true } }\n                                },\n                                axisColor: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                labelDisplayUnits: {\n                                    displayName: 'Display Units',\n                                    type: { formatting: { labelDisplayUnits: true } },\n                                },\n                            }\n                        },\n                        valueAxis: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),\n                                    type: { formatting: { yAxisPosition: true } }\n                                },\n                                axisScale: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),\n                                    type: { formatting: { axisScale: true } }\n                                },\n                                start: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),\n                                    type: { numeric: true }\n                                },\n                                end: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),\n                                    type: { numeric: true }\n                                },\n                                showAxisTitle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),\n                                    type: { bool: true }\n                                },\n                                axisStyle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),\n                                    type: { formatting: { axisStyle: true } }\n                                },\n                                axisColor: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                labelDisplayUnits: {\n                                    displayName: 'Display Units',\n                                    type: { formatting: { labelDisplayUnits: true } },\n                                }\n                            }\n                        },\n                        legend: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),\n                                    type: { enumeration: visuals.legendPosition.type },\n                                },\n                                showTitle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),\n                                    type: { bool: true }\n                                },\n                                titleText: {\n                                    displayName: 'Legend Name',\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),\n                                    type: { text: true }\n                                },\n                                labelColor: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: 'Text Size',\n                                    type: { formatting: { fontSize: true } }\n                                }\n                            }\n                        },\n                        categoryLabels: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                color: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: 'Text Size',\n                                    type: { formatting: { fontSize: true } }\n                                },\n                            },\n                        },\n                        fillPoint: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_FillPoint'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { bool: true }\n                                },\n                            },\n                        },\n                        backdrop: {\n                            displayName: 'Backdrop',\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                url: {\n                                    displayName: 'Image URL',\n                                    type: { text: true }\n                                },\n                            },\n                        },\n                        crosshair: {\n                            displayName: 'Crosshair',\n                            properties: {\n                                show: {\n                                    displayName: 'Crosshair',\n                                    type: { bool: true }\n                                },\n                            },\n                        },\n                        outline: {\n                            displayName: 'Outline',\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),\n                                    type: { bool: true }\n                                }\n                            }\n                        }\n                    }\n                };\n                return EnhancedScatterChart;\n            }());\n            samples.EnhancedScatterChart = EnhancedScatterChart;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar THREE;\nvar WebGLHeatmap;\nvar GlobeMapCanvasLayers;\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var DataRoleHelper = powerbi.data.DataRoleHelper;\n            var GlobeMap = (function () {\n                function GlobeMap() {\n                    this.renderData = [];\n                    this.locationsToLoad = 0;\n                    this.locationsLoaded = 0;\n                    this.renderLoopEnabled = true;\n                    this.needsRender = false;\n                }\n                GlobeMap.converter = function (dataView) {\n                    return {};\n                };\n                GlobeMap.prototype.init = function (options) {\n                    this.container = options.element;\n                    this.viewport = options.viewport;\n                    this.readyToRender = false;\n                    if (!this.globeMapLocationCache)\n                        this.globeMapLocationCache = {};\n                    if (!THREE) {\n                        loadGlobeMapLibs();\n                    }\n                    if (THREE) {\n                        this.setup();\n                    }\n                };\n                GlobeMap.prototype.setup = function () {\n                    this.initSettings();\n                    this.initTextures();\n                    this.initMercartorSphere();\n                    this.initZoomControl();\n                    this.initScene();\n                    this.initHeatmap();\n                    this.readyToRender = true;\n                    this.composeRenderData();\n                    this.initRayCaster();\n                };\n                GlobeMap.prototype.initSettings = function () {\n                    var settings = this.settings = {};\n                    settings.autoRotate = false;\n                    settings.earthRadius = 30;\n                    settings.cameraRadius = 100;\n                    settings.earthSegments = 100;\n                    settings.heatmapSize = 1000;\n                    settings.heatPointSize = 7;\n                    settings.heatIntensity = 10;\n                    settings.heatmapScaleOnZoom = 0.95;\n                    settings.barWidth = 0.3;\n                    settings.barHeight = 5;\n                    settings.rotateSpeed = 0.5;\n                    settings.zoomSpeed = 0.8;\n                    settings.cameraAnimDuration = 1000; //ms\n                    settings.clickInterval = 200; //ms\n                };\n                GlobeMap.prototype.initScene = function () {\n                    var viewport = this.viewport;\n                    var settings = this.settings;\n                    var clock = new THREE.Clock();\n                    var renderer = this.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });\n                    this.container.append(renderer.domElement);\n                    this.domElement = renderer.domElement;\n                    var camera = this.camera = new THREE.PerspectiveCamera(35, viewport.width / viewport.height, 0.1, 10000);\n                    var orbitControls = this.orbitControls = new THREE.OrbitControls(camera, this.domElement);\n                    var scene = this.scene = new THREE.Scene();\n                    renderer.setSize(viewport.width, viewport.height);\n                    renderer.setClearColor(0xbac4d2, 1);\n                    camera.position.z = settings.cameraRadius;\n                    orbitControls.maxDistance = settings.cameraRadius;\n                    orbitControls.minDistance = settings.earthRadius + 1;\n                    orbitControls.rotateSpeed = settings.rotateSpeed;\n                    orbitControls.zoomSpeed = settings.zoomSpeed;\n                    orbitControls.autoRotate = settings.autoRotate;\n                    var ambientLight = new THREE.AmbientLight(0x000000);\n                    var light1 = new THREE.DirectionalLight(0xffffff, 0.4);\n                    var light2 = new THREE.DirectionalLight(0xffffff, 0.4);\n                    var earth = this.earth = this.createEarth();\n                    scene.add(ambientLight);\n                    scene.add(light1);\n                    scene.add(light2);\n                    scene.add(earth);\n                    light1.position.set(20, 20, 20);\n                    light2.position.set(0, 0, -20);\n                    var _zis = this;\n                    requestAnimationFrame(function render() {\n                        try {\n                            if (_zis.renderLoopEnabled)\n                                requestAnimationFrame(render);\n                            if (!_zis.shouldRender())\n                                return;\n                            orbitControls.update(clock.getDelta());\n                            _zis.setEarthTexture();\n                            _zis.intersectBars();\n                            _zis.heatmap.display(); // Needed for IE/Edge to behave nicely\n                            renderer.render(scene, camera);\n                            _zis.needsRender = false;\n                        }\n                        catch (e) {\n                            console.error(e);\n                        }\n                    });\n                };\n                GlobeMap.prototype.shouldRender = function () {\n                    return this.readyToRender && this.needsRender;\n                };\n                GlobeMap.prototype.createEarth = function () {\n                    var geometry = new GlobeMap.MercartorSphere(this.settings.earthRadius, this.settings.earthSegments, this.settings.earthSegments);\n                    var material = new THREE.MeshPhongMaterial({\n                        map: this.mapTextures[0],\n                        side: THREE.DoubleSide,\n                        shininess: 1,\n                        emissive: 0xaaaaaa,\n                    });\n                    return new THREE.Mesh(geometry, material);\n                };\n                GlobeMap.prototype.zoomClicked = function (zoomDirection) {\n                    if (this.orbitControls.enabled === false || this.orbitControls.enableZoom === false)\n                        return;\n                    if (zoomDirection === -1)\n                        this.orbitControls.constraint.dollyOut(Math.pow(0.95, this.settings.zoomSpeed));\n                    else if (zoomDirection === 1)\n                        this.orbitControls.constraint.dollyIn(Math.pow(0.95, this.settings.zoomSpeed));\n                    this.orbitControls.update();\n                    this.animateCamera(this.camera.position);\n                };\n                GlobeMap.prototype.rotateCam = function (deltaX, deltaY) {\n                    if (this.orbitControls.enabled === false || this.orbitControls.enableRotate === false)\n                        return;\n                    this.orbitControls.constraint.rotateLeft(2 * Math.PI * deltaX / this.domElement.offsetHeight * this.settings.rotateSpeed);\n                    this.orbitControls.constraint.rotateUp(2 * Math.PI * deltaY / this.domElement.offsetHeight * this.settings.rotateSpeed);\n                    this.orbitControls.update();\n                    this.animateCamera(this.camera.position);\n                };\n                GlobeMap.prototype.initZoomControl = function () {\n                    var _this = this;\n                    var radius = 17;\n                    var zoomControlWidth = radius * 8.5;\n                    var zoomControlHeight = radius * 8.5;\n                    var startX = radius * 3;\n                    var startY = radius + 3;\n                    var gap = radius * 2;\n                    var zoomCss = {\n                        'position': 'absolute',\n                        'left': 'calc(100% - ' + zoomControlWidth + 'px)',\n                        'top': 'calc(100% - ' + zoomControlHeight + 'px)',\n                        'zIndex': '1000',\n                    };\n                    var zoomContainer = d3.select(this.container[0])\n                        .append('div')\n                        .style(zoomCss);\n                    this.zoomControl = zoomContainer.append(\"svg\")\n                        .attr({\n                        \"width\": zoomControlWidth,\n                        \"height\": zoomControlHeight\n                    });\n                    var bottom = this.zoomControl.append(\"g\").on(\"click\", function () { return _this.rotateCam(0, -5); });\n                    bottom.append(\"circle\").attr({\n                        cx: startX + gap,\n                        cy: startY + (2 * gap),\n                        r: radius,\n                        fill: \"white\",\n                        opacity: 0.5,\n                        stroke: 'gray',\n                    });\n                    bottom.append(\"path\").attr({\n                        d: \"M\" + (startX + (2 * radius)) + \" \" + (startY + (radius * 4.7)) + \" l12 -20 a40,70 0 0,1 -24,0z\",\n                        fill: \"gray\",\n                    });\n                    var left = this.zoomControl.append(\"g\").on(\"click\", function () { return _this.rotateCam(5, 0); });\n                    left.append(\"circle\").attr({\n                        cx: startX,\n                        cy: startY + gap,\n                        r: radius,\n                        fill: \"white\",\n                        stroke: \"gray\",\n                        opacity: 0.5,\n                    });\n                    left.append(\"path\").attr({\n                        d: \"M\" + (startX - radius / 1.5) + \" \" + (startY + (radius * 2)) + \" l20 -12 a70,40 0 0,0 0,24z\",\n                        fill: \"gray\",\n                    });\n                    var top = this.zoomControl.append(\"g\").on(\"click\", function () { return _this.rotateCam(0, 5); });\n                    top.append(\"circle\").attr({\n                        cx: startX + gap,\n                        cy: startY,\n                        r: radius,\n                        fill: \"white\",\n                        stroke: \"gray\",\n                        opacity: 0.5,\n                    });\n                    top.append(\"path\").attr({\n                        d: \"M\" + (startX + (2 * radius)) + \" \" + (startY - (radius / 1.5)) + \" l12 20 a40,70 0 0,0 -24,0z\",\n                        fill: \"gray\",\n                    });\n                    var right = this.zoomControl.append(\"g\").on(\"click\", function () { return _this.rotateCam(-5, 0); });\n                    right.append(\"circle\").attr({\n                        cx: startX + (2 * gap),\n                        cy: startY + gap,\n                        r: radius,\n                        fill: \"white\",\n                        stroke: \"gray\",\n                        opacity: 0.5,\n                    });\n                    right.append(\"path\").attr({\n                        d: \"M\" + (startX + (4.7 * radius)) + \" \" + (startY + (radius * 2)) + \" l-20 -12 a70,40 0 0,1 0,24z\",\n                        fill: \"gray\",\n                    });\n                    var zoomIn = this.zoomControl.append(\"g\").on(\"click\", function () { return _this.zoomClicked(-1); });\n                    zoomIn.append(\"circle\").attr({\n                        cx: startX + 4 * radius,\n                        cy: startY + 6 * radius,\n                        r: radius,\n                        fill: \"white\",\n                        stroke: \"gray\",\n                        opacity: 0.5,\n                    });\n                    zoomIn.append(\"rect\").attr({\n                        x: startX + 3.5 * radius,\n                        y: startY + 5.9 * radius,\n                        width: radius,\n                        height: radius / 3,\n                        fill: \"gray\",\n                    });\n                    zoomIn.append(\"rect\").attr({\n                        x: startX + (4 * radius) - radius / 6,\n                        y: startY + 5.55 * radius,\n                        width: radius / 3,\n                        height: radius,\n                        fill: \"gray\",\n                    });\n                    var zoomOut = this.zoomControl.append(\"g\").on(\"click\", function () { return _this.zoomClicked(1); });\n                    zoomOut.append(\"circle\").attr({\n                        cx: startX,\n                        cy: startY + 6 * radius,\n                        r: radius,\n                        fill: \"white\",\n                        stroke: \"gray\",\n                        opacity: \"0.50\",\n                    });\n                    zoomOut.append(\"rect\").attr({\n                        x: startX - (radius / 2),\n                        y: startY + 5.9 * radius,\n                        width: radius,\n                        height: radius / 3,\n                        fill: \"gray\",\n                    });\n                };\n                GlobeMap.prototype.initTextures = function () {\n                    var _this = this;\n                    if (!GlobeMapCanvasLayers) {\n                        // Initialize once, since this is a CPU + Network heavy operation.\n                        GlobeMapCanvasLayers = [];\n                        for (var level = 2; level <= 5; ++level) {\n                            var canvas = this.getBingMapCanvas(level);\n                            GlobeMapCanvasLayers.push(canvas);\n                        }\n                    }\n                    // Can't execute in for loop because variable assignement gets overwritten\n                    var createTexture = function (canvas) {\n                        var texture = new THREE.Texture(canvas.get(0));\n                        texture.needsUpdate = true;\n                        canvas.on(\"ready\", function (e, resolution) {\n                            //console.log(\"level ready\", resolution, texture)\n                            texture.needsUpdate = true;\n                            _this.needsRender = true;\n                        });\n                        return texture;\n                    };\n                    this.mapTextures = [];\n                    for (var i = 0; i < GlobeMapCanvasLayers.length; ++i) {\n                        this.mapTextures.push(createTexture(GlobeMapCanvasLayers[i]));\n                    }\n                };\n                GlobeMap.prototype.initHeatmap = function () {\n                    var settings = this.settings;\n                    //console.log(\"initHeatmap\");\n                    try {\n                        var heatmap = this.heatmap = new WebGLHeatmap({ width: settings.heatmapSize, height: settings.heatmapSize, intensityToAlpha: true });\n                    }\n                    catch (e) {\n                        // IE & Edge will throw an error about texImage2D, we need to ignore it\n                        console.error(e);\n                    }\n                    // canvas contents will be used for a texture\n                    var texture = this.heatTexture = new THREE.Texture(heatmap.canvas);\n                    texture.needsUpdate = true;\n                    var material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });\n                    var geometry = new THREE.SphereGeometry(settings.earthRadius + 0.01, settings.earthSegments, settings.earthSegments);\n                    var mesh = new THREE.Mesh(geometry, material);\n                    window[\"heatmap\"] = heatmap;\n                    window[\"heatmapTexture\"] = texture;\n                    this.scene.add(mesh);\n                };\n                GlobeMap.prototype.setEarthTexture = function () {\n                    //get distance as arbitrary value from 0-1\n                    if (!this.camera)\n                        return;\n                    var maxDistance = this.settings.cameraRadius - this.settings.earthRadius;\n                    var distance = (this.camera.position.length() - this.settings.earthRadius) / maxDistance;\n                    var texture;\n                    if (distance <= 1 / 5) {\n                        texture = this.mapTextures[3];\n                    }\n                    else if (distance <= 2 / 5) {\n                        texture = this.mapTextures[2];\n                    }\n                    else if (distance <= 3 / 5) {\n                        texture = this.mapTextures[1];\n                    }\n                    else {\n                        texture = this.mapTextures[0];\n                    }\n                    if (this.earth.material.map !== texture) {\n                        this.earth.material.map = texture;\n                    }\n                    if (this.selectedBar) {\n                        this.orbitControls.rotateSpeed = this.settings.rotateSpeed;\n                    }\n                    else {\n                        this.orbitControls.rotateSpeed = this.settings.rotateSpeed * distance;\n                    }\n                    //console.log(distance, this.orbitControls.rotateSpeed);\n                };\n                GlobeMap.prototype.update = function (options) {\n                    this.needsRender = true;\n                    this.cleanHeatAndBar();\n                    if (options.viewport.height !== this.viewport.height || options.viewport.width !== this.viewport.width) {\n                        var viewport = this.viewport = options.viewport;\n                        if (this.camera && this.renderer) {\n                            this.camera.aspect = viewport.width / viewport.height;\n                            this.camera.updateProjectionMatrix();\n                            this.renderer.setSize(viewport.width, viewport.height);\n                        }\n                        return;\n                    }\n                    // PowerBI fires two update calls, one for size, one for data\n                    if (options.dataViews[0] && options.dataViews[0].categorical) {\n                        this.composeRenderData(options.dataViews[0].categorical);\n                    }\n                };\n                GlobeMap.prototype.cleanHeatAndBar = function () {\n                    this.heatmap.clear();\n                    this.heatTexture.needsUpdate = true;\n                    if (this.barsGroup) {\n                        this.scene.remove(this.barsGroup);\n                    }\n                };\n                GlobeMap.prototype.renderMagic = function () {\n                    if (!this.readyToRender) {\n                        //console.log(\"not ready to render\");\n                        this.defferedRender();\n                        return;\n                    }\n                    var renderData = this.renderData;\n                    var heatmap = this.heatmap;\n                    var settings = this.settings;\n                    heatmap.clear();\n                    if (this.barsGroup) {\n                        this.scene.remove(this.barsGroup);\n                    }\n                    this.barsGroup = new THREE.Object3D();\n                    this.scene.add(this.barsGroup);\n                    //colors for stacked vector by series values\n                    var barMaterials = [\n                        new THREE.MeshPhongMaterial({ color: 0xff00ff, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                        new THREE.MeshPhongMaterial({ color: 0xffff1a, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                        new THREE.MeshPhongMaterial({ color: 0xff0000, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                        new THREE.MeshPhongMaterial({ color: 0x00ffff, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                        new THREE.MeshPhongMaterial({ color: 0x994d00, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                        new THREE.MeshPhongMaterial({ color: 0xb3cccc, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                        new THREE.MeshPhongMaterial({ color: 0xace600, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                        new THREE.MeshPhongMaterial({ color: 0x52527a, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\n                    ];\n                    this.averageBarVector = new THREE.Vector3();\n                    for (var i = 0, len = renderData.length; i < len; ++i) {\n                        var renderDatum = renderData[i];\n                        if (!renderDatum.lat || !renderDatum.lng)\n                            continue;\n                        if (renderDatum.heat > 0.001) {\n                            if (renderDatum.heat < 0.1)\n                                renderDatum.heat = 0.1;\n                            var x = (180 + renderDatum.lng) / 360 * settings.heatmapSize;\n                            var y = (1 - ((90 + renderDatum.lat) / 180)) * settings.heatmapSize;\n                            heatmap.addPoint(x, y, settings.heatPointSize, renderDatum.heat * settings.heatIntensity);\n                        }\n                        if (renderDatum.height >= 0) {\n                            if (renderDatum.height < 0.01)\n                                renderDatum.height = 0.01;\n                            var latRadians = renderDatum.lat / 180 * Math.PI; //radians\n                            var lngRadians = renderDatum.lng / 180 * Math.PI;\n                            var x = Math.cos(lngRadians) * Math.cos(latRadians);\n                            var z = -Math.sin(lngRadians) * Math.cos(latRadians);\n                            var y = Math.sin(latRadians);\n                            var v = new THREE.Vector3(x, y, z);\n                            this.averageBarVector.add(v);\n                            var barHeight = settings.barHeight * renderDatum.height;\n                            //this array holds the relative series values to the actual measure for example [0.2,0.3,0.5]\n                            //this is how we draw the vectors relativly to the complete value one on top of another. \n                            var measuresBySeries = [];\n                            //this array holds the original values of the series for the tool tips\n                            var dataPointToolTip = [];\n                            if (renderDatum.heightBySeries) {\n                                for (var c = 0; c < renderDatum.heightBySeries.length; c++) {\n                                    if (renderDatum.heightBySeries[c])\n                                        measuresBySeries.push(renderDatum.heightBySeries[c]);\n                                    dataPointToolTip.push(renderDatum.seriesToolTipData[c]);\n                                }\n                            }\n                            else {\n                                //no category series so we'll just draw one value\n                                measuresBySeries.push(1);\n                            }\n                            var previousMeasureValue = 0;\n                            for (var j = 0; j < measuresBySeries.length; j++) {\n                                previousMeasureValue += measuresBySeries[j];\n                                var geometry = new THREE.CubeGeometry(settings.barWidth, settings.barWidth, barHeight * measuresBySeries[j]);\n                                var bar = new THREE.Mesh(geometry, barMaterials[j % (barMaterials.length - 1)]);\n                                bar.position = v.clone().multiplyScalar(settings.earthRadius + ((barHeight / 2) * previousMeasureValue));\n                                bar.lookAt(v);\n                                bar.toolTipData = dataPointToolTip.length === 0 ? renderDatum.toolTipData : this.getToolTipDataForSeries(renderDatum.toolTipData, dataPointToolTip[j]);\n                                this.barsGroup.add(bar);\n                                previousMeasureValue += measuresBySeries[j];\n                            }\n                        }\n                    }\n                    if (this.barsGroup.children.length > 0 && this.camera) {\n                        this.averageBarVector.multiplyScalar(1 / this.barsGroup.children.length);\n                        if (this.locationsLoaded === this.locationsToLoad) {\n                            this.animateCamera(this.averageBarVector);\n                        }\n                    }\n                    heatmap.update();\n                    heatmap.blur();\n                    this.heatTexture.needsUpdate = true;\n                    this.needsRender = true;\n                    //console.log(\"renderMagic done! locations:\", this.barsGroup.children.length, \"toload/loaded\", this.locationsToLoad, this.locationsLoaded)\n                };\n                GlobeMap.prototype.getToolTipDataForSeries = function (toolTipData, dataPointToolTip) {\n                    var result = jQuery.extend(true, {\n                        series: { displayName: dataPointToolTip.displayName, value: dataPointToolTip.value }\n                    }, toolTipData);\n                    result.height.value = dataPointToolTip.dataPointValue;\n                    return result;\n                };\n                GlobeMap.prototype.composeRenderData = function (categoricalView) {\n                    // memoize last value\n                    if (categoricalView) {\n                        this.categoricalView = categoricalView;\n                    }\n                    else {\n                        categoricalView = this.categoricalView;\n                    }\n                    this.renderData = [];\n                    var locations = [];\n                    var globeMapLocationCache = this.globeMapLocationCache;\n                    //console.log(\"categoricalView\", categoricalView)\n                    if (!categoricalView)\n                        return;\n                    var categories = categoricalView.categories;\n                    var grouped = categoricalView.values.grouped();\n                    var heightIndex = 0;\n                    var intensityIndex = 0;\n                    try {\n                        heightIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"Height\");\n                        intensityIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"Heat\");\n                        var longitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"X\");\n                        var latitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"Y\");\n                    }\n                    catch (e) { }\n                    var locationType, heights, heightsBySeries, toolTipDataBySeries, heats, latitudes, longitudes, locationDispName, heightDispName, heatDispName, heightFormat, heatFormat;\n                    if (heightIndex !== undefined && categoricalView.values[heightIndex] && categoricalView.values !== undefined) {\n                        var locationCategory = categories[0];\n                        locations = locationCategory.values;\n                        locationDispName = locationCategory.source.displayName;\n                        if (locationCategory.source.type.category) {\n                            locationType = locationCategory.source.type.category.toLowerCase();\n                        }\n                        else {\n                            locationType = \"\";\n                        }\n                    }\n                    else {\n                        locations = [];\n                    }\n                    // For debugging since devTools - salesByCountry isn't really sales by country\n                    //var places = [\"kenya\", \"india\", \"united states\", \"london\", \"australia\", \"canada\"]\n                    //heightIndex = 0;\n                    if (heightIndex !== undefined && categoricalView.values[heightIndex]) {\n                        // heights = categoricalView.values[heightIndex].values;\n                        heightDispName = categoricalView.values[heightIndex].source.displayName;\n                        heightFormat = categoricalView.values[heightIndex].source.format;\n                        if (grouped.length > 1) {\n                            heights = new Array(locations.length);\n                            heightsBySeries = new Array(locations.length);\n                            toolTipDataBySeries = new Array(locations.length);\n                            //creating a matrix for drawing values by series later.\n                            for (var i = 0; i < grouped.length; i++) {\n                                var values = grouped[i].values[heightIndex].values;\n                                for (var j = 0; j < values.length; j++) {\n                                    if (!heights[j])\n                                        heights[j] = 0;\n                                    heights[j] += values[j] ? values[j] : 0;\n                                    if (!heightsBySeries[j])\n                                        heightsBySeries[j] = [];\n                                    heightsBySeries[j][i] = values[j];\n                                    if (!toolTipDataBySeries[j])\n                                        toolTipDataBySeries[j] = [];\n                                    toolTipDataBySeries[j][i] = { displayName: categoricalView.values.source.displayName, value: grouped[i].name, dataPointValue: values[j] };\n                                }\n                            }\n                            for (var i = 0; i < grouped.length; i++) {\n                                var values = grouped[i].values[heightIndex].values;\n                                for (var j = 0; j < values.length; j++) {\n                                    //calculating relative size of series\n                                    heightsBySeries[j][i] = values[j] / heights[j];\n                                }\n                            }\n                        }\n                        else {\n                            heights = categoricalView.values[heightIndex].values;\n                            heightsBySeries = new Array(grouped.length);\n                        }\n                    }\n                    else {\n                        heightsBySeries = new Array(locations.length);\n                        heights = new Array(locations.length);\n                    }\n                    if (intensityIndex !== undefined && categoricalView.values[intensityIndex]) {\n                        if (grouped.length > 1) {\n                            heats = new Array(locations.length);\n                            for (var i = 0; i < grouped.length; i++) {\n                                var values = grouped[i].values[intensityIndex].values;\n                                for (var j = 0; j < values.length; j++) {\n                                    if (!heats[j])\n                                        heats[j] = 0;\n                                    heats[j] += values[j] ? values[j] : 0;\n                                }\n                            }\n                        }\n                        else {\n                            heats = categoricalView.values[intensityIndex].values;\n                        }\n                        heatDispName = categoricalView.values[intensityIndex].source.displayName;\n                        heatFormat = categoricalView.values[intensityIndex].source.format;\n                    }\n                    else {\n                        heats = new Array(locations.length);\n                    }\n                    if (longitudeIndex !== undefined && categoricalView.values[longitudeIndex]\n                        && latitudeIndex !== undefined && categoricalView.values[latitudeIndex]) {\n                        longitudes = categoricalView.values[longitudeIndex].values;\n                        latitudes = categoricalView.values[latitudeIndex].values;\n                    }\n                    else {\n                        longitudes = null;\n                        latitudes = null;\n                    }\n                    var maxHeight = Math.max.apply(null, heights) || 1;\n                    var maxHeat = Math.max.apply(null, heats) || 1;\n                    var heatFormatter = visuals.valueFormatter.create({ format: heatFormat, value: heats[0], value2: heats[1] });\n                    var heightFormatter = visuals.valueFormatter.create({ format: heightFormat, value: heights[0], value2: heights[1] });\n                    for (var i = 0, len = locations.length; i < len; ++i) {\n                        var place = locations[i];\n                        var lat, lng, latlng, height, heat;\n                        //place = places[i];\n                        if (place && typeof (place) === \"string\") {\n                            place = place.toLowerCase();\n                            var placeKey = place + \"/\" + locationType;\n                            if (!longitudes && globeMapLocationCache[placeKey]) {\n                                latlng = globeMapLocationCache[placeKey];\n                                lat = latlng.latitude;\n                                lng = latlng.longitude;\n                            }\n                            else if (longitudes) {\n                                lat = latitudes[i];\n                                lng = longitudes[i];\n                            }\n                            height = heights[i] / maxHeight;\n                            heat = heats[i] / maxHeat;\n                            var renderDatum = {\n                                lat: lat,\n                                lng: lng,\n                                height: height ? height || 0.01 : undefined,\n                                heightBySeries: heightsBySeries[i],\n                                seriesToolTipData: toolTipDataBySeries ? toolTipDataBySeries[i] : undefined,\n                                heat: heat || 0,\n                                toolTipData: {\n                                    location: { displayName: locationDispName, value: locations[i] },\n                                    height: { displayName: heightDispName, value: heightFormatter.format(heights[i]) },\n                                    heat: { displayName: heatDispName, value: heatFormatter.format(heats[i]) }\n                                }\n                            };\n                            this.renderData.push(renderDatum);\n                            if (!longitudes && !latlng) {\n                                this.geocodeRenderDatum(renderDatum, place, locationType);\n                            }\n                        }\n                    }\n                    try {\n                        this.renderMagic();\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                };\n                GlobeMap.prototype.geocodeRenderDatum = function (renderDatum, place, locationType) {\n                    var _this = this;\n                    var placeKey = place + \"/\" + locationType;\n                    this.globeMapLocationCache[placeKey] = {}; //store empty object so we don't send AJAX request again\n                    this.locationsToLoad++;\n                    try {\n                        var geocoder = powerbi.visuals[\"BI\"].Services.GeocodingManager.geocode;\n                    }\n                    catch (e) {\n                        geocoder = visuals.services.geocode;\n                    }\n                    if (geocoder) {\n                        geocoder(place, locationType).always(function (latlng) {\n                            // we use always because we want to cache unknown values. \n                            // No point asking bing again and again when it tells us it doesn't know about a location\n                            _this.globeMapLocationCache[placeKey] = latlng;\n                            _this.locationsLoaded++;\n                            //console.log(place, latlng);\n                            if (latlng.latitude && latlng.longitude) {\n                                renderDatum.lat = latlng.latitude;\n                                renderDatum.lng = latlng.longitude;\n                                _this.defferedRender();\n                            }\n                        });\n                    }\n                };\n                GlobeMap.prototype.defferedRender = function () {\n                    var _this = this;\n                    if (!this.deferredRenderTimerId) {\n                        this.deferredRenderTimerId = setTimeout(function () {\n                            _this.deferredRenderTimerId = null;\n                            _this.composeRenderData();\n                        }, 500);\n                    }\n                };\n                GlobeMap.prototype.initRayCaster = function () {\n                    var _this = this;\n                    this.rayCaster = new THREE.Raycaster();\n                    var settings = this.settings;\n                    var mousePosNormalized = this.mousePosNormalized = new THREE.Vector2();\n                    var mousePos = this.mousePos = new THREE.Vector2();\n                    var element = this.container.get(0);\n                    var mouseDownTime;\n                    $(this.domElement).on(\"mousemove\", function (event) {\n                        // get coordinates in -1 to +1 space\n                        var rect = element.getBoundingClientRect();\n                        mousePos.x = event.clientX;\n                        mousePos.y = event.clientY;\n                        mousePosNormalized.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n                        mousePosNormalized.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n                        _this.needsRender = true;\n                    }).on(\"mousedown\", function (event) {\n                        mouseDownTime = Date.now();\n                    }).on(\"mouseup\", function (event) {\n                        // Debounce slow clicks\n                        if ((Date.now() - mouseDownTime) > settings.clickInterval)\n                            return;\n                        if (_this.hoveredBar && event.shiftKey) {\n                            _this.selectedBar = _this.hoveredBar;\n                            _this.animateCamera(_this.selectedBar.position, function () {\n                                if (!_this.selectedBar)\n                                    return;\n                                _this.orbitControls.center.copy(_this.selectedBar.position.clone().normalize().multiplyScalar(settings.earthRadius));\n                                _this.orbitControls.minDistance = 1;\n                            });\n                        }\n                        else {\n                            if (_this.selectedBar) {\n                                _this.animateCamera(_this.selectedBar.position, function () {\n                                    _this.orbitControls.center.set(0, 0, 0);\n                                    _this.orbitControls.minDistance = settings.earthRadius + 1;\n                                });\n                                _this.selectedBar = null;\n                            }\n                        }\n                    }).on(\"mousewheel DOMMouseScroll\", function (e) {\n                        _this.needsRender = true;\n                        if (_this.orbitControls.enabled && _this.orbitControls.enableZoom) {\n                            _this.heatTexture.needsUpdate = true;\n                            e = e.originalEvent;\n                            var delta = e.wheelDelta > 0 || e.detail < 0 ? 1 : -1;\n                            var scale = delta > 0 ? _this.settings.heatmapScaleOnZoom : (1 / _this.settings.heatmapScaleOnZoom);\n                            _this.heatmap.multiply(scale);\n                            _this.heatmap.update();\n                        }\n                    });\n                };\n                GlobeMap.prototype.intersectBars = function () {\n                    if (!this.rayCaster || !this.barsGroup)\n                        return;\n                    var rayCaster = this.rayCaster;\n                    rayCaster.setFromCamera(this.mousePosNormalized, this.camera);\n                    var intersects = rayCaster.intersectObjects(this.barsGroup.children);\n                    if (intersects && intersects.length > 0) {\n                        //console.log(intersects[0], this.mousePos.x, this.mousePos.y);\n                        var object = intersects[0].object;\n                        if (!object || !object.toolTipData)\n                            return;\n                        var toolTipData = object.toolTipData;\n                        var toolTipItems = [];\n                        if (toolTipData.location.displayName)\n                            toolTipItems.push(toolTipData.location);\n                        if (toolTipData.series)\n                            toolTipItems.push(toolTipData.series);\n                        if (toolTipData.height.displayName)\n                            toolTipItems.push(toolTipData.height);\n                        if (toolTipData.heat.displayName)\n                            toolTipItems.push(toolTipData.heat);\n                        this.hoveredBar = object;\n                        visuals.TooltipManager.ToolTipInstance.show(toolTipItems, { x: this.mousePos.x, y: this.mousePos.y, width: 0, height: 0 });\n                    }\n                    else {\n                        this.hoveredBar = null;\n                        visuals.TooltipManager.ToolTipInstance.hide();\n                    }\n                };\n                GlobeMap.prototype.animateCamera = function (to, done) {\n                    var _this = this;\n                    if (!this.camera)\n                        return;\n                    var startTime = Date.now();\n                    var duration = this.settings.cameraAnimDuration;\n                    var endTime = startTime + duration;\n                    var startPos = this.camera.position.clone().normalize();\n                    var endPos = to.clone().normalize();\n                    var length = this.camera.position.length();\n                    var easeInOut = function (t) {\n                        t *= 2;\n                        if (t < 1)\n                            return (t * t * t) / 2;\n                        t -= 2;\n                        return (t * t * t + 2) / 2;\n                    };\n                    var onUpdate = function () {\n                        var now = Date.now();\n                        var t = (now - startTime) / duration;\n                        if (t > 1)\n                            t = 1;\n                        t = easeInOut(t);\n                        var pos = new THREE.Vector3()\n                            .add(startPos.clone().multiplyScalar(1 - t))\n                            .add(endPos.clone().multiplyScalar(t))\n                            .normalize()\n                            .multiplyScalar(length);\n                        _this.camera.position = pos;\n                        if (now < endTime) {\n                            requestAnimationFrame(onUpdate);\n                        }\n                        else if (done) {\n                            done();\n                        }\n                        _this.needsRender = true;\n                    };\n                    requestAnimationFrame(onUpdate);\n                };\n                GlobeMap.prototype.destroy = function () {\n                    clearTimeout(this.deferredRenderTimerId);\n                    this.renderLoopEnabled = false;\n                    this.scene = null;\n                    this.heatmap = null;\n                    this.heatTexture = null;\n                    this.camera = null;\n                    if (this.renderer) {\n                        if (this.renderer.context) {\n                            var extension = this.renderer.context.getExtension('WEBGL_lose_context');\n                            if (extension)\n                                extension.loseContext();\n                            this.renderer.context = null;\n                        }\n                        this.renderer.domElement = null;\n                    }\n                    this.renderer = null;\n                    this.renderData = null;\n                    this.barsGroup = null;\n                    if (this.orbitControls)\n                        this.orbitControls.dispose();\n                    this.orbitControls = null;\n                    if (this.domElement)\n                        $(this.domElement)\n                            .off(\"mousemove mouseup mousedown mousewheel DOMMouseScroll\");\n                    this.domElement = null;\n                    if (this.container)\n                        this.container.empty();\n                };\n                GlobeMap.prototype.initMercartorSphere = function () {\n                    if (GlobeMap.MercartorSphere)\n                        return;\n                    var MercartorSphere = function (radius, widthSegments, heightSegments) {\n                        THREE.Geometry.call(this);\n                        this.radius = radius;\n                        this.widthSegments = widthSegments;\n                        this.heightSegments = heightSegments;\n                        this.t = 0;\n                        var x, y, vertices = [], uvs = [];\n                        function interplolate(a, b, t) {\n                            return (1 - t) * a + t * b;\n                        }\n                        // interpolates between sphere and plane\n                        function interpolateVertex(u, v, t) {\n                            var maxLng = Math.PI * 2;\n                            var maxLat = Math.PI;\n                            var radius = this.radius;\n                            var sphereX = -radius * Math.cos(u * maxLng) * Math.sin(v * maxLat);\n                            var sphereY = -radius * Math.cos(v * maxLat);\n                            var sphereZ = radius * Math.sin(u * maxLng) * Math.sin(v * maxLat);\n                            var planeX = u * radius * 2 - radius;\n                            var planeY = v * radius * 2 - radius;\n                            var planeZ = 0;\n                            var x = interplolate(sphereX, planeX, t);\n                            var y = interplolate(sphereY, planeY, t);\n                            var z = interplolate(sphereZ, planeZ, t);\n                            return new THREE.Vector3(x, y, z);\n                        }\n                        // http://mathworld.wolfram.com/MercatorProjection.html\n                        // Mercator projection goes form +85.05 to -85.05 degrees\n                        function interpolateUV(u, v, t) {\n                            var lat = (v - 0.5) * 90 * 2 / 180 * Math.PI; //turn from 0-1 into lat in radians\n                            var sin = Math.sin(lat);\n                            var normalizedV = 0.5 + 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n                            return new THREE.Vector2(u, normalizedV); //interplolate(normalizedV1, v, t))\n                        }\n                        for (y = 0; y <= heightSegments; y++) {\n                            var verticesRow = [];\n                            var uvsRow = [];\n                            for (x = 0; x <= widthSegments; x++) {\n                                var u = x / widthSegments;\n                                var v = y / heightSegments;\n                                this.vertices.push(interpolateVertex.call(this, u, v, this.t));\n                                uvsRow.push(interpolateUV.call(this, u, v, this.t));\n                                verticesRow.push(this.vertices.length - 1);\n                            }\n                            vertices.push(verticesRow);\n                            uvs.push(uvsRow);\n                        }\n                        //console.log(vertices, uvs);\n                        for (y = 0; y < this.heightSegments; y++) {\n                            for (x = 0; x < this.widthSegments; x++) {\n                                var v1 = vertices[y][x + 1];\n                                var v2 = vertices[y][x];\n                                var v3 = vertices[y + 1][x];\n                                var v4 = vertices[y + 1][x + 1];\n                                var n1 = this.vertices[v1].clone().normalize();\n                                var n2 = this.vertices[v2].clone().normalize();\n                                var n3 = this.vertices[v3].clone().normalize();\n                                var n4 = this.vertices[v4].clone().normalize();\n                                var uv1 = uvs[y][x + 1].clone();\n                                var uv2 = uvs[y][x].clone();\n                                var uv3 = uvs[y + 1][x].clone();\n                                var uv4 = uvs[y + 1][x + 1].clone();\n                                var normals = [n1, n2, n3, n4];\n                                this.faces.push(new THREE.Face4(v1, v2, v3, v4, normals));\n                                this.faceVertexUvs[0].push([uv1, uv2, uv3, uv4]);\n                            }\n                        }\n                        this.computeCentroids();\n                        this.computeFaceNormals();\n                        this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\n                    };\n                    MercartorSphere.prototype = Object.create(THREE.Geometry.prototype);\n                    GlobeMap.MercartorSphere = MercartorSphere;\n                };\n                GlobeMap.prototype.getBingMapCanvas = function (resolution) {\n                    var tileSize = 256;\n                    var numSegments = Math.pow(2, resolution);\n                    var numTiles = numSegments * numSegments;\n                    var tilesLoaded = 0;\n                    var canvasSize = tileSize * numSegments;\n                    var canvas = $('<canvas/>').attr({ width: canvasSize, height: canvasSize });\n                    var canvasElem = canvas.get(0);\n                    var canvasContext = canvasElem.getContext(\"2d\");\n                    function generateQuads(res, quad) {\n                        if (res <= resolution) {\n                            if (res === resolution) {\n                                loadTile(quad);\n                            }\n                            generateQuads(res + 1, quad + \"0\");\n                            generateQuads(res + 1, quad + \"1\");\n                            generateQuads(res + 1, quad + \"2\");\n                            generateQuads(res + 1, quad + \"3\");\n                        }\n                    }\n                    function loadTile(quad) {\n                        var template = \"https://t{server}.tiles.virtualearth.net/tiles/r{quad}.jpeg?g=0&mkt={language}\";\n                        var numServers = 7;\n                        var server = Math.round(Math.random() * numServers);\n                        var language = (navigator[\"languages\"] && navigator[\"languages\"].length) ? navigator[\"languages\"][0] : navigator.language;\n                        var url = template.replace(\"{server}\", server)\n                            .replace(\"{quad}\", quad)\n                            .replace(\"{language}\", language);\n                        var coords = getCoords(quad);\n                        //console.log(quad, coords.x, coords.y)\n                        var tile = new Image();\n                        tile.onload = function () {\n                            tilesLoaded++;\n                            canvasContext.drawImage(tile, coords.x * tileSize, coords.y * tileSize, tileSize, tileSize);\n                            if (tilesLoaded === numTiles) {\n                                canvas.trigger(\"ready\", resolution);\n                            }\n                        };\n                        // So the canvas doesn't get tainted\n                        tile.crossOrigin = '';\n                        tile.src = url;\n                    }\n                    function getCoords(quad) {\n                        var x = 0;\n                        var y = 0;\n                        var last = quad.length - 1;\n                        for (var i = last; i >= 0; i--) {\n                            var chr = quad.charAt(i);\n                            var pow = Math.pow(2, last - i);\n                            if (chr === \"1\") {\n                                x += pow;\n                            }\n                            else if (chr === \"2\") {\n                                y += pow;\n                            }\n                            else if (chr === \"3\") {\n                                x += pow;\n                                y += pow;\n                            }\n                        }\n                        return { x: x, y: y };\n                    }\n                    generateQuads(0, \"\");\n                    return canvas;\n                };\n                GlobeMap.capabilities = {\n                    dataRoles: [\n                        {\n                            name: 'Category',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),\n                            preferredTypes: [\n                                { geography: { address: true } },\n                                { geography: { city: true } },\n                                { geography: { continent: true } },\n                                { geography: { country: true } },\n                                { geography: { county: true } },\n                                { geography: { place: true } },\n                                { geography: { postalCode: true } },\n                                { geography: { region: true } },\n                                { geography: { stateOrProvince: true } },\n                            ],\n                        },\n                        {\n                            name: 'Series',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: \"Legend\",\n                        },\n                        {\n                            name: 'X',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Longitude',\n                            description: 'Use to override the longitude of locations',\n                            preferredTypes: [{ geography: { longitude: true } }],\n                        },\n                        {\n                            name: 'Y',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Latitude',\n                            description: 'Use to override the latitude of locations',\n                            preferredTypes: [{ geography: { latitude: true } }],\n                        },\n                        {\n                            name: 'Height',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Bar Height',\n                        },\n                        {\n                            name: 'Heat',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Heat Intensity',\n                        }\n                    ],\n                    objects: {\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),\n                            properties: {\n                                formatString: {\n                                    type: { formatting: { formatString: true } },\n                                },\n                            },\n                        },\n                        legend: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),\n                                    type: { formatting: { legendPosition: true } }\n                                },\n                                showTitle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),\n                                    type: { bool: true }\n                                },\n                                titleText: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),\n                                    type: { text: true }\n                                }\n                            }\n                        },\n                        dataPoint: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),\n                            properties: {\n                                defaultColor: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                showAllDataPoints: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\n                                    type: { bool: true }\n                                },\n                                fill: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fillRule: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),\n                                    type: { fillRule: {} },\n                                    rule: {\n                                        inputRole: 'Gradient',\n                                        output: {\n                                            property: 'fill',\n                                            selector: ['Category'],\n                                        },\n                                    },\n                                }\n                            }\n                        },\n                        categoryLabels: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                color: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                            },\n                        },\n                    },\n                    dataViewMappings: [{\n                            conditions: [\n                                { 'Category': { max: 1 }, 'Series': { max: 1 }, 'Height': { max: 1 }, 'Heat': { max: 1 } },\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Category' },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: {\n                                    group: {\n                                        by: 'Series',\n                                        select: [\n                                            { bind: { to: 'Height' } },\n                                            { bind: { to: 'Heat' } },\n                                            { bind: { to: 'X' } },\n                                            { bind: { to: 'Y' } },\n                                        ],\n                                        dataReductionAlgorithm: { top: {} }\n                                    }\n                                },\n                                rowCount: { preferred: { min: 2 } }\n                            },\n                        }],\n                    sorting: {\n                        custom: {},\n                    }\n                };\n                return GlobeMap;\n            }());\n            samples.GlobeMap = GlobeMap;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\nfunction loadGlobeMapLibs() {\n    // include GlobeMapLibs.js\n}\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var SelectionManager = visuals.utility.SelectionManager;\n            var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n            var PixelConverter = jsCommon.PixelConverter;\n            /**\n             * RadarChartBehavior\n             */\n            var RadarChartWebBehavior = (function () {\n                function RadarChartWebBehavior() {\n                }\n                RadarChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {\n                    var selection = this.selection = options.selection;\n                    var clearCatcher = options.clearCatcher;\n                    selection.on('click', function (d) {\n                        selectionHandler.handleSelection(d, d3.event.ctrlKey);\n                        d3.event.stopPropagation();\n                    });\n                    clearCatcher.on('click', function () {\n                        selectionHandler.handleClearSelection();\n                    });\n                };\n                RadarChartWebBehavior.prototype.renderSelection = function (hasSelection) {\n                    this.selection.style(\"opacity\", function (d) { return (hasSelection && !d.selected) ? RadarChart.DimmedAreaFillOpacity : RadarChart.AreaFillOpacity; });\n                };\n                return RadarChartWebBehavior;\n            }());\n            samples.RadarChartWebBehavior = RadarChartWebBehavior;\n            var RadarChart = (function () {\n                function RadarChart(options) {\n                    if (options) {\n                        if (options.svg)\n                            this.svg = options.svg;\n                        if (options.animator)\n                            this.animator = options.animator;\n                        if (options.margin)\n                            this.margin = options.margin;\n                    }\n                }\n                RadarChart.converter = function (dataView, colors) {\n                    if (!dataView ||\n                        !dataView.categorical ||\n                        !dataView.categorical.categories ||\n                        !(dataView.categorical.categories.length > 0) ||\n                        !dataView.categorical.categories[0] ||\n                        !dataView.categorical.values ||\n                        !(dataView.categorical.values.length > 0)) {\n                        return {\n                            legendData: {\n                                dataPoints: []\n                            },\n                            settings: {\n                                showLegend: true\n                            },\n                            series: [],\n                            dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),\n                        };\n                    }\n                    var catDv = dataView.categorical;\n                    var values = catDv.values;\n                    var series = [];\n                    var colorHelper = new visuals.ColorHelper(colors, RadarChart.Properties.dataPoint.fill);\n                    var legendData = {\n                        fontSize: 8.25,\n                        dataPoints: [],\n                        title: \"\"\n                    };\n                    //Parse legend settings          \n                    var legendSettings = RadarChart.parseSettings(dataView);\n                    var dataLabelsSettings = RadarChart.parseLabelSettings(dataView);\n                    for (var i = 0, iLen = values.length; i < iLen; i++) {\n                        var color = colors.getColorByIndex(i).value, serieIdentity = void 0, queryName = void 0, displayName = void 0, dataPoints = [];\n                        if (values[i].source) {\n                            var source = values[i].source;\n                            if (source.queryName) {\n                                queryName = source.queryName;\n                                serieIdentity = visuals.SelectionId.createWithMeasure(queryName);\n                            }\n                            if (source.displayName)\n                                displayName = source.displayName;\n                            if (source.objects) {\n                                var objects = source.objects;\n                                color = colorHelper.getColorForMeasure(objects, queryName);\n                            }\n                        }\n                        legendData.dataPoints.push({\n                            label: displayName,\n                            color: color,\n                            icon: visuals.LegendIcon.Box,\n                            selected: false,\n                            identity: serieIdentity\n                        });\n                        for (var k = 0, kLen = values[i].values.length; k < kLen; k++) {\n                            var dataPointIdentity = visuals.SelectionIdBuilder\n                                .builder()\n                                .withMeasure(queryName)\n                                .withCategory(catDv.categories[0], k)\n                                .withSeries(dataView.categorical.values, dataView.categorical.values[i])\n                                .createSelectionId();\n                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(RadarChart.formatStringProp, catDv, catDv.categories[0].values[k], values[i].values[k], null, null, i);\n                            var labelFormatString = visuals.valueFormatter.getFormatString(catDv.values[i].source, RadarChart.formatStringProp);\n                            var fontSizeInPx = jsCommon.PixelConverter.fromPoint(dataLabelsSettings.fontSize);\n                            dataPoints.push({\n                                x: k,\n                                y: values[i].values[k],\n                                color: color,\n                                identity: dataPointIdentity,\n                                selected: false,\n                                tooltipInfo: tooltipInfo,\n                                value: values[i].values[k],\n                                labelFormatString: labelFormatString,\n                                labelFontSize: fontSizeInPx,\n                            });\n                        }\n                        if (dataPoints.length > 0)\n                            series.push({\n                                fill: color,\n                                name: displayName,\n                                data: dataPoints,\n                                identity: serieIdentity,\n                            });\n                    }\n                    return {\n                        legendData: legendData,\n                        settings: legendSettings,\n                        series: series,\n                        dataLabelsSettings: dataLabelsSettings,\n                    };\n                };\n                RadarChart.prototype.init = function (options) {\n                    var element = options.element;\n                    this.selectionManager = new SelectionManager({ hostServices: options.host });\n                    if (!this.svg) {\n                        this.svg = d3.select(element.get(0)).append('svg');\n                        this.svg.style('position', 'absolute');\n                    }\n                    if (!this.margin)\n                        this.margin = RadarChart.DefaultMargin;\n                    this.svg.classed(RadarChart.VisualClassName, true);\n                    this.interactivityService = visuals.createInteractivityService(options.host);\n                    this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;\n                    this.legend = visuals.createLegend(element, this.isInteractiveChart, this.interactivityService, true, visuals.LegendPosition.Top);\n                    this.colors = options.style.colorPalette.dataColors;\n                    this.mainGroupElement = this.svg.append('g');\n                    this.segments = this.mainGroupElement\n                        .append('g')\n                        .classed(RadarChart.Segments.class, true);\n                    this.axis = this.mainGroupElement\n                        .append('g')\n                        .classed(RadarChart.Axis.class, true);\n                    this.chart = this.mainGroupElement\n                        .append('g')\n                        .classed(RadarChart.Chart.class, true);\n                };\n                RadarChart.prototype.update = function (options) {\n                    if (!options.dataViews || !options.dataViews[0])\n                        return;\n                    var dataView = options.dataViews[0];\n                    this.radarChartData = RadarChart.converter(dataView, this.colors);\n                    var categories = [], series = this.radarChartData.series, dataViewMetadataColumn, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, options.suppressAnimations);\n                    if (dataView.categorical &&\n                        dataView.categorical.categories &&\n                        dataView.categorical.categories[0] &&\n                        dataView.categorical.categories[0].values)\n                        categories = dataView.categorical.categories[0].values;\n                    if (dataView.metadata && dataView.metadata.columns && dataView.metadata.columns.length > 0)\n                        dataViewMetadataColumn = dataView.metadata.columns[0];\n                    this.viewport = {\n                        height: options.viewport.height > 0 ? options.viewport.height : 0,\n                        width: options.viewport.width > 0 ? options.viewport.width : 0\n                    };\n                    this.parseLegendProperties(dataView);\n                    this.renderLegend(this.radarChartData);\n                    this.updateViewport();\n                    this.svg\n                        .attr({\n                        'height': this.viewport.height,\n                        'width': this.viewport.width\n                    });\n                    var mainGroup = this.mainGroupElement;\n                    mainGroup.attr('transform', visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));\n                    var width = this.viewport.width - this.margin.left - this.margin.right;\n                    var height = this.viewport.height - this.margin.top - this.margin.bottom;\n                    this.angle = RadarChart.Radians / categories.length;\n                    this.radius = RadarChart.SegmentFactor * RadarChart.Scale * Math.min(width, height) / 2;\n                    this.drawCircularSegments(categories);\n                    this.drawAxes(categories);\n                    this.drawAxesLabels(categories, dataViewMetadataColumn);\n                    this.drawChart(series, duration);\n                    this.drawDataLabels(series);\n                };\n                RadarChart.prototype.getRadarChartLabelLayout = function (labelSettings, allDataPoints) {\n                    var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();\n                    var angle = this.angle;\n                    var radius = this.radius;\n                    var dataPoints = this.getDataPoints(this.radarChartData.series);\n                    var stack = d3.layout.stack();\n                    var layers = stack(dataPoints);\n                    var viewport = this.viewport;\n                    var halfHeight = this.viewport.height / 2;\n                    var halfWidth = this.viewport.width / 2;\n                    var y = d3.scale.linear()\n                        .domain([0, d3.max(layers, function (layer) {\n                            return d3.max(layer, function (d) {\n                                return d.y0 + d.y;\n                            });\n                        })]).range([0, radius]);\n                    return {\n                        labelText: function (d) {\n                            var formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings);\n                            if (labelSettings.displayUnits === 0) {\n                                var maxDataPoint = _.max(allDataPoints, function (d) { return d.value; });\n                                var maxValue = maxDataPoint.value > 0 ? maxDataPoint.value : 0;\n                                formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings, maxValue);\n                            }\n                            return visuals.dataLabelUtils.getLabelFormattedText({ label: formmater.format(d.value), maxWidth: viewport.width, fontSize: labelSettings.fontSize });\n                        },\n                        labelLayout: {\n                            x: function (d) { return -1 * y(d.y) * Math.sin(d.x * angle) + halfWidth; },\n                            y: function (d) { return -1 * y(d.y) * Math.cos(d.x * angle) + halfHeight - 10; },\n                        },\n                        filter: function (d) {\n                            return (d != null && d.value != null);\n                        },\n                        style: {\n                            'fill': labelSettings.labelColor,\n                            'font-size': function (d) { return PixelConverter.fromPoint(labelSettings.fontSize); },\n                        },\n                    };\n                };\n                RadarChart.prototype.drawCircularSegments = function (values) {\n                    var data = [];\n                    var angle = this.angle, factor = RadarChart.SegmentFactor, levels = RadarChart.SegmentLevels, radius = this.radius;\n                    for (var level = 0; level < levels - 1; level++) {\n                        var levelFactor = radius * ((level + 1) / levels);\n                        var transform = -1 * levelFactor;\n                        for (var i = 0; i < values.length; i++)\n                            data.push({\n                                x1: levelFactor * (1 - factor * Math.sin(i * angle)),\n                                y1: levelFactor * (1 - factor * Math.cos(i * angle)),\n                                x2: levelFactor * (1 - factor * Math.sin((i + 1) * angle)),\n                                y2: levelFactor * (1 - factor * Math.cos((i + 1) * angle)),\n                                translate: visuals.SVGUtil.translate(transform, transform)\n                            });\n                    }\n                    var selection = this.mainGroupElement\n                        .select(RadarChart.Segments.selector)\n                        .selectAll(RadarChart.SegmentNode.selector)\n                        .data(data);\n                    selection\n                        .enter()\n                        .append('svg:line')\n                        .classed(RadarChart.SegmentNode.class, true);\n                    selection\n                        .attr({\n                        'x1': function (item) { return item.x1; },\n                        'y1': function (item) { return item.y1; },\n                        'x2': function (item) { return item.x2; },\n                        'y2': function (item) { return item.y2; },\n                        'transform': function (item) { return item.translate; }\n                    });\n                    selection.exit().remove();\n                };\n                RadarChart.prototype.drawDataLabels = function (series) {\n                    var allDataPoints = this.getAllDataPointsList(series);\n                    if (this.radarChartData.dataLabelsSettings.show) {\n                        var layout = this.getRadarChartLabelLayout(this.radarChartData.dataLabelsSettings, allDataPoints);\n                        var viewport = this.viewport;\n                        var labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(allDataPoints, this.mainGroupElement, layout, viewport);\n                        if (labels)\n                            labels.attr('transform', visuals.SVGUtil.translate(-(viewport.width / 2), -(viewport.height / 2)));\n                    }\n                    else\n                        visuals.dataLabelUtils.cleanDataLabels(this.mainGroupElement);\n                };\n                RadarChart.prototype.drawAxes = function (values) {\n                    var angle = this.angle, radius = -1 * this.radius;\n                    var selection = this.mainGroupElement\n                        .select(RadarChart.Axis.selector)\n                        .selectAll(RadarChart.AxisNode.selector);\n                    var axis = selection.data(values);\n                    axis\n                        .enter()\n                        .append('svg:line');\n                    axis\n                        .attr({\n                        'x1': 0,\n                        'y1': 0,\n                        'x2': function (name, i) { return radius * Math.sin(i * angle); },\n                        'y2': function (name, i) { return radius * Math.cos(i * angle); }\n                    })\n                        .classed(RadarChart.AxisNode.class, true);\n                    axis.exit().remove();\n                };\n                RadarChart.prototype.drawAxesLabels = function (values, dataViewMetadataColumn) {\n                    var angle = this.angle, radius = -1 * this.radius, length = values.length;\n                    var formatter = visuals.valueFormatter.create({\n                        format: visuals.valueFormatter.getFormatString(dataViewMetadataColumn, RadarChart.formatStringProp, true),\n                        value: values[0],\n                        value2: values[length - 1],\n                    });\n                    var selection = this.mainGroupElement\n                        .select(RadarChart.Axis.selector)\n                        .selectAll(RadarChart.AxisLabel.selector);\n                    var labels = selection.data(values);\n                    labels\n                        .enter()\n                        .append('svg:text');\n                    labels\n                        .attr({\n                        'text-anchor': 'middle',\n                        'dy': '1.5em',\n                        'transform': visuals.SVGUtil.translate(0, -10),\n                        'x': function (name, i) { return (radius - 20) * Math.sin(i * angle); },\n                        'y': function (name, i) { return (radius - 10) * Math.cos(i * angle); }\n                    })\n                        .text(function (item) { return formatter.format(item); })\n                        .classed(RadarChart.AxisLabel.class, true);\n                    labels.exit().remove();\n                };\n                RadarChart.prototype.drawChart = function (series, duration) {\n                    var angle = this.angle, radius = this.radius, dotRadius = 5, dataPoints = this.getDataPoints(series);\n                    var stack = d3.layout.stack();\n                    var layers = stack(dataPoints);\n                    var y = d3.scale.linear()\n                        .domain([0, d3.max(layers, function (layer) {\n                            return d3.max(layer, function (d) {\n                                return d.y0 + d.y;\n                            });\n                        })]).range([0, radius]);\n                    var calculatePoints = function (points) {\n                        return points.map(function (value) {\n                            var x1 = -1 * y(value.y) * Math.sin(value.x * angle);\n                            var y1 = -1 * y(value.y) * Math.cos(value.x * angle);\n                            return x1 + \",\" + y1;\n                        }).join(' ');\n                    };\n                    var selection = this.chart.selectAll(RadarChart.ChartNode.selector).data(layers);\n                    selection\n                        .enter()\n                        .append('g')\n                        .classed(RadarChart.ChartNode.class, true);\n                    var polygon = selection.selectAll(RadarChart.ChartPolygon.selector).data(function (d) {\n                        if (d && d.length > 0) {\n                            return [d];\n                        }\n                        return [];\n                    });\n                    polygon\n                        .enter()\n                        .append('polygon')\n                        .classed(RadarChart.ChartPolygon.class, true);\n                    polygon\n                        .style('fill', function (d) { return d[0].color; })\n                        .style('opacity', RadarChart.DimmedAreaFillOpacity)\n                        .on('mouseover', function (d) {\n                        d3.select(this).transition()\n                            .duration(duration)\n                            .style('opacity', RadarChart.AreaFillOpacity);\n                    })\n                        .on('mouseout', function (d) {\n                        d3.select(this).transition()\n                            .duration(duration)\n                            .style('opacity', RadarChart.DimmedAreaFillOpacity);\n                    })\n                        .attr('points', calculatePoints);\n                    polygon.exit().remove();\n                    var dots = selection.selectAll(RadarChart.ChartDot.selector)\n                        .data(function (d) { return d.filter(function (d) { return d.y != null; }); });\n                    dots.enter()\n                        .append('svg:circle')\n                        .classed(RadarChart.ChartDot.class, true);\n                    dots.attr('r', dotRadius)\n                        .attr({\n                        'cx': function (value) { return -1 * y(value.y) * Math.sin(value.x * angle); },\n                        'cy': function (value) { return -1 * y(value.y) * Math.cos(value.x * angle); }\n                    })\n                        .style('fill', function (d) { return d.color; });\n                    dots.exit().remove();\n                    visuals.TooltipManager.addTooltip(dots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);\n                    selection.exit().remove();\n                    var behaviorOptions = undefined;\n                    if (this.interactivityService) {\n                        // Register interactivity\n                        var dataPointsToBind = this.getAllDataPointsList(series);\n                        behaviorOptions = { selection: dots, clearCatcher: this.svg };\n                        this.interactivityService.bind(dataPointsToBind, new RadarChartWebBehavior(), behaviorOptions);\n                    }\n                };\n                RadarChart.prototype.renderLegend = function (radarChartData) {\n                    if (!radarChartData.legendData)\n                        return;\n                    var legendData = radarChartData.legendData;\n                    if (this.legendObjectProperties) {\n                        visuals.LegendData.update(legendData, this.legendObjectProperties);\n                        var position = this.legendObjectProperties[visuals.legendProps.position];\n                        if (position)\n                            this.legend.changeOrientation(visuals.LegendPosition[position]);\n                    }\n                    else\n                        this.legend.changeOrientation(visuals.LegendPosition.Top);\n                    var viewport = this.viewport;\n                    this.legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });\n                    visuals.Legend.positionChartArea(this.svg, this.legend);\n                };\n                RadarChart.prototype.getDataPoints = function (series) {\n                    var dataPoints = [];\n                    for (var _i = 0, series_3 = series; _i < series_3.length; _i++) {\n                        var serie = series_3[_i];\n                        dataPoints.push(serie.data);\n                    }\n                    return dataPoints;\n                };\n                RadarChart.prototype.getAllDataPointsList = function (series) {\n                    var dataPoints = [];\n                    for (var _i = 0, series_4 = series; _i < series_4.length; _i++) {\n                        var serie = series_4[_i];\n                        dataPoints = dataPoints.concat(serie.data);\n                    }\n                    return dataPoints;\n                };\n                RadarChart.prototype.parseLegendProperties = function (dataView) {\n                    if (!dataView || !dataView.metadata) {\n                        this.legendObjectProperties = {};\n                        return;\n                    }\n                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, \"legend\", {});\n                };\n                RadarChart.parseSettings = function (dataView) {\n                    var objects;\n                    if (!dataView || !dataView.metadata || !dataView.metadata.columns || !dataView.metadata.objects)\n                        objects = null;\n                    else\n                        objects = dataView.metadata.objects;\n                    return {\n                        showLegend: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.legend.show, true)\n                    };\n                };\n                RadarChart.parseLabelSettings = function (dataView) {\n                    var objects;\n                    if (!dataView || !dataView.metadata || !dataView.metadata.objects)\n                        objects = null;\n                    else\n                        objects = dataView.metadata.objects;\n                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();\n                    var labelsObj = {\n                        show: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.show, dataLabelsSettings.show),\n                        labelColor: powerbi.DataViewObjects.getFillColor(objects, RadarChart.Properties.labels.color, dataLabelsSettings.labelColor),\n                        displayUnits: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.displayUnits, dataLabelsSettings.displayUnits),\n                        precision: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.precision, dataLabelsSettings.precision),\n                        fontSize: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.fontSize, dataLabelsSettings.fontSize),\n                        position: dataLabelsSettings.position\n                    };\n                    return labelsObj;\n                };\n                // This function returns the values to be displayed in the property pane for each object.\n                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do\n                // validation and return other values/defaults\n                RadarChart.prototype.enumerateObjectInstances = function (options) {\n                    var enumeration = new visuals.ObjectEnumerationBuilder();\n                    var settings;\n                    if (!this.radarChartData || !this.radarChartData.settings)\n                        return [];\n                    settings = this.radarChartData.settings;\n                    switch (options.objectName) {\n                        case \"legend\":\n                            enumeration.pushInstance(this.enumerateLegend(settings));\n                            break;\n                        case \"dataPoint\":\n                            this.enumerateDataPoint(enumeration);\n                            break;\n                        case 'labels':\n                            this.enumerateDataLabels(enumeration);\n                            break;\n                    }\n                    return enumeration.complete();\n                };\n                RadarChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings) {\n                    return {\n                        enumeration: enumeration,\n                        dataLabelsSettings: labelSettings,\n                        show: true,\n                        displayUnits: true,\n                        precision: true,\n                        fontSize: true,\n                    };\n                };\n                RadarChart.prototype.enumerateDataLabels = function (enumeration) {\n                    var labelSettings = this.radarChartData.dataLabelsSettings;\n                    //Draw default settings\n                    visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings));\n                };\n                RadarChart.prototype.enumerateLegend = function (settings) {\n                    var showTitle = true, titleText = \"\", legend, labelColor, fontSize = 8;\n                    showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle);\n                    titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText);\n                    labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, labelColor);\n                    fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, fontSize);\n                    legend = {\n                        objectName: \"legend\",\n                        displayName: \"legend\",\n                        selector: null,\n                        properties: {\n                            show: settings.showLegend,\n                            position: visuals.LegendPosition[this.legend.getOrientation()],\n                            showTitle: showTitle,\n                            titleText: titleText,\n                            labelColor: labelColor,\n                            fontSize: fontSize,\n                        }\n                    };\n                    return legend;\n                };\n                RadarChart.prototype.enumerateDataPoint = function (enumeration) {\n                    if (!this.radarChartData || !this.radarChartData.series)\n                        return;\n                    var series = this.radarChartData.series;\n                    for (var _i = 0, series_5 = series; _i < series_5.length; _i++) {\n                        var serie = series_5[_i];\n                        enumeration.pushInstance({\n                            objectName: \"dataPoint\",\n                            displayName: serie.name,\n                            selector: visuals.ColorHelper.normalizeSelector(serie.identity.getSelector(), false),\n                            properties: {\n                                fill: { solid: { color: serie.fill } }\n                            }\n                        });\n                    }\n                };\n                RadarChart.prototype.updateViewport = function () {\n                    var legendMargins = this.legend.getMargins(), legendPosition;\n                    legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];\n                    switch (legendPosition) {\n                        case visuals.LegendPosition.Top:\n                        case visuals.LegendPosition.TopCenter:\n                        case visuals.LegendPosition.Bottom:\n                        case visuals.LegendPosition.BottomCenter:\n                            this.viewport.height -= legendMargins.height;\n                            break;\n                        case visuals.LegendPosition.Left:\n                        case visuals.LegendPosition.LeftCenter:\n                        case visuals.LegendPosition.Right:\n                        case visuals.LegendPosition.RightCenter:\n                            this.viewport.width -= legendMargins.width;\n                            break;\n                    }\n                };\n                RadarChart.capabilities = {\n                    dataRoles: [\n                        {\n                            displayName: 'Category',\n                            name: 'Category',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                        },\n                        {\n                            displayName: 'Y Axis',\n                            name: 'Y',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                        },\n                    ],\n                    dataViewMappings: [{\n                            conditions: [{ 'Category': { min: 1, max: 1 } }],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Category' },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: {\n                                    select: [{ bind: { to: 'Y' } }]\n                                }\n                            }\n                        }],\n                    objects: {\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),\n                            properties: {\n                                formatString: {\n                                    type: { formatting: { formatString: true } },\n                                },\n                            },\n                        },\n                        legend: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),\n                            description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),\n                                    type: { enumeration: visuals.legendPosition.type }\n                                },\n                                showTitle: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),\n                                    type: { bool: true }\n                                },\n                                titleText: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),\n                                    type: { text: true },\n                                    suppressFormatPainterCopy: true\n                                },\n                                labelColor: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { formatting: { fontSize: true } }\n                                }\n                            }\n                        },\n                        dataPoint: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),\n                            description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),\n                            properties: {\n                                fill: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        labels: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),\n                            description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),\n                            properties: {\n                                show: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),\n                                    type: { bool: true }\n                                },\n                                color: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                labelDisplayUnits: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),\n                                    type: { formatting: { labelDisplayUnits: true } },\n                                    suppressFormatPainterCopy: true,\n                                },\n                                labelPrecision: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),\n                                    description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),\n                                    placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),\n                                    type: { numeric: true },\n                                    suppressFormatPainterCopy: true,\n                                },\n                                fontSize: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),\n                                    type: { formatting: { fontSize: true } }\n                                },\n                            }\n                        }\n                    }\n                };\n                /** Note: Public for testability */\n                RadarChart.formatStringProp = {\n                    objectName: 'general',\n                    propertyName: 'formatString',\n                };\n                RadarChart.Properties = {\n                    legend: {\n                        show: { objectName: 'legend', propertyName: 'show' }\n                    },\n                    dataPoint: {\n                        fill: { objectName: 'dataPoint', propertyName: 'fill' }\n                    },\n                    labels: {\n                        show: { objectName: 'labels', propertyName: 'show' },\n                        color: { objectName: 'labels', propertyName: 'color' },\n                        displayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },\n                        precision: { objectName: 'labels', propertyName: 'labelPrecision' },\n                        fontSize: { objectName: 'labels', propertyName: 'fontSize' },\n                    }\n                };\n                RadarChart.VisualClassName = 'radarChart';\n                RadarChart.Segments = CreateClassAndSelector('segments');\n                RadarChart.SegmentNode = CreateClassAndSelector('segmentNode');\n                RadarChart.Axis = CreateClassAndSelector('axis');\n                RadarChart.AxisNode = CreateClassAndSelector('axisNode');\n                RadarChart.AxisLabel = CreateClassAndSelector('axisLabel');\n                RadarChart.Chart = CreateClassAndSelector('chart');\n                RadarChart.ChartNode = CreateClassAndSelector('chartNode');\n                RadarChart.ChartPolygon = CreateClassAndSelector('chartPolygon');\n                RadarChart.ChartDot = CreateClassAndSelector('chartDot');\n                RadarChart.DefaultMargin = {\n                    top: 50,\n                    bottom: 50,\n                    right: 100,\n                    left: 100\n                };\n                RadarChart.SegmentLevels = 6;\n                RadarChart.SegmentFactor = 1;\n                RadarChart.Radians = 2 * Math.PI;\n                RadarChart.Scale = 1;\n                RadarChart.AreaFillOpacity = 1;\n                RadarChart.DimmedAreaFillOpacity = 0.4;\n                return RadarChart;\n            }());\n            samples.RadarChart = RadarChart;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var SelectionManager = visuals.utility.SelectionManager;\n            var ValueFormatter = powerbi.visuals.valueFormatter;\n            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;\n            var HistogramChartWarning = (function () {\n                function HistogramChartWarning(message) {\n                    this.message = message;\n                }\n                Object.defineProperty(HistogramChartWarning.prototype, \"code\", {\n                    get: function () {\n                        return \"BulletChartWarning\";\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                HistogramChartWarning.prototype.getMessages = function (resourceProvider) {\n                    return {\n                        message: this.message,\n                        title: resourceProvider.get(\"\"),\n                        detail: resourceProvider.get(\"\")\n                    };\n                };\n                HistogramChartWarning.ErrorInvalidDataValues = \"Some data values are invalid or too big\";\n                return HistogramChartWarning;\n            }());\n            samples.HistogramChartWarning = HistogramChartWarning;\n            var Histogram = (function () {\n                function Histogram(histogramConstructorOptions) {\n                    this.ColumnPadding = 1;\n                    this.MinColumnHeight = 1;\n                    this.MinOpacity = 0.3;\n                    this.MaxOpacity = 1;\n                    this.NumberOfLabelsOnAxisY = 5;\n                    this.MinNumberOfBins = 0;\n                    this.MaxNumberOfBins = 100;\n                    this.MinPrecision = 0;\n                    this.MaxPrecision = 17; // max number of decimals in float\n                    this.TooltipDisplayName = \"Range\";\n                    this.SeparatorNumbers = \", \";\n                    this.LegendSize = 50;\n                    this.AxisSize = 30;\n                    this.ExcludeBrackets = {\n                        left: \"(\",\n                        right: \")\"\n                    };\n                    this.IncludeBrackets = {\n                        left: \"[\",\n                        right: \"]\"\n                    };\n                    this.margin = {\n                        top: 10,\n                        right: 10,\n                        bottom: 10,\n                        left: 10\n                    };\n                    this.durationAnimations = 200;\n                    if (histogramConstructorOptions) {\n                        if (histogramConstructorOptions.svg) {\n                            this.svg = histogramConstructorOptions.svg;\n                        }\n                        if (histogramConstructorOptions.animator) {\n                            this.animator = histogramConstructorOptions.animator;\n                        }\n                        this.margin = histogramConstructorOptions.margin || this.margin;\n                    }\n                }\n                Object.defineProperty(Histogram.prototype, \"columnsSelection\", {\n                    get: function () {\n                        return this.main.select(Histogram.Columns.selector)\n                            .selectAll(Histogram.Column.selector);\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Histogram.prototype.init = function (visualsOptions) {\n                    this.hostService = visualsOptions.host;\n                    if (this.svg) {\n                        this.root = this.svg;\n                    }\n                    else {\n                        this.root = d3.select(visualsOptions.element.get(0))\n                            .append(\"svg\");\n                    }\n                    var style = visualsOptions.style;\n                    this.colors = style && style.colorPalette\n                        ? style.colorPalette.dataColors\n                        : new visuals.DataColorPalette();\n                    this.root.classed(Histogram.ClassName, true);\n                    this.main = this.root.append(\"g\");\n                    this.axes = this.main\n                        .append(\"g\")\n                        .classed(Histogram.Axes[\"class\"], true);\n                    this.axisX = this.axes\n                        .append(\"g\")\n                        .classed(Histogram.Axis[\"class\"], true);\n                    this.axisY = this.axes\n                        .append(\"g\")\n                        .classed(Histogram.Axis[\"class\"], true);\n                    this.legend = this.main\n                        .append(\"g\")\n                        .classed(Histogram.Legends[\"class\"], true);\n                    this.columns = this.main\n                        .append(\"g\")\n                        .classed(Histogram.Columns[\"class\"], true);\n                    this.selectionManager = new SelectionManager({ hostServices: visualsOptions.host });\n                };\n                Histogram.prototype.converter = function (dataView) {\n                    var _this = this;\n                    if (!dataView ||\n                        !dataView.categorical ||\n                        !dataView.categorical.categories ||\n                        !dataView.categorical.categories[0] ||\n                        !dataView.categorical.categories[0].values ||\n                        !(dataView.categorical.categories[0].values.length > 0)) {\n                        return null;\n                    }\n                    var settings, histogramLayout, values, numericalValues = [], data, xScale, yScale, valueFormatter, frequencies = [], identities = [], shiftByValues = 0, sumFrequency = 0;\n                    if (dataView.categorical.values &&\n                        dataView.categorical.values[0] &&\n                        dataView.categorical.values[0].values) {\n                        frequencies = dataView.categorical.values[0].values;\n                    }\n                    if (dataView.categorical.categories[0].identity\n                        && dataView.categorical.categories[0].identity.length > 0) {\n                        identities = dataView.categorical.categories[0].identity;\n                    }\n                    settings = this.parseSettings(dataView);\n                    if (!settings) {\n                        return null;\n                    }\n                    values = this.getValuesByFrequencies(dataView.categorical.categories[0].values, frequencies, identities);\n                    values.forEach(function (value) {\n                        numericalValues.push(value.value);\n                        sumFrequency += value.frequency;\n                    });\n                    histogramLayout = d3.layout.histogram();\n                    if (settings.bins && settings.bins > this.MinNumberOfBins) {\n                        histogramLayout = histogramLayout.bins(settings.bins);\n                    }\n                    data = histogramLayout.frequency(settings.frequency)(numericalValues);\n                    data.forEach(function (bin, index) {\n                        var filteredValues, frequency;\n                        filteredValues = values.filter(function (value) {\n                            return _this.isValueContainedInRange(value, bin, index);\n                        });\n                        frequency = filteredValues.reduce(function (previousValue, currentValue) {\n                            return previousValue + currentValue.frequency;\n                        }, 0);\n                        bin.y = settings.frequency\n                            ? frequency\n                            : frequency / sumFrequency;\n                        shiftByValues += bin.length;\n                    });\n                    xScale = d3.scale.linear()\n                        .domain([\n                        d3.min(data, function (item) { return d3.min(item); }),\n                        d3.max(data, function (item) { return d3.max(item); })\n                    ])\n                        .range([0, this.viewport.width - this.LegendSize - this.AxisSize]);\n                    yScale = d3.scale.linear()\n                        .domain([\n                        0,\n                        d3.max(data, function (item) { return item.y; })\n                    ])\n                        .range([this.viewport.height - this.LegendSize, 0]);\n                    valueFormatter = ValueFormatter.create({\n                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, Histogram.Properties[\"general\"][\"formatString\"]),\n                        value: values[0].value,\n                        value2: values[values.length - 1].value,\n                        precision: settings.precision\n                    });\n                    return {\n                        xScale: xScale,\n                        yScale: yScale,\n                        settings: settings,\n                        data: this.getData(values, numericalValues, data, settings, valueFormatter),\n                        formatter: valueFormatter\n                    };\n                };\n                Histogram.prototype.getValuesByFrequencies = function (sourceValues, frequencies, identities) {\n                    var values = [];\n                    sourceValues.forEach(function (item, index) {\n                        var frequency = 1, value = Number(item);\n                        value = isNaN(value) ? 0 : value;\n                        if (frequencies\n                            && frequencies[index]\n                            && !isNaN(frequencies[index])\n                            && frequencies[index] > 1) {\n                            frequency = frequencies[index];\n                        }\n                        values.push({\n                            value: value,\n                            frequency: frequency,\n                            selectionId: visuals.SelectionId.createWithId(identities[index])\n                        });\n                    });\n                    return values;\n                };\n                Histogram.prototype.getData = function (values, numericalValues, data, settings, valueFormatter) {\n                    var _this = this;\n                    var minValue = d3.min(numericalValues), maxValue = d3.max(numericalValues);\n                    return data.map(function (bin, index) {\n                        bin.range = _this.getRange(minValue, maxValue, bin.dx, index);\n                        bin.tooltipInfo = _this.getTooltipData(bin.y, bin.range, settings, index === 0, valueFormatter);\n                        bin.selectionIds = _this.getSelectionIds(values, bin, index);\n                        return bin;\n                    });\n                };\n                Histogram.prototype.getRange = function (minValue, maxValue, step, index) {\n                    var leftBorder = minValue + index * step, rightBorder = leftBorder + step;\n                    return [leftBorder, rightBorder];\n                };\n                Histogram.prototype.getTooltipData = function (value, range, settings, includeLeftBorder, valueFormatter) {\n                    return [{\n                            displayName: this.getLegendText(settings),\n                            value: valueFormatter.format(value)\n                        }, {\n                            displayName: this.TooltipDisplayName,\n                            value: this.rangeToString(range, includeLeftBorder, valueFormatter)\n                        }];\n                };\n                Histogram.prototype.getSelectionIds = function (values, bin, index) {\n                    var _this = this;\n                    var selectionIds = [];\n                    values.forEach(function (value) {\n                        if (_this.isValueContainedInRange(value, bin, index)) {\n                            selectionIds.push(value.selectionId);\n                        }\n                    });\n                    return selectionIds;\n                };\n                Histogram.prototype.isValueContainedInRange = function (value, bin, index) {\n                    return ((index === 0 && value.value >= bin.x) || (value.value > bin.x)) && value.value <= bin.x + bin.dx;\n                };\n                Histogram.prototype.parseSettings = function (dataView) {\n                    if (!dataView ||\n                        !dataView.metadata ||\n                        !dataView.metadata.columns ||\n                        !dataView.metadata.columns[0]) {\n                        return null;\n                    }\n                    var histogramSettings = {}, objects, colorHelper;\n                    colorHelper = new visuals.ColorHelper(this.colors, Histogram.Properties[\"dataPoint\"][\"fill\"], Histogram.DefaultHistogramSettings.fillColor);\n                    histogramSettings.displayName = Histogram.DefaultHistogramSettings.displayName;\n                    histogramSettings.fillColor = Histogram.DefaultHistogramSettings.fillColor;\n                    histogramSettings.bins = Histogram.DefaultHistogramSettings.bins;\n                    histogramSettings.frequency = Histogram.DefaultHistogramSettings.frequency;\n                    histogramSettings.displayName =\n                        dataView.metadata.columns[0].displayName || Histogram.DefaultHistogramSettings.displayName;\n                    objects = this.getObjectsFromDataView(dataView);\n                    if (objects) {\n                        histogramSettings.fillColor = colorHelper.getColorForMeasure(objects, \"\");\n                        histogramSettings.bins = this.getBins(objects);\n                        histogramSettings.frequency = this.getFrequency(objects);\n                        histogramSettings.precision = this.getPrecision(objects);\n                    }\n                    return histogramSettings;\n                };\n                Histogram.prototype.getBins = function (objects) {\n                    var binsNumber;\n                    binsNumber = Number(powerbi.DataViewObjects.getValue(objects, Histogram.Properties[\"general\"][\"bins\"], Histogram.DefaultHistogramSettings.bins));\n                    if (!binsNumber || isNaN(binsNumber) || binsNumber <= this.MinNumberOfBins) {\n                        return Histogram.DefaultHistogramSettings.bins;\n                    }\n                    if (binsNumber > this.MaxNumberOfBins) {\n                        return this.MaxNumberOfBins;\n                    }\n                    return binsNumber;\n                };\n                Histogram.prototype.getFrequency = function (objects) {\n                    return powerbi.DataViewObjects.getValue(objects, Histogram.Properties[\"general\"][\"frequency\"], Histogram.DefaultHistogramSettings.frequency);\n                };\n                Histogram.prototype.getPrecision = function (objects) {\n                    var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties[\"labels\"][\"labelPrecision\"], Histogram.DefaultHistogramSettings.precision);\n                    if (precision <= this.MinPrecision) {\n                        return this.MinPrecision;\n                    }\n                    if (precision >= this.MaxPrecision) {\n                        return this.MaxPrecision;\n                    }\n                    return precision;\n                };\n                Histogram.prototype.validateData = function (data) {\n                    if (data && data.data.some(function (x) { return x.range.some(function (x) { return isNaN(x) || x === Infinity || x === -Infinity; }); })) {\n                        this.hostService.setWarnings([new HistogramChartWarning(HistogramChartWarning.ErrorInvalidDataValues)]);\n                        return false;\n                    }\n                    return true;\n                };\n                Histogram.prototype.update = function (visualUpdateOptions) {\n                    if (!visualUpdateOptions ||\n                        !visualUpdateOptions.dataViews ||\n                        !visualUpdateOptions.dataViews[0]) {\n                        return;\n                    }\n                    var dataView = visualUpdateOptions.dataViews[0];\n                    this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);\n                    this.setSize(visualUpdateOptions.viewport);\n                    this.histogramDataView = this.converter(dataView);\n                    if (!this.validateData(this.histogramDataView)) {\n                        this.histogramDataView.data = [];\n                    }\n                    this.render();\n                };\n                Histogram.prototype.setSize = function (viewport) {\n                    var height, width;\n                    height = viewport.height -\n                        this.margin.top -\n                        this.margin.bottom;\n                    width = viewport.width -\n                        this.margin.left -\n                        this.margin.right;\n                    this.viewport = {\n                        height: height,\n                        width: width\n                    };\n                    this.updateElements(viewport.height, viewport.width);\n                };\n                Histogram.prototype.updateElements = function (height, width) {\n                    var shiftToRight = this.margin.left + this.LegendSize;\n                    this.root.attr({\n                        \"height\": height,\n                        \"width\": width\n                    });\n                    this.main.attr(\"transform\", visuals.SVGUtil.translate(this.margin.left, this.margin.top));\n                    this.legend.attr(\"transform\", visuals.SVGUtil.translate(this.margin.left, this.margin.top));\n                    this.columns.attr(\"transform\", visuals.SVGUtil.translate(shiftToRight, 0));\n                    this.axes.attr(\"transform\", visuals.SVGUtil.translate(shiftToRight, 0));\n                    this.axisX.attr(\"transform\", visuals.SVGUtil.translate(0, this.viewport.height - this.LegendSize));\n                };\n                Histogram.prototype.render = function () {\n                    if (!this.histogramDataView || !this.histogramDataView.settings) {\n                        return;\n                    }\n                    this.renderAxes();\n                    var columnsSelection = this.renderColumns();\n                    this.renderLegend();\n                    this.bindSelectionHandler(columnsSelection);\n                };\n                Histogram.prototype.renderColumns = function () {\n                    var _this = this;\n                    var data = this.histogramDataView.data, yScale = this.histogramDataView.yScale, countOfValues = data.length, widthOfColumn, updateColumnsSelection;\n                    widthOfColumn = countOfValues && ((this.viewport.width - this.AxisSize - this.LegendSize) / countOfValues - this.ColumnPadding);\n                    if (widthOfColumn < 0) {\n                        widthOfColumn = 0;\n                    }\n                    updateColumnsSelection = this.columnsSelection.data(data);\n                    updateColumnsSelection\n                        .enter()\n                        .append(\"svg:rect\");\n                    updateColumnsSelection\n                        .attr(\"x\", this.ColumnPadding / 2)\n                        .attr(\"width\", widthOfColumn)\n                        .attr(\"height\", function (item) { return _this.getColumnHeight(item, yScale); })\n                        .style(\"fill\", this.histogramDataView.settings.fillColor)\n                        .attr(\"class\", Histogram.Column[\"class\"])\n                        .attr(\"transform\", function (item, index) { return visuals.SVGUtil.translate(widthOfColumn * index + _this.ColumnPadding * index, yScale(item.y) - _this.ColumnPadding / 2.5); });\n                    if (countOfValues) {\n                        //if data is empty, it throws for some reason\n                        updateColumnsSelection.classed(Histogram.Column[\"class\"]);\n                    }\n                    updateColumnsSelection.exit().remove();\n                    this.renderTooltip(updateColumnsSelection);\n                    return updateColumnsSelection;\n                };\n                Histogram.prototype.renderTooltip = function (selection) {\n                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {\n                        return tooltipEvent.data.tooltipInfo;\n                    });\n                };\n                Histogram.prototype.getColumnHeight = function (column, y) {\n                    var height = this.viewport.height - this.LegendSize - y(column.y);\n                    return height > 0 ? height : this.MinColumnHeight;\n                };\n                Histogram.prototype.renderAxes = function () {\n                    var xScale = this.histogramDataView.xScale, yScale = this.histogramDataView.yScale, valueFormatter = this.histogramDataView.formatter, xAxis, yAxis;\n                    xAxis = d3.svg.axis()\n                        .scale(xScale)\n                        .orient(\"bottom\")\n                        .tickValues(this.rangesToArray(this.histogramDataView.data))\n                        .tickFormat(function (item) { return valueFormatter.format(item); });\n                    yAxis = d3.svg.axis()\n                        .scale(yScale)\n                        .orient(\"left\")\n                        .ticks(this.NumberOfLabelsOnAxisY);\n                    this.axisX.call(xAxis);\n                    this.axisY.call(yAxis);\n                };\n                Histogram.prototype.rangesToArray = function (data) {\n                    return data.reduce(function (previousValue, currentValue, index) {\n                        var range;\n                        range = index === 0\n                            ? currentValue.range\n                            : currentValue.range.slice(1);\n                        return previousValue.concat(range);\n                    }, []);\n                };\n                Histogram.prototype.rangeToString = function (range, includeLeftBorder, valueFormatter) {\n                    var leftBracket, rightBracket = this.IncludeBrackets.right, leftBorder = valueFormatter.format(range[0]), rightBorder = valueFormatter.format(range[1]);\n                    leftBracket = includeLeftBorder\n                        ? this.IncludeBrackets.left\n                        : this.ExcludeBrackets.left;\n                    return \"\" + leftBracket + leftBorder + this.SeparatorNumbers + rightBorder + rightBracket;\n                };\n                Histogram.prototype.renderLegend = function () {\n                    var legendElements, legendSelection, datalegends = this.getDataLegends(this.histogramDataView.settings);\n                    legendElements = this.main\n                        .select(Histogram.Legends.selector)\n                        .selectAll(Histogram.Legend.selector);\n                    legendSelection = legendElements.data(datalegends);\n                    legendSelection\n                        .enter()\n                        .append(\"svg:text\");\n                    legendSelection\n                        .attr(\"x\", 0)\n                        .attr(\"y\", 0)\n                        .attr(\"dx\", function (item) { return item.dx; })\n                        .attr(\"dy\", function (item) { return item.dy; })\n                        .attr(\"transform\", function (item) { return item.transform; })\n                        .attr(\"class\", Histogram.Legend[\"class\"])\n                        .text(function (item) { return item.text; })\n                        .classed(Histogram.Legend[\"class\"], true);\n                    legendSelection\n                        .exit()\n                        .remove();\n                };\n                Histogram.prototype.getDataLegends = function (settings) {\n                    var bottomLegendText = this.getLegendText(settings);\n                    return [{\n                            transform: visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height),\n                            text: settings.displayName,\n                            dx: \"1em\",\n                            dy: \"-1em\"\n                        }, {\n                            transform: visuals.SVGUtil.translateAndRotate(0, this.viewport.height / 2, 0, 0, 270),\n                            text: bottomLegendText,\n                            dx: \"3em\"\n                        }];\n                };\n                Histogram.prototype.getLegendText = function (settings) {\n                    return settings.frequency\n                        ? Histogram.FrequencyText\n                        : Histogram.DensityText;\n                };\n                Histogram.prototype.bindSelectionHandler = function (columnsSelection) {\n                    var _this = this;\n                    this.setSelection(columnsSelection);\n                    columnsSelection.on(\"click\", function (data) {\n                        _this.selectionManager.clear();\n                        data.selectionIds.forEach(function (selectionId) {\n                            _this.selectionManager.select(selectionId, true).then(function (selectionIds) {\n                                if (selectionIds.length > 0) {\n                                    _this.setSelection(columnsSelection, data);\n                                }\n                                else {\n                                    _this.setSelection(columnsSelection);\n                                }\n                            });\n                        });\n                        d3.event.stopPropagation();\n                    });\n                    this.root.on(\"click\", function () {\n                        _this.selectionManager.clear();\n                        _this.setSelection(columnsSelection);\n                    });\n                };\n                Histogram.prototype.setSelection = function (columnsSelection, data) {\n                    columnsSelection.transition()\n                        .duration(this.durationAnimations)\n                        .style(\"fill-opacity\", this.MaxOpacity);\n                    if (!data) {\n                        return;\n                    }\n                    columnsSelection\n                        .filter(function (columnSelection) {\n                        return columnSelection !== data;\n                    })\n                        .transition()\n                        .duration(this.durationAnimations)\n                        .style(\"fill-opacity\", this.MinOpacity);\n                };\n                Histogram.prototype.enumerateObjectInstances = function (options) {\n                    var instances = [], settings;\n                    if (!this.histogramDataView ||\n                        !this.histogramDataView.settings) {\n                        return instances;\n                    }\n                    settings = this.histogramDataView.settings;\n                    switch (options.objectName) {\n                        case \"general\": {\n                            var general = {\n                                objectName: \"general\",\n                                displayName: \"general\",\n                                selector: null,\n                                properties: {\n                                    bins: settings.bins,\n                                    frequency: settings.frequency\n                                }\n                            };\n                            instances.push(general);\n                            break;\n                        }\n                        case \"dataPoint\": {\n                            var dataPoint = {\n                                objectName: \"dataPoint\",\n                                displayName: \"dataPoint\",\n                                selector: null,\n                                properties: {\n                                    fill: settings.fillColor\n                                }\n                            };\n                            instances.push(dataPoint);\n                            break;\n                        }\n                        case \"labels\": {\n                            var labels = {\n                                objectName: \"labels\",\n                                displayName: \"labels\",\n                                selector: null,\n                                properties: {\n                                    labelPrecision: settings.precision\n                                }\n                            };\n                            instances.push(labels);\n                            break;\n                        }\n                    }\n                    return instances;\n                };\n                Histogram.prototype.getObjectsFromDataView = function (dataView) {\n                    if (!dataView ||\n                        !dataView.metadata ||\n                        !dataView.metadata.columns ||\n                        !dataView.metadata.objects) {\n                        return null;\n                    }\n                    return dataView.metadata.objects;\n                };\n                Histogram.prototype.destroy = function () {\n                    this.root = null;\n                };\n                Histogram.ClassName = \"histogram\";\n                Histogram.FrequencyText = \"Frequency\";\n                Histogram.DensityText = \"Density\";\n                Histogram.Properties = {\n                    general: {\n                        bins: {\n                            objectName: \"general\",\n                            propertyName: \"bins\"\n                        },\n                        frequency: {\n                            objectName: \"general\",\n                            propertyName: \"frequency\"\n                        },\n                        formatString: {\n                            objectName: \"general\",\n                            propertyName: \"formatString\"\n                        }\n                    },\n                    dataPoint: {\n                        fill: {\n                            objectName: \"dataPoint\",\n                            propertyName: \"fill\"\n                        }\n                    },\n                    labels: {\n                        labelPrecision: {\n                            objectName: \"labels\",\n                            propertyName: \"labelPrecision\"\n                        }\n                    }\n                };\n                Histogram.DefaultHistogramSettings = {\n                    frequency: true,\n                    displayName: \"Histogram\",\n                    bins: null,\n                    fillColor: \"cadetblue\",\n                    precision: 2\n                };\n                Histogram.Axes = {\n                    \"class\": \"axes\",\n                    selector: \".axes\"\n                };\n                Histogram.Axis = {\n                    \"class\": \"axis\",\n                    selector: \".axis\"\n                };\n                Histogram.Columns = {\n                    \"class\": \"columns\",\n                    selector: \".columns\"\n                };\n                Histogram.Column = {\n                    \"class\": \"column\",\n                    selector: \".column\"\n                };\n                Histogram.Legends = {\n                    \"class\": \"legends\",\n                    selector: \".legends\"\n                };\n                Histogram.Legend = {\n                    \"class\": \"legend\",\n                    selector: \".legend\"\n                };\n                Histogram.capabilities = {\n                    dataRoles: [{\n                            name: \"Values\",\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: powerbi.data.createDisplayNameGetter(\"Role_DisplayName_Values\")\n                        }, {\n                            name: \"Frequency\",\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: \"Frequency\"\n                        }],\n                    dataViewMappings: [{\n                            conditions: [{ \"Values\": { min: 1, max: 1 }, \"Frequency\": { min: 0, max: 1 } }],\n                            categorical: {\n                                categories: {\n                                    bind: { to: \"Values\" },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: { for: { in: \"Frequency\" } }\n                            }\n                        }],\n                    sorting: {\n                        implicit: {\n                            clauses: [{ role: \"Values\", direction: 1 /*SortDirection.Ascending*/ }] //Constant SortDirection.Ascending currently is not supported on the msit\n                        }\n                    },\n                    objects: {\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter(\"Visual_General\"),\n                            properties: {\n                                formatString: { type: { formatting: { formatString: true } } },\n                                bins: {\n                                    displayName: \"Bins\",\n                                    type: { numeric: true }\n                                },\n                                frequency: {\n                                    displayName: \"Frequency\",\n                                    type: { bool: true }\n                                }\n                            },\n                        },\n                        dataPoint: {\n                            displayName: powerbi.data.createDisplayNameGetter(\"Visual_DataPoint\"),\n                            properties: {\n                                fill: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        labels: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),\n                            properties: {\n                                labelPrecision: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),\n                                    type: { numeric: true }\n                                }\n                            }\n                        }\n                    }\n                };\n                return Histogram;\n            }());\n            samples.Histogram = Histogram;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var ValueFormatter = powerbi.visuals.valueFormatter;\n            var ColorBarChart = (function () {\n                function ColorBarChart() {\n                    this.NumberOfLabelsOnAxisY = 5;\n                    this.margin = {\n                        top: 10,\n                        right: 10,\n                        bottom: 20,\n                        left: 40\n                    };\n                }\n                ColorBarChart.converter = function (dataView) {\n                    var viewModel = {\n                        values: []\n                    };\n                    var table = dataView.table;\n                    if (!table)\n                        return viewModel;\n                    for (var _i = 0, _a = table.rows; _i < _a.length; _i++) {\n                        var row = _a[_i];\n                        var chartData = {\n                            category: row[0],\n                            value: row[1],\n                            color: row[2]\n                        };\n                        viewModel.values.push(chartData);\n                    }\n                    return viewModel;\n                };\n                ColorBarChart.prototype.init = function (options) {\n                    this.root = d3.select(options.element.get(0))\n                        .append('svg')\n                        .classed('colorBarChart', true);\n                    this.main = this.root.append('g');\n                    this.axes = this.main\n                        .append(\"g\")\n                        .classed(\"axes\", true);\n                    this.axisX = this.axes\n                        .append(\"g\")\n                        .classed(\"axis\", true);\n                    this.axisY = this.axes\n                        .append(\"g\")\n                        .classed(\"axis\", true);\n                };\n                ColorBarChart.prototype.update = function (options) {\n                    if (!options.dataViews && !options.dataViews[0])\n                        return;\n                    var dataView = this.dataView = options.dataViews[0];\n                    var viewModel = ColorBarChart.converter(dataView);\n                    this.valueFormatter = ValueFormatter.create({\n                        value: viewModel.values[0].value,\n                        value2: viewModel.values[viewModel.values.length - 1].value\n                    });\n                    this.viewport = options.viewport;\n                    this.setSize(options.viewport);\n                    this.renderAxes(viewModel);\n                    this.renderColumns(viewModel);\n                };\n                ColorBarChart.prototype.renderAxes = function (viewModel) {\n                    var valueFormatter = this.valueFormatter;\n                    this.xScale = d3.scale.ordinal()\n                        .domain(viewModel.values.map(function (v) { return v.category; }))\n                        .rangeRoundBands([0, this.viewport.width], .1);\n                    this.yScale = d3.scale.linear()\n                        .domain([0, d3.max(viewModel.values.map(function (v) { return v.value; }))])\n                        .range([this.viewport.height, 0]);\n                    this.xAxis = d3.svg.axis()\n                        .scale(this.xScale)\n                        .orient(\"bottom\")\n                        .tickValues(viewModel.values.map(function (v) { return v.category; }));\n                    this.yAxis = d3.svg.axis()\n                        .scale(this.yScale)\n                        .orient(\"left\")\n                        .tickFormat(function (item) { return valueFormatter.format(item); })\n                        .ticks(this.NumberOfLabelsOnAxisY);\n                    this.axisX.call(this.xAxis);\n                    this.axisY.call(this.yAxis);\n                };\n                ColorBarChart.prototype.renderColumns = function (viewModel) {\n                    var _this = this;\n                    var self = this;\n                    this.columns = this.main.append('g').selectAll('.column')\n                        .data(viewModel.values)\n                        .enter().append('svg:rect')\n                        .attr('class', 'column')\n                        .attr('fill', function (item) { return item.color; })\n                        .attr('x', function (item) { return _this.xScale(item.category); })\n                        .attr('y', function (item) { return _this.yScale(item.value); })\n                        .attr('width', this.xScale.rangeBand())\n                        .attr('height', function (item) { return self.viewport.height - _this.yScale(item.value); });\n                };\n                ColorBarChart.prototype.setSize = function (viewport) {\n                    var height, width;\n                    height = viewport.height -\n                        this.margin.top -\n                        this.margin.bottom;\n                    width = viewport.width -\n                        this.margin.left -\n                        this.margin.right;\n                    this.viewport = {\n                        height: height,\n                        width: width\n                    };\n                    this.updateElements(viewport.height, viewport.width);\n                };\n                ColorBarChart.prototype.updateElements = function (height, width) {\n                    var shiftToRight = 0;\n                    this.root.attr({\n                        \"height\": height,\n                        \"width\": width\n                    });\n                    this.main.attr(\"transform\", visuals.SVGUtil.translate(this.margin.left, this.margin.top));\n                    this.axes.attr(\"transform\", visuals.SVGUtil.translate(shiftToRight, 0));\n                    this.axisX.attr(\"transform\", visuals.SVGUtil.translate(0, this.viewport.height));\n                };\n                ColorBarChart.getFill = function (dataView) {\n                    if (dataView) {\n                        var objects = dataView.metadata.objects;\n                        if (objects) {\n                            var general = objects['general'];\n                            if (general) {\n                                var fill = general['fill'];\n                                if (fill)\n                                    return fill;\n                            }\n                        }\n                    }\n                    return { solid: { color: 'red' } };\n                };\n                ColorBarChart.getSize = function (dataView) {\n                    if (dataView) {\n                        var objects = dataView.metadata.objects;\n                        if (objects) {\n                            var general = objects['general'];\n                            if (general) {\n                                var size = general['size'];\n                                if (size)\n                                    return size;\n                            }\n                        }\n                    }\n                    return 100;\n                };\n                ColorBarChart.prototype.enumerateObjectInstances = function (options) {\n                    var instances = [];\n                    var dataView = this.dataView;\n                    switch (options.objectName) {\n                        case 'general':\n                            var general = {\n                                objectName: 'general',\n                                displayName: 'General',\n                                selector: null,\n                                properties: {\n                                    fill: ColorBarChart.getFill(dataView),\n                                    size: ColorBarChart.getSize(dataView)\n                                }\n                            };\n                            instances.push(general);\n                            break;\n                    }\n                    return instances;\n                };\n                ColorBarChart.prototype.destroy = function () {\n                    this.root = null;\n                };\n                ColorBarChart.capabilities = {\n                    dataRoles: [{\n                            displayName: 'Values',\n                            name: 'Values',\n                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure\n                        }],\n                    dataViewMappings: [{\n                            table: {\n                                rows: {\n                                    for: { in: 'Values' },\n                                    dataReductionAlgorithm: { window: { count: 100 } }\n                                },\n                                rowCount: { preferred: { min: 1 } }\n                            },\n                        }],\n                    objects: {\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),\n                            properties: {\n                                fill: {\n                                    type: { fill: { solid: { color: true } } },\n                                    displayName: 'Fill'\n                                },\n                                size: {\n                                    type: { numeric: true },\n                                    displayName: 'Size'\n                                }\n                            },\n                        }\n                    },\n                };\n                return ColorBarChart;\n            }());\n            samples.ColorBarChart = ColorBarChart;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;\n            var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n            var AxisScale = powerbi.visuals.axisScale;\n            var PixelConverter = jsCommon.PixelConverter;\n            var MaxXAxisHeight = 40;\n            var LabelMargin = 15;\n            var DefaultRadius = 5;\n            var DefaultStrokeWidth = 1;\n            var DefaultDataPointColor = \"#00B8AA\";\n            var MinPrecision = 0;\n            var MaxPrecision = 17;\n            samples.DotPlotProperties = {\n                general: {\n                    formatString: {\n                        objectName: \"general\",\n                        propertyName: \"formatString\"\n                    }\n                },\n                labels: {\n                    show: {\n                        objectName: \"labels\",\n                        propertyName: \"show\"\n                    },\n                    fontSize: {\n                        objectName: \"labels\",\n                        propertyName: \"fontSize\"\n                    },\n                    labelPrecision: {\n                        objectName: \"labels\",\n                        propertyName: \"labelPrecision\"\n                    },\n                    labelDisplayUnits: {\n                        objectName: \"labels\",\n                        propertyName: \"labelDisplayUnits\"\n                    },\n                    labelColor: {\n                        objectName: \"labels\",\n                        propertyName: \"labelColor\"\n                    }\n                },\n                dataPoint: {\n                    fill: {\n                        objectName: \"dataPoint\",\n                        propertyName: \"fill\"\n                    }\n                },\n                categories: {\n                    show: {\n                        objectName: \"categories\",\n                        propertyName: \"show\"\n                    },\n                    fontColor: {\n                        objectName: \"categories\",\n                        propertyName: \"fontColor\"\n                    },\n                    fontSize: {\n                        objectName: \"categories\",\n                        propertyName: \"fontSize\"\n                    }\n                }\n            };\n            var DotPlot = (function () {\n                function DotPlot(options) {\n                    this.DefaultMargin = {\n                        top: 10,\n                        bottom: 10,\n                        right: 20,\n                        left: 20\n                    };\n                    this.durationAnimations = 200;\n                    this.scaleType = AxisScale.linear;\n                    this.textProperties = {\n                        fontFamily: 'wf_segoe-ui_normal',\n                        fontSize: jsCommon.PixelConverter.toString(9),\n                    };\n                    this.dotPlotSelectors = {\n                        svgPlotSelector: CreateClassAndSelector('dotplot'),\n                        plotSelector: CreateClassAndSelector('dotplotSelector'),\n                        plotGroupSelector: CreateClassAndSelector('dotplotGroup'),\n                        axisSelector: CreateClassAndSelector('axisGraphicsContext'),\n                        xAxisSelector: CreateClassAndSelector('x axis'),\n                        circleSeletor: CreateClassAndSelector('circleSelector'),\n                    };\n                    this.DefaultDotPlotSettings = {\n                        labelSettings: {\n                            show: true,\n                            precision: 2,\n                            fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,\n                            displayUnits: 0,\n                            labelColor: visuals.dataLabelUtils.defaultLabelColor,\n                        },\n                        categorySettings: {\n                            show: true,\n                            fontColor: visuals.LegendData.DefaultLegendLabelFillColor\n                        },\n                        defaultDataPointColor: DefaultDataPointColor\n                    };\n                    if (options) {\n                        if (options.svg) {\n                            this.svg = options.svg;\n                        }\n                        if (options.animator) {\n                            this.animator = options.animator;\n                        }\n                        this.radius = options.radius || DefaultRadius;\n                        this.strokeWidth = options.strokeWidth || DefaultStrokeWidth;\n                    }\n                }\n                DotPlot.getTooltipData = function (value) {\n                    return [{\n                            displayName: \"Value\",\n                            value: value.toString()\n                        }];\n                };\n                DotPlot.converter = function (dataView, scale, defaultMargin, defaultSetting, colors, viewport, radius) {\n                    var values = dataView.categorical.values, dataPointsGroup = [], displayName = dataView.categorical.categories[0].source.displayName, objects = this.getObjectsFromDataView(dataView), settings, defaultColor = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value);\n                    var categories = dataView.categorical.categories[0].values.map(function (x, i) { return {\n                        value: x,\n                        selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i])\n                    }; });\n                    settings = {\n                        categorySettings: this.getCategorySettings(objects, defaultSetting),\n                        defaultDataPointColor: defaultColor,\n                        labelSettings: this.parseSettings(objects, defaultSetting)\n                    };\n                    var categoryColumn = dataView.categorical.categories[0];\n                    var diameter = 2 * radius + 1;\n                    var dotsTotalHeight = viewport.height - radius - MaxXAxisHeight;\n                    var maxDots = Math.floor((dotsTotalHeight - defaultMargin.top) / diameter) - 1;\n                    var fontSizeInPx = PixelConverter.fromPoint(settings.labelSettings.fontSize);\n                    var yScale = d3.scale.linear()\n                        .domain([0, maxDots])\n                        .range([dotsTotalHeight - defaultMargin.bottom, defaultMargin.top + defaultMargin.bottom]);\n                    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n                        var value = values_1[_i];\n                        var min = _.min(value.values);\n                        var max = _.max(value.values);\n                        var color = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value);\n                        var length_1 = value.values.length;\n                        var minDots = min / (max / maxDots);\n                        var dotsScale = d3.scale.log().domain([min, max]).range([minDots === 0 ? 1 : minDots, maxDots]).clamp(true);\n                        for (var k = 0; k < length_1; k++) {\n                            var y = dotsScale(value.values[k]);\n                            var dataPoints = [];\n                            for (var level = 0; level < y; level++) {\n                                dataPoints.push({\n                                    x: scale(categories[k].value) + scale.rangeBand() / 2,\n                                    y: yScale(level),\n                                    tooltipInfo: DotPlot.getTooltipData(value.values[k])\n                                });\n                            }\n                            var categorySelectionId = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, k).createSelectionId();\n                            var tooltipInfo = DotPlot.getTooltipData(value.values[k]);\n                            dataPointsGroup.push({\n                                selected: false,\n                                value: value.values[k],\n                                label: value.values[k],\n                                color: color,\n                                identity: categorySelectionId,\n                                tooltipInfo: tooltipInfo,\n                                dataPoints: dataPoints,\n                                labelFontSize: fontSizeInPx,\n                            });\n                        }\n                    }\n                    return {\n                        dataPoints: dataPointsGroup,\n                        values: dataView.categorical.categories[0].values,\n                        displayName: displayName,\n                        categories: categories,\n                        settings: settings\n                    };\n                };\n                DotPlot.prototype.init = function (options) {\n                    var element = options.element;\n                    this.behavior = new DotplotBehavior();\n                    this.interactivityService = visuals.createInteractivityService(options.host);\n                    this.radius = DefaultRadius;\n                    this.strokeWidth = DefaultStrokeWidth;\n                    this.colors = options.style.colorPalette.dataColors;\n                    this.svg = d3.select(element.get(0)).append('svg').classed(this.dotPlotSelectors.svgPlotSelector.class, true).style('position', 'absolute');\n                    this.clearCatcher = visuals.appendClearCatcher(this.svg);\n                    var axisGraphicsContext = this.svg.append('g').classed(this.dotPlotSelectors.axisSelector.class, true);\n                    this.dotPlot = this.svg.append('g').classed(this.dotPlotSelectors.plotSelector.class, true);\n                    this.xAxis = axisGraphicsContext.append(\"g\").classed(this.dotPlotSelectors.xAxisSelector.class, true);\n                };\n                DotPlot.prototype.update = function (options) {\n                    if (!options.dataViews || !options.dataViews[0])\n                        return;\n                    this.durationAnimations = getAnimationDuration(this.animator, options.suppressAnimations);\n                    var dataView = this.dataView = options.dataViews[0];\n                    var viewport = options.viewport;\n                    if (!dataView ||\n                        !dataView.categorical ||\n                        !dataView.categorical.values ||\n                        dataView.categorical.values.length < 1 ||\n                        !dataView.categorical ||\n                        !dataView.categorical.categories ||\n                        !dataView.categorical.categories[0]) {\n                        this.clearData();\n                        return;\n                    }\n                    var viewportIn = {\n                        height: (viewport.height - this.DefaultMargin.top),\n                        width: (viewport.width - this.DefaultMargin.left)\n                    };\n                    this.svg.style({\n                        height: PixelConverter.toString(viewport.height),\n                        width: PixelConverter.toString(viewport.width)\n                    });\n                    var xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, false);\n                    var data = DotPlot.converter(dataView, xAxisProperties.scale, this.DefaultMargin, this.DefaultDotPlotSettings, this.colors, viewport, this.radius);\n                    this.dotPlotDataView = data;\n                    var dataPoints = data.dataPoints;\n                    if (this.interactivityService)\n                        this.interactivityService.applySelectionStateToData(dataPoints);\n                    this.renderAxis(viewportIn.height - MaxXAxisHeight, xAxisProperties, data, this.durationAnimations);\n                    this.drawDotPlot(dataPoints, data.settings);\n                    var dataLabelsSettings = data.settings.labelSettings;\n                    if (dataLabelsSettings.show) {\n                        var layout = this.getEnhanchedDotplotLayout(dataLabelsSettings, viewportIn);\n                        visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.svg, layout, viewportIn, !options.suppressAnimations, this.durationAnimations);\n                    }\n                    else {\n                        visuals.dataLabelUtils.cleanDataLabels(this.svg);\n                    }\n                };\n                DotPlot.prototype.enumerateObjectInstances = function (options) {\n                    var enumeration = new visuals.ObjectEnumerationBuilder();\n                    switch (options.objectName) {\n                        case 'dataPoint':\n                            this.enumerateDataPoints(enumeration, this.dataView);\n                            break;\n                        case 'labels':\n                            this.enumerateDataLabels(enumeration, this.dataView);\n                            break;\n                        case 'categories':\n                            this.enumerateCategories(enumeration, this.dataView);\n                            break;\n                    }\n                    return enumeration.complete();\n                };\n                DotPlot.getObjectsFromDataView = function (dataView) {\n                    if (!dataView ||\n                        !dataView.metadata ||\n                        !dataView.metadata.columns ||\n                        !dataView.metadata.objects) {\n                        return null;\n                    }\n                    return dataView.metadata.objects;\n                };\n                DotPlot.parseSettings = function (objects, defaultDotPlotSettings) {\n                    var precision = this.getPrecision(objects, defaultDotPlotSettings);\n                    return {\n                        show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, defaultDotPlotSettings.labelSettings.show),\n                        precision: precision,\n                        fontSize: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, defaultDotPlotSettings.labelSettings.fontSize),\n                        displayUnits: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, defaultDotPlotSettings.labelSettings.displayUnits),\n                        labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, defaultDotPlotSettings.labelSettings.labelColor),\n                    };\n                };\n                DotPlot.getCategorySettings = function (objects, defaultDotPlotSettings) {\n                    return {\n                        show: powerbi.DataViewObject.getValue(objects, samples.DotPlotProperties.categories.show, defaultDotPlotSettings.categorySettings.show),\n                        fontColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.categories.fontColor, defaultDotPlotSettings.categorySettings.fontColor)\n                    };\n                };\n                DotPlot.getPrecision = function (objects, defaultDotPlotSettings) {\n                    var precision = powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, defaultDotPlotSettings.labelSettings.precision);\n                    if (precision <= MinPrecision)\n                        return MinPrecision;\n                    if (precision >= MaxPrecision)\n                        return MaxPrecision;\n                    return precision;\n                };\n                DotPlot.prototype.drawDotPlot = function (data, setting) {\n                    var selection = this.dotPlot.selectAll(this.dotPlotSelectors.plotGroupSelector.selector).data(data);\n                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();\n                    selection\n                        .enter()\n                        .append('g')\n                        .attr({\n                        stroke: \"black\",\n                        \"stroke-width\": this.strokeWidth\n                    }).\n                        style(\"fill-opacity\", function (item) { return visuals.ColumnUtil.getFillOpacity(item.selected, item.highlight, hasSelection, false); }).\n                        classed(this.dotPlotSelectors.plotGroupSelector.class, true);\n                    var circleSelection = selection.selectAll(this.dotPlotSelectors.circleSeletor.selector).data(function (d) { return d.dataPoints; });\n                    circleSelection.enter().append('circle')\n                        .classed(this.dotPlotSelectors.circleSeletor.class, true);\n                    circleSelection.attr({\n                        cx: function (point) { return point.x; },\n                        cy: function (point) { return point.y; },\n                        r: this.radius,\n                        fill: setting.defaultDataPointColor\n                    });\n                    this.renderTooltip(selection);\n                    circleSelection.exit().remove();\n                    selection.exit().remove();\n                    var interactivityService = this.interactivityService;\n                    if (interactivityService) {\n                        interactivityService.applySelectionStateToData(data);\n                        var behaviorOptions = {\n                            columns: selection,\n                            clearCatcher: this.clearCatcher,\n                            interactivityService: this.interactivityService,\n                        };\n                        interactivityService.bind(data, this.behavior, behaviorOptions);\n                    }\n                };\n                DotPlot.prototype.getEnhanchedDotplotLayout = function (labelSettings, viewport) {\n                    var fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize);\n                    var formatter = visuals.valueFormatter.create({\n                        format: visuals.valueFormatter.getFormatString(this.dataView.categorical.categories[0].source, samples.DotPlotProperties.general.formatString),\n                        precision: labelSettings.precision,\n                        value: labelSettings.displayUnits\n                    });\n                    return {\n                        labelText: function (d) {\n                            return visuals.dataLabelUtils.getLabelFormattedText({\n                                label: formatter.format(d.label),\n                                fontSize: labelSettings.fontSize,\n                                maxWidth: viewport.width,\n                            });\n                        },\n                        labelLayout: {\n                            x: function (d) { return d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].x : 0; },\n                            y: function (d) { return d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].y - LabelMargin : 0; }\n                        },\n                        filter: function (d) {\n                            return (d != null && d.label != null);\n                        },\n                        style: {\n                            'fill': labelSettings.categoryLabelColor,\n                            'font-size': fontSizeInPx,\n                        },\n                    };\n                };\n                DotPlot.prototype.enumerateDataLabels = function (enumeration, dataView) {\n                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;\n                    enumeration.pushInstance({\n                        objectName: \"labels\",\n                        displayName: \"Labels\",\n                        selector: null,\n                        properties: {\n                            show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, this.DefaultDotPlotSettings.labelSettings.show),\n                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, this.DefaultDotPlotSettings.labelSettings.fontSize),\n                            labelPrecision: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, this.DefaultDotPlotSettings.labelSettings.precision),\n                            labelDisplayUnits: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, this.DefaultDotPlotSettings.labelSettings.displayUnits),\n                            labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, this.DefaultDotPlotSettings.labelSettings.labelColor)\n                        }\n                    });\n                };\n                DotPlot.prototype.enumerateDataPoints = function (enumeration, dataView) {\n                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;\n                    var dataPointColor = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, this.DefaultDotPlotSettings.defaultDataPointColor);\n                    enumeration.pushInstance({\n                        objectName: \"dataPoint\",\n                        displayName: \"Data Points\",\n                        selector: null,\n                        properties: {\n                            fill: { solid: { color: dataPointColor } }\n                        }\n                    });\n                };\n                DotPlot.prototype.enumerateCategories = function (enumeration, dataView) {\n                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;\n                    var categoriesSettings = DotPlot.getCategorySettings(objects, this.DefaultDotPlotSettings);\n                    enumeration.pushInstance({\n                        objectName: \"categories\",\n                        displayName: \"Categories\",\n                        selector: null,\n                        properties: {\n                            show: categoriesSettings.show,\n                            fontSize: categoriesSettings.fontSize,\n                            fontColor: categoriesSettings.fontColor\n                        }\n                    });\n                };\n                DotPlot.prototype.clearData = function () {\n                    this.dotPlot.selectAll(\"*\").remove();\n                    this.xAxis.selectAll(\"*\").remove();\n                    visuals.dataLabelUtils.cleanDataLabels(this.svg);\n                };\n                DotPlot.prototype.renderTooltip = function (selection) {\n                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {\n                        return tooltipEvent.data.tooltipInfo;\n                    });\n                };\n                DotPlot.prototype.calculateAxes = function (viewportIn, textProperties, scrollbarVisible) {\n                    var category = this.dataView.categorical.categories && this.dataView.categorical.categories.length > 0\n                        ? this.dataView.categorical.categories[0]\n                        : {\n                            source: undefined,\n                            values: [visuals.valueFormatter.format(null)],\n                            identity: undefined,\n                        };\n                    var visualOptions = {\n                        viewport: viewportIn,\n                        margin: this.DefaultMargin,\n                        forcedXDomain: this.dataView.categorical.categories[0].values,\n                        forceMerge: false,\n                        showCategoryAxisLabel: false,\n                        showValueAxisLabel: false,\n                        categoryAxisScaleType: this.scaleType,\n                        valueAxisScaleType: null,\n                        valueAxisDisplayUnits: 0,\n                        categoryAxisDisplayUnits: 0,\n                        trimOrdinalDataOnOverflow: false,\n                    };\n                    var width = viewportIn.width;\n                    var axes = this.calculateAxesProperties(viewportIn, visualOptions, category.source);\n                    axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);\n                    // If labels do not fit and we are not scrolling, try word breaking\n                    axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.DefaultMargin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);\n                    return axes;\n                };\n                DotPlot.prototype.calculateAxesProperties = function (viewportIn, options, metaDataColumn) {\n                    var xAxisProperties = visuals.AxisHelper.createAxis({\n                        pixelSpan: viewportIn.width,\n                        dataDomain: options.forcedXDomain,\n                        metaDataColumn: metaDataColumn,\n                        formatString: visuals.valueFormatter.getFormatString(metaDataColumn, samples.DotPlotProperties.general.formatString),\n                        outerPadding: 0,\n                        isScalar: false,\n                        isVertical: false,\n                        forcedTickCount: options.forcedTickCount,\n                        useTickIntervalForDisplayUnits: true,\n                        isCategoryAxis: true,\n                        getValueFn: function (index, type) { return index; },\n                        scaleType: options.categoryAxisScaleType,\n                        axisDisplayUnits: options.categoryAxisDisplayUnits\n                    });\n                    xAxisProperties.axisLabel = \"New Label\";\n                    return xAxisProperties;\n                };\n                DotPlot.prototype.renderAxis = function (height, xAxisProperties, data, duration) {\n                    this.xAxis.attr({\n                        transform: visuals.SVGUtil.translate(0, height)\n                    });\n                    var xAxis = xAxisProperties.axis;\n                    xAxis.orient('bottom');\n                    this.xAxis\n                        .transition()\n                        .duration(duration)\n                        .call(xAxis);\n                };\n                DotPlot.capabilities = {\n                    dataRoles: [{\n                            name: 'Category',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Category'\n                        },\n                        {\n                            name: \"Values\",\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Values'\n                        }],\n                    dataViewMappings: [{\n                            conditions: [\n                                { 'Category': { max: 1 }, 'Values': { max: 1 } },\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Category' },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: {\n                                    group: {\n                                        by: \"Series\",\n                                        select: [{ for: { in: \"Values\" } }],\n                                        dataReductionAlgorithm: { top: {} }\n                                    }\n                                }\n                            },\n                        }],\n                    objects: {\n                        general: {\n                            displayName: 'General',\n                            properties: {\n                                formatString: {\n                                    type: { formatting: { formatString: true } },\n                                },\n                            },\n                        },\n                        dataPoint: {\n                            displayName: 'Data colors',\n                            properties: {\n                                fill: {\n                                    displayName: 'Fill',\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        labels: {\n                            displayName: \"Data labels\",\n                            description: 'Display data label options',\n                            properties: {\n                                show: {\n                                    displayName: 'Show',\n                                    type: { bool: true }\n                                },\n                                showSeries: {\n                                    displayName: 'Show',\n                                    type: { bool: true }\n                                },\n                                color: {\n                                    displayName: 'Color',\n                                    description: 'Select color for data labels',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                labelDisplayUnits: {\n                                    displayName: 'Display units',\n                                    description: 'Select the units (millions, billions, etc.)',\n                                    type: { formatting: { labelDisplayUnits: true } },\n                                    suppressFormatPainterCopy: true\n                                },\n                                labelPrecision: {\n                                    displayName: 'Decimal places',\n                                    description: 'Select the number of decimal places to display',\n                                    placeHolderText: 'Auto',\n                                    type: { numeric: true },\n                                    suppressFormatPainterCopy: true\n                                },\n                                showAll: {\n                                    displayName: 'Customize series',\n                                    type: { bool: true }\n                                },\n                                fontSize: {\n                                    displayName: 'Text Size',\n                                    type: { formatting: { fontSize: true } }\n                                },\n                            }\n                        }\n                    }\n                };\n                return DotPlot;\n            }());\n            samples.DotPlot = DotPlot;\n            var DotplotBehavior = (function () {\n                function DotplotBehavior() {\n                }\n                DotplotBehavior.prototype.bindEvents = function (options, selectionHandler) {\n                    this.columns = options.columns;\n                    this.clearCatcher = options.clearCatcher;\n                    this.interactivityService = options.interactivityService;\n                    this.columns.on('click', function (d, i) {\n                        selectionHandler.handleSelection(d, d3.event.ctrlKey);\n                    });\n                    options.clearCatcher.on('click', function () {\n                        selectionHandler.handleClearSelection();\n                    });\n                };\n                DotplotBehavior.prototype.renderSelection = function (hasSelection) {\n                    var hasHighlights = this.interactivityService.hasSelection();\n                    this.columns.style(\"fill-opacity\", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights); });\n                };\n                return DotplotBehavior;\n            }());\n            samples.DotplotBehavior = DotplotBehavior;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  This file is based on or incorporates material from the projects listed below (Third Party IP).\n *  The original copyright notice and the license under which Microsoft received such Third Party IP,\n *  are set forth below. Such licenses and notices are provided for informational purposes only.\n *  Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.\n *  Microsoft reserves all other rights not expressly granted under this agreement, whether by\n *  implication, estoppel or otherwise.\n *\n *  d3 Force Layout\n *  Copyright (c) 2010-2015, Michael Bostock\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n *  * Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n *  * The name Michael Bostock may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var PixelConverter = jsCommon.PixelConverter;\n            var linkColorType;\n            (function (linkColorType) {\n                linkColorType.byWeight = 'ByWeight';\n                linkColorType.byLinkType = 'ByLinkType';\n                linkColorType.interactive = 'Interactive';\n                linkColorType.type = powerbi.createEnumType([\n                    { value: linkColorType.byWeight, displayName: 'ByWeight' },\n                    { value: linkColorType.byLinkType, displayName: 'ByLinkType' },\n                    { value: linkColorType.interactive, displayName: 'Interactive' },\n                ]);\n            })(linkColorType || (linkColorType = {}));\n            samples.forceProps = {\n                general: {\n                    formatString: {\n                        objectName: \"general\",\n                        propertyName: \"formatString\"\n                    }\n                },\n                labels: {\n                    show: {\n                        objectName: \"labels\",\n                        propertyName: \"show\"\n                    },\n                    color: {\n                        objectName: \"labels\",\n                        propertyName: \"color\"\n                    },\n                    fontSize: {\n                        objectName: \"labels\",\n                        propertyName: \"fontSize\"\n                    }\n                },\n                links: {\n                    showArrow: { objectName: 'links', propertyName: 'showArrow' },\n                    showLabel: { objectName: 'links', propertyName: 'showLabel' },\n                    colorLink: { objectName: 'links', propertyName: 'colorLink' },\n                    thickenLink: { objectName: 'links', propertyName: 'thickenLink' },\n                },\n                nodes: {\n                    displayImage: { objectName: 'nodes', propertyName: 'displayImage' },\n                    defaultImage: { objectName: 'nodes', propertyName: 'defaultImage' },\n                    imageUrl: { objectName: 'nodes', propertyName: 'imageUrl' },\n                    imageExt: { objectName: 'nodes', propertyName: 'imageExt' },\n                    nameMaxLength: { objectName: 'nodes', propertyName: 'nameMaxLength' },\n                    highlightReachableLinks: { objectName: 'nodes', propertyName: 'highlightReachableLinks' },\n                },\n                size: {\n                    charge: { objectName: 'size', propertyName: 'charge' },\n                }\n            };\n            var ForceGraph = (function () {\n                function ForceGraph() {\n                }\n                Object.defineProperty(ForceGraph.prototype, \"margin\", {\n                    get: function () {\n                        return this.marginValue || { left: 0, right: 0, top: 0, bottom: 0 };\n                    },\n                    set: function (value) {\n                        this.marginValue = $.extend({}, value);\n                        this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(ForceGraph.prototype, \"viewport\", {\n                    get: function () {\n                        return this.viewportValue || { width: 0, height: 0 };\n                    },\n                    set: function (value) {\n                        this.viewportValue = $.extend({}, value);\n                        this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(ForceGraph.prototype, \"viewportIn\", {\n                    get: function () {\n                        return this.viewportInValue || this.viewport;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                ForceGraph.substractMargin = function (viewport, margin) {\n                    return {\n                        width: Math.max(viewport.width - (margin.left + margin.right), 0),\n                        height: Math.max(viewport.height - (margin.top + margin.bottom), 0)\n                    };\n                };\n                ForceGraph.prototype.scale1to10 = function (d) {\n                    var scale = d3.scale.linear().domain([this.data.minFiles, this.data.maxFiles]).rangeRound([1, 10]).clamp(true);\n                    return scale(d);\n                };\n                ForceGraph.prototype.getLinkColor = function (d) {\n                    switch (this.options.colorLink) {\n                        case linkColorType.byWeight:\n                            return this.colors.getColorByIndex(this.scale1to10(d.filecount)).value;\n                        case linkColorType.byLinkType:\n                            return d.type && this.data.linkTypes[d.type] ? this.data.linkTypes[d.type].color : this.options.defaultLinkColor;\n                    }\n                    ;\n                    return this.options.defaultLinkColor;\n                };\n                ForceGraph.prototype.getDefaultOptions = function () {\n                    return {\n                        showDataLabels: true,\n                        labelColor: visuals.dataLabelUtils.defaultLabelColor,\n                        fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,\n                        showArrow: false,\n                        showLabel: false,\n                        colorLink: linkColorType.interactive,\n                        thickenLink: true,\n                        displayImage: false,\n                        defaultImage: \"Home\",\n                        imageUrl: \"\",\n                        imageExt: \".png\",\n                        nameMaxLength: 10,\n                        highlightReachableLinks: false,\n                        charge: -15,\n                        defaultLinkColor: \"#bbb\",\n                        defaultLinkHighlightColor: \"#f00\",\n                        defaultLinkThickness: \"1.5px\",\n                    };\n                };\n                ForceGraph.prototype.updateOptions = function (objects) {\n                    this.options.showDataLabels = powerbi.DataViewObjects.getValue(objects, samples.forceProps.labels.show, this.options.showDataLabels);\n                    this.options.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.forceProps.labels.color, this.options.labelColor);\n                    this.options.fontSize = powerbi.DataViewObjects.getValue(objects, samples.forceProps.labels.fontSize, this.options.fontSize);\n                    this.options.showArrow = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.showArrow, this.options.showArrow);\n                    this.options.showLabel = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.showLabel, this.options.showLabel);\n                    this.options.colorLink = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.colorLink, this.options.colorLink);\n                    this.options.thickenLink = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.thickenLink, this.options.thickenLink);\n                    this.options.displayImage = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.displayImage, this.options.displayImage);\n                    this.options.defaultImage = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.defaultImage, this.options.defaultImage);\n                    this.options.imageUrl = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.imageUrl, this.options.imageUrl);\n                    this.options.imageExt = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.imageExt, this.options.imageExt);\n                    this.options.nameMaxLength = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.nameMaxLength, this.options.nameMaxLength);\n                    this.options.highlightReachableLinks = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.highlightReachableLinks, this.options.highlightReachableLinks);\n                    this.options.charge = powerbi.DataViewObjects.getValue(objects, samples.forceProps.size.charge, this.options.charge);\n                    if (this.options.charge >= 0 || this.options.charge < -100)\n                        this.options.charge = this.getDefaultOptions().charge;\n                };\n                ForceGraph.prototype.enumerateObjectInstances = function (options) {\n                    var enumeration = new visuals.ObjectEnumerationBuilder();\n                    switch (options.objectName) {\n                        case 'labels':\n                            this.enumerateLabels(enumeration);\n                            break;\n                        case 'links':\n                            this.enumerateLinks(enumeration);\n                            break;\n                        case 'nodes':\n                            this.enumerateNodes(enumeration);\n                            break;\n                        case 'size':\n                            this.enumerateSize(enumeration);\n                            break;\n                        default:\n                            break;\n                    }\n                    return enumeration.complete();\n                };\n                ForceGraph.prototype.enumerateLabels = function (enumeration) {\n                    var labels, options;\n                    if (!this.options || !this.options)\n                        return;\n                    options = this.options;\n                    labels = {\n                        objectName: 'labels',\n                        displayName: 'Labels',\n                        selector: null,\n                        properties: {\n                            show: options.showDataLabels,\n                            fontSize: options.fontSize,\n                            color: options.labelColor\n                        }\n                    };\n                    enumeration.pushInstance(labels);\n                };\n                ForceGraph.prototype.enumerateLinks = function (enumeration) {\n                    var links, options;\n                    if (!this.options)\n                        return;\n                    options = this.options;\n                    links = {\n                        objectName: 'links',\n                        displayName: 'Links',\n                        selector: null,\n                        properties: {\n                            showArrow: options.showArrow,\n                            colorLink: options.colorLink,\n                            showLabel: options.showLabel,\n                            thickenLink: options.thickenLink,\n                        }\n                    };\n                    enumeration.pushInstance(links);\n                };\n                ForceGraph.prototype.enumerateNodes = function (enumeration) {\n                    var nodes, options;\n                    if (!this.options)\n                        return;\n                    options = this.options;\n                    nodes = {\n                        objectName: 'nodes',\n                        displayName: 'Nodes',\n                        selector: null,\n                        properties: {\n                            displayImage: options.displayImage,\n                            defaultImage: options.defaultImage,\n                            imageUrl: options.imageUrl,\n                            imageExt: options.imageExt,\n                            nameMaxLength: options.nameMaxLength,\n                            highlightReachableLinks: options.highlightReachableLinks,\n                        }\n                    };\n                    enumeration.pushInstance(nodes);\n                };\n                ForceGraph.prototype.enumerateSize = function (enumeration) {\n                    var size, options;\n                    if (!this.options)\n                        return;\n                    options = this.options;\n                    size = {\n                        objectName: 'size',\n                        displayName: 'Size',\n                        selector: null,\n                        properties: {\n                            charge: options.charge,\n                        }\n                    };\n                    enumeration.pushInstance(size);\n                };\n                ForceGraph.converter = function (dataView, colors) {\n                    var categorical = dataView.categorical;\n                    var nodes = {};\n                    var minFiles = Number.MAX_VALUE;\n                    var maxFiles = 0;\n                    var linkedByName = {};\n                    var links = [];\n                    var linkDataPoints = {};\n                    var linkTypeCount = 0;\n                    var sourceCol = -1, targetCol = -1, weightCol = -1, linkTypeCol = -1, sourceTypeCol = -1, targetTypeCol = -1;\n                    var rows;\n                    var tooltipInfo = [];\n                    var formatStringProp = samples.forceProps.general.formatString;\n                    if (dataView && dataView.categorical && dataView.categorical.categories && dataView.metadata && dataView.metadata.columns) {\n                        var metadataColumns = dataView.metadata.columns;\n                        for (var i = 0; i < metadataColumns.length; i++) {\n                            var col = metadataColumns[i];\n                            if (col.roles) {\n                                if (col.roles['Source'])\n                                    sourceCol = i;\n                                else if (col.roles['Target'])\n                                    targetCol = i;\n                                else if (col.roles['Weight'])\n                                    weightCol = i;\n                                else if (col.roles['LinkType'])\n                                    linkTypeCol = i;\n                                else if (col.roles['SourceType'])\n                                    sourceTypeCol = i;\n                                else if (col.roles['TargetType'])\n                                    targetTypeCol = i;\n                            }\n                        }\n                    }\n                    if (dataView && dataView.table) {\n                        rows = dataView.table.rows;\n                    }\n                    if (sourceCol < 0 || targetCol < 0)\n                        return {\n                            nodes: {},\n                            links: [],\n                            minFiles: 0,\n                            maxFiles: 0,\n                            linkedByName: {},\n                            linkTypes: {},\n                        };\n                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(categorical.categories[0].source, formatStringProp);\n                    var categoryTargetFormatString = visuals.valueFormatter.getFormatString(categorical.categories[1].source, formatStringProp);\n                    var weightFormatString = visuals.valueFormatter.getFormatString(categorical.values ? categorical.values[0].source : null, formatStringProp, true);\n                    rows.forEach(function (item) {\n                        linkedByName[item[sourceCol] + \",\" + item[targetCol]] = 1;\n                        var source = nodes[item[sourceCol]] ||\n                            (nodes[item[sourceCol]] = { name: item[sourceCol], image: sourceTypeCol > 0 ? item[sourceTypeCol] : '', adj: {} });\n                        var target = nodes[item[targetCol]] ||\n                            (nodes[item[targetCol]] = { name: item[targetCol], image: targetTypeCol > 0 ? item[targetTypeCol] : '', adj: {} });\n                        source.adj[target.name] = 1;\n                        target.adj[source.name] = 1;\n                        tooltipInfo = [{\n                                displayName: dataView.metadata.columns[0].displayName,\n                                value: visuals.valueFormatter.format(source.name, categorySourceFormatString)\n                            }, {\n                                displayName: dataView.metadata.columns[1].displayName,\n                                value: visuals.valueFormatter.format(target.name, categoryTargetFormatString)\n                            }];\n                        if (weightCol > 0)\n                            tooltipInfo.push({\n                                displayName: dataView.metadata.columns[2].displayName,\n                                value: visuals.valueFormatter.format(item[weightCol], weightFormatString)\n                            });\n                        var link = {\n                            source: source,\n                            target: target,\n                            filecount: weightCol > 0 ? item[weightCol] : 0,\n                            type: linkTypeCol > 0 ? item[linkTypeCol] : '',\n                            tooltipInfo: tooltipInfo,\n                        };\n                        if (linkTypeCol > 0) {\n                            if (!linkDataPoints[item[linkTypeCol]]) {\n                                linkDataPoints[item[linkTypeCol]] = {\n                                    label: item[linkTypeCol],\n                                    color: colors.getColorByIndex(linkTypeCount++).value,\n                                };\n                            }\n                            ;\n                        }\n                        ;\n                        if (link.filecount < minFiles) {\n                            minFiles = link.filecount;\n                        }\n                        ;\n                        if (link.filecount > maxFiles) {\n                            maxFiles = link.filecount;\n                        }\n                        ;\n                        links.push(link);\n                    });\n                    return {\n                        nodes: nodes,\n                        links: links,\n                        minFiles: minFiles,\n                        maxFiles: maxFiles,\n                        linkedByName: linkedByName,\n                        linkTypes: linkDataPoints,\n                    };\n                };\n                ForceGraph.prototype.init = function (options) {\n                    this.root = d3.select(options.element.get(0));\n                    this.forceLayout = d3.layout.force();\n                    this.colors = options.style.colorPalette.dataColors;\n                    this.options = this.getDefaultOptions();\n                };\n                ForceGraph.prototype.update = function (options) {\n                    var _this = this;\n                    if (!options.dataViews || (options.dataViews.length < 1))\n                        return;\n                    this.data = ForceGraph.converter(this.dataView = options.dataViews[0], this.colors);\n                    if (!this.data)\n                        return;\n                    if (options.dataViews[0].metadata && options.dataViews[0].metadata.objects)\n                        this.updateOptions(options.dataViews[0].metadata.objects);\n                    this.viewport = options.viewport;\n                    var k = Math.sqrt(Object.keys(this.data.nodes).length / (this.viewport.width * this.viewport.height));\n                    this.root.selectAll(\"svg\").remove();\n                    var svg = this.root\n                        .append(\"svg\")\n                        .attr(\"width\", this.viewport.width)\n                        .attr(\"height\", this.viewport.height)\n                        .classed(ForceGraph.VisualClassName, true);\n                    this.forceLayout\n                        .gravity(100 * k)\n                        .links(this.data.links)\n                        .size([this.viewport.width, this.viewport.height])\n                        .linkDistance(100)\n                        .charge(this.options.charge / k)\n                        .on(\"tick\", this.tick());\n                    this.updateNodes();\n                    this.forceLayout.start();\n                    // uncomment if we don't need the marker-end workaround\n                    //if (this.options.showArrow) {\n                    // build the arrow.\n                    //function marker(d, i) {\n                    //    let val = \"mid_\" + i;\n                    //    svg.append(\"defs\").selectAll(\"marker\")\n                    //        .data([val])      // Different link/path types can be defined here\n                    //        .enter().append(\"marker\")    // This section adds in the arrows\n                    //        .attr(\"id\", String)\n                    //        .attr(\"viewBox\", \"0 -5 10 10\")\n                    //        .attr(\"refX\", 10)\n                    //        .attr(\"refY\", 0)\n                    //        .attr(\"markerWidth\", 6)\n                    //        .attr(\"markerHeight\", 6)\n                    //        .attr(\"orient\", \"auto\")\n                    //        .attr(\"markerUnits\", \"userSpaceOnUse\")\n                    //        .append(\"path\")\n                    //        .attr(\"d\", \"M0,-5L10,0L0,5\")\n                    //    //below works if no marker-end workaround needed\n                    //        .style(\"fill\", d => this.getLinkColor(d))\n                    //    ;\n                    //    return \"url(#\" + val + \")\";\n                    //}\n                    //}\n                    this.paths = svg.selectAll(\".link\")\n                        .data(this.forceLayout.links())\n                        .enter().append(\"path\")\n                        .attr(\"class\", \"link\")\n                        .attr(\"id\", function (d, i) { return \"linkid_\" + i; })\n                        .attr(\"stroke-width\", function (d) { return _this.options.thickenLink ? _this.scale1to10(d.filecount) : _this.options.defaultLinkThickness; })\n                        .style(\"stroke\", function (d) { return _this.getLinkColor(d); })\n                        .style(\"fill\", function (d) { if (_this.options.showArrow)\n                        return _this.getLinkColor(d); })\n                        .on(\"mouseover\", this.fadePath(.3, this.options.defaultLinkHighlightColor))\n                        .on(\"mouseout\", this.fadePath(1, this.options.defaultLinkColor));\n                    visuals.TooltipManager.addTooltip(this.paths, function (tooltipEvent) {\n                        return tooltipEvent.data.tooltipInfo;\n                    });\n                    if (this.options.showLabel) {\n                        svg.selectAll(\".linklabelholder\")\n                            .data(this.forceLayout.links())\n                            .enter().append(\"g\")\n                            .attr(\"class\", \"linklabelholder\")\n                            .append(\"text\")\n                            .attr(\"class\", \"linklabel\")\n                            .attr(\"y\", \"-12\")\n                            .attr(\"text-anchor\", \"middle\")\n                            .style(\"fill\", \"#000\")\n                            .append(\"textPath\")\n                            .attr(\"xlink:href\", function (d, i) { return \"#linkid_\" + i; })\n                            .attr(\"startOffset\", \"25%\") //use \"50%\" if we don't need the marker-end workaround\n                            .text(function (d) { return _this.options.colorLink === linkColorType.byLinkType ? d.type : d.filecount; });\n                    }\n                    // define the nodes\n                    this.nodes = svg.selectAll(\".node\")\n                        .data(this.forceLayout.nodes())\n                        .enter().append(\"g\")\n                        .attr(\"class\", \"node\")\n                        .call(this.forceLayout.drag)\n                        .on(\"mouseover\", this.fadeNode(.3, this.options.defaultLinkHighlightColor))\n                        .on(\"mouseout\", this.fadeNode(1, this.options.defaultLinkColor))\n                        .on(\"mousedown\", function () { return d3.event.stopPropagation(); })\n                        .attr(\"drag-resize-disabled\", true);\n                    // add the nodes\n                    if (this.options.displayImage) {\n                        this.nodes.append(\"image\")\n                            .attr(\"xlink:href\", function (d) {\n                            return d.image && d.image !== '' ?\n                                _this.options.imageUrl + d.image + _this.options.imageExt :\n                                (_this.options.defaultImage && _this.options.defaultImage !== '' ?\n                                    _this.options.imageUrl + _this.options.defaultImage + _this.options.imageExt :\n                                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAMAAAHNDTTxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuUExURQAAAMbGxvLy8sfHx/Hx8fLy8vHx8cnJycrKyvHx8fHx8cvLy/Ly8szMzM3NzfHx8dDQ0PHx8fLy8vHx8e/v79LS0tPT0/Ly8tTU1NXV1dbW1vHx8fHx8fDw8NjY2PT09PLy8vLy8vHx8fLy8vHx8fHx8enp6fDw8PLy8uPj4+Tk5OXl5fHx8b+/v/Pz8+bm5vHx8ejo6PLy8vHx8fLy8sTExPLy8vLy8sXFxfHx8YCtMbUAAAA6dFJOUwD/k/+b7/f///+r/////0z/w1RcEP//ZP///4fj/v8Yj3yXn/unDEhQ////YP9Y/8//aIMU/9+L/+fzC4s1AAAACXBIWXMAABcRAAAXEQHKJvM/AAABQElEQVQoU5WS61LCMBCFFymlwSPKVdACIgWkuNyL+P4v5ibZ0jKjP/xm0uw5ySa7mRItAhnMoIC5TwQZdCZiZjcoC8WU6EVsmZgzoqGdxafgvJAvjUXCb2M+0cXNsd/GDarZqSf7av3M2P1E3xhfLkPUvLD5joEYwVVJQXM6+9McWUwLf4nDTCQZAy96UoDjNI/jhl3xPLbQamu8xD7iaIsPKw7GJ7KZEnWLY3Gi8EFj5nqibXnwD5VEGjJXk5sbpLppfvvo1RazQVrhSopPK4TODrtnjS3dY4ic8KurruWQYF+UG60BacexTMyT2jlNg41dOmKvTpkUd/Jevy7ZxQ61ULRUpoododx8GeDPvIrktbFVdUsK6f8Na5VlVpjZJtowTXVy7kfXF5wCaV1tqXAFuIdWJu+JviaQzNzfQvQDGKRXXEmy83cAAAAASUVORK5CYII=');\n                        })\n                            .attr(\"x\", \"-12px\")\n                            .attr(\"y\", \"-12px\")\n                            .attr(\"width\", \"24px\")\n                            .attr(\"height\", \"24px\");\n                    }\n                    else {\n                        this.nodes.append(\"circle\")\n                            .attr(\"r\", function (d) { return d.weight < 5 ? 5 : d.weight; });\n                    }\n                    // add the text\n                    if (this.options.showDataLabels) {\n                        this.nodes.append(\"text\")\n                            .attr({\n                            x: 12,\n                            dy: \".35em\"\n                        })\n                            .style({\n                            fill: this.options.labelColor,\n                            'font-size': PixelConverter.fromPoint(this.options.fontSize)\n                        })\n                            .text(function (d) { return d.name ? (d.name.length > _this.options.nameMaxLength ? d.name.substr(0, _this.options.nameMaxLength) : d.name) : ''; });\n                    }\n                };\n                ForceGraph.prototype.updateNodes = function () {\n                    var oldNodes = this.forceLayout.nodes();\n                    this.forceLayout.nodes(d3.values(this.data.nodes));\n                    this.forceLayout.nodes().forEach(function (node, i) {\n                        if (!oldNodes[i]) {\n                            return;\n                        }\n                        node.x = oldNodes[i].x;\n                        node.y = oldNodes[i].y;\n                        node.px = oldNodes[i].px;\n                        node.py = oldNodes[i].py;\n                        node.weight = oldNodes[i].weight;\n                    });\n                };\n                ForceGraph.prototype.tick = function () {\n                    var _this = this;\n                    var viewport = this.viewportIn;\n                    // limitX and limitY is necessary when you minimize the graph and then resize it to normal.\n                    //\"width/height * 20\" seems enough to move nodes freely by force layout.\n                    var maxWidth = viewport.width * 20;\n                    var maxHeight = viewport.height * 20;\n                    var limitX = function (x) { return Math.max((viewport.width - maxWidth) / 2, Math.min((viewport.width + maxWidth) / 2, x)); };\n                    var limitY = function (y) { return Math.max((viewport.height - maxHeight) / 2, Math.min((viewport.height + maxHeight) / 2, y)); };\n                    //use this if we don't need the marker-end workaround\n                    //path.attr(\"d\", function (d) {\n                    //    let dx = d.target.x - d.source.x,\n                    //        dy = d.target.y - d.source.y,\n                    //        dr = Math.sqrt(dx * dx + dy * dy);\n                    //    // x and y distances from center to outside edge of target node\n                    //    let offsetX = (dx * d.target.radius) / dr;\n                    //    let offsetY = (dy * d.target.radius) / dr;\n                    //    return \"M\" +\n                    //        d.source.x + \",\" +\n                    //        d.source.y + \"A\" +\n                    //        dr + \",\" + dr + \" 0 0,1 \" +\n                    //        (d.target.x - offsetX) + \",\" +\n                    //        (d.target.y - offsetY);\n                    //});\n                    var getPath = this.options.showArrow ?\n                        //this is for marker-end workaround, build the marker with the path\n                        //this is for marker-end workaround, build the marker with the path\n                        function (d) {\n                            d.source.x = limitX(d.source.x);\n                            d.source.y = limitY(d.source.y);\n                            d.target.x = limitX(d.target.x);\n                            d.target.y = limitY(d.target.y);\n                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy), theta = Math.atan2(dy, dx) + Math.PI / 7.85, d90 = Math.PI / 2, dtxs = d.target.x - 6 * Math.cos(theta), dtys = d.target.y - 6 * Math.sin(theta);\n                            return \"M\" +\n                                d.source.x + \",\" +\n                                d.source.y + \"A\" +\n                                dr + \",\" + dr + \" 0 0 1,\" +\n                                d.target.x + \",\" +\n                                d.target.y +\n                                \"A\" + dr + \",\" + dr + \" 0 0 0,\" + d.source.x + \",\" + d.source.y + \"M\" + dtxs + \",\" + dtys + \"l\" + (3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + \",\" + (-3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + \"L\" + (dtxs - 3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + \",\" + (dtys + 3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + \"z\";\n                        } :\n                        function (d) {\n                            d.source.x = limitX(d.source.x);\n                            d.source.y = limitY(d.source.y);\n                            d.target.x = limitX(d.target.x);\n                            d.target.y = limitY(d.target.y);\n                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);\n                            return \"M\" +\n                                d.source.x + \",\" +\n                                d.source.y + \"A\" +\n                                dr + \",\" + dr + \" 0 0,1 \" +\n                                d.target.x + \",\" +\n                                d.target.y;\n                        };\n                    return function () {\n                        _this.paths.each(function () { this.parentNode.insertBefore(this, this); });\n                        _this.paths.attr(\"d\", getPath);\n                        _this.nodes.attr(\"transform\", function (d) { return \"translate(\" + limitX(d.x) + \",\" + limitY(d.y) + \")\"; });\n                    };\n                };\n                ForceGraph.prototype.fadePath = function (opacity, highlight) {\n                    var _this = this;\n                    if (this.options.colorLink !== linkColorType.interactive)\n                        return;\n                    return function (d) {\n                        _this.paths.style(\"stroke-opacity\", function (o) { return o.source === d.source && o.target === d.target ? 1 : opacity; });\n                        _this.paths.style(\"stroke\", function (o) { return o.source === d.source && o.target === d.target ? highlight : _this.options.defaultLinkColor; });\n                    };\n                };\n                ForceGraph.prototype.isReachable = function (a, b) {\n                    if (a.name === b.name)\n                        return true;\n                    if (this.data.linkedByName[a.name + \",\" + b.name])\n                        return true;\n                    var visited = {};\n                    for (var name_1 in this.data.nodes) {\n                        visited[name_1] = false;\n                    }\n                    ;\n                    visited[a.name] = true;\n                    var stack = [];\n                    stack.push(a.name);\n                    while (stack.length > 0) {\n                        var cur = stack.pop();\n                        var node = this.data.nodes[cur];\n                        for (var nb in node.adj) {\n                            if (nb === b.name)\n                                return true;\n                            if (!visited[nb]) {\n                                visited[nb] = true;\n                                stack.push(nb);\n                            }\n                        }\n                    }\n                    ;\n                    return false;\n                };\n                ForceGraph.prototype.fadeNode = function (opacity, highlight) {\n                    var _this = this;\n                    if (this.options.colorLink !== linkColorType.interactive)\n                        return;\n                    var isConnected = function (a, b) { return _this.data.linkedByName[a.name + \",\" + b.name] || _this.data.linkedByName[b.name + \",\" + a.name] || a.name === b.name; };\n                    return function (d) {\n                        var that = _this;\n                        _this.nodes.style(\"stroke-opacity\", function (o) {\n                            var thisOpacity = (that.options.highlightReachableLinks ? that.isReachable(d, o) : isConnected(d, o)) ? 1 : opacity;\n                            this.setAttribute('fill-opacity', thisOpacity);\n                            return thisOpacity;\n                        });\n                        _this.paths.style(\"stroke-opacity\", function (o) {\n                            return (_this.options.highlightReachableLinks ? _this.isReachable(d, o.source) :\n                                (o.source === d || o.target === d)) ? 1 : opacity;\n                        });\n                        _this.paths.style(\"stroke\", function (o) {\n                            return (_this.options.highlightReachableLinks ? _this.isReachable(d, o.source) :\n                                (o.source === d || o.target === d)) ? highlight : _this.options.defaultLinkColor;\n                        });\n                    };\n                };\n                ForceGraph.prototype.destroy = function () {\n                    this.root = null;\n                };\n                ForceGraph.VisualClassName = 'forceGraph';\n                ForceGraph.capabilities = {\n                    dataRoles: [\n                        {\n                            name: 'Source',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Source',\n                        },\n                        {\n                            name: 'Target',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Target',\n                        },\n                        {\n                            name: 'Weight',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Weight',\n                        },\n                        {\n                            name: 'LinkType',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'LinkType',\n                            description: 'Links can be colored by link types',\n                        },\n                        {\n                            name: 'SourceType',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'SourceType',\n                            description: 'Source type represents the image name for source entities',\n                        },\n                        {\n                            name: 'TargetType',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'TargetType',\n                            description: 'Target type represents the image name for target entities',\n                        },\n                    ],\n                    objects: {\n                        general: {\n                            properties: {\n                                formatString: {\n                                    type: { formatting: { formatString: true } },\n                                }\n                            }\n                        },\n                        labels: {\n                            displayName: 'Data labels',\n                            properties: {\n                                show: {\n                                    displayName: 'Show',\n                                    type: { bool: true }\n                                },\n                                color: {\n                                    displayName: 'Fill',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: 'Text Size',\n                                    type: { formatting: { fontSize: true } }\n                                }\n                            }\n                        },\n                        links: {\n                            displayName: 'Links',\n                            properties: {\n                                showArrow: {\n                                    type: { bool: true },\n                                    displayName: 'Arrow'\n                                },\n                                showLabel: {\n                                    type: { bool: true },\n                                    displayName: 'Label',\n                                    description: 'Displays weight on links',\n                                },\n                                colorLink: {\n                                    type: { enumeration: linkColorType.type },\n                                    displayName: 'Color',\n                                },\n                                thickenLink: {\n                                    type: { bool: true },\n                                    displayName: 'Thickness',\n                                    description: 'Thickenss of links represents weight',\n                                },\n                            }\n                        },\n                        nodes: {\n                            displayName: 'Nodes',\n                            properties: {\n                                displayImage: {\n                                    type: { bool: true },\n                                    displayName: 'Image',\n                                    description: 'Images are loaded from image url + source or target type + image extension',\n                                },\n                                defaultImage: {\n                                    type: { text: true },\n                                    displayName: 'Default image'\n                                },\n                                imageUrl: {\n                                    type: { text: true },\n                                    displayName: 'Image url'\n                                },\n                                imageExt: {\n                                    type: { text: true },\n                                    displayName: 'Image extension'\n                                },\n                                nameMaxLength: {\n                                    type: { numeric: true },\n                                    displayName: 'Max name length',\n                                    description: 'Max length of the name of entities displayed',\n                                },\n                                highlightReachableLinks: {\n                                    type: { bool: true },\n                                    displayName: 'Highlight all reachable links',\n                                    description: \"In interactive mode, whether a node's all reachable links will be highlighted\",\n                                },\n                            }\n                        },\n                        size: {\n                            displayName: 'Size',\n                            properties: {\n                                charge: {\n                                    type: { numeric: true },\n                                    displayName: 'Charge',\n                                    description: 'The larger the negative charge the more apart the entities, must be negative but greater than -100',\n                                },\n                            }\n                        },\n                    },\n                    dataViewMappings: [{\n                            conditions: [\n                                { 'Source': { max: 1 }, 'Target': { max: 1 }, 'Weight': { max: 1 }, 'LinkType': { max: 1 }, 'SourceType': { max: 1 }, 'TargetType': { max: 1 } },\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Source' },\n                                    dataReductionAlgorithm: { top: {} }\n                                },\n                                values: {\n                                    select: [\n                                        { bind: { to: 'Target' } },\n                                        { bind: { to: 'Weight' } },\n                                        { bind: { to: 'LinkType' } },\n                                        { bind: { to: 'SourceType' } },\n                                        { bind: { to: 'TargetType' } },\n                                    ],\n                                },\n                                rowCount: { preferred: { min: 1 } }\n                            },\n                        }],\n                    suppressDefaultTitle: true,\n                };\n                return ForceGraph;\n            }());\n            samples.ForceGraph = ForceGraph;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var SelectionManager = visuals.utility.SelectionManager;\n            var PixelConverter = jsCommon.PixelConverter;\n            var PercentFormat = \"0.00 %;-0.00 %;0.00 %\";\n            var MillisecondsInADay = 86400000;\n            var MillisecondsInWeek = 604800000;\n            var MillisecondsInAMonth = 2629746000;\n            var MillisecondsInAYear = 31556952000;\n            samples.DefaultDateType = \"Week\";\n            var ChartLineHeight = 40;\n            var PaddingTasks = 5;\n            var dateTypeSelector;\n            (function (dateTypeSelector) {\n                dateTypeSelector.day = 'Day';\n                dateTypeSelector.week = 'Week';\n                dateTypeSelector.month = 'Month';\n                dateTypeSelector.year = 'Year';\n                dateTypeSelector.type = powerbi.createEnumType([\n                    { value: dateTypeSelector.day, displayName: 'Day' },\n                    { value: dateTypeSelector.week, displayName: 'Week' },\n                    { value: dateTypeSelector.month, displayName: 'Month' },\n                    { value: dateTypeSelector.year, displayName: 'Year' }\n                ]);\n            })(dateTypeSelector = samples.dateTypeSelector || (samples.dateTypeSelector = {}));\n            ;\n            samples.GanttChartProps = {\n                legend: {\n                    show: { objectName: 'legend', propertyName: 'show' },\n                    position: { objectName: 'legend', propertyName: 'position' },\n                    showTitle: { objectName: 'legend', propertyName: 'showTitle' },\n                    titleText: { objectName: 'legend', propertyName: 'titleText' },\n                    labelColor: { objectName: 'legend', propertyName: 'labelColor' },\n                    fontSize: { objectName: 'legend', propertyName: 'fontSize' },\n                },\n                taskCompletion: {\n                    fill: { objectName: 'taskCompletion', propertyName: 'fill' },\n                },\n                dataPoint: {\n                    fill: { objectName: 'dataPoint', propertyName: 'fill' },\n                },\n                taskLabels: {\n                    show: { objectName: 'taskLabels', propertyName: 'show' },\n                    fill: { objectName: 'taskLabels', propertyName: 'fill' },\n                    fontSize: { objectName: 'taskLabels', propertyName: 'fontSize' },\n                    width: { objectName: 'taskLabels', propertyName: 'width' },\n                },\n                taskResource: {\n                    show: { objectName: 'taskResource', propertyName: 'show' },\n                    fill: { objectName: 'taskResource', propertyName: 'fill' },\n                    fontSize: { objectName: 'taskResource', propertyName: 'fontSize' },\n                },\n                ganttDateType: {\n                    type: { objectName: 'ganttDateType', propertyName: 'type' },\n                }\n            };\n            var Selectors;\n            (function (Selectors) {\n                var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n                Selectors.ClassName = CreateClassAndSelector(\"gantt\");\n                Selectors.Chart = CreateClassAndSelector(\"chart\");\n                Selectors.ChartLine = CreateClassAndSelector(\"chart-line\");\n                Selectors.Body = CreateClassAndSelector(\"gantt-body\");\n                Selectors.AxisGroup = CreateClassAndSelector(\"axis\");\n                Selectors.Domain = CreateClassAndSelector(\"domain\");\n                Selectors.AxisTick = CreateClassAndSelector(\"tick\");\n                Selectors.Tasks = CreateClassAndSelector(\"tasks\");\n                Selectors.SingleTask = CreateClassAndSelector(\"task\");\n                Selectors.TaskRect = CreateClassAndSelector(\"task-rect\");\n                Selectors.TaskProgress = CreateClassAndSelector(\"task-progress\");\n                Selectors.TaskResource = CreateClassAndSelector(\"task-resource\");\n                Selectors.SingleMilestone = CreateClassAndSelector(\"milestone\");\n                Selectors.TaskLabels = CreateClassAndSelector(\"task-labels\");\n                Selectors.TaskLines = CreateClassAndSelector(\"task-lines\");\n                Selectors.SingleTaskLine = CreateClassAndSelector(\"task-line\");\n                Selectors.Label = CreateClassAndSelector(\"label\");\n                Selectors.LegendItems = CreateClassAndSelector(\"legendItem\");\n                Selectors.LegendTitle = CreateClassAndSelector(\"legendTitle\");\n            })(Selectors || (Selectors = {}));\n            var Gantt = (function () {\n                function Gantt() {\n                    this.textProperties = {\n                        fontFamily: 'wf_segoe-ui_normal',\n                        fontSize: jsCommon.PixelConverter.toString(9),\n                    };\n                    this.margin = {\n                        top: 50,\n                        right: 40,\n                        bottom: 40,\n                        left: 10\n                    };\n                }\n                Gantt.getMaxTaskOpacity = function () {\n                    return Gantt.DefaultValues.MaxTaskOpacity;\n                };\n                Gantt.getMinTaskOpacity = function () {\n                    return Gantt.DefaultValues.MinTaskOpacity;\n                };\n                Gantt.prototype.init = function (options) {\n                    var element = options.element;\n                    this.style = options.style;\n                    this.body = d3.select(element.get(0));\n                    this.hostServices = options.host;\n                    this.selectionManager = new SelectionManager({ hostServices: options.host });\n                    this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;\n                    this.interactivityService = visuals.createInteractivityService(this.hostServices);\n                    this.createViewport(element);\n                    this.updateChartSize(options.viewport);\n                    this.behavior = new GanttChartBehavior();\n                    this.colors = options.style.colorPalette.dataColors;\n                    this.data = {\n                        legendData: null,\n                        series: null,\n                        showLegend: null\n                    };\n                };\n                /**\n                 * Create the vieport area of the gantt chart\n                 */\n                Gantt.prototype.createViewport = function (element) {\n                    //create div container to the whole viewport area\n                    this.ganttDiv = this.body.append(\"div\")\n                        .classed(Selectors.Body.class, true);\n                    //create container to the svg area\n                    this.ganttSvg = this.ganttDiv\n                        .append(\"svg\")\n                        .classed(Selectors.ClassName.class, true);\n                    //create clear catcher\n                    this.clearCatcher = visuals.appendClearCatcher(this.ganttSvg);\n                    //create axis container\n                    this.axisGroup = this.ganttSvg\n                        .append(\"g\")\n                        .classed(Selectors.AxisGroup.class, true);\n                    //create task lines container\n                    this.lineGroup = this.ganttSvg\n                        .append(\"g\")\n                        .classed(Selectors.TaskLines.class, true);\n                    //create chart container\n                    this.chartGroup = this.ganttSvg\n                        .append(\"g\")\n                        .classed(Selectors.Chart.class, true);\n                    //create tasks container\n                    this.taskGroup = this.chartGroup\n                        .append(\"g\")\n                        .classed(Selectors.Tasks.class, true);\n                    //create legend container\n                    this.legend = visuals.createLegend(element.children(Selectors.Body.selector), this.isInteractiveChart, this.interactivityService, true, visuals.LegendPosition.Top);\n                };\n                /**\n                 * Clear the viewport area\n                 */\n                Gantt.prototype.clearViewport = function () {\n                    this.body.selectAll(Selectors.LegendItems.selector).remove();\n                    this.body.selectAll(Selectors.LegendTitle.selector).remove();\n                    this.axisGroup.selectAll(Selectors.AxisTick.selector).remove();\n                    this.axisGroup.selectAll(Selectors.Domain.selector).remove();\n                    this.lineGroup.selectAll(\"*\").remove();\n                    this.chartGroup.selectAll(Selectors.ChartLine.selector).remove();\n                    this.chartGroup.selectAll(Selectors.SingleTask.selector).remove();\n                };\n                /**\n                 * Update div container size to the whole viewport area\n                 * @param viewport The vieport to change it size\n                 */\n                Gantt.prototype.updateChartSize = function (viewport) {\n                    this.ganttDiv.style({\n                        height: PixelConverter.toString(viewport.height),\n                        width: PixelConverter.toString(viewport.width)\n                    });\n                };\n                /**\n               * Create the gantt tasks series based on all task types\n               * @param taskTypes All unique types from the tasks array.\n               */\n                Gantt.prototype.createSeries = function (objects, tasks) {\n                    var colorHelper = new visuals.ColorHelper(this.colors, samples.GanttChartProps.dataPoint.fill);\n                    var taskGroup = _.groupBy(tasks, function (t) { return t.taskType; });\n                    var taskTypes = Gantt.getAllTasksTypes(this.dataView);\n                    var series = _.map(taskTypes.types, function (type) {\n                        return {\n                            tasks: taskGroup[type],\n                            fill: colorHelper.getColorForMeasure(objects, type),\n                            name: type,\n                            identity: visuals.SelectionId.createWithMeasure(type),\n                            selected: false\n                        };\n                    });\n                    return series;\n                };\n                /**\n                * Convert the dataView to view model\n                * @param dataView The data Model\n                */\n                Gantt.converter = function (dataView, colorPalette) {\n                    var taskLabelsShow = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.show, true);\n                    var taskLabelsColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor);\n                    var taskLabelsFontSize = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize);\n                    var taskLabelsWidth = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.width, taskLabelsShow ? Gantt.DefaultValues.TaskLabelWidth : 0);\n                    var taskProgressColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor);\n                    var taskResourceColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor);\n                    var taskResourceFontSize = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize);\n                    var taskResourceShow = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskResource.show, true);\n                    var dateType = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.ganttDateType.type, samples.DefaultDateType);\n                    var taskTypes = Gantt.getAllTasksTypes(dataView);\n                    var colorHelper = new visuals.ColorHelper(colorPalette, samples.GanttChartProps.dataPoint.fill);\n                    var legendData = {\n                        fontSize: Gantt.DefaultValues.LegendFontSize,\n                        dataPoints: [],\n                        title: taskTypes.typeName\n                    };\n                    legendData.dataPoints = _.map(taskTypes.types, function (type) {\n                        return {\n                            label: type,\n                            color: colorHelper.getColorForMeasure(dataView.metadata.objects, type),\n                            icon: visuals.LegendIcon.Circle,\n                            selected: false,\n                            identity: visuals.SelectionId.createWithMeasure(type)\n                        };\n                    });\n                    var settings = {\n                        taskLabelsShow: taskLabelsShow,\n                        taskLabelsColor: taskLabelsColor,\n                        taskLabelsFontSize: taskLabelsFontSize,\n                        taskLabelsWidth: taskLabelsWidth,\n                        taskProgressColor: taskProgressColor,\n                        taskResourceShow: taskResourceShow,\n                        taskResourceColor: taskResourceColor,\n                        taskResourceFontSize: taskResourceFontSize,\n                        legendData: legendData,\n                        taskTypes: taskTypes,\n                        dateType: dateType\n                    };\n                    return settings;\n                };\n                /**\n                 * Returns the chart formatters\n                 * @param dataView The data Model\n                 */\n                Gantt.prototype.parseSettings = function (dataView) {\n                    if (!dataView ||\n                        !dataView.metadata ||\n                        !dataView.metadata.columns)\n                        return null;\n                    var dateFormat = \"d\";\n                    var numberFormat = \"#\";\n                    for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {\n                        var dvColumn = _a[_i];\n                        if (!!dataView.categorical.categories) {\n                            for (var _b = 0, _c = dataView.categorical.categories; _b < _c.length; _b++) {\n                                var dvCategory = _c[_b];\n                                if (this.hasRole(dvCategory.source, \"StartDate\"))\n                                    dateFormat = dvColumn.format;\n                            }\n                        }\n                    }\n                    return {\n                        startDateFormatter: visuals.valueFormatter.create({ format: dateFormat }),\n                        durationFormatter: visuals.valueFormatter.create({ format: numberFormat }),\n                        completionFormatter: visuals.valueFormatter.create({ format: PercentFormat, value: 1, allowFormatBeautification: true })\n                    };\n                };\n                Gantt.prototype.isValidDate = function (date) {\n                    if (Object.prototype.toString.call(date) !== \"[object Date]\")\n                        return false;\n                    return !isNaN(date.getTime());\n                };\n                Gantt.prototype.convertToDecimal = function (number) {\n                    if (!(number >= 0 && number <= 1))\n                        return (number / 100);\n                    return number;\n                };\n                /**\n                * Create task objects dataView\n                * @param dataView The data Model.\n                * @param formatters task attributes represented format.\n                * @param series An array that holds the color data of different task groups.\n                */\n                Gantt.prototype.createTasks = function (dataView, formatters) {\n                    var _this = this;\n                    var columnSource = dataView.table.columns;\n                    var data = dataView.table.rows;\n                    var categories = dataView.categorical.categories[0];\n                    var colorHelper = new visuals.ColorHelper(this.colors, samples.GanttChartProps.dataPoint.fill);\n                    return data.map(function (child, index) {\n                        var dateString = _this.getTaskProperty(columnSource, child, \"StartDate\");\n                        //let startDate = new Date(dateString);\n                        dateString = _this.isValidDate(dateString) ? dateString : new Date(Date.now());\n                        var duration = _this.getTaskProperty(columnSource, child, \"Duration\");\n                        var completionValue = _this.getTaskProperty(columnSource, child, \"Completion\");\n                        var completion = _this.convertToDecimal(completionValue);\n                        completion = completion <= 1 ? completion : 1;\n                        var taskType = _this.getTaskProperty(columnSource, child, \"Legend\");\n                        var tasksTypeColor = colorHelper.getColorForMeasure(dataView.metadata.objects, taskType);\n                        var task = {\n                            id: index,\n                            name: _this.getTaskProperty(columnSource, child, \"Task\"),\n                            start: dateString ? dateString : new Date(Date.now()),\n                            duration: duration > 0 ? duration : 1,\n                            end: null,\n                            completion: completion > 0 ? completion : 0,\n                            resource: _this.getTaskProperty(columnSource, child, \"Resource\"),\n                            taskType: taskType,\n                            color: tasksTypeColor ? tasksTypeColor : Gantt.DefaultValues.TaskColor,\n                            tooltipInfo: null,\n                            description: \"\",\n                            identity: visuals.SelectionId.createWithIdAndMeasure(categories.identity[index], taskType),\n                            selected: false\n                        };\n                        task.end = d3.time.day.offset(task.start, task.duration);\n                        task.tooltipInfo = _this.getTooltipInfo(task, formatters);\n                        return task;\n                    });\n                };\n                /**\n                * Gets all unique types from the tasks array\n                * @param dataView The data model.\n                */\n                Gantt.getAllTasksTypes = function (dataView) {\n                    var types = [];\n                    var groupName = \"\";\n                    var taskTypes;\n                    var data = dataView.table.rows;\n                    var index = _.findIndex(dataView.table.columns, function (col) { return col.roles.hasOwnProperty(\"Legend\"); });\n                    if (index !== -1) {\n                        groupName = dataView.table.columns[index].displayName;\n                        types = _.unique(data, function (d) { return d[index]; }).map(function (d) { return d[index]; });\n                    }\n                    taskTypes = {\n                        typeName: groupName,\n                        types: types\n                    };\n                    return taskTypes;\n                };\n                /**\n                * Get the tooltip info (data display names & formated values)\n                * @param task All task attributes.\n                * @param formatters Formatting options for gantt attributes.\n                */\n                Gantt.prototype.getTooltipInfo = function (task, formatters, timeInterval) {\n                    if (timeInterval === void 0) { timeInterval = \"Days\"; }\n                    var tooltipDataArray = [];\n                    if (task.taskType)\n                        tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[0].name, value: task.taskType });\n                    tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[1].name, value: task.name });\n                    if (!isNaN(task.start.getDate()))\n                        tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[2].name, value: formatters.startDateFormatter.format(task.start.toLocaleDateString()) });\n                    tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[3].name, value: formatters.durationFormatter.format(task.duration) + \" \" + timeInterval });\n                    tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[4].name, value: formatters.completionFormatter.format(task.completion) });\n                    if (task.resource)\n                        tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[5].name, value: task.resource });\n                    return tooltipDataArray;\n                };\n                /**\n                 * Get task property from the data view\n                 * @param columnSource\n                 * @param child\n                 * @param propertyName The property to get\n                 */\n                Gantt.prototype.getTaskProperty = function (columnSource, child, propertyName) {\n                    if (!child ||\n                        !columnSource ||\n                        !(columnSource.length > 0) ||\n                        !columnSource[0].roles)\n                        return null;\n                    var index = columnSource.indexOf(columnSource.filter(function (x) { return x.roles[propertyName]; })[0]);\n                    return index !== -1 ? child[index] : null;\n                };\n                /**\n                 * Check if dataView has a given role\n                 * @param column The dataView headers\n                 * @param name The role to find\n                 */\n                Gantt.prototype.hasRole = function (column, name) {\n                    var roles = column.roles;\n                    return roles && roles[name];\n                };\n                /**\n                 * Check if task has data for task\n                 * @param dataView\n                 */\n                Gantt.prototype.isChartHasTask = function (dataView) {\n                    if (dataView.table &&\n                        dataView.table.columns) {\n                        for (var _i = 0, _a = dataView.table.columns; _i < _a.length; _i++) {\n                            var column = _a[_i];\n                            if (this.hasRole(column, \"Task\")) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                };\n                /**\n                 * Get legend data, calculate position and draw it\n                 * @param ganttChartData Data for series and legend\n                 */\n                Gantt.prototype.renderLegend = function (legendData) {\n                    if (!legendData)\n                        return;\n                    if (this.legendObjectProperties) {\n                        visuals.LegendData.update(legendData, this.legendObjectProperties);\n                        var position;\n                        position = this.legendObjectProperties[visuals.legendProps.position];\n                        if (position)\n                            this.legend.changeOrientation(visuals.LegendPosition[position]);\n                    }\n                    var viewport = this.viewport;\n                    this.legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });\n                    visuals.Legend.positionChartArea(this.ganttSvg, this.legend);\n                };\n                Gantt.prototype.parseLegendProperties = function (dataView) {\n                    if (!dataView || !dataView.metadata) {\n                        this.legendObjectProperties = {};\n                        return;\n                    }\n                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'legend', {});\n                };\n                /**\n                * Called on data change or resizing\n                * @param options The visual option that contains the dataview and the viewport\n                */\n                Gantt.prototype.update = function (options) {\n                    if (!options.dataViews || !options.dataViews[0])\n                        return;\n                    var dataView = options.dataViews[0];\n                    if (!this.isChartHasTask(dataView) || options.dataViews[0].table.rows.length === 0) {\n                        this.clearViewport();\n                        return;\n                    }\n                    this.dataView = dataView;\n                    var viewport = options.viewport;\n                    this.viewport = viewport;\n                    this.updateChartSize(viewport);\n                    var viewModel = Gantt.converter(dataView, this.colors), formatters = this.parseSettings(dataView), tasks = this.createTasks(dataView, formatters);\n                    this.parseLegendProperties(dataView);\n                    this.renderLegend(viewModel.legendData);\n                    this.data.series = this.createSeries(dataView.metadata.objects, tasks);\n                    this.viewModel = viewModel;\n                    if (this.interactivityService) {\n                        this.interactivityService.applySelectionStateToData(tasks);\n                        this.interactivityService.applySelectionStateToData(this.data.series);\n                    }\n                    if (tasks.length > 0) {\n                        var tasksSortedByStartDate = _.sortBy(tasks, function (t) { return t.start; });\n                        var tasksSortedByEndDate = _.sortBy(tasks, function (t) { return t.end; });\n                        var dateTypeMilliseconds = this.getDateType();\n                        var startDate = tasksSortedByStartDate[0].start, endDate = tasksSortedByEndDate[tasks.length - 1].end, ticks = Math.ceil(Math.round(endDate.valueOf() - startDate.valueOf()) / dateTypeMilliseconds);\n                        ticks = ticks === 0 || ticks === 1 ? 2 : ticks;\n                        var axisLength = ticks * 50;\n                        this.ganttSvg\n                            .attr({\n                            height: PixelConverter.toString(tasks.length * ChartLineHeight + this.margin.top),\n                            width: PixelConverter.toString(this.margin.left + this.viewModel.taskLabelsWidth + axisLength + Gantt.DefaultValues.ResourceWidth)\n                        });\n                        var viewportIn = {\n                            height: viewport.height,\n                            width: axisLength\n                        };\n                        var xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, startDate, endDate, axisLength, ticks, false);\n                        this.timeScale = xAxisProperties.scale;\n                        this.renderAxis(xAxisProperties, 200);\n                        this.renderTasks(tasks);\n                        this.createMilestoneLine(tasks);\n                        this.updateTaskLabels(tasks, viewModel.taskLabelsWidth);\n                        this.updateElementsPositions(viewport, this.margin);\n                        if (this.interactivityService) {\n                            var behaviorOptions = {\n                                clearCatcher: this.clearCatcher,\n                                taskSelection: this.taskGroup.selectAll(Selectors.SingleTask.selector),\n                                legendSelection: this.body.selectAll(Selectors.LegendItems.selector),\n                                interactivityService: this.interactivityService\n                            };\n                            this.interactivityService.bind(tasks, this.behavior, behaviorOptions);\n                        }\n                    }\n                };\n                Gantt.prototype.getDateType = function () {\n                    var milliSeconds = MillisecondsInWeek;\n                    switch (this.viewModel.dateType) {\n                        case \"Day\":\n                            milliSeconds = MillisecondsInADay;\n                            break;\n                        case \"Week\":\n                            milliSeconds = MillisecondsInWeek;\n                            break;\n                        case \"Month\":\n                            milliSeconds = MillisecondsInAMonth;\n                            break;\n                        case \"Year\":\n                            milliSeconds = MillisecondsInAYear;\n                            break;\n                    }\n                    return milliSeconds;\n                };\n                Gantt.prototype.calculateAxes = function (viewportIn, textProperties, startDate, endDate, axisLength, ticksCount, scrollbarVisible) {\n                    var dataTypeDatetime = powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Date);\n                    var category = { displayName: \"StartDate\", queryName: \"StartDate\", type: dataTypeDatetime, index: 0 };\n                    var visualOptions = {\n                        viewport: viewportIn,\n                        margin: this.margin,\n                        forcedXDomain: [startDate, endDate],\n                        forceMerge: false,\n                        showCategoryAxisLabel: false,\n                        showValueAxisLabel: false,\n                        categoryAxisScaleType: powerbi.visuals.axisScale.linear,\n                        valueAxisScaleType: null,\n                        valueAxisDisplayUnits: 0,\n                        categoryAxisDisplayUnits: 0,\n                        trimOrdinalDataOnOverflow: false,\n                        forcedTickCount: ticksCount\n                    };\n                    var width = viewportIn.width;\n                    var axes = this.calculateAxesProperties(viewportIn, visualOptions, axisLength, category);\n                    axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);\n                    // If labels do not fit and we are not scrolling, try word breaking\n                    axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);\n                    return axes;\n                };\n                Gantt.prototype.calculateAxesProperties = function (viewportIn, options, axisLength, metaDataColumn) {\n                    var xAxisProperties = visuals.AxisHelper.createAxis({\n                        pixelSpan: viewportIn.width,\n                        dataDomain: options.forcedXDomain,\n                        metaDataColumn: metaDataColumn,\n                        formatString: Gantt.DefaultValues.ganttFormatString,\n                        outerPadding: 0,\n                        isScalar: true,\n                        isVertical: false,\n                        forcedTickCount: options.forcedTickCount,\n                        useTickIntervalForDisplayUnits: true,\n                        isCategoryAxis: true,\n                        getValueFn: function (index, type) {\n                            return visuals.valueFormatter.format(new Date(index), Gantt.DefaultValues.ganttFormatString);\n                        },\n                        scaleType: options.categoryAxisScaleType,\n                        axisDisplayUnits: options.categoryAxisDisplayUnits,\n                    });\n                    xAxisProperties.axisLabel = metaDataColumn.displayName;\n                    return xAxisProperties;\n                };\n                Gantt.prototype.renderAxis = function (xAxisProperties, duration) {\n                    var xAxis = xAxisProperties.axis;\n                    xAxis.orient('bottom');\n                    this.axisGroup.transition().duration(duration).call(xAxis);\n                };\n                /**\n                * Update task labels and add its tooltips\n                * @param tasks All tasks array\n                * @param width The task label width\n                */\n                Gantt.prototype.updateTaskLabels = function (tasks, width) {\n                    var _this = this;\n                    var axisLabel;\n                    var taskLineCoordinateX = 15;\n                    var taskLabelsShow = this.viewModel ? this.viewModel.taskLabelsShow : true;\n                    var taskLabelsColor = this.viewModel ? this.viewModel.taskLabelsColor : Gantt.DefaultValues.TaskLabelColor;\n                    var taskLabelsFontSize = this.viewModel ? this.viewModel.taskLabelsFontSize : Gantt.DefaultValues.LabelFontSize;\n                    if (taskLabelsShow) {\n                        axisLabel = this.lineGroup.selectAll(Selectors.Label.selector).data(tasks);\n                        axisLabel.enter().append(\"text\").classed(Selectors.Label.class, true);\n                        axisLabel.attr({\n                            x: taskLineCoordinateX,\n                            y: function (task, i) { return _this.getTaskLabelCoordinateY(task.id); },\n                            fill: taskLabelsColor,\n                            \"stroke-width\": 1\n                        })\n                            .style(\"font-size\", PixelConverter.fromPoint(taskLabelsFontSize))\n                            .text(function (task) { return task.name; });\n                        axisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width - 20, powerbi.TextMeasurementService.svgEllipsis);\n                        axisLabel.append(\"title\").text(function (task) { return task.name; });\n                        axisLabel.exit().remove();\n                    }\n                    else {\n                        this.lineGroup.selectAll(Selectors.Label.selector).remove();\n                    }\n                };\n                Gantt.prototype.renderTasks = function (tasks) {\n                    var _this = this;\n                    var taskSelection = this.taskGroup.selectAll(Selectors.SingleTask.selector).data(tasks);\n                    var taskProgressColor = this.viewModel ? this.viewModel.taskProgressColor : Gantt.DefaultValues.ProgressColor;\n                    var taskResourceShow = this.viewModel ? this.viewModel.taskResourceShow : true;\n                    var padding = 4;\n                    var taskResourceColor = this.viewModel ? this.viewModel.taskResourceColor : Gantt.DefaultValues.TaskResourceColor;\n                    var taskResourceFontSize = this.viewModel ? this.viewModel.taskResourceFontSize : Gantt.DefaultValues.ResourceFontSize;\n                    //render task group container \n                    taskSelection.enter().append(\"g\").classed(Selectors.SingleTask.class, true);\n                    //render task main rect\n                    var taskRect = taskSelection.selectAll(Selectors.TaskRect.selector).data(function (d) { return [d]; });\n                    taskRect.enter().append(\"rect\").classed(Selectors.TaskRect.class, true);\n                    taskRect.classed(Selectors.TaskRect.class, true).attr({\n                        x: function (task) { return _this.timeScale(task.start); },\n                        y: function (task) { return _this.getBarYCoordinate(task.id); },\n                        width: function (task) { return _this.taskDurationToWidth(task); },\n                        height: function () { return _this.getBarHeight(); }\n                    }).style(\"fill\", function (task) { return task.color; });\n                    taskRect.exit().remove();\n                    //render task progress rect \n                    var taskProgress = taskSelection.selectAll(Selectors.TaskProgress.selector).data(function (d) { return [d]; });\n                    taskProgress.enter().append(\"rect\").classed(Selectors.TaskProgress.class, true);\n                    taskProgress.attr({\n                        x: function (task) { return _this.timeScale(task.start); },\n                        y: function (task) { return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 - Gantt.DefaultValues.ProgressBarHeight / 2; },\n                        width: function (task) { return _this.setTaskProgress(task); },\n                        height: Gantt.DefaultValues.ProgressBarHeight\n                    }).style(\"fill\", taskProgressColor);\n                    taskProgress.exit().remove();\n                    if (taskResourceShow) {\n                        //render task resource labels\n                        var taskResource = taskSelection.selectAll(Selectors.TaskResource.selector).data(function (d) { return [d]; });\n                        taskResource.enter().append(\"text\").classed(Selectors.TaskResource.class, true);\n                        taskResource.attr({\n                            x: function (task) { return _this.timeScale(task.end) + padding; },\n                            y: function (task) { return (_this.getBarYCoordinate(task.id) + (_this.getBarHeight() / 2) + padding); }\n                        })\n                            .text(function (task) { return task.resource; })\n                            .style({\n                            fill: taskResourceColor,\n                            \"font-size\": PixelConverter.fromPoint(taskResourceFontSize)\n                        }).call(visuals.AxisHelper.LabelLayoutStrategy.clip, Gantt.DefaultValues.ResourceWidth - 10, powerbi.TextMeasurementService.svgEllipsis);\n                        taskResource.exit().remove();\n                    }\n                    else {\n                        taskSelection.selectAll(Selectors.TaskResource.selector).remove();\n                    }\n                    visuals.TooltipManager.addTooltip(taskSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });\n                    taskSelection.exit().remove();\n                };\n                Gantt.prototype.onClearSelection = function () {\n                    this.selectionManager.clear();\n                };\n                /**\n                 * Returns the matching Y coordinate for a given task index\n                 * @param taskIndex Task Number\n                 */\n                Gantt.prototype.getTaskLabelCoordinateY = function (taskIndex) {\n                    var fontSize = +this.getTaskLabelFontSize();\n                    return (ChartLineHeight * taskIndex) + (this.getBarHeight() + 5 - (40 - fontSize) / 4);\n                };\n                /**\n                 * Set the task progress bar in the gantt\n                 * @param task All task attributes\n                 */\n                Gantt.prototype.setTaskProgress = function (task) {\n                    var fraction = task.completion / 1.0, y = this.timeScale, progress = (y(task.end) - y(task.start)) * fraction;\n                    return progress;\n                };\n                /**\n                 * Set the task progress bar in the gantt\n                 * @param lineNumber Line number that represents the task number\n                 */\n                Gantt.prototype.getBarYCoordinate = function (lineNumber) {\n                    return (ChartLineHeight * lineNumber) + (PaddingTasks);\n                };\n                Gantt.prototype.getBarHeight = function () {\n                    return ChartLineHeight / 1.5;\n                };\n                /**\n                * convert task duration to width in the time scale\n                * @param task The task to convert\n                */\n                Gantt.prototype.taskDurationToWidth = function (task) {\n                    return this.timeScale(task.end) - this.timeScale(task.start);\n                };\n                Gantt.prototype.getTooltipForMilstoneLine = function (timestamp, milestoneTitle) {\n                    var stringDate = new Date(timestamp).toDateString();\n                    var tooltip = [{ displayName: milestoneTitle, value: stringDate }];\n                    return tooltip;\n                };\n                /**\n                * Create vertical dotted line that represent milestone in the time axis (by default it shows not time)\n                * @param tasks All tasks array\n                * @param timestamp the milestone to be shown in the time axis (default Date.now())\n                */\n                Gantt.prototype.createMilestoneLine = function (tasks, milestoneTitle, timestamp) {\n                    if (milestoneTitle === void 0) { milestoneTitle = \"Today\"; }\n                    if (timestamp === void 0) { timestamp = Date.now(); }\n                    var line = [{\n                            x1: this.timeScale(timestamp),\n                            y1: 0,\n                            x2: this.timeScale(timestamp),\n                            y2: this.getMilestoneLineLength(tasks.length),\n                            tooltipInfo: this.getTooltipForMilstoneLine(timestamp, milestoneTitle)\n                        }];\n                    var chartLineSelection = this.chartGroup.selectAll(Selectors.ChartLine.selector).data(line);\n                    chartLineSelection.enter().append(\"line\").classed(Selectors.ChartLine.class, true);\n                    chartLineSelection.attr({\n                        x1: function (line) { return line.x1; },\n                        y1: function (line) { return line.y1; },\n                        x2: function (line) { return line.x2; },\n                        y2: function (line) { return line.y2; },\n                        tooltipInfo: function (line) { return line.tooltipInfo; }\n                    });\n                    visuals.TooltipManager.addTooltip(chartLineSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });\n                    chartLineSelection.exit().remove();\n                };\n                Gantt.prototype.updateElementsPositions = function (viewport, margin) {\n                    var viewModel = this.viewModel;\n                    this.axisGroup.attr(\"transform\", visuals.SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, 15));\n                    this.chartGroup.attr(\"transform\", visuals.SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, margin.top));\n                    this.lineGroup.attr(\"transform\", visuals.SVGUtil.translate(0, margin.top));\n                };\n                /**\n                 * Returns the width of the now line based on num of tasks\n                 * @param numOfTasks Number of tasks\n                 */\n                Gantt.prototype.getMilestoneLineLength = function (numOfTasks) {\n                    return numOfTasks * ChartLineHeight;\n                };\n                Gantt.prototype.getTaskLabelFontSize = function () {\n                    return powerbi.DataViewObjects.getValue(this.dataView.metadata.objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize);\n                };\n                /**\n                 * handle \"Legend\" card\n                 * @param enumeration The instance to be pushed into \"Legend\" card\n                 * @param objects Dataview objects\n                 */\n                Gantt.prototype.enumerateLegendOptions = function (enumeration, objects) {\n                    enumeration.pushInstance({\n                        displayName: samples.GanttChartProps.legend.show.objectName,\n                        selector: null,\n                        properties: {\n                            show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.show, true),\n                            position: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.position, true),\n                            showTitle: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.showTitle, true),\n                            titleText: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.titleText, \"\"),\n                            labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.legend.labelColor, Gantt.DefaultValues.LegendLabelColor),\n                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.fontSize, Gantt.DefaultValues.LegendFontSize)\n                        },\n                        objectName: samples.GanttChartProps.legend.show.objectName\n                    });\n                };\n                /**\n                * handle \"Data Colors\" card\n                * @param enumeration The instance to be pushed into \"Data Colors\" card\n                * @param objects Dataview objects\n                */\n                Gantt.prototype.enumerateDataPoints = function (enumeration, objects) {\n                    var taskSeries = this.data.series;\n                    taskSeries.forEach(function (item) {\n                        enumeration.pushInstance({\n                            objectName: 'dataPoint',\n                            displayName: item.name,\n                            selector: visuals.ColorHelper.normalizeSelector(item.identity.getSelector(), false),\n                            properties: {\n                                fill: { solid: { color: item.fill } }\n                            }\n                        });\n                    });\n                };\n                /**\n                * handle \"Task Completion\" card\n                * @param enumeration The instance to be pushed into \"Task Completion\" card\n                * @param objects Dataview objects\n                */\n                Gantt.prototype.enumerateTaskCompletion = function (enumeration, objects) {\n                    enumeration.pushInstance({\n                        selector: null,\n                        properties: {\n                            fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor)\n                        },\n                        objectName: samples.GanttChartProps.taskCompletion.fill.objectName\n                    });\n                };\n                /**\n                * handle \"Labels\" card\n                * @param enumeration The instance to be pushed into \"Data Labels\" card\n                * @param objects Dataview objects\n                */\n                Gantt.prototype.enumerateTaskLabels = function (enumeration, objects) {\n                    enumeration.pushInstance({\n                        selector: null,\n                        properties: {\n                            show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.show, true),\n                            fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor),\n                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize),\n                            width: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.width, Gantt.DefaultValues.TaskLabelWidth),\n                        },\n                        objectName: samples.GanttChartProps.taskLabels.show.objectName\n                    });\n                };\n                /**\n                * handle \"Data Labels\" card\n                * @param enumeration The instance to be pushed into \"Task Resource\" card\n                * @param objects Dataview objects\n                */\n                Gantt.prototype.enumerateDataLabels = function (enumeration, objects) {\n                    enumeration.pushInstance({\n                        selector: null,\n                        properties: {\n                            show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskResource.show, true),\n                            fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor),\n                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize)\n                        },\n                        objectName: samples.GanttChartProps.taskResource.show.objectName\n                    });\n                };\n                Gantt.prototype.enumerateDateType = function (enumeration, objects) {\n                    enumeration.pushInstance({\n                        selector: null,\n                        properties: {\n                            type: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.ganttDateType.type, samples.DefaultDateType),\n                        },\n                        objectName: samples.GanttChartProps.ganttDateType.type.objectName\n                    });\n                };\n                /**\n                * handle the property pane options\n                * @param objects Dataview enumerate objects\n                */\n                Gantt.prototype.enumerateObjectInstances = function (options) {\n                    var dataView = this.dataView;\n                    if (!dataView)\n                        return;\n                    var enumeration = new visuals.ObjectEnumerationBuilder();\n                    switch (options.objectName) {\n                        case 'legend':\n                            this.enumerateLegendOptions(enumeration, dataView.metadata.objects);\n                            break;\n                        case 'dataPoint':\n                            this.enumerateDataPoints(enumeration, dataView.metadata.objects);\n                            break;\n                        case 'taskLabels':\n                            this.enumerateTaskLabels(enumeration, dataView.metadata.objects);\n                            break;\n                        case 'taskCompletion':\n                            this.enumerateTaskCompletion(enumeration, dataView.metadata.objects);\n                            break;\n                        case 'taskResource':\n                            this.enumerateDataLabels(enumeration, dataView.metadata.objects);\n                            break;\n                        case 'ganttDateType':\n                            this.enumerateDateType(enumeration, dataView.metadata.objects);\n                            break;\n                    }\n                    return enumeration.complete();\n                };\n                Gantt.DefaultValues = {\n                    AxisTickSize: 6,\n                    LabelFontSize: 9,\n                    LegendFontSize: 8,\n                    LegendLabelColor: \"#000000\",\n                    MaxTaskOpacity: 1,\n                    MinTaskOpacity: 0.4,\n                    ProgressBarHeight: 4,\n                    ProgressColor: \"#000000\",\n                    ResourceFontSize: 9,\n                    ResourceWidth: 100,\n                    TaskColor: \"#00B099\",\n                    TaskLabelColor: \"#000000\",\n                    TaskLabelWidth: 110,\n                    TaskLineWidth: 15,\n                    TaskResourceColor: \"#000000\",\n                    ganttFormatString: \"MMM dd\"\n                };\n                Gantt.capabilities = {\n                    dataRoles: [\n                        {\n                            name: \"Legend\",\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: \"Legend\",\n                        }, {\n                            name: \"Task\",\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: \"Task\"\n                        }, {\n                            name: \"StartDate\",\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: \"Start Date\",\n                        }, {\n                            name: \"Duration\",\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: \"Duration\",\n                            requiredTypes: [{ numeric: true }, { integer: true }]\n                        }, {\n                            name: \"Completion\",\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: \"% Completion\",\n                            requiredTypes: [{ numeric: true }, { integer: true }]\n                        }, {\n                            name: \"Resource\",\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: \"Resource\"\n                        }\n                    ],\n                    dataViewMappings: [{\n                            conditions: [\n                                {\n                                    \"Legend\": { min: 0, max: 1 },\n                                    \"Task\": { min: 1, max: 1 },\n                                    \"StartDate\": { min: 0, max: 0 },\n                                    \"Duration\": { min: 0, max: 0 },\n                                    \"Completion\": { min: 0, max: 0 },\n                                    \"Resource\": { min: 0, max: 0 }\n                                }, {\n                                    \"Legend\": { min: 0, max: 1 },\n                                    \"Task\": { min: 1, max: 1 },\n                                    \"StartDate\": { min: 0, max: 1 },\n                                    \"Duration\": { min: 0, max: 0 },\n                                    \"Completion\": { min: 0, max: 0 },\n                                    \"Resource\": { min: 0, max: 0 }\n                                }, {\n                                    \"Legend\": { min: 0, max: 1 },\n                                    \"Task\": { min: 0, max: 1 },\n                                    \"StartDate\": { min: 0, max: 1 },\n                                    \"Duration\": { min: 0, max: 1 },\n                                    \"Completion\": { min: 0, max: 1 },\n                                    \"Resource\": { min: 0, max: 1 },\n                                }\n                            ],\n                            table: {\n                                rows: {\n                                    select: [\n                                        { for: { in: \"Legend\" } },\n                                        { for: { in: \"Task\" } },\n                                        { for: { in: \"StartDate\" } },\n                                        { for: { in: \"Duration\" } },\n                                        { for: { in: \"Completion\" } },\n                                        { for: { in: \"Resource\" } },\n                                    ]\n                                },\n                            },\n                        }],\n                    sorting: {\n                        default: {},\n                    },\n                    objects: {\n                        legend: {\n                            displayName: \"Legend\",\n                            description: \"Display legend options\",\n                            properties: {\n                                show: {\n                                    displayName: \"Show\",\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: \"Position\",\n                                    description: \"Select the location for the legend\",\n                                    type: { enumeration: visuals.legendPosition.type }\n                                },\n                                showTitle: {\n                                    displayName: \"Title\",\n                                    description: \"Display a title for legend symbols\",\n                                    type: { bool: true }\n                                },\n                                titleText: {\n                                    displayName: \"Legend Name\",\n                                    description: \"Title text\",\n                                    type: { text: true },\n                                    suppressFormatPainterCopy: true\n                                },\n                                labelColor: {\n                                    displayName: \"Color\",\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: \"Text Size\",\n                                    type: { formatting: { fontSize: true } }\n                                }\n                            }\n                        },\n                        //dataPoint: {\n                        //    displayName: \"Data colors\",\n                        //    properties: {\n                        //        fill: {\n                        //            displayName: \"Fill\",\n                        //            type: { fill: { solid: { color: true } } }\n                        //        }\n                        //    }\n                        //},\n                        taskLabels: {\n                            displayName: 'Category Labels',\n                            properties: {\n                                show: {\n                                    displayName: \"Show\",\n                                    type: { bool: true }\n                                },\n                                fill: {\n                                    displayName: 'Fill',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: 'Font Size',\n                                    type: { formatting: { fontSize: true } }\n                                },\n                                width: {\n                                    displayName: 'Width',\n                                    type: { numeric: true }\n                                }\n                            }\n                        },\n                        taskCompletion: {\n                            displayName: 'Task Completion',\n                            properties: {\n                                show: {\n                                    type: { bool: true }\n                                },\n                                fill: {\n                                    displayName: 'Completion Color',\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        taskResource: {\n                            displayName: 'Data Labels',\n                            properties: {\n                                show: {\n                                    displayName: \"Show\",\n                                    type: { bool: true }\n                                },\n                                fill: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: 'Font Size',\n                                    type: { formatting: { fontSize: true } }\n                                }\n                            }\n                        },\n                        ganttDateType: {\n                            displayName: 'Gantt Date Type',\n                            properties: {\n                                type: {\n                                    displayName: \"Type\",\n                                    type: { enumeration: dateTypeSelector.type }\n                                },\n                            }\n                        },\n                    }\n                };\n                return Gantt;\n            }());\n            samples.Gantt = Gantt;\n            var GanttChartBehavior = (function () {\n                function GanttChartBehavior() {\n                }\n                GanttChartBehavior.prototype.bindEvents = function (options, selectionHandler) {\n                    this.options = options;\n                    var clearCatcher = options.clearCatcher;\n                    options.taskSelection.on('click', function (d) {\n                        selectionHandler.handleSelection(d, d3.event.ctrlKey);\n                        d3.event.stopPropagation();\n                    });\n                    clearCatcher.on('click', function () {\n                        selectionHandler.handleClearSelection();\n                    });\n                };\n                GanttChartBehavior.prototype.renderSelection = function (hasSelection) {\n                    var options = this.options;\n                    var ganttMaxOpacity = Gantt.getMaxTaskOpacity();\n                    var ganttMinOpacity = Gantt.getMinTaskOpacity();\n                    options.taskSelection.style(\"opacity\", function (d) {\n                        return (hasSelection && !d.selected) ? ganttMinOpacity : ganttMaxOpacity;\n                    });\n                };\n                return GanttChartBehavior;\n            }());\n            samples.GanttChartBehavior = GanttChartBehavior;\n            var GanttChartWarning = (function () {\n                function GanttChartWarning() {\n                }\n                Object.defineProperty(GanttChartWarning.prototype, \"code\", {\n                    get: function () {\n                        return \"GanttChartWarning\";\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                GanttChartWarning.prototype.getMessages = function (resourceProvider) {\n                    var message = \"This visual requires task value\", titleKey = \"\", detailKey = \"\", visualMessage;\n                    visualMessage = {\n                        message: message,\n                        title: resourceProvider.get(titleKey),\n                        detail: resourceProvider.get(detailKey)\n                    };\n                    return visualMessage;\n                };\n                return GanttChartWarning;\n            }());\n            samples.GanttChartWarning = GanttChartWarning;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n*  Power BI Visualizations\n*\n*  Copyright (c) Microsoft Corporation\n*  All rights reserved.\n*  MIT License\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n*  The above copyright notice and this permission notice shall be included in\n*  all copies or substantial portions of the Software.\n*\n*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n*  THE SOFTWARE.\n*/\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n            var SelectionManager = visuals.utility.SelectionManager;\n            var px = jsCommon.PixelConverter.toString;\n            var pt = jsCommon.PixelConverter.fromPoint;\n            var fromPointToPixel = jsCommon.PixelConverter.fromPointToPixel;\n            samples.Months = powerbi.createEnumType([\n                { value: 1, displayName: 'January' },\n                { value: 2, displayName: 'February' },\n                { value: 3, displayName: 'March' },\n                { value: 4, displayName: 'April' },\n                { value: 5, displayName: 'May' },\n                { value: 6, displayName: 'June' },\n                { value: 7, displayName: 'July' },\n                { value: 8, displayName: 'August' },\n                { value: 9, displayName: 'September' },\n                { value: 10, displayName: 'October' },\n                { value: 11, displayName: 'November' },\n                { value: 12, displayName: 'December' }\n            ]);\n            samples.WeekDays = powerbi.createEnumType([\n                { value: 0, displayName: 'Sunday' },\n                { value: 1, displayName: 'Monday' },\n                { value: 2, displayName: 'Tuesday' },\n                { value: 3, displayName: 'Wednesday' },\n                { value: 4, displayName: 'Thursday' },\n                { value: 5, displayName: 'Friday' },\n                { value: 6, displayName: 'Saturday' }\n            ]);\n            (function (GranularityType) {\n                GranularityType[GranularityType[\"year\"] = 0] = \"year\";\n                GranularityType[GranularityType[\"quarter\"] = 1] = \"quarter\";\n                GranularityType[GranularityType[\"month\"] = 2] = \"month\";\n                GranularityType[GranularityType[\"week\"] = 3] = \"week\";\n                GranularityType[GranularityType[\"day\"] = 4] = \"day\";\n            })(samples.GranularityType || (samples.GranularityType = {}));\n            var GranularityType = samples.GranularityType;\n            var SelectedCellColorProp = { objectName: 'cells', propertyName: 'fillSelected' };\n            var UnselectedCellColorProp = { objectName: 'cells', propertyName: 'fillUnselected' };\n            var TimeRangeColorProp = { objectName: 'rangeHeader', propertyName: 'fontColor' };\n            var TimeRangeSizeProp = { objectName: 'rangeHeader', propertyName: 'textSize' };\n            var TimeRangeShowProp = { objectName: 'rangeHeader', propertyName: 'show' };\n            var LabelsColorProp = { objectName: 'labels', propertyName: 'fontColor' };\n            var LabelsSizeProp = { objectName: 'labels', propertyName: 'textSize' };\n            var LabelsShowProp = { objectName: 'labels', propertyName: 'show' };\n            var CalendarMonthProp = { objectName: 'calendar', propertyName: 'month' };\n            var CalendarDayProp = { objectName: 'calendar', propertyName: 'day' };\n            var WeekDayProp = { objectName: 'weekDay', propertyName: 'day' };\n            var GranularityNames = [\n                {\n                    granularityType: GranularityType.year,\n                    name: \"year\"\n                }, {\n                    granularityType: GranularityType.quarter,\n                    name: \"quarter\"\n                }, {\n                    granularityType: GranularityType.month,\n                    name: \"month\"\n                }, {\n                    granularityType: GranularityType.week,\n                    name: \"week\"\n                }, {\n                    granularityType: GranularityType.day,\n                    name: \"day\"\n                }];\n            var TimelineGranularity = (function () {\n                function TimelineGranularity() {\n                    this.datePeriods = [];\n                }\n                /**\n                * Returns the short month name of the given date (e.g. Jan, Feb, Mar)\n                */\n                TimelineGranularity.prototype.shortMonthName = function (date) {\n                    return date.toString().split(' ')[1];\n                };\n                TimelineGranularity.prototype.resetDatePeriods = function () {\n                    this.datePeriods = [];\n                };\n                TimelineGranularity.prototype.getDatePeriods = function () {\n                    return this.datePeriods;\n                };\n                TimelineGranularity.prototype.getExtendedLabel = function () {\n                    return this.extendedLabel;\n                };\n                TimelineGranularity.prototype.setExtendedLabel = function (extendedLabel) {\n                    this.extendedLabel = extendedLabel;\n                };\n                TimelineGranularity.prototype.createLabels = function (granularity) {\n                    var labels = [];\n                    var lastDatePeriod;\n                    _.map(this.datePeriods, function (x) {\n                        if (_.isEmpty(labels) || !granularity.sameLabel(x, lastDatePeriod)) {\n                            lastDatePeriod = x;\n                            labels.push(granularity.generateLabel(x));\n                        }\n                    });\n                    return labels;\n                };\n                /**\n                * Adds the new date into the given datePeriods array\n                * If the date corresponds to the last date period, given the current granularity,\n                * it will be added to that date period. Otherwise, a new date period will be added to the array.\n                * i.e. using Month granularity, Feb 2 2015 corresponds to Feb 3 2015.\n                * It is assumed that the given date does not correspond to previous date periods, other than the last date period\n                */\n                TimelineGranularity.prototype.addDate = function (date, identifierArray) {\n                    var datePeriods = this.getDatePeriods();\n                    var lastDatePeriod = datePeriods[datePeriods.length - 1];\n                    if (datePeriods.length === 0 || !_.isEqual(lastDatePeriod.identifierArray, identifierArray)) {\n                        if (datePeriods.length > 0)\n                            lastDatePeriod.endDate = date;\n                        datePeriods.push({\n                            identifierArray: identifierArray,\n                            startDate: date,\n                            endDate: date,\n                            week: this.determineWeek(date),\n                            year: this.determineYear(date),\n                            fraction: 1,\n                            index: datePeriods.length\n                        });\n                    }\n                    else\n                        lastDatePeriod.endDate = date;\n                };\n                TimelineGranularity.prototype.setNewEndDate = function (date) {\n                    _.last(this.datePeriods).endDate = date;\n                };\n                /**\n                 * Splits a given period into two periods.\n                 * The new period is added after the index of the old one, while the old one is simply updated.\n                 * @param index The index of the date priod to be split\n                 * @param newFraction The fraction value of the new date period\n                 * @param newDate The date in which the date period is split\n                 */\n                TimelineGranularity.prototype.splitPeriod = function (index, newFraction, newDate) {\n                    var oldDatePeriod = this.datePeriods[index];\n                    oldDatePeriod.fraction -= newFraction;\n                    var newDateObject = {\n                        identifierArray: oldDatePeriod.identifierArray,\n                        startDate: newDate,\n                        endDate: oldDatePeriod.endDate,\n                        week: this.determineWeek(newDate),\n                        year: this.determineYear(newDate),\n                        fraction: newFraction,\n                        index: oldDatePeriod.index + oldDatePeriod.fraction\n                    };\n                    oldDatePeriod.endDate = newDate;\n                    this.datePeriods.splice(index + 1, 0, newDateObject);\n                };\n                TimelineGranularity.prototype.previousMonth = function (month) {\n                    return (month > 0) ? month - 1 : 11;\n                };\n                TimelineGranularity.prototype.nextMonth = function (month) {\n                    return (month < 11) ? month + 1 : 0;\n                };\n                TimelineGranularity.prototype.countWeeks = function (startDate, endDate) {\n                    var totalDays;\n                    if (endDate.getFullYear() === startDate.getFullYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() >= startDate.getDate())\n                        totalDays = endDate.getDate() - startDate.getDate();\n                    else {\n                        totalDays = endDate.getDate() - 1;\n                        var lastMonth = this.nextMonth(startDate.getMonth());\n                        var month = endDate.getMonth();\n                        while (month !== lastMonth) {\n                            totalDays += new Date(endDate.getFullYear(), month, 0).getDate();\n                            month = this.previousMonth(month);\n                        }\n                        totalDays += new Date(endDate.getFullYear(), lastMonth, 0).getDate() - startDate.getDate();\n                    }\n                    return 1 + Math.floor(totalDays / 7);\n                };\n                TimelineGranularity.prototype.determineWeek = function (date) {\n                    var year = date.getFullYear();\n                    if (this.inPreviousYear(date))\n                        year--;\n                    var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(year);\n                    var weeks = this.countWeeks(dateOfFirstWeek, date);\n                    return [weeks, year];\n                };\n                TimelineGranularity.prototype.inPreviousYear = function (date) {\n                    var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(date.getFullYear());\n                    return date < dateOfFirstWeek;\n                };\n                TimelineGranularity.prototype.determineYear = function (date) {\n                    var firstDay = new Date(date.getFullYear(), Timeline.calendar.getFirstMonthOfYear(), Timeline.calendar.getFirstDayOfYear());\n                    return date.getFullYear() - ((firstDay <= date) ? 0 : 1);\n                };\n                return TimelineGranularity;\n            }());\n            samples.TimelineGranularity = TimelineGranularity;\n            var DayGranularity = (function (_super) {\n                __extends(DayGranularity, _super);\n                function DayGranularity() {\n                    _super.apply(this, arguments);\n                }\n                DayGranularity.prototype.getType = function () {\n                    return GranularityType.day;\n                };\n                DayGranularity.prototype.splitDate = function (date) {\n                    return [this.shortMonthName(date), date.getDate(), date.getFullYear()];\n                };\n                DayGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {\n                    return firstDatePeriod.startDate.getTime() === secondDatePeriod.startDate.getTime();\n                };\n                DayGranularity.prototype.generateLabel = function (datePeriod) {\n                    return {\n                        title: this.shortMonthName(datePeriod.startDate) + ' ' + datePeriod.startDate.getDate() + ' - ' + datePeriod.year,\n                        text: datePeriod.startDate.getDate().toString(),\n                        id: datePeriod.index\n                    };\n                };\n                return DayGranularity;\n            }(TimelineGranularity));\n            samples.DayGranularity = DayGranularity;\n            var MonthGranularity = (function (_super) {\n                __extends(MonthGranularity, _super);\n                function MonthGranularity() {\n                    _super.apply(this, arguments);\n                }\n                MonthGranularity.prototype.getType = function () {\n                    return GranularityType.month;\n                };\n                MonthGranularity.prototype.splitDate = function (date) {\n                    return [this.shortMonthName(date), date.getFullYear()];\n                };\n                MonthGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {\n                    return this.shortMonthName(firstDatePeriod.startDate) === this.shortMonthName(secondDatePeriod.startDate);\n                };\n                MonthGranularity.prototype.generateLabel = function (datePeriod) {\n                    var shortMonthName = this.shortMonthName(datePeriod.startDate);\n                    return {\n                        title: shortMonthName,\n                        text: shortMonthName,\n                        id: datePeriod.index\n                    };\n                };\n                return MonthGranularity;\n            }(TimelineGranularity));\n            samples.MonthGranularity = MonthGranularity;\n            var WeekGranularity = (function (_super) {\n                __extends(WeekGranularity, _super);\n                function WeekGranularity() {\n                    _super.apply(this, arguments);\n                }\n                WeekGranularity.prototype.getType = function () {\n                    return GranularityType.week;\n                };\n                WeekGranularity.prototype.splitDate = function (date) {\n                    return this.determineWeek(date);\n                };\n                WeekGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {\n                    return _.isEqual(firstDatePeriod.week, secondDatePeriod.week);\n                };\n                WeekGranularity.prototype.generateLabel = function (datePeriod) {\n                    return {\n                        title: 'Week ' + datePeriod.week[0] + ' - ' + datePeriod.week[1],\n                        text: 'W' + datePeriod.week[0],\n                        id: datePeriod.index\n                    };\n                };\n                return WeekGranularity;\n            }(TimelineGranularity));\n            samples.WeekGranularity = WeekGranularity;\n            var QuarterGranularity = (function (_super) {\n                __extends(QuarterGranularity, _super);\n                function QuarterGranularity() {\n                    _super.apply(this, arguments);\n                }\n                /**\n                 * Returns the date's quarter name (e.g. Q1, Q2, Q3, Q4)\n                 * @param date A date\n                 */\n                QuarterGranularity.prototype.quarterText = function (date) {\n                    var quarter = 3;\n                    var year = date.getFullYear();\n                    while (date < Timeline.calendar.getQuarterStartDate(year, quarter))\n                        if (quarter > 0)\n                            quarter--;\n                        else {\n                            quarter = 3;\n                            year--;\n                        }\n                    quarter++;\n                    return 'Q' + quarter;\n                };\n                QuarterGranularity.prototype.getType = function () {\n                    return GranularityType.quarter;\n                };\n                QuarterGranularity.prototype.splitDate = function (date) {\n                    return [this.quarterText(date), date.getFullYear()];\n                };\n                QuarterGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {\n                    return this.quarterText(firstDatePeriod.startDate) === this.quarterText(secondDatePeriod.startDate)\n                        && firstDatePeriod.year === secondDatePeriod.year;\n                };\n                QuarterGranularity.prototype.generateLabel = function (datePeriod) {\n                    var quarter = this.quarterText(datePeriod.startDate);\n                    return {\n                        title: quarter + ' ' + datePeriod.year,\n                        text: quarter,\n                        id: datePeriod.index\n                    };\n                };\n                return QuarterGranularity;\n            }(TimelineGranularity));\n            samples.QuarterGranularity = QuarterGranularity;\n            var YearGranularity = (function (_super) {\n                __extends(YearGranularity, _super);\n                function YearGranularity() {\n                    _super.apply(this, arguments);\n                }\n                YearGranularity.prototype.getType = function () {\n                    return GranularityType.year;\n                };\n                YearGranularity.prototype.splitDate = function (date) {\n                    return [date.getFullYear()];\n                };\n                YearGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {\n                    return firstDatePeriod.year === secondDatePeriod.year;\n                };\n                YearGranularity.prototype.generateLabel = function (datePeriod) {\n                    return {\n                        title: 'Year ' + datePeriod.year,\n                        text: datePeriod.year.toString(),\n                        id: datePeriod.index\n                    };\n                };\n                return YearGranularity;\n            }(TimelineGranularity));\n            samples.YearGranularity = YearGranularity;\n            var TimelineGranularityData = (function () {\n                function TimelineGranularityData(startDate, endDate) {\n                    this.granularities = [];\n                    this.setDatesRange(startDate, endDate);\n                    var lastDate = this.dates[this.dates.length - 1];\n                    this.endingDate = TimelineGranularityData.nextDay(lastDate);\n                }\n                /**\n                 * Returns the date of the previos day\n                 * @param date The following date\n                 */\n                TimelineGranularityData.previousDay = function (date) {\n                    var prevDay = new Date(date.getTime());\n                    prevDay.setDate(prevDay.getDate() - 1);\n                    return prevDay;\n                };\n                /**\n                 * Returns the date of the next day\n                 * @param date The previous date\n                 */\n                TimelineGranularityData.nextDay = function (date) {\n                    var nextDay = new Date(date.getTime());\n                    nextDay.setDate(nextDay.getDate() + 1);\n                    return nextDay;\n                };\n                /**\n                * Returns an array of dates with all the days between the start date and the end date\n                */\n                TimelineGranularityData.prototype.setDatesRange = function (startDate, endDate) {\n                    this.dates = [];\n                    var date = startDate;\n                    while (date <= endDate) {\n                        this.dates.push(date);\n                        date = TimelineGranularityData.nextDay(date);\n                    }\n                };\n                /**\n                 * Adds a new granularity to the array of granularities.\n                 * Resets the new granularity, adds all dates to it, and then edits the last date period with the ending date.\n                 * @param granularity The new granularity to be added\n                 */\n                TimelineGranularityData.prototype.addGranularity = function (granularity) {\n                    granularity.resetDatePeriods();\n                    for (var _i = 0, _a = this.dates; _i < _a.length; _i++) {\n                        var date = _a[_i];\n                        var identifierArray = granularity.splitDate(date);\n                        granularity.addDate(date, identifierArray);\n                    }\n                    granularity.setNewEndDate(this.endingDate);\n                    this.granularities.push(granularity);\n                };\n                /**\n                 * Returns a specific granularity from the array of granularities\n                 * @param index The index of the requested granularity\n                 */\n                TimelineGranularityData.prototype.getGranularity = function (index) {\n                    return this.granularities[index];\n                };\n                TimelineGranularityData.prototype.createGranularities = function () {\n                    this.granularities = [];\n                    this.addGranularity(new YearGranularity());\n                    this.addGranularity(new QuarterGranularity());\n                    this.addGranularity(new MonthGranularity());\n                    this.addGranularity(new WeekGranularity());\n                    this.addGranularity(new DayGranularity());\n                };\n                TimelineGranularityData.prototype.createLabels = function () {\n                    var _this = this;\n                    this.granularities.forEach(function (x) {\n                        x.setExtendedLabel({\n                            dayLabels: x.getType() >= GranularityType.day ? x.createLabels(_this.granularities[GranularityType.day]) : [],\n                            weekLabels: x.getType() >= GranularityType.week ? x.createLabels(_this.granularities[GranularityType.week]) : [],\n                            monthLabels: x.getType() >= GranularityType.month ? x.createLabels(_this.granularities[GranularityType.month]) : [],\n                            quarterLabels: x.getType() >= GranularityType.quarter ? x.createLabels(_this.granularities[GranularityType.quarter]) : [],\n                            yearLabels: x.getType() >= GranularityType.year ? x.createLabels(_this.granularities[GranularityType.year]) : [],\n                        });\n                    });\n                };\n                return TimelineGranularityData;\n            }());\n            samples.TimelineGranularityData = TimelineGranularityData;\n            var Utils = (function () {\n                function Utils() {\n                }\n                /**\n                 * Returns the date of the start of the selection\n                 * @param timelineData The TimelineData which contains all the date periods\n                 */\n                Utils.getStartSelectionDate = function (timelineData) {\n                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionStartIndex].startDate;\n                };\n                /**\n                 * Returns the date of the end of the selection\n                 * @param timelineData The TimelineData which contains all the date periods\n                 */\n                Utils.getEndSelectionDate = function (timelineData) {\n                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex].endDate;\n                };\n                /**\n                 * Returns the date period of the end of the selection\n                 * @param timelineData The TimelineData which contains all the date periods\n                 */\n                Utils.getEndSelectionPeriod = function (timelineData) {\n                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex];\n                };\n                /**\n                 * Returns the color of a cell, depending on whether its date period is between the selected date periods\n                 * @param d The TimelineDataPoint of the cell\n                 * @param timelineData The TimelineData with the selected date periods\n                 * @param timelineFormat The TimelineFormat with the chosen colors\n                 */\n                Utils.getCellColor = function (d, timelineData, cellFormat) {\n                    var inSelectedPeriods = d.datePeriod.startDate >= Utils.getStartSelectionDate(timelineData) && d.datePeriod.endDate <= Utils.getEndSelectionDate(timelineData);\n                    return inSelectedPeriods ? cellFormat.colorInProperty : cellFormat.colorOutProperty;\n                };\n                /**\n                 * Returns the granularity type of the given granularity name\n                 * @param granularityName The name of the granularity\n                 */\n                Utils.getGranularityType = function (granularityName) {\n                    var index = _.findIndex(GranularityNames, function (x) { return x.name === granularityName; });\n                    return GranularityNames[index].granularityType;\n                };\n                /**\n                 * Returns the name of the granularity type\n                 * @param granularity The type of granularity\n                 */\n                Utils.getGranularityName = function (granularity) {\n                    var index = _.findIndex(GranularityNames, function (x) { return x.granularityType === granularity; });\n                    return GranularityNames[index].name;\n                };\n                /**\n                 * Splits the date periods of the current granularity, in case the stard and end of the selection is in between a date period.\n                 * i.e. for a quarter granularity and a selection between Feb 6 and Dec 23, the date periods for Q1 and Q4 will be split accordingly\n                 * @param timelineData The TimelineData that contains the date periods\n                 * @param startDate The starting date of the selection\n                 * @param endDate The ending date of the selection\n                 */\n                Utils.separateSelection = function (timelineData, startDate, endDate) {\n                    var datePeriods = timelineData.currentGranularity.getDatePeriods();\n                    var startDateIndex = _.findIndex(datePeriods, function (x) { return startDate < x.endDate; });\n                    var endDateIndex = _.findIndex(datePeriods, function (x) { return endDate <= x.endDate; });\n                    timelineData.selectionStartIndex = startDateIndex;\n                    timelineData.selectionEndIndex = endDateIndex;\n                    var startRatio = Utils.getDateRatio(datePeriods[startDateIndex], startDate, true);\n                    var endRatio = Utils.getDateRatio(datePeriods[endDateIndex], endDate, false);\n                    if (endRatio > 0)\n                        timelineData.currentGranularity.splitPeriod(endDateIndex, endRatio, endDate);\n                    if (startRatio > 0) {\n                        var startFration = datePeriods[startDateIndex].fraction - startRatio;\n                        timelineData.currentGranularity.splitPeriod(startDateIndex, startFration, startDate);\n                        timelineData.selectionStartIndex++;\n                        timelineData.selectionEndIndex++;\n                    }\n                };\n                /**\n                 * Returns the ratio of the given date compared to the whole date period.\n                 * The ratio is calculated either from the start or the end of the date period.\n                 * i.e. the ratio of Feb 7 2016 compared to the month of Feb 2016,\n                 * is 0.2142 from the start of the month, or 0.7857 from the end of the month.\n                 * @param datePeriod The date period that contain the specified date\n                 * @param date The date\n                 * @param fromStart Whether to calculater the ratio from the start of the date period.\n                 */\n                Utils.getDateRatio = function (datePeriod, date, fromStart) {\n                    var dateDifference = fromStart ? date.getTime() - datePeriod.startDate.getTime() : datePeriod.endDate.getTime() - date.getTime();\n                    var periodDifference = datePeriod.endDate.getTime() - datePeriod.startDate.getTime();\n                    return periodDifference === 0 ? 0 : dateDifference / periodDifference;\n                };\n                /**\n                * Returns the time range text, depending on the given granularity (e.g. \"Feb 3 2014 - Apr 5 2015\", \"Q1 2014 - Q2 2015\")\n                */\n                Utils.timeRangeText = function (timelineData) {\n                    var startSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getStartSelectionDate(timelineData));\n                    var endSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getEndSelectionPeriod(timelineData).startDate);\n                    return startSelectionDateArray.join(' ') + ' - ' + endSelectionDateArray.join(' ');\n                };\n                Utils.dateRangeText = function (datePeriod) {\n                    return datePeriod.startDate.toDateString() + ' - ' + TimelineGranularityData.previousDay(datePeriod.endDate).toDateString();\n                };\n                /**\n                 * Combines the first two partial date periods, into a single date period.\n                 * Returns whether a partial date period was found.\n                 * i.e. combines \"Feb 1 2016 - Feb 5 2016\" with \"Feb 5 2016 - Feb 29 2016\" into \"Feb 1 2016 - Feb 29 2016\"\n                 * @param datePeriods The list of date periods\n                 */\n                Utils.unseparateSelection = function (datePeriods) {\n                    var separationIndex = _.findIndex(datePeriods, function (x) { return x.fraction < 1; });\n                    if (separationIndex >= 0) {\n                        datePeriods[separationIndex].endDate = datePeriods[separationIndex + 1].endDate;\n                        datePeriods[separationIndex].fraction += datePeriods[separationIndex + 1].fraction;\n                        datePeriods.splice(separationIndex + 1, 1);\n                        return true;\n                    }\n                    return false;\n                };\n                return Utils;\n            }());\n            samples.Utils = Utils;\n            var Calendar = (function () {\n                function Calendar(calendarFormat) {\n                    var _this = this;\n                    this.firstDayOfWeek = calendarFormat.weekDayProperty;\n                    this.firstMonthOfYear = calendarFormat.firstMonthProperty - 1;\n                    this.firstDayOfYear = calendarFormat.firstDayProperty;\n                    this.dateOfFirstWeek = {};\n                    this.quarterFirstMonths = [0, 3, 6, 9].map(function (x) { return x + _this.firstMonthOfYear; });\n                }\n                Calendar.prototype.getFirstDayOfWeek = function () {\n                    return this.firstDayOfWeek;\n                };\n                Calendar.prototype.getFirstMonthOfYear = function () {\n                    return this.firstMonthOfYear;\n                };\n                Calendar.prototype.getFirstDayOfYear = function () {\n                    return this.firstDayOfYear;\n                };\n                Calendar.prototype.getQuarterStartDate = function (year, quarterIndex) {\n                    return new Date(year, this.quarterFirstMonths[quarterIndex], this.firstDayOfYear);\n                };\n                Calendar.prototype.isChanged = function (calendarFormat) {\n                    return this.firstMonthOfYear !== (calendarFormat.firstMonthProperty - 1)\n                        || this.firstDayOfYear !== calendarFormat.firstDayProperty\n                        || this.firstDayOfWeek !== calendarFormat.weekDayProperty;\n                };\n                Calendar.prototype.calculateDateOfFirstWeek = function (year) {\n                    var date = new Date(year, this.firstMonthOfYear, this.firstDayOfYear);\n                    while (date.getDay() !== this.firstDayOfWeek)\n                        date = TimelineGranularityData.nextDay(date);\n                    return date;\n                };\n                Calendar.prototype.getDateOfFirstWeek = function (year) {\n                    if (!this.dateOfFirstWeek[year])\n                        this.dateOfFirstWeek[year] = this.calculateDateOfFirstWeek(year);\n                    return this.dateOfFirstWeek[year];\n                };\n                return Calendar;\n            }());\n            samples.Calendar = Calendar;\n            var Timeline = (function () {\n                function Timeline() {\n                    var _this = this;\n                    this.requiresNoUpdate = false;\n                    this.foreignSelection = false;\n                    this.selector = ['Y', 'Q', 'M', 'W', 'D'];\n                    this.timelineMargins = {\n                        LeftMargin: 15,\n                        RightMargin: 15,\n                        TopMargin: 15,\n                        BottomMargin: 10,\n                        CellWidth: 40,\n                        CellHeight: 25,\n                        StartXpoint: 10,\n                        StartYpoint: 20,\n                        ElementWidth: 30,\n                        MinCellWidth: 30,\n                        MaxCellHeight: 60,\n                        PeriodSlicerRectWidth: 15,\n                        PeriodSlicerRectHeight: 23\n                    };\n                    this.defaultTimelineProperties = {\n                        DefaultLabelsShow: true,\n                        TimelineDefaultTextSize: 9,\n                        TimelineDefaultCellColor: \"#ADD8E6\",\n                        TimelineDefaultCellColorOut: \"#FFFFFF\",\n                        TimelineDefaultTimeRangeShow: true,\n                        DefaultTimeRangeColor: \"#777777\",\n                        DefaultLabelColor: \"#777777\",\n                        DefaultGranularity: GranularityType.month,\n                        DefaultFirstMonth: 1,\n                        DefaultFirstDay: 1,\n                        DefaultFirstWeekDay: 0\n                    };\n                    this.timelineSelectors = {\n                        TimelineVisual: createClassAndSelector('Timeline'),\n                        SelectionRangeContainer: createClassAndSelector('selectionRangeContainer'),\n                        textLabel: createClassAndSelector('label'),\n                        LowerTextCell: createClassAndSelector('lowerTextCell'),\n                        UpperTextCell: createClassAndSelector('upperTextCell'),\n                        UpperTextArea: createClassAndSelector('upperTextArea'),\n                        LowerTextArea: createClassAndSelector('lowerTextArea'),\n                        RangeTextArea: createClassAndSelector('rangeTextArea'),\n                        CellsArea: createClassAndSelector('cellsArea'),\n                        CursorsArea: createClassAndSelector('cursorsArea'),\n                        MainArea: createClassAndSelector('mainArea'),\n                        SelectionCursor: createClassAndSelector('selectionCursor'),\n                        Cell: createClassAndSelector('cell'),\n                        CellRect: createClassAndSelector('cellRect'),\n                        VertLine: createClassAndSelector('timelineVertLine'),\n                        TimelineSlicer: createClassAndSelector('timelineSlicer'),\n                        PeriodSlicerGranularities: createClassAndSelector('periodSlicerGranularities'),\n                        PeriodSlicerSelection: createClassAndSelector('periodSlicerSelection'),\n                        PeriodSlicerSelectionRect: createClassAndSelector('periodSlicerSelectionRect'),\n                        PeriodSlicerRect: createClassAndSelector('periodSlicerRect')\n                    };\n                    this.drag = d3.behavior.drag()\n                        .origin(function (d) {\n                        d.x = d.selectionIndex * _this.timelineProperties.cellWidth;\n                        return d;\n                    })\n                        .on(\"dragstart\", function () { _this.dragstarted(); })\n                        .on(\"drag\", function (d) { _this.dragged(d); })\n                        .on(\"dragend\", function () { _this.dragended(); });\n                }\n                /**\n                 * Changes the current granularity depending on the given granularity type\n                 * Separates the new granularity's date periods which contain the start/end selection\n                 * Unseparates the date periods of the previous granularity.\n                 * @param granularity The new granularity type\n                 */\n                Timeline.prototype.changeGranularity = function (granularity, startDate, endDate) {\n                    if (Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()))\n                        Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods());\n                    this.timelineData.currentGranularity = this.timelineGranularityData.getGranularity(granularity);\n                    Utils.separateSelection(this.timelineData, startDate, endDate);\n                };\n                Timeline.prototype.init = function (options) {\n                    this.hostServices = options.host;\n                    this.initialized = false;\n                    var element = options.element;\n                    this.selectionManager = new SelectionManager({ hostServices: options.host });\n                    this.timelineProperties = {\n                        element: element,\n                        textYPosition: 50,\n                        cellsYPosition: this.timelineMargins.TopMargin * 3 + 65,\n                        topMargin: this.timelineMargins.TopMargin,\n                        bottomMargin: this.timelineMargins.BottomMargin,\n                        leftMargin: this.timelineMargins.LeftMargin,\n                        startXpoint: this.timelineMargins.StartXpoint,\n                        startYpoint: this.timelineMargins.StartYpoint,\n                        cellWidth: this.timelineMargins.CellWidth,\n                        cellHeight: this.timelineMargins.CellHeight,\n                        elementWidth: this.timelineMargins.ElementWidth,\n                        rightMargin: this.timelineMargins.RightMargin\n                    };\n                    this.body = d3.select(element.get(0));\n                    this.timelineDiv = this.body.append('div');\n                    this.svg = this.timelineDiv.append('svg').attr('width', px(options.viewport.width)).classed(this.timelineSelectors.TimelineVisual.class, true);\n                    this.clearCatcher = visuals.appendClearCatcher(this.svg);\n                    this.clearCatcher.data([this])\n                        .on(\"click\", function (timeline) { return timeline.clear(); })\n                        .on(\"touchstart\", function (timeline) { return timeline.clear(); });\n                    this.rangeText = this.svg.append('g').classed(this.timelineSelectors.RangeTextArea.class, true).append('text');\n                    this.mainGroupElement = this.svg.append('g').classed(this.timelineSelectors.MainArea.class, true);\n                    this.yearLabelsElement = this.mainGroupElement.append('g');\n                    this.quarterLabelsElement = this.mainGroupElement.append('g');\n                    this.monthLabelsElement = this.mainGroupElement.append('g');\n                    this.weekLabelsElement = this.mainGroupElement.append('g');\n                    this.dayLabelsElement = this.mainGroupElement.append('g');\n                    this.cellsElement = this.mainGroupElement.append('g').classed(this.timelineSelectors.CellsArea.class, true);\n                    this.cursorGroupElement = this.svg.append('g').classed(this.timelineSelectors.CursorsArea.class, true);\n                };\n                Timeline.prototype.clear = function () {\n                    this.selectionManager.clear();\n                    if (this.timelineData) {\n                        this.timelineData.selectionStartIndex = 0;\n                        this.timelineData.selectionEndIndex = this.timelineData.currentGranularity.getDatePeriods().length - 1;\n                        if (_.any(this.timelineData.timelineDatapoints, function (x) { return x.index % 1 !== 0; }))\n                            this.selectPeriod(this.timelineData.currentGranularity.getType());\n                        else {\n                            Timeline.updateCursors(this.timelineData, this.timelineProperties.cellWidth);\n                            this.fillCells(this.timelineFormat.cellFormat);\n                            this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition);\n                            this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);\n                        }\n                        this.setSelection(this.timelineData);\n                    }\n                };\n                Timeline.prototype.drawGranular = function (timelineProperties) {\n                    var _this = this;\n                    var dragPeriodRectState = false;\n                    var startXpoint = timelineProperties.startXpoint;\n                    var startYpoint = timelineProperties.startYpoint;\n                    var elementWidth = timelineProperties.elementWidth;\n                    this.selectorContainer = this.svg.append('g').classed(this.timelineSelectors.TimelineSlicer.class, true);\n                    this.selectorContainer.on('mouseleave', function (d) { return dragPeriodRectState = false; });\n                    var fillRect = this.selectorContainer.append('rect');\n                    var selectorPeriods = this.selector;\n                    fillRect.attr({\n                        height: px(1),\n                        x: px(startXpoint),\n                        y: px(startYpoint + 2),\n                        width: px((selectorPeriods.length - 1) * elementWidth)\n                    });\n                    var fillVertLine = this.selectorContainer.selectAll(\"vertLines\")\n                        .data(selectorPeriods).enter().append('rect');\n                    fillVertLine\n                        .classed(this.timelineSelectors.VertLine.class, true)\n                        .attr({\n                        x: function (d, index) { return px(startXpoint + index * elementWidth); },\n                        y: px(startYpoint),\n                        width: px(2),\n                        height: px(3)\n                    })\n                        .style({ 'cursor': 'pointer' });\n                    var text = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerGranularities.selector)\n                        .data(selectorPeriods)\n                        .enter()\n                        .append(\"text\")\n                        .classed(this.timelineSelectors.PeriodSlicerGranularities.class, true);\n                    var textLabels;\n                    textLabels = text.text(function (d) { return d; })\n                        .attr({\n                        x: function (d, index) { return px(startXpoint - 3 + index * elementWidth); },\n                        y: px(startYpoint - 3)\n                    });\n                    this.selectedText = this.selectorContainer.append(\"text\").classed(this.timelineSelectors.PeriodSlicerSelection.class, true);\n                    this.selectedText.text(Utils.getGranularityName(this.defaultTimelineProperties.DefaultGranularity))\n                        .attr({\n                        x: px(startXpoint + 2 * elementWidth),\n                        y: px(startYpoint + 17),\n                    });\n                    var selRects = this.selectorContainer\n                        .selectAll(this.timelineSelectors.PeriodSlicerSelectionRect.selector)\n                        .data(selectorPeriods)\n                        .enter()\n                        .append('rect')\n                        .classed(this.timelineSelectors.PeriodSlicerSelectionRect.class, true);\n                    var clickHandler = function (d, index) {\n                        _this.selectPeriod(index);\n                        dragPeriodRectState = true;\n                    };\n                    selRects.attr({\n                        x: function (d, index) { return px(startXpoint - elementWidth / 2 + index * elementWidth); },\n                        y: px(3),\n                        width: px(elementWidth),\n                        height: px(23)\n                    })\n                        .style({ 'cursor': 'pointer' })\n                        .on('mousedown', clickHandler)\n                        .on('touchstart', clickHandler)\n                        .on('mouseup', function () { return dragPeriodRectState = false; })\n                        .on('touchend', function () { return dragPeriodRectState = false; })\n                        .on(\"mouseover\", function (d, index) {\n                        if (dragPeriodRectState) {\n                            _this.selectPeriod(index);\n                        }\n                    });\n                    var dragPeriodRect = d3.behavior.drag()\n                        .on(\"dragstart\", function (e, b) {\n                        dragPeriodRectState = true;\n                    })\n                        .on(\"dragend\", function (e, b) {\n                        dragPeriodRectState = false;\n                    });\n                    this.periodSlicerRect = this.selectorContainer\n                        .append('rect').classed(this.timelineSelectors.PeriodSlicerRect.class, true)\n                        .attr({\n                        x: px(startXpoint - 6 + this.defaultTimelineProperties.DefaultGranularity * elementWidth),\n                        y: px(startYpoint - 16),\n                        rx: px(4),\n                        width: px(15),\n                        height: px(23)\n                    })\n                        .on('mouseup', function (d) { return dragPeriodRectState = false; });\n                    this.periodSlicerRect.call(dragPeriodRect);\n                };\n                Timeline.prototype.redrawPeriod = function (granularity) {\n                    var dx = this.timelineMargins.StartXpoint + granularity * this.timelineMargins.ElementWidth;\n                    this.periodSlicerRect.transition().attr(\"x\", px(dx - 7));\n                    this.selectedText.text(Utils.getGranularityName(granularity));\n                    var startDate = Utils.getStartSelectionDate(this.timelineData);\n                    var endDate = Utils.getEndSelectionDate(this.timelineData);\n                    this.changeGranularity(granularity, startDate, endDate);\n                };\n                Timeline.setMeasures = function (labelFormat, granularityType, datePeriodsCount, viewport, timelineProperties, timelineMargins) {\n                    timelineProperties.cellsYPosition = timelineProperties.textYPosition;\n                    var labelSize = fromPointToPixel(labelFormat.sizeProperty);\n                    if (labelFormat.showProperty)\n                        timelineProperties.cellsYPosition += labelSize * 1.5 * (granularityType + 1);\n                    var svgHeight = Math.max(0, viewport.height - timelineMargins.TopMargin);\n                    var maxHeight = viewport.width - timelineMargins.RightMargin - timelineMargins.MinCellWidth * datePeriodsCount;\n                    var height = Math.max(timelineMargins.MinCellWidth, Math.min(timelineMargins.MaxCellHeight, maxHeight, svgHeight - timelineProperties.cellsYPosition - 20));\n                    var width = Math.max(timelineMargins.MinCellWidth, (viewport.width - height - timelineMargins.RightMargin) / datePeriodsCount);\n                    timelineProperties.cellHeight = height;\n                    timelineProperties.cellWidth = width;\n                };\n                Timeline.prototype.visualChangeOnly = function (options) {\n                    if (options && options.dataViews && options.dataViews[0] && options.dataViews[0].metadata &&\n                        this.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].metadata) {\n                        var newObjects_1 = options.dataViews[0].metadata.objects;\n                        var oldObjects_1 = this.options.dataViews[0].metadata.objects;\n                        var properties = ['rangeHeader', 'cells', 'labels'];\n                        var metadataChanged = !properties.every(function (x) { return _.isEqual(newObjects_1 ? newObjects_1[x] : undefined, oldObjects_1 ? oldObjects_1[x] : undefined); });\n                        return options.suppressAnimations || metadataChanged;\n                    }\n                    return false;\n                };\n                Timeline.prototype.unavailableType = function (dataViewCategorical) {\n                    return !dataViewCategorical.categories\n                        || dataViewCategorical.categories.length !== 1\n                        || !dataViewCategorical.categories[0].values\n                        || dataViewCategorical.categories[0].values.length === 0\n                        || !dataViewCategorical.categories[0].source\n                        || !dataViewCategorical.categories[0].source.type;\n                };\n                Timeline.prototype.unavailableChildIdentityField = function (dataViewTree) {\n                    return !dataViewTree.root || !dataViewTree.root.childIdentityFields || dataViewTree.root.childIdentityFields.length === 0;\n                };\n                Timeline.prototype.createTimelineOptions = function (dataView) {\n                    this.dataView = dataView;\n                    if (!dataView.categorical\n                        || !dataView.metadata\n                        || this.unavailableType(dataView.categorical)\n                        || !dataView.tree\n                        || this.unavailableChildIdentityField(dataView.tree))\n                        return false;\n                    var columnExp = dataView.tree.root.childIdentityFields[0];\n                    this.valueType = columnExp ? columnExp.ref : null;\n                    if (!(dataView.categorical.categories[0].source.type.dateTime ||\n                        (dataView.categorical.categories[0].source.type.numeric && (this.valueType === 'Year' || this.valueType === 'Date'))))\n                        return false;\n                    this.values = this.prepareValues(this.dataView.categorical.categories[0].values);\n                    return true;\n                };\n                //Public for testability.\n                Timeline.prototype.prepareValues = function (values) {\n                    // remove null strings and rebuild string type date \n                    // (BUG #7266283 IN PBI-service)\n                    values = values.filter(Boolean);\n                    for (var i in values) {\n                        var item = values[i];\n                        if (typeof (item) === 'String' && (String(new Date(item)) !== 'Invalid Date')) {\n                            return values[i] = new Date(item);\n                        }\n                    }\n                    ;\n                    return values;\n                };\n                Timeline.prototype.createTimelineData = function () {\n                    var startDate;\n                    var endDate;\n                    if (this.valueType === 'Year') {\n                        var years = this.values;\n                        startDate = new Date(_.min(years), 0);\n                        endDate = new Date(_.max(years), 11);\n                    }\n                    else {\n                        var dates = this.values;\n                        startDate = _.min(dates);\n                        endDate = _.max(dates);\n                    }\n                    if (!this.initialized)\n                        this.drawGranular(this.timelineProperties);\n                    if (this.initialized) {\n                        var actualEndDate = TimelineGranularityData.nextDay(endDate);\n                        var daysPeriods = this.timelineGranularityData.getGranularity(GranularityType.day).getDatePeriods();\n                        var prevStartDate = daysPeriods[0].startDate;\n                        var prevEndDate = daysPeriods[daysPeriods.length - 1].endDate;\n                        var changedSelection = startDate.getTime() >= prevStartDate.getTime() && actualEndDate.getTime() <= prevEndDate.getTime();\n                        this.newGranularity = this.timelineData.currentGranularity.getType();\n                        if (changedSelection) {\n                            this.foreignSelection = true;\n                            this.changeGranularity(this.newGranularity, startDate, actualEndDate);\n                            this.timelineFormat = Timeline.fillTimelineFormat(this.options.dataViews[0].metadata.objects, this.defaultTimelineProperties);\n                        }\n                        else {\n                            if (actualEndDate < prevEndDate)\n                                endDate = daysPeriods[daysPeriods.length - 1].startDate;\n                            if (startDate > prevStartDate)\n                                startDate = prevStartDate;\n                            this.initialized = false;\n                        }\n                    }\n                    if (!this.initialized) {\n                        this.timelineGranularityData = new TimelineGranularityData(startDate, endDate);\n                        this.timelineData = {\n                            elementsCount: 0,\n                            timelineDatapoints: [],\n                            cursorDataPoints: new Array()\n                        };\n                    }\n                };\n                Timeline.prototype.update = function (options) {\n                    var visualChange = this.visualChangeOnly(options);\n                    this.requiresNoUpdate = this.requiresNoUpdate && !visualChange;\n                    if (this.requiresNoUpdate) {\n                        if (this.foreignSelection)\n                            this.foreignSelection = false;\n                        else\n                            this.requiresNoUpdate = false;\n                        return;\n                    }\n                    this.options = options;\n                    if (!options.dataViews || !options.dataViews[0])\n                        return;\n                    var validOptions = this.createTimelineOptions(options.dataViews[0]);\n                    if (!validOptions) {\n                        this.clearData();\n                        return;\n                    }\n                    this.newGranularity = this.defaultTimelineProperties.DefaultGranularity;\n                    if (!visualChange)\n                        this.createTimelineData();\n                    this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, options.dataViews[0], this.initialized, this.newGranularity, options.viewport, this.timelineMargins);\n                    this.render(this.timelineData, this.timelineFormat, this.timelineProperties, options);\n                    this.initialized = true;\n                };\n                Timeline.prototype.selectPeriod = function (periodNameIndex) {\n                    this.redrawPeriod(periodNameIndex);\n                    this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, this.options.dataViews[0], this.initialized, this.timelineData.currentGranularity.getType(), this.options.viewport, this.timelineMargins);\n                    this.render(this.timelineData, this.timelineFormat, this.timelineProperties, this.options);\n                };\n                Timeline.isDataNotMatch = function (dataView) {\n                    if (dataView.categorical.categories.length <= 0 ||\n                        dataView.categorical.categories[0] === undefined ||\n                        dataView.categorical.categories[0].identityFields === undefined ||\n                        dataView.categorical.categories[0].identityFields.length <= 0)\n                        return true;\n                    return false;\n                };\n                Timeline.converter = function (timelineData, timelineProperties, defaultTimelineProperties, timelineGranularityData, dataView, initialized, granularityType, viewport, timelineMargins) {\n                    var timelineFormat = Timeline.fillTimelineFormat(dataView.metadata.objects, defaultTimelineProperties);\n                    if (!initialized) {\n                        timelineData.cursorDataPoints.push({ x: 0, selectionIndex: 0, cursorIndex: 0 });\n                        timelineData.cursorDataPoints.push({ x: 0, selectionIndex: 0, cursorIndex: 1 });\n                    }\n                    if (!initialized || Timeline.calendar.isChanged(timelineFormat.calendarFormat)) {\n                        Timeline.calendar = new Calendar(timelineFormat.calendarFormat);\n                        timelineGranularityData.createGranularities();\n                        timelineGranularityData.createLabels();\n                        timelineData.currentGranularity = timelineGranularityData.getGranularity(granularityType);\n                        timelineData.selectionStartIndex = 0;\n                        timelineData.selectionEndIndex = timelineData.currentGranularity.getDatePeriods().length - 1;\n                    }\n                    timelineData.categorySourceName = dataView.categorical.categories[0].source.displayName;\n                    timelineData.columnIdentity = dataView.categorical.categories[0].identityFields[0];\n                    if (dataView.categorical.categories[0].source.type.numeric) {\n                        timelineData.columnIdentity.ref = \"Date\";\n                    }\n                    if (this.isDataNotMatch(dataView))\n                        return;\n                    var timelineElements = timelineData.currentGranularity.getDatePeriods();\n                    timelineData.elementsCount = timelineElements.length;\n                    timelineData.timelineDatapoints = [];\n                    for (var _i = 0, timelineElements_1 = timelineElements; _i < timelineElements_1.length; _i++) {\n                        var currentTimePeriod = timelineElements_1[_i];\n                        var datapoint = {\n                            index: currentTimePeriod.index,\n                            datePeriod: currentTimePeriod\n                        };\n                        timelineData.timelineDatapoints.push(datapoint);\n                    }\n                    var countFullCells = timelineData.currentGranularity.getDatePeriods().filter(function (x) { return x.index % 1 === 0; }).length;\n                    Timeline.setMeasures(timelineFormat.labelFormat, timelineData.currentGranularity.getType(), countFullCells, viewport, timelineProperties, timelineMargins);\n                    Timeline.updateCursors(timelineData, timelineProperties.cellWidth);\n                    return timelineFormat;\n                };\n                Timeline.prototype.render = function (timelineData, timelineFormat, timelineProperties, options) {\n                    var timelineDatapointsCount = this.timelineData.timelineDatapoints.filter(function (x) { return x.index % 1 === 0; }).length;\n                    this.svgWidth = 1 + this.timelineProperties.cellHeight + timelineProperties.cellWidth * timelineDatapointsCount;\n                    this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);\n                    this.timelineDiv.attr({\n                        height: px(options.viewport.height),\n                        width: px(options.viewport.width),\n                        'drag-resize-disabled': true\n                    }).style({\n                        'overflow-x': 'auto',\n                        'overflow-y': 'auto'\n                    });\n                    this.svg.attr({\n                        height: px(Math.max(0, options.viewport.height - this.timelineMargins.TopMargin)),\n                        width: px(Math.max(0, this.svgWidth))\n                    });\n                    var fixedTranslateString = visuals.SVGUtil.translate(timelineProperties.leftMargin, timelineProperties.topMargin);\n                    var translateString = visuals.SVGUtil.translate(timelineProperties.cellHeight / 2, timelineProperties.topMargin);\n                    this.mainGroupElement.attr('transform', translateString);\n                    this.selectorContainer.attr('transform', fixedTranslateString);\n                    this.cursorGroupElement.attr('transform', translateString);\n                    var extendedLabels = this.timelineData.currentGranularity.getExtendedLabel();\n                    var granularityType = this.timelineData.currentGranularity.getType();\n                    var yPos = 0, yDiff = 1.50;\n                    this.renderLabels(extendedLabels.yearLabels, this.yearLabelsElement, yPos, granularityType === 0);\n                    yPos += yDiff;\n                    this.renderLabels(extendedLabels.quarterLabels, this.quarterLabelsElement, yPos, granularityType === 1);\n                    yPos += yDiff;\n                    this.renderLabels(extendedLabels.monthLabels, this.monthLabelsElement, yPos, granularityType === 2);\n                    yPos += yDiff;\n                    this.renderLabels(extendedLabels.weekLabels, this.weekLabelsElement, yPos, granularityType === 3);\n                    yPos += yDiff;\n                    this.renderLabels(extendedLabels.dayLabels, this.dayLabelsElement, yPos, granularityType === 4);\n                    this.renderCells(timelineData, timelineFormat, timelineProperties, options.suppressAnimations);\n                    this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);\n                };\n                Timeline.prototype.renderLabels = function (labels, labelsElement, index, isLast) {\n                    var _this = this;\n                    var labelTextSelection = labelsElement.selectAll(this.timelineSelectors.textLabel.selector);\n                    if (!this.timelineFormat.labelFormat.showProperty) {\n                        labelTextSelection.remove();\n                        return;\n                    }\n                    var labelsGroupSelection = labelTextSelection.data(labels);\n                    labelsGroupSelection.enter().append('text').classed(this.timelineSelectors.textLabel.class, true);\n                    labelsGroupSelection.text(function (x, id) {\n                        if (!isLast && id === 0 && labels.length > 1) {\n                            var fontSize = pt(_this.timelineFormat.labelFormat.sizeProperty);\n                            var textProperties = {\n                                text: labels[0].text,\n                                fontFamily: 'arial',\n                                fontSize: fontSize\n                            };\n                            var halfFirstTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2;\n                            textProperties = {\n                                text: labels[1].text,\n                                fontFamily: 'arial',\n                                fontSize: fontSize\n                            };\n                            var halfSecondTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2;\n                            var diff = _this.timelineProperties.cellWidth * (labels[1].id - labels[0].id);\n                            if (diff < halfFirstTextWidth + halfSecondTextWidth)\n                                return \"\";\n                        }\n                        var labelFormattedTextOptions = {\n                            label: x.text,\n                            maxWidth: _this.timelineProperties.cellWidth * (isLast ? 0.90 : 3),\n                            fontSize: _this.timelineFormat.labelFormat.sizeProperty\n                        };\n                        return visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);\n                    })\n                        .style('font-size', pt(this.timelineFormat.labelFormat.sizeProperty))\n                        .attr({\n                        x: function (x) { return (x.id + 0.5) * _this.timelineProperties.cellWidth; },\n                        y: this.timelineProperties.textYPosition + (1 + index) * fromPointToPixel(this.timelineFormat.labelFormat.sizeProperty),\n                        fill: this.timelineFormat.labelFormat.colorProperty\n                    }).append('title').text(function (x) { return x.title; });\n                    labelsGroupSelection.exit().remove();\n                };\n                Timeline.prototype.clearData = function () {\n                    this.initialized = false;\n                    this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).remove();\n                    this.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector).remove();\n                    this.rangeText.text(\"\");\n                    this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).remove();\n                    this.svg.select(this.timelineSelectors.TimelineSlicer.selector).remove();\n                };\n                Timeline.updateCursors = function (timelineData, cellWidth) {\n                    var startDate = timelineData.timelineDatapoints[timelineData.selectionStartIndex].datePeriod;\n                    timelineData.cursorDataPoints[0].selectionIndex = startDate.index;\n                    var endDate = timelineData.timelineDatapoints[timelineData.selectionEndIndex].datePeriod;\n                    timelineData.cursorDataPoints[1].selectionIndex = (endDate.index + endDate.fraction);\n                };\n                Timeline.fillTimelineFormat = function (objects, timelineProperties) {\n                    var timelineFormat = {\n                        rangeTextFormat: {\n                            showProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, timelineProperties.TimelineDefaultTimeRangeShow),\n                            colorProperty: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, timelineProperties.DefaultTimeRangeColor),\n                            sizeProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, timelineProperties.TimelineDefaultTextSize)\n                        },\n                        cellFormat: {\n                            colorInProperty: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, timelineProperties.TimelineDefaultCellColor),\n                            colorOutProperty: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, timelineProperties.TimelineDefaultCellColorOut)\n                        },\n                        labelFormat: {\n                            showProperty: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, timelineProperties.DefaultLabelsShow),\n                            colorProperty: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, timelineProperties.DefaultLabelColor),\n                            sizeProperty: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, timelineProperties.TimelineDefaultTextSize)\n                        },\n                        calendarFormat: {\n                            firstMonthProperty: powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1),\n                            firstDayProperty: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, timelineProperties.DefaultFirstDay))),\n                            weekDayProperty: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, timelineProperties.DefaultFirstWeekDay)))\n                        }\n                    };\n                    return timelineFormat;\n                };\n                Timeline.prototype.fillCells = function (cellFormat) {\n                    var _this = this;\n                    var dataPoints = this.timelineData.timelineDatapoints;\n                    var cellSelection = this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).data(dataPoints);\n                    cellSelection.attr('fill', function (d) { return Utils.getCellColor(d, _this.timelineData, cellFormat); });\n                };\n                Timeline.prototype.renderCells = function (timelineData, timelineFormat, timelineProperties, suppressAnimations) {\n                    var _this = this;\n                    var allDataPoints = timelineData.timelineDatapoints;\n                    var totalX = 0;\n                    var cellsSelection = this.cellsElement.selectAll(this.timelineSelectors.CellRect.selector).data(allDataPoints);\n                    cellsSelection.enter().append('rect').classed(this.timelineSelectors.CellRect.class, true);\n                    cellsSelection\n                        .attr({\n                        height: px(timelineProperties.cellHeight),\n                        width: function (d) { return px(d.datePeriod.fraction * timelineProperties.cellWidth); },\n                        x: function (d) {\n                            var value = totalX;\n                            totalX += d.datePeriod.fraction * timelineProperties.cellWidth;\n                            return px(value);\n                        },\n                        y: px(timelineProperties.cellsYPosition),\n                        id: function (d) { return d.index; }\n                    });\n                    var clickHandler = function (d, index) {\n                        d3.event.preventDefault();\n                        var cursorDataPoints = _this.timelineData.cursorDataPoints;\n                        var keyEvent = d3.event;\n                        if (keyEvent.altKey || keyEvent.shiftKey) {\n                            if (_this.timelineData.selectionEndIndex < index) {\n                                cursorDataPoints[1].selectionIndex = (d.datePeriod.index + d.datePeriod.fraction);\n                                timelineData.selectionEndIndex = index;\n                            }\n                            else {\n                                cursorDataPoints[0].selectionIndex = d.datePeriod.index;\n                                timelineData.selectionStartIndex = index;\n                            }\n                        }\n                        else {\n                            timelineData.selectionStartIndex = index;\n                            timelineData.selectionEndIndex = index;\n                            cursorDataPoints[0].selectionIndex = d.datePeriod.index;\n                            cursorDataPoints[1].selectionIndex = (d.datePeriod.index + d.datePeriod.fraction);\n                        }\n                        _this.fillCells(timelineFormat.cellFormat);\n                        _this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);\n                        _this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);\n                        _this.setSelection(timelineData);\n                    };\n                    cellsSelection\n                        .on('click', clickHandler)\n                        .on(\"touchstart\", clickHandler);\n                    this.fillCells(timelineFormat.cellFormat);\n                    cellsSelection.exit().remove();\n                };\n                Timeline.prototype.dragstarted = function () {\n                    this.timelineData.dragging = true;\n                };\n                Timeline.prototype.dragged = function (currentCursor) {\n                    if (this.timelineData.dragging === true) {\n                        var xScale = 1;\n                        var container = d3.select(this.timelineSelectors.TimelineVisual.selector);\n                        if (container) {\n                            var transform = container.style(\"transform\");\n                            if (transform !== undefined && transform !== 'none') {\n                                var str = transform.split(\"(\")[1];\n                                xScale = Number(str.split(\", \")[0]);\n                            }\n                        }\n                        var cursorOverElement = this.findCursorOverElement(d3.event.x);\n                        if (!cursorOverElement) {\n                            return;\n                        }\n                        var currentlyMouseOverElement = cursorOverElement.datapoint, currentlyMouseOverElementIndex = cursorOverElement.index;\n                        if (currentCursor.cursorIndex === 0 && currentlyMouseOverElementIndex <= this.timelineData.selectionEndIndex) {\n                            this.timelineData.selectionStartIndex = currentlyMouseOverElementIndex;\n                            this.timelineData.cursorDataPoints[0].selectionIndex = currentlyMouseOverElement.datePeriod.index;\n                        }\n                        if (currentCursor.cursorIndex === 1 && currentlyMouseOverElementIndex >= this.timelineData.selectionStartIndex) {\n                            this.timelineData.selectionEndIndex = currentlyMouseOverElementIndex;\n                            this.timelineData.cursorDataPoints[1].selectionIndex = (currentlyMouseOverElement.datePeriod.index + currentlyMouseOverElement.datePeriod.fraction);\n                        }\n                        this.fillCells(this.timelineFormat.cellFormat);\n                        this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition);\n                        this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);\n                    }\n                };\n                /**\n                 * Note: Public for testability.\n                 */\n                Timeline.prototype.findCursorOverElement = function (x) {\n                    var timelineDatapoints = this.timelineData.timelineDatapoints || [], length = timelineDatapoints.length, cellWidth = this.timelineProperties.cellWidth;\n                    if (timelineDatapoints[0] && timelineDatapoints[1] && x <= timelineDatapoints[1].index * cellWidth) {\n                        return {\n                            index: 0,\n                            datapoint: timelineDatapoints[0]\n                        };\n                    }\n                    else if (timelineDatapoints[length - 1] && x >= timelineDatapoints[length - 1].index * cellWidth) {\n                        return {\n                            index: length - 1,\n                            datapoint: timelineDatapoints[length - 1]\n                        };\n                    }\n                    for (var i = 1; i < length; i++) {\n                        var left = timelineDatapoints[i].index * cellWidth, right = timelineDatapoints[i + 1].index * cellWidth;\n                        if (x >= left && x <= right) {\n                            return {\n                                index: i,\n                                datapoint: timelineDatapoints[i]\n                            };\n                        }\n                    }\n                    return null;\n                };\n                Timeline.prototype.dragended = function () {\n                    this.setSelection(this.timelineData);\n                };\n                Timeline.prototype.renderCursors = function (timelineData, timelineFormat, cellHeight, cellsYPosition) {\n                    var _this = this;\n                    var cursorSelection = this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).data(timelineData.cursorDataPoints);\n                    cursorSelection.enter().append('path').classed(this.timelineSelectors.SelectionCursor.class, true);\n                    cursorSelection.attr(\"transform\", function (d) { return visuals.SVGUtil.translate(d.selectionIndex * _this.timelineProperties.cellWidth, cellHeight / 2 + cellsYPosition); }).attr({\n                        d: d3.svg.arc()\n                            .innerRadius(0)\n                            .outerRadius(cellHeight / 2)\n                            .startAngle(function (d) { return d.cursorIndex * Math.PI + Math.PI; })\n                            .endAngle(function (d) { return d.cursorIndex * Math.PI + 2 * Math.PI; })\n                    })\n                        .call(this.drag);\n                    cursorSelection.exit().remove();\n                    return cursorSelection;\n                };\n                Timeline.prototype.renderTimeRangeText = function (timelineData, timeRangeFormat) {\n                    var leftMargin = (GranularityNames.length + 2) * this.timelineProperties.elementWidth;\n                    var maxWidth = this.svgWidth - leftMargin - this.timelineProperties.leftMargin;\n                    if (timeRangeFormat.showProperty && maxWidth > 0) {\n                        var timeRangeText = Utils.timeRangeText(timelineData);\n                        var labelFormattedTextOptions = {\n                            label: timeRangeText,\n                            maxWidth: maxWidth,\n                            fontSize: timeRangeFormat.sizeProperty\n                        };\n                        var actualText = visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);\n                        this.rangeText.classed(this.timelineSelectors.SelectionRangeContainer.class, true);\n                        this.rangeText.attr({\n                            x: (GranularityNames.length) * (this.timelineProperties.elementWidth + this.timelineProperties.leftMargin),\n                            y: 40,\n                            fill: timeRangeFormat.colorProperty\n                        })\n                            .style({\n                            'font-size': pt(timeRangeFormat.sizeProperty)\n                        }).text(actualText)\n                            .append('title').text(timeRangeText);\n                        ;\n                    }\n                    else\n                        this.rangeText.text(\"\");\n                };\n                Timeline.prototype.setSelection = function (timelineData) {\n                    this.requiresNoUpdate = true;\n                    var lower = powerbi.data.SQExprBuilder.dateTime(Utils.getStartSelectionDate(timelineData));\n                    var upper = powerbi.data.SQExprBuilder.dateTime(new Date(Utils.getEndSelectionDate(timelineData).getTime() - 1));\n                    var filterExpr = powerbi.data.SQExprBuilder.between(timelineData.columnIdentity, lower, upper);\n                    var filter = powerbi.data.SemanticFilter.fromSQExpr(filterExpr);\n                    var objects = {\n                        merge: [\n                            {\n                                objectName: \"general\",\n                                selector: undefined,\n                                properties: {\n                                    \"filter\": filter,\n                                }\n                            }\n                        ]\n                    };\n                    this.hostServices.persistProperties(objects);\n                    this.hostServices.onSelect({ data: [] });\n                };\n                // This function retruns the values to be displayed in the property pane for each object.\n                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do\n                // validation and return other values/defaults \n                Timeline.prototype.enumerateObjectInstances = function (options) {\n                    var enumeration = new visuals.ObjectEnumerationBuilder();\n                    switch (options.objectName) {\n                        case 'rangeHeader':\n                            this.enumerateRangeHeader(enumeration, this.dataView);\n                            break;\n                        case 'cells':\n                            this.enumerateCells(enumeration, this.dataView);\n                            break;\n                        case 'labels':\n                            this.enumerateLabels(enumeration, this.dataView);\n                            break;\n                        case 'calendar':\n                            this.enumerateCalendar(enumeration, this.dataView);\n                            break;\n                        case 'weekDay':\n                            this.enumerateWeekDay(enumeration, this.dataView);\n                            break;\n                    }\n                    return enumeration.complete();\n                };\n                Timeline.prototype.enumerateRangeHeader = function (enumeration, dataview) {\n                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\n                    enumeration.pushInstance({\n                        objectName: 'rangeHeader',\n                        displayName: 'Selection Color',\n                        selector: null,\n                        properties: {\n                            show: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, this.defaultTimelineProperties.TimelineDefaultTimeRangeShow),\n                            fontColor: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, this.defaultTimelineProperties.DefaultTimeRangeColor),\n                            textSize: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)\n                        }\n                    });\n                };\n                Timeline.prototype.enumerateCells = function (enumeration, dataview) {\n                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\n                    enumeration.pushInstance({\n                        objectName: 'cells',\n                        selector: null,\n                        properties: {\n                            fillSelected: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColor),\n                            fillUnselected: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColorOut)\n                        }\n                    });\n                };\n                Timeline.prototype.enumerateLabels = function (enumeration, dataview) {\n                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\n                    enumeration.pushInstance({\n                        objectName: 'labels',\n                        selector: null,\n                        properties: {\n                            show: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, this.defaultTimelineProperties.DefaultLabelsShow),\n                            fontColor: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, this.defaultTimelineProperties.DefaultLabelColor),\n                            textSize: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)\n                        }\n                    });\n                };\n                Timeline.prototype.enumerateCalendar = function (enumeration, dataview) {\n                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\n                    enumeration.pushInstance({\n                        objectName: 'calendar',\n                        selector: null,\n                        properties: {\n                            month: Math.max(1, Math.min(12, powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1))),\n                            day: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, 1))),\n                        }\n                    });\n                };\n                Timeline.prototype.enumerateWeekDay = function (enumeration, dataview) {\n                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\n                    enumeration.pushInstance({\n                        objectName: 'weekDay',\n                        selector: null,\n                        properties: {\n                            day: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, 0)))\n                        }\n                    });\n                };\n                Timeline.capabilities = {\n                    dataRoles: [{\n                            name: 'Time',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Time'\n                        }],\n                    dataViewMappings: [{\n                            conditions: [\n                                { 'Time': { max: 1 } }\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Time' },\n                                    dataReductionAlgorithm: { sample: {} }\n                                },\n                                values: {\n                                    select: [{\n                                            bind: { to: 'Time' }\n                                        }]\n                                },\n                            }\n                        }],\n                    objects: {\n                        general: {\n                            displayName: 'General',\n                            properties: {\n                                formatString: {\n                                    type: {\n                                        formatting: {\n                                            formatString: true\n                                        }\n                                    },\n                                },\n                                selected: {\n                                    type: { bool: true }\n                                },\n                                filter: {\n                                    type: { filter: {} },\n                                    rule: {\n                                        output: {\n                                            property: 'selected',\n                                            selector: ['Time'],\n                                        }\n                                    }\n                                },\n                            },\n                        },\n                        calendar: {\n                            displayName: 'Fiscal Year Start',\n                            properties: {\n                                month: {\n                                    displayName: 'Month',\n                                    type: { enumeration: samples.Months }\n                                },\n                                day: {\n                                    displayName: 'Day',\n                                    type: { numeric: true }\n                                }\n                            }\n                        },\n                        weekDay: {\n                            displayName: 'First Day of Week',\n                            properties: {\n                                day: {\n                                    displayName: 'Day',\n                                    type: { enumeration: samples.WeekDays }\n                                }\n                            }\n                        },\n                        rangeHeader: {\n                            displayName: 'Range Header',\n                            properties: {\n                                show: {\n                                    displayName: 'Show',\n                                    type: { bool: true }\n                                },\n                                fontColor: {\n                                    displayName: 'Font color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                textSize: {\n                                    displayName: 'Text Size',\n                                    type: { numeric: true }\n                                }\n                            }\n                        },\n                        cells: {\n                            displayName: 'Cells',\n                            properties: {\n                                fillSelected: {\n                                    displayName: 'Selected cell color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fillUnselected: {\n                                    displayName: 'Unselected cell color',\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        labels: {\n                            displayName: 'Labels',\n                            properties: {\n                                show: {\n                                    displayName: 'Show',\n                                    type: { bool: true }\n                                },\n                                fontColor: {\n                                    displayName: 'Font color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                textSize: {\n                                    displayName: 'Text Size',\n                                    type: { numeric: true }\n                                }\n                            }\n                        }\n                    }\n                };\n                return Timeline;\n            }());\n            samples.Timeline = Timeline;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var ValueFormatter = powerbi.visuals.valueFormatter;\n            var SelectionManager = visuals.utility.SelectionManager;\n            var StreamGraphAxisGraphicsContextClassName = 'axisGraphicsContext';\n            var StreamGraphXAxisClassName = 'x axis';\n            var StreamGraphYAxisClassName = 'y axis';\n            var StreamGraphDefaultAxisColor = \"#777\";\n            var StreamGraphDefaultFontSizeInPoints = 8;\n            var DefaultLegendFontSizeInPt = 8;\n            var DefaultLegendLabelFillColor = '#666666';\n            var StreamGraphDefaultFontFamily = 'wf_segoe-ui_normal';\n            var StreamGraphDefaultFontWeight = 'normal';\n            var StreamGraphDefaultSettings = {\n                legendSettings: {\n                    show: true,\n                    showTitle: true,\n                    labelColor: DefaultLegendLabelFillColor,\n                    titleText: \"\",\n                    fontSize: DefaultLegendFontSizeInPt\n                },\n                categoryAxisSettings: {\n                    show: true,\n                    axisColor: StreamGraphDefaultAxisColor,\n                    showAxisTitle: false,\n                },\n                valueAxisSettings: {\n                    show: true,\n                    axisColor: StreamGraphDefaultAxisColor,\n                    showAxisTitle: false,\n                },\n            };\n            var StreamGraph = (function () {\n                function StreamGraph() {\n                    this.margin = { left: 45, right: 20, bottom: 20, top: 20 };\n                }\n                StreamGraph.prototype.converter = function (dataView, colors) {\n                    if (!dataView || !dataView.categorical || !dataView.categorical.values || !dataView.categorical.categories)\n                        return null;\n                    var catDv = dataView.categorical, values = catDv.values, dataPoints = [], legendData = {\n                        dataPoints: [],\n                        title: values[0].source.displayName,\n                        fontSize: StreamGraphDefaultFontSizeInPoints,\n                    }, value = 0, valueFormatter, categoryFormatter;\n                    for (var i = 0; i < values.length; i++) {\n                        dataPoints.push([]);\n                        if (values[i].source.groupName) {\n                            legendData.dataPoints.push({\n                                label: values[i].source.groupName,\n                                color: colors.getColorByIndex(i).value,\n                                icon: visuals.LegendIcon.Box,\n                                selected: false,\n                                identity: visuals.SelectionId.createWithId(values[i].identity)\n                            });\n                        }\n                        for (var k = 0; k < values[i].values.length; k++) {\n                            var id = visuals.SelectionIdBuilder\n                                .builder()\n                                .withSeries(dataView.categorical.values, dataView.categorical.values[i])\n                                .createSelectionId(), y = values[i].values[k];\n                            if (y > value) {\n                                value = y;\n                            }\n                            dataPoints[i].push({\n                                x: k,\n                                y: y,\n                                identity: id\n                            });\n                        }\n                    }\n                    var streamGraphSettings = this.parseSettings(dataView);\n                    valueFormatter = ValueFormatter.create({\n                        format: \"g\",\n                        value: value\n                    });\n                    categoryFormatter = ValueFormatter.create({\n                        format: ValueFormatter.getFormatString(catDv.categories[0].source, StreamGraph.Properties.general.formatString),\n                        value: catDv.categories[0].values\n                    });\n                    return {\n                        dataPoints: dataPoints,\n                        legendData: legendData,\n                        valueFormatter: valueFormatter,\n                        categoryFormatter: categoryFormatter,\n                        streamGraphSettings: streamGraphSettings\n                    };\n                };\n                StreamGraph.prototype.parseSettings = function (dataView) {\n                    if (!dataView || !dataView.metadata)\n                        return StreamGraphDefaultSettings;\n                    var objects = dataView.metadata.objects;\n                    var streamGraphSettings = _.clone(StreamGraphDefaultSettings);\n                    var categoryAxisSettings = streamGraphSettings.categoryAxisSettings;\n                    categoryAxisSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.show, categoryAxisSettings.show);\n                    categoryAxisSettings.axisColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.categoryAxis.axisColor, categoryAxisSettings.axisColor);\n                    categoryAxisSettings.showAxisTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.showAxisTitle, categoryAxisSettings.showAxisTitle);\n                    var valueAxisSettings = streamGraphSettings.valueAxisSettings;\n                    valueAxisSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.show, valueAxisSettings.show);\n                    valueAxisSettings.axisColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.valueAxis.axisColor, valueAxisSettings.axisColor);\n                    valueAxisSettings.showAxisTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.showAxisTitle, valueAxisSettings.showAxisTitle);\n                    return streamGraphSettings;\n                };\n                StreamGraph.prototype.init = function (options) {\n                    var element = options.element;\n                    this.selectionManager = new SelectionManager({ hostServices: options.host });\n                    this.svg = d3.select(element.get(0))\n                        .append('svg')\n                        .classed(StreamGraph.VisualClassName, true)\n                        .style('position', 'absolute');\n                    this.axisGraphicsContext = this.svg.append('g')\n                        .classed(StreamGraphAxisGraphicsContextClassName, true);\n                    this.xAxis = this.axisGraphicsContext.append(\"g\").classed(StreamGraphXAxisClassName, true);\n                    this.yAxis = this.axisGraphicsContext.append(\"g\").classed(StreamGraphYAxisClassName, true);\n                    this.colors = options.style.colorPalette.dataColors;\n                    this.legend = visuals.createLegend(element, false, null, true);\n                };\n                StreamGraph.prototype.update = function (options) {\n                    var _this = this;\n                    if (!options.dataViews || !options.dataViews[0] || !options.dataViews[0].categorical) {\n                        this.clearData();\n                        return;\n                    }\n                    ;\n                    this.viewport = {\n                        width: Math.max(0, options.viewport.width),\n                        height: Math.max(0, options.viewport.height)\n                    };\n                    var duration = options.suppressAnimations ? 0 : 250, dataView = this.dataView = options.dataViews[0], data = this.data = this.converter(dataView, this.colors);\n                    if (!data || !data.dataPoints || !data.dataPoints.length) {\n                        this.clearData();\n                        return;\n                    }\n                    var dataPoints = data.dataPoints;\n                    this.renderLegend(data);\n                    this.updateViewPort();\n                    this.renderXAxisLabels();\n                    this.renderYAxisLabels();\n                    var height = Math.max(0, this.viewport.height - this.margin.top);\n                    this.svg.attr({\n                        'width': this.viewport.width,\n                        'height': height\n                    });\n                    var stack = d3.layout.stack();\n                    if (this.getWiggle(dataView))\n                        stack.offset('wiggle');\n                    var layers = stack(dataPoints);\n                    var xScale = d3.scale.linear()\n                        .domain([0, dataPoints[0].length - 1])\n                        .range([this.margin.left, this.viewport.width - this.margin.right]);\n                    var yScale = d3.scale.linear()\n                        .domain([0, d3.max(layers, function (layer) {\n                            return d3.max(layer, function (d) {\n                                return d.y0 + d.y;\n                            });\n                        })])\n                        .range([height - this.margin.bottom, this.margin.top]);\n                    var area = d3.svg.area()\n                        .interpolate('basis')\n                        .x(function (d) { return xScale(d.x); })\n                        .y0(function (d) { return yScale(d.y0); })\n                        .y1(function (d) { return yScale(d.y0 + d.y); });\n                    var selectionManager = this.selectionManager;\n                    var selection = this.svg.selectAll(StreamGraph.Layer.selector)\n                        .data(layers);\n                    selection.enter()\n                        .append('path')\n                        .classed(StreamGraph.Layer.class, true);\n                    selection\n                        .style(\"fill\", function (d, i) { return _this.colors.getColorByIndex(i).value; })\n                        .on('click', function (d) {\n                        var _this = this;\n                        selectionManager.select(d[0].identity).then(function (ids) {\n                            if (ids.length > 0) {\n                                selection.style('opacity', 0.5);\n                                d3.select(_this).style('opacity', 1);\n                            }\n                            else\n                                selection.style('opacity', 1);\n                        });\n                    })\n                        .transition()\n                        .duration(duration)\n                        .attr(\"d\", area);\n                    selection.exit().remove();\n                    this.drawAxis(data, xScale, yScale);\n                };\n                StreamGraph.prototype.drawAxis = function (data, xScale, yScale) {\n                    var _this = this;\n                    var shiftY = this.viewport.height - this.margin.bottom - this.margin.top, shiftX = this.viewport.width - this.margin.left - this.margin.right, xAxis = d3.svg.axis();\n                    xAxis.scale(xScale)\n                        .orient(\"bottom\")\n                        .tickFormat((function (item, index) {\n                        if (data.categoryFormatter)\n                            item = data.categoryFormatter.format(item);\n                        if (index != null && xAxis.tickValues() &&\n                            (index === 0 || index === xAxis.tickValues().length - 1)) {\n                            item = powerbi.TextMeasurementService.getTailoredTextOrDefault(StreamGraph.getTextPropertiesFunction(item), (index ? _this.margin.right : _this.margin.left) * 2);\n                        }\n                        return item;\n                    }).bind(xAxis));\n                    var yAxis = d3.svg.axis()\n                        .scale(yScale)\n                        .orient(\"left\")\n                        .tickFormat(function (item) {\n                        if (data.valueFormatter) {\n                            return data.valueFormatter.format(item);\n                        }\n                        return item;\n                    });\n                    this.setMaxTicks(xAxis, shiftX, StreamGraph.MaxNumberOfAxisXValues);\n                    this.setMaxTicks(yAxis, shiftY);\n                    var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;\n                    if (valueAxisSettings.show) {\n                        var axisColor = valueAxisSettings.axisColor;\n                        this.yAxis\n                            .attr(\"transform\", visuals.SVGUtil.translate(this.margin.left, 0))\n                            .call(yAxis);\n                        this.yAxis.selectAll(\"text\").style(\"fill\", axisColor);\n                    }\n                    else\n                        this.yAxis.selectAll(\"*\").remove();\n                    var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;\n                    if (categoryAxisSettings.show) {\n                        var axisColor = categoryAxisSettings.axisColor;\n                        this.xAxis\n                            .attr(\"transform\", visuals.SVGUtil.translate(0, shiftY))\n                            .call(xAxis);\n                        this.xAxis.selectAll(\"text\").style(\"fill\", axisColor);\n                    }\n                    else\n                        this.xAxis.selectAll(\"*\").remove();\n                };\n                StreamGraph.prototype.renderYAxisLabels = function () {\n                    this.yAxis.selectAll(StreamGraph.YAxisLabel.selector).remove();\n                    var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;\n                    if (valueAxisSettings.show) {\n                        this.margin.left = 45;\n                        if (valueAxisSettings.showAxisTitle)\n                            if (this.dataView.categorical.values.source) {\n                                var marginLeft_1 = this.margin.left = 65;\n                                var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;\n                                var isXAxisOn = categoryAxisSettings.show === true;\n                                var isXTitleOn = categoryAxisSettings.showAxisTitle === true;\n                                var height_1 = isXAxisOn ? isXTitleOn ? this.viewport.height - this.margin.bottom : this.viewport.height - this.margin.top : this.viewport.height;\n                                var yAxisText = this.dataView.categorical.values.source.displayName;\n                                var yAxisClass_1 = StreamGraph.YAxisLabel.class;\n                                var yAxisLabel = this.yAxis.append(\"text\")\n                                    .style(\"text-anchor\", \"middle\")\n                                    .text(yAxisText)\n                                    .call(function (text) {\n                                    text.each(function () {\n                                        var text = d3.select(this);\n                                        text.attr({\n                                            class: yAxisClass_1,\n                                            transform: \"rotate(-90)\",\n                                            y: -marginLeft_1 + 5,\n                                            x: -(height_1 / 2),\n                                            dy: \"1em\"\n                                        });\n                                    });\n                                });\n                                yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height_1, powerbi.TextMeasurementService.svgEllipsis);\n                            }\n                            else\n                                valueAxisSettings.showAxisTitle = false;\n                    }\n                    else\n                        this.margin.left = 20;\n                };\n                StreamGraph.prototype.renderXAxisLabels = function () {\n                    this.xAxis.selectAll(StreamGraph.XAxisLabel.selector).remove();\n                    var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;\n                    if (categoryAxisSettings.show) {\n                        this.margin.bottom = 20;\n                        if (categoryAxisSettings.showAxisTitle)\n                            if (this.dataView.categorical.categories[0].source) {\n                                var marginBottom_1 = this.margin.bottom = 40;\n                                var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;\n                                var isYAxisOn = valueAxisSettings.show === true;\n                                var isYTitleOn = valueAxisSettings.showAxisTitle === true;\n                                var width_1 = isYAxisOn ? isYTitleOn ? this.viewport.width + this.margin.left : this.viewport.width + this.margin.right : this.viewport.width;\n                                var xAxisText = this.dataView.categorical.categories[0].source.displayName;\n                                var xAxisClass_1 = StreamGraph.XAxisLabel.class;\n                                var xAxisLabel = this.xAxis.append(\"text\")\n                                    .style(\"text-anchor\", \"middle\")\n                                    .text(xAxisText)\n                                    .call(function (text) {\n                                    text.each(function () {\n                                        var text = d3.select(this);\n                                        text.attr({\n                                            class: xAxisClass_1,\n                                            transform: visuals.SVGUtil.translate(width_1 / 2, marginBottom_1 - 5)\n                                        });\n                                    });\n                                });\n                                xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width_1, powerbi.TextMeasurementService.svgEllipsis);\n                            }\n                            else\n                                categoryAxisSettings.showAxisTitle = false;\n                    }\n                    else\n                        this.margin.bottom = 10;\n                };\n                StreamGraph.prototype.renderLegend = function (streamGraphData) {\n                    var legendData = streamGraphData.legendData;\n                    if (!legendData || !this.dataView || !this.dataView.metadata)\n                        return;\n                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(this.dataView.metadata.objects, \"legend\", {});\n                    if (this.legendObjectProperties) {\n                        visuals.LegendData.update(legendData, this.legendObjectProperties);\n                        var position = this.legendObjectProperties[visuals.legendProps.position];\n                        if (position)\n                            this.legend.changeOrientation(visuals.LegendPosition[position]);\n                    }\n                    this.legend.drawLegend(legendData, _.clone(this.viewport));\n                    visuals.Legend.positionChartArea(this.svg, this.legend);\n                };\n                StreamGraph.prototype.updateViewPort = function () {\n                    var legendMargins = this.legend.getMargins();\n                    var legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];\n                    switch (legendPosition) {\n                        case visuals.LegendPosition.Top:\n                        case visuals.LegendPosition.TopCenter:\n                        case visuals.LegendPosition.Bottom:\n                        case visuals.LegendPosition.BottomCenter: {\n                            this.viewport.height -= legendMargins.height;\n                            break;\n                        }\n                        case visuals.LegendPosition.Left:\n                        case visuals.LegendPosition.LeftCenter:\n                        case visuals.LegendPosition.Right:\n                        case visuals.LegendPosition.RightCenter: {\n                            this.viewport.width -= legendMargins.width;\n                            break;\n                        }\n                    }\n                };\n                StreamGraph.prototype.setMaxTicks = function (axis, maxSize, maxValue) {\n                    var maxTicks = maxValue === undefined\n                        ? this.getTicksByAxis(axis).length\n                        : Math.min(maxValue, this.getTicksByAxis(axis).length);\n                    if (axis.scale().domain.toString() === d3.scale.linear().domain.toString())\n                        axis.ticks(this.getFittedTickLength(axis, maxSize, maxTicks));\n                    else\n                        axis.tickValues(this.getFittedTickValues(axis, maxSize, maxTicks));\n                };\n                StreamGraph.prototype.getFittedTickLength = function (axis, maxSize, maxTicks) {\n                    for (var ticks = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks); maxTicks > 0 && maxSize > 0 && (this.measureTicks(ticks, measureTickFunction) > maxSize || axis.scale().ticks([maxTicks]).length > maxTicks); maxTicks--, ticks = this.getTicksByAxis(axis)) {\n                        axis.ticks(maxTicks);\n                    }\n                    return maxTicks;\n                };\n                StreamGraph.prototype.getFittedTickValues = function (axis, maxSize, maxTicks) {\n                    var ticks = this.getTicksByAxis(axis), maxWidthOf2Ticks, tickPairsWidths = [], measureTickFunction = this.getMeasureTickFunction(axis, ticks);\n                    for (var currentMaxTicks = maxTicks, indexes = []; maxTicks > 0 && maxSize > 0; currentMaxTicks--, indexes = []) {\n                        switch (currentMaxTicks) {\n                            case 0:\n                                return [];\n                            case 1:\n                                indexes = [0];\n                                break;\n                            case 2:\n                                indexes = [0, ticks.length - 1];\n                                break;\n                            default:\n                                var takeEvery = ticks.length / (currentMaxTicks - 1);\n                                for (var i = 0; i < currentMaxTicks - 1; i++) {\n                                    indexes.push(Math.round(takeEvery * i));\n                                }\n                                indexes.push(ticks.length - 1);\n                                break;\n                        }\n                        var ticksIndexes = indexes.map(function (x) { return [ticks[x], x]; });\n                        maxWidthOf2Ticks = (maxSize / ticks.length) * 2;\n                        ticksIndexes.reduce(function (a, b) {\n                            tickPairsWidths.push([measureTickFunction(a[0]) + measureTickFunction(b[0]), (b[1] - a[1]) * maxWidthOf2Ticks]);\n                            return b;\n                        });\n                        if (!tickPairsWidths.some(function (x) { return x[0] > x[1]; })) {\n                            return ticksIndexes.map(function (x) { return x[0]; });\n                        }\n                    }\n                    return [];\n                };\n                StreamGraph.prototype.measureTicks = function (ticks, measureTickFunction) {\n                    return ticks.map(function (x) { return measureTickFunction(x); }).reduce(function (a, b) { return a + b; });\n                };\n                StreamGraph.prototype.getTicksByAxis = function (axis) {\n                    var scale = axis.scale();\n                    var result = axis.tickValues() === null\n                        ? scale.ticks\n                            ? scale.ticks.apply(scale, axis.ticks())\n                            : scale.domain()\n                        : axis.tickValues();\n                    return result.length === undefined ? [result] : result;\n                };\n                StreamGraph.prototype.getMeasureTickFunction = function (axis, ticks) {\n                    var measureFunction = axis.orient() === \"top\" || axis.orient() === \"bottom\"\n                        ? powerbi.TextMeasurementService.measureSvgTextWidth\n                        : powerbi.TextMeasurementService.measureSvgTextHeight;\n                    var cache = {};\n                    return function (x) {\n                        return cache[x]\n                            ? cache[x]\n                            : cache[x] = measureFunction(StreamGraph.getTextPropertiesFunction(axis.tickFormat()(x))) + axis.tickPadding();\n                    };\n                };\n                StreamGraph.getTextPropertiesFunction = function (text) {\n                    var fontFamily = StreamGraphDefaultFontFamily, fontSize = jsCommon.PixelConverter.fromPoint(StreamGraphDefaultFontSizeInPoints), fontWeight = StreamGraphDefaultFontWeight;\n                    return { text: text, fontFamily: fontFamily, fontSize: fontSize, fontWeight: fontWeight };\n                };\n                StreamGraph.prototype.getWiggle = function (dataView) {\n                    if (dataView && dataView.metadata) {\n                        var objects = dataView.metadata.objects;\n                        if (objects) {\n                            var general = powerbi.DataViewObjects.getObject(objects, 'general', undefined);\n                            if (general)\n                                return general['wiggle'];\n                        }\n                    }\n                    return true;\n                };\n                StreamGraph.prototype.enumerateValueAxisValues = function (enumeration) {\n                    var valueAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.valueAxisSettings : StreamGraphDefaultSettings.valueAxisSettings;\n                    enumeration.pushInstance({\n                        selector: null,\n                        objectName: 'valueAxis',\n                        displayName: \"Y-Axis\",\n                        properties: {\n                            show: valueAxisSettings.show,\n                            showAxisTitle: valueAxisSettings.showAxisTitle,\n                            axisColor: valueAxisSettings.axisColor,\n                        }\n                    });\n                };\n                StreamGraph.prototype.enumerateCategoryAxisValues = function (enumeration) {\n                    var categoryAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.categoryAxisSettings : StreamGraphDefaultSettings.categoryAxisSettings;\n                    enumeration.pushInstance({\n                        selector: null,\n                        objectName: 'categoryAxis',\n                        displayName: \"X-Axis\",\n                        properties: {\n                            show: categoryAxisSettings.show,\n                            showAxisTitle: categoryAxisSettings.showAxisTitle,\n                            axisColor: categoryAxisSettings.axisColor,\n                        }\n                    });\n                };\n                StreamGraph.prototype.enumerateLegend = function (enumeration) {\n                    var legendSettings = this.legendObjectProperties ? this.legendObjectProperties : {};\n                    enumeration.pushInstance({\n                        selector: null,\n                        objectName: 'legend',\n                        displayName: \"Legend\",\n                        properties: {\n                            show: this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.legendSettings.show : true,\n                            position: visuals.LegendPosition[this.legend.getOrientation()],\n                            showTitle: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.showTitle, true),\n                            titleText: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.titleText, \"\"),\n                            labelColor: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.labelColor, DefaultLegendLabelFillColor),\n                            fontSize: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.fontSize, DefaultLegendFontSizeInPt)\n                        }\n                    });\n                };\n                StreamGraph.prototype.clearData = function () {\n                    this.svg.selectAll(StreamGraph.Layer.selector).remove();\n                    this.legend.drawLegend({ dataPoints: [] }, this.viewport);\n                    this.yAxis.selectAll(\"*\").remove();\n                    this.xAxis.selectAll(\"*\").remove();\n                };\n                StreamGraph.prototype.enumerateObjectInstances = function (options) {\n                    var enumeration = new visuals.ObjectEnumerationBuilder(), dataView = this.dataView;\n                    switch (options.objectName) {\n                        case 'legend':\n                            if (dataView\n                                && dataView.categorical\n                                && dataView.categorical.values\n                                && dataView.categorical.values.source)\n                                this.enumerateLegend(enumeration);\n                            break;\n                        case 'categoryAxis':\n                            this.enumerateCategoryAxisValues(enumeration);\n                            break;\n                        case 'valueAxis':\n                            this.enumerateValueAxisValues(enumeration);\n                            break;\n                        case 'general':\n                            var general = {\n                                objectName: 'general',\n                                displayName: 'General',\n                                selector: null,\n                                properties: {\n                                    wiggle: this.getWiggle(dataView)\n                                }\n                            };\n                            enumeration.pushInstance(general);\n                            break;\n                    }\n                    return enumeration.complete();\n                };\n                StreamGraph.VisualClassName = 'streamGraph';\n                StreamGraph.Properties = {\n                    general: {\n                        formatString: {\n                            objectName: 'general',\n                            propertyName: 'formatString'\n                        }\n                    },\n                    legend: {\n                        show: {\n                            objectName: \"legend\",\n                            propertyName: \"show\"\n                        }\n                    },\n                    categoryAxis: {\n                        show: {\n                            objectName: \"categoryAxis\",\n                            propertyName: \"show\"\n                        },\n                        axisColor: {\n                            objectName: \"categoryAxis\",\n                            propertyName: \"axisColor\"\n                        },\n                        showAxisTitle: {\n                            objectName: \"categoryAxis\",\n                            propertyName: \"showAxisTitle\"\n                        }\n                    },\n                    valueAxis: {\n                        show: {\n                            objectName: \"valueAxis\",\n                            propertyName: \"show\"\n                        },\n                        axisColor: {\n                            objectName: \"valueAxis\",\n                            propertyName: \"axisColor\"\n                        },\n                        showAxisTitle: {\n                            objectName: \"valueAxis\",\n                            propertyName: \"showAxisTitle\"\n                        }\n                    }\n                };\n                StreamGraph.Layer = {\n                    'class': 'layer',\n                    selector: '.layer'\n                };\n                StreamGraph.XAxisLabel = {\n                    'class': 'xAxisLabel',\n                    selector: '.xAxisLabel'\n                };\n                StreamGraph.YAxisLabel = {\n                    'class': 'yAxisLabel',\n                    selector: '.yAxisLabel'\n                };\n                StreamGraph.MaxNumberOfAxisXValues = 5;\n                StreamGraph.capabilities = {\n                    dataRoles: [\n                        {\n                            name: 'Category',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Category',\n                        }, {\n                            name: 'Series',\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Series',\n                        }, {\n                            name: 'Y',\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),\n                        },\n                    ],\n                    dataViewMappings: [{\n                            conditions: [\n                                { 'Category': { max: 1 }, 'Series': { max: 0 } },\n                                { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }\n                            ],\n                            categorical: {\n                                categories: {\n                                    for: { in: 'Category' },\n                                    dataReductionAlgorithm: { bottom: {} }\n                                },\n                                values: {\n                                    group: {\n                                        by: 'Series',\n                                        select: [{ for: { in: 'Y' } }],\n                                        dataReductionAlgorithm: { bottom: {} }\n                                    }\n                                },\n                            }\n                        }],\n                    objects: {\n                        general: {\n                            displayName: 'General',\n                            properties: {\n                                formatString: { type: { formatting: { formatString: true } } },\n                                wiggle: {\n                                    type: { bool: true },\n                                    displayName: 'Wiggle'\n                                }\n                            }\n                        },\n                        categoryAxis: {\n                            displayName: 'X-Axis',\n                            properties: {\n                                show: {\n                                    displayName: 'show',\n                                    type: { bool: true }\n                                },\n                                showAxisTitle: {\n                                    displayName: 'Title',\n                                    type: { bool: true }\n                                },\n                                axisColor: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        valueAxis: {\n                            displayName: 'Y-Axis',\n                            properties: {\n                                show: {\n                                    displayName: 'show',\n                                    type: { bool: true }\n                                },\n                                showAxisTitle: {\n                                    displayName: 'Title',\n                                    type: { bool: true }\n                                },\n                                axisColor: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                }\n                            }\n                        },\n                        legend: {\n                            displayName: 'Legend',\n                            properties: {\n                                show: {\n                                    displayName: 'show',\n                                    type: { bool: true }\n                                },\n                                position: {\n                                    displayName: 'Position',\n                                    type: { enumeration: visuals.legendPosition.type }\n                                },\n                                showTitle: {\n                                    displayName: 'Title',\n                                    type: { bool: true }\n                                },\n                                titleText: {\n                                    displayName: 'Legend Name',\n                                    type: { text: true },\n                                    suppressFormatPainterCopy: true\n                                },\n                                labelColor: {\n                                    displayName: 'Color',\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                fontSize: {\n                                    displayName: 'Text Size',\n                                    type: { formatting: { fontSize: true } }\n                                }\n                            }\n                        }\n                    }\n                };\n                return StreamGraph;\n            }());\n            samples.StreamGraph = StreamGraph;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var SelectionManager = visuals.utility.SelectionManager;\n            samples.sunburstRoleNames = {\n                nodes: 'Nodes',\n                values: 'Values',\n            };\n            var Sunburst = (function () {\n                function Sunburst() {\n                    this.total = 0;\n                }\n                Sunburst.prototype.init = function (options) {\n                    var _this = this;\n                    this.arc = d3.svg.arc()\n                        .startAngle(function (d) { return d.x; })\n                        .endAngle(function (d) { return d.x + d.dx; })\n                        .innerRadius(function (d) { return Math.sqrt(d.y); })\n                        .outerRadius(function (d) { return Math.sqrt(d.y + d.dy); });\n                    this.colors = options.style.colorPalette.dataColors;\n                    this.selectionManager = new SelectionManager({ hostServices: options.host });\n                    this.svg = d3.select(options.element.get(0)).append('svg');\n                    this.svg.classed('mainDrawArea', true);\n                    this.g = this.svg.append('g');\n                    this.g.classed(\"container\", true);\n                    this.svg.append(\"text\")\n                        .classed(\"sunBurstPercentageFixed\", true);\n                    this.svg.on('mousedown', function (d) {\n                        _this.svg.selectAll(\"path\").style(\"opacity\", 1);\n                        _this.svg.select(\".sunBurstPercentageFixed\").style(\"opacity\", 0);\n                        _this.selectionManager.clear();\n                    });\n                };\n                Sunburst.setAllUnhide = function (selection) {\n                    selection.attr(\"setUnHide\", \"true\");\n                };\n                Sunburst.prototype.update = function (options) {\n                    if (options.dataViews.length > 0) {\n                        var data = this.converter(options.dataViews[0], this.colors);\n                        this.viewport = options.viewport;\n                        this.updateInternal(data);\n                    }\n                };\n                Sunburst.prototype.updateInternal = function (dataRootNode) {\n                    var _this = this;\n                    this.svg.attr({\n                        'height': this.viewport.height,\n                        'width': this.viewport.width\n                    });\n                    this.g.attr('transform', visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));\n                    var radius = Math.min(this.viewport.width, this.viewport.height) / 2;\n                    var partition = d3.layout.partition()\n                        .size([2 * Math.PI, radius * radius])\n                        .value(function (d) { return d.value; });\n                    var path = this.g.datum(dataRootNode).selectAll(\"path\")\n                        .data(partition.nodes);\n                    path.enter().append(\"path\");\n                    path.attr(\"display\", function (d) { return d.depth ? null : \"none\"; })\n                        .attr(\"d\", this.arc)\n                        .style(\"stroke\", \"#fff\")\n                        .style(\"fill\", function (d) { return d.color; })\n                        .style(\"fill-rule\", \"evenodd\")\n                        .on(\"mousedown\", function (d) {\n                        if (d.selector) {\n                            _this.selectionManager.select(d.selector);\n                        }\n                        d3.selectAll(\"path\").call(Sunburst.setAllUnhide).attr('setUnHide', null);\n                        _this.highlightPath(d, _this, true);\n                        var percentageFixedText = _this.svg.select(\".sunBurstPercentageFixed\");\n                        var percentage = _this.total === 0 ? 0 : (100 * d.total / _this.total).toPrecision(3);\n                        percentageFixedText.text(d ? percentage + \"%\" : \"\");\n                        percentageFixedText.style(\"fill\", d.color);\n                        _this.onResize();\n                        event.stopPropagation();\n                    });\n                    this.renderTooltip(path);\n                    path.exit().remove();\n                    this.onResize();\n                };\n                // Get all parents of the node\n                Sunburst.getTreePath = function (node) {\n                    var path = [];\n                    var current = node;\n                    while (current.parent) {\n                        path.unshift(current);\n                        current = current.parent;\n                    }\n                    return path;\n                };\n                Sunburst.prototype.onResize = function () {\n                    var width = this.viewport.width;\n                    var height = this.viewport.height;\n                    var percentageFixedText = this.svg.select(\".sunBurstPercentageFixed\");\n                    var textWidth = powerbi.TextMeasurementService.measureSvgTextElementWidth(percentageFixedText[0][0]);\n                    percentageFixedText.style(\"opacity\", 1);\n                    percentageFixedText.attr(\"y\", (height / 2 + 4));\n                    percentageFixedText.attr(\"x\", ((width / 2) - (textWidth / 2)));\n                };\n                Sunburst.prototype.highlightPath = function (d, sunBurst, setUnhide) {\n                    var parentsArray = d ? Sunburst.getTreePath(d) : [];\n                    // Set opacity for all the segments.\n                    sunBurst.svg.selectAll(\"path\").each(function () {\n                        if (d3.select(this).attr('setUnHide') !== 'true') {\n                            d3.select(this).style(\"opacity\", Sunburst.minOpacity);\n                        }\n                    });\n                    // Highlight only ancestors of the current segment.\n                    sunBurst.svg.selectAll(\"path\")\n                        .filter(function (node) {\n                        return (parentsArray.indexOf(node) >= 0);\n                    }).each(function () {\n                        d3.select(this).style(\"opacity\", 1);\n                        if (setUnhide === true) {\n                            d3.select(this).attr('setUnHide', 'true');\n                        }\n                    });\n                };\n                Sunburst.prototype.renderTooltip = function (selection) {\n                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {\n                        return tooltipEvent.data.tooltipInfo;\n                    });\n                };\n                Sunburst.getTooltipData = function (displayName, value) {\n                    return [{\n                            displayName: displayName,\n                            value: value < 0 ? \"\" : value.toString()\n                        }];\n                };\n                Sunburst.prototype.covertTreeNodeToSunBurstNode = function (originParentNode, sunburstParentNode, colors, pathIdentity, color) {\n                    var selector;\n                    if (originParentNode.identity) {\n                        pathIdentity = pathIdentity.concat([originParentNode.identity]);\n                        selector = { data: pathIdentity, };\n                    }\n                    var selectionId = pathIdentity.length === 0 ? null : new visuals.SelectionId(selector, false);\n                    var valueToSet = originParentNode.values ? originParentNode.values[0].value : 0;\n                    var newSunNode = {\n                        name: originParentNode.name,\n                        value: Math.max(valueToSet, 0),\n                        selector: selectionId,\n                        total: valueToSet\n                    };\n                    if (originParentNode.value) {\n                        newSunNode.color = color ? color : colors.getColor(originParentNode.value).value;\n                    }\n                    this.total += newSunNode.value;\n                    if (originParentNode.children && originParentNode.children.length > 0) {\n                        newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, -1);\n                        newSunNode.children = [];\n                        for (var i = 0; i < originParentNode.children.length; i++) {\n                            var newChild = this.covertTreeNodeToSunBurstNode(originParentNode.children[i], newSunNode, colors, pathIdentity, newSunNode.color);\n                            newSunNode.children.push(newChild);\n                            newSunNode.total += newChild.total;\n                        }\n                    }\n                    else {\n                        newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, valueToSet);\n                    }\n                    if (sunburstParentNode) {\n                        newSunNode.parent = sunburstParentNode;\n                    }\n                    return newSunNode;\n                };\n                Sunburst.prototype.converter = function (dataView, colors) {\n                    var colorScale = colors.getNewColorScale();\n                    this.total = 0;\n                    var root = this.covertTreeNodeToSunBurstNode(dataView.matrix.rows.root, null, colorScale, [], undefined);\n                    return root;\n                };\n                Sunburst.minOpacity = 0.2;\n                Sunburst.roleNames = {\n                    nodes: 'Nodes',\n                    values: 'Values',\n                };\n                Sunburst.capabilities = {\n                    dataRoles: [\n                        {\n                            name: Sunburst.roleNames.nodes,\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Groups'\n                        }, {\n                            name: Sunburst.roleNames.values,\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Values'\n                        }\n                    ],\n                    objects: {\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),\n                            properties: {\n                                formatString: {\n                                    type: { formatting: { formatString: true } },\n                                },\n                            },\n                        },\n                    },\n                    dataViewMappings: [{\n                            conditions: [\n                                { 'Groups': { min: 0 }, 'Values': { max: 1 } },\n                            ],\n                            matrix: {\n                                rows: {\n                                    for: { in: Sunburst.roleNames.nodes },\n                                },\n                                values: {\n                                    for: { in: Sunburst.roleNames.values }\n                                },\n                            }\n                        }],\n                };\n                return Sunburst;\n            }());\n            samples.Sunburst = Sunburst;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var samples;\n        (function (samples) {\n            var SelectionManager = visuals.utility.SelectionManager;\n            ;\n            ;\n            var LineDotChart = (function () {\n                function LineDotChart() {\n                    this.margin = {\n                        top: 10,\n                        right: 30,\n                        bottom: 10,\n                        left: 10\n                    };\n                    this.LegendSize = 50;\n                    this.AxisSize = 30;\n                }\n                /* One time setup*/\n                LineDotChart.prototype.init = function (options) {\n                    var _this = this;\n                    this.hostServices = options.host;\n                    this.selectionManager = new SelectionManager({ hostServices: this.hostServices });\n                    this.root = d3.select(options.element.get(0))\n                        .append('svg')\n                        .classed(LineDotChart.Identity.class, true);\n                    this.root.on('click', function (d) { _this.clearSelection(); });\n                    this.main = this.root.append('g');\n                    this.axes = this.main.append('g').classed(LineDotChart.Axes.class, true);\n                    this.axisX = this.axes.append('g').classed(LineDotChart.Axis.class, true);\n                    this.axisY = this.axes.append('g').classed(LineDotChart.Axis.class, true);\n                    this.axisY2 = this.axes.append('g').classed(LineDotChart.Axis.class, true);\n                    this.legends = this.main.append('g').classed(LineDotChart.Legends.class, true);\n                    this.line = this.main.append('g').classed(LineDotChart.Values.class, true);\n                    this.colors = options.style && options.style.colorPalette\n                        ? options.style.colorPalette.dataColors\n                        : new visuals.DataColorPalette();\n                };\n                /* Called for data, size, formatting changes*/\n                LineDotChart.prototype.update = function (options) {\n                    if (!options.dataViews || !options.dataViews[0]) {\n                        return;\n                    }\n                    var viewport = options.viewport;\n                    var model = this.model = this.converter(options.dataViews[0], viewport);\n                    // if (!model) {\n                    //     return;\n                    // }\n                    this.clearSelection();\n                    this.resize(viewport);\n                    // this.draw(model, !options.suppressAnimations);\n                    this.draw(model);\n                };\n                /*About to remove your visual, do clean up here */\n                LineDotChart.prototype.destroy = function () {\n                    this.root = null;\n                };\n                LineDotChart.prototype.setIsStopped = function (isstopped) {\n                    var objects = {\n                        merge: [\n                            {\n                                objectName: \"misc\",\n                                selector: undefined,\n                                properties: {\n                                    \"isstopped\": isstopped,\n                                }\n                            }\n                        ]\n                    };\n                    this.hostServices.persistProperties(objects);\n                    this.hostServices.onSelect({ data: [] });\n                };\n                LineDotChart.prototype.enumerateObjectInstances = function (options) {\n                    var instances = [];\n                    if (!this.model || !this.model.settings) {\n                        return instances;\n                    }\n                    var settings = this.model.settings;\n                    switch (options.objectName) {\n                        case \"lineoptions\":\n                            var lineoptions = {\n                                objectName: \"lineoptions\",\n                                displayName: \"lineoptions\",\n                                selector: null,\n                                properties: {\n                                    fill: settings.lineFill,\n                                    lineThickness: settings.lineThickness\n                                }\n                            };\n                            instances.push(lineoptions);\n                            break;\n                        case \"dotoptions\":\n                            var dotoptions = {\n                                objectName: \"dotoptions\",\n                                displayName: \"dotoptions\",\n                                selector: null,\n                                properties: {\n                                    color: settings.dotFill,\n                                    dotSizeMin: settings.dotSizeMin,\n                                    dotSizeMax: settings.dotSizeMax\n                                }\n                            };\n                            instances.push(dotoptions);\n                            break;\n                        case \"counteroptions\":\n                            var counteroptions = {\n                                objectName: \"counteroptions\",\n                                displayName: \"counteroptions\",\n                                selector: null,\n                                properties: {\n                                    counterTitle: settings.counterTitle\n                                }\n                            };\n                            instances.push(counteroptions);\n                            break;\n                        // case \"labels\":\n                        //     var labels: VisualObjectInstance = {\n                        //         objectName: \"labels\",\n                        //         displayName: \"labels\",\n                        //         selector: null,\n                        //         properties: {\n                        //             labelPrecision: settings.precision\n                        //         }\n                        //     };\n                        //     instances.push(labels);\n                        //     break;\n                        case \"misc\":\n                            var misc = {\n                                objectName: \"misc\",\n                                displayName: \"misc\",\n                                selector: null,\n                                properties: {\n                                    isanimated: settings.isanimated,\n                                    isstopped: settings.isstopped,\n                                    duration: settings.duration\n                                }\n                            };\n                            instances.push(misc);\n                            break;\n                    }\n                    return instances;\n                };\n                LineDotChart.prototype.selectDot = function (dotelement, selector) {\n                    var dot = d3.select(dotelement);\n                    if (!dot.classed('point_selected')) {\n                        if (selector) {\n                            this.selectionManager.select(selector);\n                        }\n                        this.root.classed(\"filtered\", true);\n                        this.line.selectAll('circle.point')\n                            .classed('point_selected', false);\n                        d3.select(dotelement)\n                            .classed('point_selected', true);\n                    }\n                    else {\n                        this.clearSelection();\n                    }\n                    d3.event.stopPropagation();\n                };\n                LineDotChart.prototype.clearSelection = function () {\n                    this.root.classed(\"filtered\", false);\n                    this.root.selectAll(\"circle.point\").classed(\"point_selected\", false);\n                    this.selectionManager.clear();\n                };\n                // Convert a DataView into a view model\n                LineDotChart.prototype.converter = function (dataView, viewport) {\n                    if (!dataView.categorical ||\n                        !dataView.categorical.categories ||\n                        !dataView.categorical.categories[0] ||\n                        !dataView.categorical.categories[0].values ||\n                        !(dataView.categorical.categories[0].values.length > 0) ||\n                        !dataView.categorical ||\n                        !dataView.categorical.values ||\n                        !dataView.categorical.values[0] ||\n                        !dataView.categorical.values[0].values ||\n                        !(dataView.categorical.values[0].values.length > 0)) {\n                        return null;\n                    }\n                    var values = [];\n                    var metadataColumn;\n                    var extent;\n                    var min;\n                    var max;\n                    var that = this;\n                    var categoryType = visuals.AxisHelper.getCategoryValueType(dataView.categorical.categories[0].source, true);\n                    this.isDateTime = visuals.AxisHelper.isDateTime(categoryType);\n                    var isScalar = true;\n                    var settings = this.parseSettings(dataView);\n                    var effectiveWidth = Math.max(0, viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize);\n                    var effectiveHeight = Math.max(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize);\n                    var format = \"\";\n                    var formatter;\n                    // X for categories\n                    values = dataView.categorical.categories[0].values;\n                    metadataColumn = dataView.categorical.categories[0].source;\n                    extent = d3.extent(values);\n                    if (this.isDateTime) {\n                        min = extent[0].getTime();\n                        max = extent[1].getTime();\n                        min = new Date(min);\n                        max = new Date(max + (max - min) * .05);\n                        // var xDomain: number[] = isScalar ? [min, max] : [min.getTime(), max.getTime()]\n                        // var format: string = \"MMM dd yyyy HH:mm\";\n                        format = \"MMM dd yyyy\";\n                        formatter = visuals.valueFormatter.create({ format: format });\n                    }\n                    else {\n                        min = extent[0];\n                        max = extent[1];\n                        max = max + (max - min) * .05;\n                        formatter = visuals.valueFormatter.create({ value: 0 });\n                    }\n                    var xAxis = visuals.AxisHelper.createAxis({\n                        pixelSpan: effectiveWidth,\n                        dataDomain: [min, max],\n                        metaDataColumn: metadataColumn,\n                        formatString: null,\n                        //formatString: LineDotChart.Properties.general.formatString,\n                        outerPadding: 0,\n                        isCategoryAxis: true,\n                        isScalar: isScalar,\n                        isVertical: false,\n                        forcedTickCount: undefined,\n                        useTickIntervalForDisplayUnits: true,\n                        // axisPrecision: settings.precision,\n                        getValueFn: function (index, type) {\n                            if (that.isDateTime) {\n                                return formatter.format(new Date(index));\n                            }\n                            else {\n                                return index;\n                            }\n                        }\n                    });\n                    xAxis.formatter = formatter;\n                    metadataColumn = dataView.categorical.values[0].source;\n                    values = dataView.categorical.values[0].values;\n                    extent = d3.extent(values);\n                    min = extent[0];\n                    max = extent[1];\n                    var result = [];\n                    var value_sum = 0;\n                    var value = 0;\n                    var time = 0;\n                    var selector;\n                    for (var i = 0; i < dataView.categorical.categories[0].values.length; i++) {\n                        value = dataView.categorical.values[0].values[i];\n                        time = dataView.categorical.categories[0].values[i];\n                        value_sum += value;\n                        selector = visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i]);\n                        result.push({\n                            dot: (value - min) / (max - min),\n                            value: value,\n                            sum: value_sum,\n                            time: time,\n                            selector: selector\n                        });\n                    }\n                    // make some space for counter + 25%\n                    value_sum = value_sum + (value_sum - min) * 0.10;\n                    var yAxis = visuals.AxisHelper.createAxis({\n                        pixelSpan: effectiveHeight,\n                        dataDomain: [min, value_sum],\n                        metaDataColumn: metadataColumn,\n                        formatString: null,\n                        outerPadding: 0,\n                        isCategoryAxis: false,\n                        isScalar: true,\n                        isVertical: true,\n                        useTickIntervalForDisplayUnits: true\n                    });\n                    var yAxis2 = visuals.AxisHelper.createAxis({\n                        pixelSpan: effectiveHeight,\n                        dataDomain: [min, value_sum],\n                        metaDataColumn: metadataColumn,\n                        formatString: null,\n                        outerPadding: 0,\n                        isCategoryAxis: false,\n                        isScalar: true,\n                        isVertical: true,\n                        useTickIntervalForDisplayUnits: true\n                    });\n                    yAxis2.axis.orient('right');\n                    // Show gridlines on the chart to make the values more readable.\n                    // TODO: Make this a configuration setting that can be toggled.\n                    // xAxis.axis = xAxis.axis.tickSize(-effectiveHeight);\n                    // yAxis.axis = yAxis.axis.tickSize(-effectiveWidth);\n                    return {\n                        points: result,\n                        settings: settings,\n                        xAxis: xAxis,\n                        yAxis: yAxis,\n                        yAxis2: yAxis2,\n                        legends: this.generateAxisLabels(viewport, settings)\n                    };\n                };\n                LineDotChart.prototype.parseSettings = function (dataView) {\n                    if (!dataView ||\n                        !dataView.metadata ||\n                        !dataView.metadata.columns ||\n                        !dataView.metadata.columns[0]) {\n                        return null;\n                    }\n                    var objects = dataView.metadata.objects;\n                    var lineFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.lineoptions.fill, LineDotChart.DefaultSettings.lineFill);\n                    var dotFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.dotoptions.color, LineDotChart.DefaultSettings.dotFill);\n                    var xAxisTitle = LineDotChart.DefaultSettings.xAxisTitle;\n                    var yAxisTitle = LineDotChart.DefaultSettings.yAxisTitle;\n                    if (dataView.categorical.categories[0] &&\n                        dataView.categorical.categories[0].source &&\n                        dataView.categorical.categories[0].source.displayName &&\n                        dataView.categorical.values[0] &&\n                        dataView.categorical.values[0].source &&\n                        dataView.categorical.values[0].source.displayName) {\n                        xAxisTitle = dataView.categorical.categories[0].source.displayName;\n                        yAxisTitle = dataView.categorical.values[0].source.displayName;\n                    }\n                    var lineThickness = LineDotChart.DefaultSettings.lineThickness;\n                    var dotSizeMin = LineDotChart.DefaultSettings.dotSizeMin;\n                    var dotSizeMax = LineDotChart.DefaultSettings.dotSizeMax;\n                    var counterTitle = LineDotChart.DefaultSettings.counterTitle;\n                    var isanimated = LineDotChart.DefaultSettings.isanimated;\n                    var isstopped = LineDotChart.DefaultSettings.isstopped;\n                    var duration = LineDotChart.DefaultSettings.duration;\n                    if (objects) {\n                        lineThickness = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.lineoptions.lineThickness, LineDotChart.DefaultSettings.lineThickness);\n                        dotSizeMin = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMin, LineDotChart.DefaultSettings.dotSizeMin);\n                        dotSizeMax = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMax, LineDotChart.DefaultSettings.dotSizeMax);\n                        counterTitle = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.counteroptions.counterTitle, LineDotChart.DefaultSettings.counterTitle);\n                        isanimated = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isanimated, LineDotChart.DefaultSettings.isanimated);\n                        isstopped = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isstopped, LineDotChart.DefaultSettings.isstopped);\n                        duration = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.duration, LineDotChart.DefaultSettings.duration);\n                    }\n                    return {\n                        // precision: LineDotChart.getPrecision(objects),\n                        xAxisTitle: xAxisTitle,\n                        yAxisTitle: yAxisTitle,\n                        lineFill: lineFillColorHelper.getColorForMeasure(objects, ''),\n                        lineThickness: lineThickness,\n                        dotFill: dotFillColorHelper.getColorForMeasure(objects, ''),\n                        dotSizeMin: dotSizeMin,\n                        dotSizeMax: dotSizeMax,\n                        counterTitle: counterTitle,\n                        isstopped: isstopped,\n                        isanimated: isanimated,\n                        duration: duration\n                    };\n                };\n                // private static getPrecision(objects: DataViewObjects): number {\n                //     if (!objects) {\n                //         return LineDotChart.DefaultSettings.precision;\n                //     }\n                //     var precision: number = DataViewObjects.getValue(\n                //         objects,\n                //         LineDotChart.Properties.labels.labelPrecision,\n                //         LineDotChart.DefaultSettings.precision);\n                //     if (precision < LineDotChart.MinPrecision) {\n                //         return LineDotChart.MinPrecision;\n                //     }\n                //     return precision;\n                // }\n                LineDotChart.prototype.generateAxisLabels = function (viewport, settings) {\n                    return [\n                        {\n                            transform: visuals.SVGUtil.translate((viewport.width - this.margin.left - this.margin.right) / 2, (viewport.height - this.margin.top - this.margin.bottom)),\n                            text: settings.xAxisTitle,\n                            dx: \"1em\",\n                            dy: \"-1em\"\n                        }, {\n                            transform: visuals.SVGUtil.translateAndRotate(0, (viewport.height - this.margin.top - this.margin.bottom) / 2, 0, 0, 270),\n                            text: settings.yAxisTitle,\n                            dx: \"3em\"\n                        }\n                    ];\n                };\n                LineDotChart.prototype.resize = function (viewport) {\n                    this.root.attr({\n                        'height': Math.max(0, viewport.height),\n                        'width': Math.max(0, viewport.width)\n                    });\n                    this.main.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top));\n                    this.legends.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top));\n                    this.line.attr('transform', visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0));\n                    this.axes.attr('transform', visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0));\n                    this.axisX.attr('transform', visuals.SVGUtil.translate(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize));\n                    this.axisY2.attr('transform', visuals.SVGUtil.translate(viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize, 0));\n                };\n                LineDotChart.prototype.draw = function (model) {\n                    var _this = this;\n                    var that = this;\n                    // Clear canvas\n                    this.line.selectAll('*').remove();\n                    this.legends.selectAll('*').remove();\n                    this.axisX.selectAll('*').remove();\n                    this.axisY.selectAll('*').remove();\n                    this.axisY2.selectAll('*').remove();\n                    if (!model) {\n                        return;\n                    }\n                    this.renderLegends(model);\n                    if (model && model.points && model.points.length) {\n                        this.axisX.call(model.xAxis.axis);\n                        this.axisY.call(model.yAxis.axis);\n                        this.axisY2.call(model.yAxis2.axis);\n                        if (model.settings.isanimated) {\n                            var playBtn = this.line\n                                .append(\"g\")\n                                .classed(\"lineDotChart__playBtn\", true)\n                                .attr(\"transform\", \"translate(40, 20)\");\n                            playBtn\n                                .append(\"circle\")\n                                .attr(\"r\", 34 / 2);\n                            // play / reset buttin\n                            if (model.settings.isstopped) {\n                                playBtn\n                                    .append(\"path\")\n                                    .attr(\"d\", \"M0 2l10 6-10 6z\")\n                                    .attr(\"transform\", \"translate(-4,-8)\");\n                                playBtn\n                                    .on('click.lineDotChart__playBt', function () {\n                                    that.setIsStopped(false);\n                                });\n                                return;\n                            }\n                            else {\n                                playBtn\n                                    .append(\"path\")\n                                    .attr(\"d\", \"M0 2l10 6-10 6z\")\n                                    .attr(\"transform-origin\", \"center\")\n                                    .attr(\"transform\", \"translate(6, 8) rotate(180)\");\n                                playBtn\n                                    .append(\"rect\")\n                                    .attr(\"width\", \"2\")\n                                    .attr(\"height\", \"12\")\n                                    .attr(\"transform\", \"translate(-7,-6)\");\n                                playBtn\n                                    .on('click.lineDotChart__playBt', function () {\n                                    that.setIsStopped(true);\n                                });\n                            }\n                        }\n                        var clip = this.line\n                            .append(\"clipPath\")\n                            .attr(\"id\", \"lineClip\")\n                            .append(\"rect\")\n                            .attr(\"x\", 0)\n                            .attr(\"y\", 0)\n                            .attr(\"width\", 1)\n                            .attr(\"height\", 10000);\n                        // Draw the line\n                        var line = d3.svg.line()\n                            .x(function (d) { return model.xAxis.scale(d.time); })\n                            .y(function (d) { return model.yAxis.scale(d.sum); });\n                        // .interpolate(\"basis\");\n                        var lineSelection = this.line.selectAll('path.plot')\n                            .data([model.points]);\n                        lineSelection.enter().append('path');\n                        lineSelection\n                            .classed('plot', true)\n                            .attr('stroke', function (d, i) { return model.settings.lineFill; })\n                            .attr('stroke-width', model.settings.lineThickness)\n                            .attr('d', line);\n                        var totalLength = lineSelection.node().getTotalLength();\n                        var line_left = lineSelection.node().getPointAtLength(0).x;\n                        var line_right = lineSelection.node().getPointAtLength(totalLength).x;\n                        lineSelection\n                            .attr(\"clip-path\", \"url(\" + location.href + \"#lineClip)\");\n                        if (!model.settings.isanimated) {\n                            clip\n                                .interrupt()\n                                .attr('x', line_left)\n                                .attr('width', line_right - line_left);\n                        }\n                        else {\n                            clip\n                                .attr('x', line_left)\n                                .interrupt()\n                                .transition()\n                                .ease(\"linear\")\n                                .duration(model.settings.duration * 1000)\n                                .attr('width', line_right - line_left);\n                        }\n                        lineSelection\n                            .exit().remove();\n                        var point_time = 300;\n                        var counter_time = 0; // point_time / 100;\n                        // Draw the individual data points that will be shown on hover with a tooltip\n                        var lineTipSelection = this.line.selectAll('circle.point')\n                            .data(model.points);\n                        var that = this;\n                        lineTipSelection.enter()\n                            .append('circle')\n                            .attr('fill', model.settings.dotFill)\n                            .attr('opacity', .77)\n                            .attr('r', function (d) { return model.settings.dotSizeMin + d.dot * (model.settings.dotSizeMax - model.settings.dotSizeMin); })\n                            .classed('point', true)\n                            .on('mouseover.point', this.showDataPoint)\n                            .on('mouseout.point', this.hideDataPoint)\n                            .on(\"click.point\", function (d) {\n                            that.selectDot(this, d.selector);\n                        });\n                        if (!model.settings.isanimated) {\n                            lineTipSelection\n                                .interrupt()\n                                .attr('transform', function (d) {\n                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(1)';\n                            });\n                        }\n                        else {\n                            lineTipSelection\n                                .interrupt()\n                                .attr('transform', function (d) {\n                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(0.005)';\n                            })\n                                .transition()\n                                .duration(point_time)\n                                .delay(function (d, i) { return _this.pointDelay(model.points, i, model.settings.duration); })\n                                .ease(\"linear\")\n                                .attr('transform', function (d) {\n                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(3.4)';\n                            })\n                                .transition()\n                                .duration(point_time)\n                                .delay(function (d, i) { return _this.pointDelay(model.points, i, model.settings.duration) + point_time; })\n                                .ease(\"elastic\")\n                                .attr('transform', function (d) {\n                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(1)';\n                            });\n                        }\n                        lineTipSelection.exit().remove();\n                        for (var i = 0; i < lineTipSelection[0].length; i++) {\n                            this.addTooltip(model, lineTipSelection[0][i]);\n                        }\n                        // Feature Counter text \n                        var lineTextSelection = this.line.selectAll('text')\n                            .data(model.points);\n                        lineTextSelection.enter()\n                            .append(\"text\")\n                            .classed('text', true)\n                            .text(function (d, i) {\n                            // if (model.points[i + 1]) {\n                            return model.settings.counterTitle + ' ' + (i + 1);\n                            // } else {\n                            //     // TODO: CRAZY hard code\n                            //     return model.settings.counterTitle + ' 265'\n                            // }\n                        })\n                            .attr('x', line_right - 260)\n                            .attr('y', 30);\n                        if (!model.settings.isanimated) {\n                            // opacity 1 only for last\n                            lineTextSelection\n                                .interrupt()\n                                .attr('transform', 'translate(0 0)')\n                                .attr('opacity', function (d, i) { return Number(i === model.points.length - 1); });\n                        }\n                        else {\n                            lineTextSelection\n                                .attr('opacity', 0)\n                                .interrupt()\n                                .transition()\n                                .duration(counter_time)\n                                .delay(function (d, i) { return _this.pointDelay(model.points, i, model.settings.duration); })\n                                .attr('transform', 'translate(0 0)')\n                                .attr('opacity', 1)\n                                .transition()\n                                .duration(counter_time)\n                                .delay(function (d, i) {\n                                if (model.points[i + 1]) {\n                                    return _this.pointDelay(model.points, i + 1, model.settings.duration);\n                                }\n                                else {\n                                    return Number.POSITIVE_INFINITY;\n                                }\n                            })\n                                .attr('opacity', 0);\n                        }\n                        lineTextSelection.exit().remove();\n                    }\n                };\n                LineDotChart.prototype.pointDelay = function (points, num, animation_duration) {\n                    if (!points.length || !points[num] || num === 0) {\n                        return 0;\n                    }\n                    if (this.isDateTime) {\n                        var time = points[num].time;\n                        var min = points[0].time.getTime();\n                        var max = points[points.length - 1].time.getTime();\n                        var val = time.getTime();\n                    }\n                    else {\n                        var time = points[num].time;\n                        var min = points[0].time;\n                        var max = points[points.length - 1].time;\n                        var val = time;\n                    }\n                    return animation_duration * 1000 * (val - min) / (max - min);\n                };\n                LineDotChart.prototype.showDataPoint = function (data, index) {\n                    d3.select(this).classed('show', true);\n                };\n                LineDotChart.prototype.hideDataPoint = function (data, index) {\n                    d3.select(this).classed('show', false);\n                };\n                LineDotChart.prototype.addTooltip = function (model, element) {\n                    var selection = d3.select(element);\n                    var data = selection.datum();\n                    visuals.TooltipManager.addTooltip(selection, function (event) {\n                        return [\n                            {\n                                displayName: model.settings.xAxisTitle,\n                                value: model.xAxis.formatter.format(data.time)\n                            },\n                            {\n                                displayName: model.settings.yAxisTitle,\n                                value: data.value.toString()\n                            }\n                        ];\n                    });\n                };\n                LineDotChart.prototype.renderLegends = function (model) {\n                    var legendSelection = this.legends\n                        .selectAll(LineDotChart.Legend.selector)\n                        .data(model.legends);\n                    legendSelection\n                        .enter()\n                        .append(\"svg:text\");\n                    legendSelection\n                        .attr(\"x\", 0)\n                        .attr(\"y\", 0)\n                        .attr(\"dx\", function (item) { return item.dx; })\n                        .attr(\"dy\", function (item) { return item.dy; })\n                        .attr(\"transform\", function (item) { return item.transform; })\n                        .text(function (item) { return item.text; })\n                        .classed(LineDotChart.Legend.class, true);\n                    legendSelection\n                        .exit()\n                        .remove();\n                };\n                LineDotChart.DefaultSettings = {\n                    lineFill: 'rgb(102, 212, 204)',\n                    lineThickness: 3,\n                    dotFill: '#005c55',\n                    dotSizeMin: 4,\n                    dotSizeMax: 38,\n                    counterTitle: 'Total features',\n                    // precision: 2,\n                    xAxisTitle: '',\n                    yAxisTitle: '',\n                    duration: 20,\n                    isanimated: true,\n                    isstopped: true\n                };\n                /**\n                * Informs the System what it can do\n                * Fields, Formatting options, data reduction & QnA hints\n                */\n                LineDotChart.capabilities = {\n                    dataRoles: [\n                        {\n                            name: \"Date\",\n                            kind: powerbi.VisualDataRoleKind.Grouping,\n                            displayName: 'Date'\n                        },\n                        {\n                            name: \"Values\",\n                            kind: powerbi.VisualDataRoleKind.Measure,\n                            displayName: 'Values'\n                        },\n                    ],\n                    dataViewMappings: [{\n                            conditions: [{\n                                    \"Date\": {\n                                        min: 0,\n                                        max: 1\n                                    },\n                                    \"Values\": {\n                                        min: 0,\n                                        max: 1\n                                    },\n                                    \"Labels\": {\n                                        min: 0,\n                                        max: 1\n                                    }\n                                }],\n                            categorical: {\n                                categories: {\n                                    for: { in: \"Date\" },\n                                    dataReductionAlgorithm: { sample: {} }\n                                },\n                                values: {\n                                    for: { in: \"Values\" }\n                                },\n                            }\n                        }],\n                    objects: {\n                        general: {\n                            displayName: powerbi.data.createDisplayNameGetter(\"Visual_General\"),\n                            properties: {\n                                formatString: {\n                                    type: {\n                                        formatting: {\n                                            formatString: true\n                                        }\n                                    },\n                                }\n                            },\n                        },\n                        lineoptions: {\n                            displayName: 'Line',\n                            properties: {\n                                fill: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                lineThickness: {\n                                    displayName: 'Thickness',\n                                    type: { numeric: true }\n                                }\n                            }\n                        },\n                        dotoptions: {\n                            displayName: 'Dot',\n                            properties: {\n                                color: {\n                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),\n                                    type: { fill: { solid: { color: true } } }\n                                },\n                                dotSizeMin: {\n                                    displayName: 'Min size',\n                                    type: { numeric: true }\n                                },\n                                dotSizeMax: {\n                                    displayName: 'Min size',\n                                    type: { numeric: true }\n                                }\n                            }\n                        },\n                        counteroptions: {\n                            displayName: 'Counter',\n                            properties: {\n                                counterTitle: {\n                                    displayName: 'Title',\n                                    type: { text: true }\n                                }\n                            }\n                        },\n                        misc: {\n                            displayName: 'Animation',\n                            properties: {\n                                isanimated: {\n                                    displayName: 'Animated',\n                                    type: { bool: true }\n                                },\n                                isstopped: {\n                                    displayName: 'Stop on load',\n                                    type: { bool: true }\n                                },\n                                duration: {\n                                    displayName: 'Time',\n                                    type: { numeric: true }\n                                }\n                            }\n                        }\n                    }\n                };\n                LineDotChart.Identity = {\n                    \"class\": \"lineDotChart\",\n                    selector: \".lineDotChart\"\n                };\n                LineDotChart.Axes = {\n                    \"class\": \"axes\",\n                    selector: \".axes\"\n                };\n                LineDotChart.Axis = {\n                    \"class\": \"axis\",\n                    selector: \".axis\"\n                };\n                LineDotChart.Legends = {\n                    \"class\": \"legends\",\n                    selector: \".legends\"\n                };\n                LineDotChart.Legend = {\n                    \"class\": \"legend\",\n                    selector: \".legend\"\n                };\n                LineDotChart.Values = {\n                    \"class\": \"line\",\n                    selector: \".line\"\n                };\n                LineDotChart.Properties = {\n                    general: {\n                        formatString: {\n                            objectName: \"general\",\n                            propertyName: \"formatString\"\n                        }\n                    },\n                    lineoptions: {\n                        fill: {\n                            objectName: \"lineoptions\",\n                            propertyName: \"fill\"\n                        },\n                        lineThickness: {\n                            objectName: \"lineoptions\",\n                            propertyName: \"lineThickness\"\n                        }\n                    },\n                    dotoptions: {\n                        color: {\n                            objectName: \"dotoptions\",\n                            propertyName: \"color\"\n                        },\n                        dotSizeMin: {\n                            objectName: \"dotoptions\",\n                            propertyName: \"dotSizeMin\"\n                        },\n                        dotSizeMax: {\n                            objectName: \"dotoptions\",\n                            propertyName: \"dotSizeMax\"\n                        }\n                    },\n                    counteroptions: {\n                        counterTitle: {\n                            objectName: \"counteroptions\",\n                            propertyName: \"counterTitle\"\n                        }\n                    },\n                    // labels: {\n                    //     labelPrecision: <DataViewObjectPropertyIdentifier>{\n                    //         objectName: \"labels\",\n                    //         propertyName: \"labelPrecision\"\n                    //     }\n                    // },\n                    misc: {\n                        isanimated: {\n                            objectName: \"misc\",\n                            propertyName: \"isanimated\"\n                        },\n                        isstopped: {\n                            objectName: \"misc\",\n                            propertyName: \"isstopped\"\n                        },\n                        duration: {\n                            objectName: \"misc\",\n                            propertyName: \"duration\"\n                        }\n                    }\n                };\n                return LineDotChart;\n            }());\n            samples.LineDotChart = LineDotChart;\n        })(samples = visuals.samples || (visuals.samples = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var plugins;\n        (function (plugins) {\n            plugins.sunburstCustom = {\n                name: 'sunburstCustom',\n                watermarkKey: 'defaultWatermark',\n                capabilities: visuals.samples.Sunburst.capabilities,\n                create: function () { return new visuals.samples.Sunburst(); }\n            };\n            plugins.asterPlot = {\n                name: 'asterPlot',\n                capabilities: visuals.samples.AsterPlot.capabilities,\n                create: function () { return new visuals.samples.AsterPlot(); }\n            };\n            plugins.tornadoChart = {\n                name: \"tornadoChart\",\n                capabilities: visuals.samples.TornadoChart.capabilities,\n                create: function () { return new visuals.samples.TornadoChart(); }\n            };\n            plugins.sankeyDiagram = {\n                name: \"sankeyDiagram\",\n                capabilities: visuals.samples.SankeyDiagram.capabilities,\n                create: function () { return new visuals.samples.SankeyDiagram(); }\n            };\n            plugins.mekkoChart = {\n                name: 'mekkoChart',\n                watermarkKey: 'mekko',\n                capabilities: visuals.samples.MekkoChart.capabilities,\n                create: function () { return new visuals.samples.MekkoChart({ chartType: 0 /* HundredPercentStackedColumn */ }); },\n                customizeQuery: visuals.ColumnChart.customizeQuery,\n                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },\n            };\n            plugins.bulletChart = {\n                name: \"bulletChart\",\n                capabilities: visuals.samples.BulletChart.capabilities,\n                create: function () { return new visuals.samples.BulletChart(); }\n            };\n            plugins.wordCloud = {\n                name: \"wordCloud\",\n                capabilities: visuals.samples.WordCloud.capabilities,\n                create: function () { return new visuals.samples.WordCloud(); }\n            };\n            plugins.chicletSlicer = {\n                name: 'chicletSlicer',\n                capabilities: visuals.samples.ChicletSlicer.capabilities,\n                create: function () { return new visuals.samples.ChicletSlicer(); }\n            };\n            plugins.chordChart = {\n                name: \"chordChart\",\n                capabilities: visuals.samples.ChordChart.capabilities,\n                create: function () { return new visuals.samples.ChordChart(); }\n            };\n            plugins.enhancedScatterChart = {\n                name: 'enhancedScatterChart',\n                capabilities: visuals.samples.EnhancedScatterChart.capabilities,\n                create: function () { return new visuals.samples.EnhancedScatterChart(); }\n            };\n            plugins.radarChart = {\n                name: 'radarChart',\n                capabilities: visuals.samples.RadarChart.capabilities,\n                create: function () { return new visuals.samples.RadarChart(); }\n            };\n            plugins.dotPlot = {\n                name: 'dotPlot',\n                capabilities: visuals.samples.DotPlot.capabilities,\n                create: function () { return new visuals.samples.DotPlot(); }\n            };\n            plugins.histogram = {\n                name: \"histogram\",\n                capabilities: visuals.samples.Histogram.capabilities,\n                create: function () { return new visuals.samples.Histogram(); }\n            };\n            plugins.colorBarChart = {\n                name: \"colorBarChart\",\n                capabilities: visuals.samples.ColorBarChart.capabilities,\n                create: function () { return new visuals.samples.ColorBarChart(); }\n            };\n            plugins.timeline = {\n                name: 'timeline',\n                capabilities: visuals.samples.Timeline.capabilities,\n                create: function () { return new visuals.samples.Timeline(); }\n            };\n            plugins.forceGraph = {\n                name: \"forceGraph\",\n                capabilities: visuals.samples.ForceGraph.capabilities,\n                create: function () { return new visuals.samples.ForceGraph(); }\n            };\n            plugins.gantt = {\n                name: \"gantt\",\n                capabilities: visuals.samples.Gantt.capabilities,\n                create: function () { return new visuals.samples.Gantt(); }\n            };\n            plugins.streamGraph = {\n                name: \"streamGraph\",\n                capabilities: visuals.samples.StreamGraph.capabilities,\n                create: function () { return new visuals.samples.StreamGraph(); }\n            };\n            plugins.lineDotChart = {\n                name: \"lineDotChart\",\n                capabilities: visuals.samples.LineDotChart.capabilities,\n                create: function () { return new visuals.samples.LineDotChart(); }\n            };\n        })(plugins = visuals.plugins || (visuals.plugins = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var visualPluginFactory;\n        (function (visualPluginFactory) {\n            var CustomVisualPluginService = (function (_super) {\n                __extends(CustomVisualPluginService, _super);\n                function CustomVisualPluginService() {\n                    _super.call(this, {});\n                    this.initCustomVisualPlugins();\n                }\n                CustomVisualPluginService.prototype.getVisuals = function () {\n                    var registry = this.customVisualPlugins, names = Object.keys(registry);\n                    return names.map(function (name) { return registry[name]; });\n                };\n                CustomVisualPluginService.prototype.getPlugin = function (type) {\n                    if (!type) {\n                        return null;\n                    }\n                    var plugin = this.customVisualPlugins[type];\n                    if (!plugin) {\n                        return null;\n                    }\n                    return plugin;\n                };\n                CustomVisualPluginService.prototype.capabilities = function (type) {\n                    var plugin = this.getPlugin(type);\n                    if (plugin) {\n                        return plugin.capabilities;\n                    }\n                    return {};\n                };\n                CustomVisualPluginService.prototype.initCustomVisualPlugins = function () {\n                    // Aster Plot\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.asterPlot, function () { return new visuals.samples.AsterPlot(); });\n                    // Tornado Chart\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.tornadoChart, function () { return new visuals.samples.TornadoChart({\n                        animator: new visuals.BaseAnimator()\n                    }); });\n                    // Sankey Diagram\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.sankeyDiagram, function () { return new visuals.samples.SankeyDiagram(); });\n                    // Mekko Chart\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.mekkoChart, function () { return new visuals.samples.MekkoChart({\n                        chartType: 0 /* HundredPercentStackedColumn */,\n                        isScrollable: true,\n                        animator: new visuals.WebColumnChartAnimator(),\n                        behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()])\n                    }); });\n                    // Bullet Chart\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.bulletChart, function () { return new visuals.samples.BulletChart(); });\n                    // Word Cloud\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.wordCloud, function () { return new visuals.samples.WordCloud({\n                        animator: new visuals.BaseAnimator()\n                    }); });\n                    // Chiclet Slicer\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.chicletSlicer, function () { return new visuals.samples.ChicletSlicer({\n                        behavior: new visuals.samples.ChicletSlicerWebBehavior()\n                    }); });\n                    // Enhanced Scatter Chart\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.enhancedScatterChart, function () { return new visuals.samples.EnhancedScatterChart(); });\n                    // Radar Chart\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.radarChart, function () { return new visuals.samples.RadarChart({\n                        animator: new visuals.BaseAnimator()\n                    }); });\n                    // DotPlot\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.dotPlot, function () { return new visuals.samples.DotPlot({\n                        animator: new visuals.BaseAnimator()\n                    }); });\n                    // Histogram\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.histogram, function () { return new visuals.samples.Histogram({\n                        animator: new visuals.BaseAnimator()\n                    }); });\n                    // Force Graph\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.forceGraph, function () { return new visuals.samples.ForceGraph(); });\n                    // Gantt Chart\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.gantt, function () { return new visuals.samples.Gantt(); });\n                    // Stream Graph\n                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.streamGraph, function () { return new visuals.samples.StreamGraph(); });\n                };\n                return CustomVisualPluginService;\n            }(visualPluginFactory.VisualPluginService));\n            visualPluginFactory.CustomVisualPluginService = CustomVisualPluginService;\n            function createCustomVisualPluginService() {\n                return new CustomVisualPluginService();\n            }\n            visualPluginFactory.createCustomVisualPluginService = createCustomVisualPluginService;\n        })(visualPluginFactory = visuals.visualPluginFactory || (visuals.visualPluginFactory = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n\n\n","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *   \n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *   \n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import ArcDescriptor = D3.Layout.ArcDescriptor;\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n    import createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n    import PixelConverter = jsCommon.PixelConverter;\n    import ValueFormatter = powerbi.visuals.valueFormatter;\n\n    const AsterPlotVisualClassName: string = 'asterPlot';\n    const AsterPlotLegendObjectName: string = 'legend';\n    const AsterDefaultOuterLineThickness: number = 1;\n    const AsterDefaultLabelFill: Fill = { solid: { color: '#333' } };\n    const AsterDefaultLegendFontSize: number = 8;\n    const AsterRadiusRatio: number = 0.9;\n    const AsterConflictRatio = 0.9;\n    const MaxPrecision: number = 17;\n\n    export interface AsterData {\n        dataPoints: AsterDataPoint[];\n        highlightedDataPoints?: AsterDataPoint[];\n        legendData: LegendData;\n        valueFormatter: IValueFormatter;\n        legendSettings: AsterPlotLegendSettings;\n        labelSettings: VisualDataLabelsSettings;\n        showOuterLine: boolean;\n        outerLineThickness: number;\n    }\n\n    export interface AsterPlotLegendSettings {\n        show: boolean;\n        position: string;\n        showTitle: boolean;\n        labelColor: string;\n        titleText: string;\n        fontSize: number;\n    }\n\n    export interface AsterArcDescriptor extends ArcDescriptor {\n        isLabelHasConflict?: boolean;\n    }\n\n    export interface AsterDataPoint extends SelectableDataPoint {\n        color: string;\n        sliceHeight: number;\n        sliceWidth: number;\n        label: string;\n        highlight?: boolean;\n        tooltipInfo: TooltipDataItem[];\n        labelFontSize: string;\n    }\n\n    export interface AsterPlotBehaviorOptions {\n        selection: D3.Selection;\n        highlightedSelection: D3.Selection;\n        clearCatcher: D3.Selection;\n        interactivityService: IInteractivityService;\n    }\n\n    class AsterPlotWebBehavior implements IInteractiveBehavior {\n        private selection: D3.Selection;\n        private highlightedSelection: D3.Selection;\n        private clearCatcher: D3.Selection;\n        private interactivityService: IInteractivityService;\n\n        public bindEvents(options: AsterPlotBehaviorOptions, selectionHandler: ISelectionHandler) {\n            this.selection = options.selection;\n            this.highlightedSelection = options.highlightedSelection;\n            this.clearCatcher = options.clearCatcher;\n            this.interactivityService = options.interactivityService;\n\n            this.selection.on('click', (d, i: number) => {\n                selectionHandler.handleSelection(d.data, d3.event.ctrlKey);\n            });\n\n            if (this.highlightedSelection)\n                this.highlightedSelection.on('click', (d, i: number) => {\n                    selectionHandler.handleSelection(d.data, d3.event.ctrlKey);\n                });\n\n            this.clearCatcher.on('click', () => {\n                selectionHandler.handleClearSelection();\n            });\n        }\n\n        public renderSelection(hasSelection: boolean) {\n            let hasHighlights = this.interactivityService.hasSelection();\n            this.selection.style(\"fill-opacity\", (d) => {\n                return ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, !d.data.highlight && hasSelection, !d.data.selected && hasHighlights);\n            });\n        }\n    }\n\n    export class AsterPlotWarning implements IVisualWarning {\n        private message: string;\n        constructor(message: string) {\n            this.message = message;\n        }\n\n        public get code(): string {\n            return \"AsterPlotWarning\";\n        }\n\n        public getMessages(resourceProvider: jsCommon.IStringResourceProvider): IVisualErrorMessage {\n            return {\n                message: this.message,\n                title: resourceProvider.get(\"\"),\n                detail: resourceProvider.get(\"\")\n            };\n        }\n    }\n\n    export class AsterPlot implements IVisual {\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    displayName: 'Category',\n                    name: 'Category',\n                    kind: powerbi.VisualDataRoleKind.Grouping,\n                },\n                {\n                    displayName: 'Y Axis',\n                    name: 'Y',\n                    kind: powerbi.VisualDataRoleKind.Measure,\n                },\n            ],\n            dataViewMappings: [{\n                conditions: [\n                    { 'Category': { max: 1 }, 'Y': { max: 2 } }\n                ],\n                categorical: {\n                    categories: {\n                        for: { in: 'Category' },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: {\n                        select: [{ bind: { to: 'Y' } }]\n                    },\n                }\n            }],\n            objects: {\n                general: {\n                    displayName: data.createDisplayNameGetter('Visual_General'),\n                    properties: {\n                        formatString: {\n                            type: { formatting: { formatString: true } },\n                        },\n                    },\n                },\n                legend: {\n                    displayName: 'Legend',\n                    description: 'Display legend options',\n                    properties: {\n                        show: {\n                            displayName: 'Show',\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: 'Position',\n                            description: 'Select the location for the legend',\n                            type: { enumeration: legendPosition.type }\n                        },\n                        showTitle: {\n                            displayName: 'Title',\n                            description: 'Display a title for legend symbols',\n                            type: { bool: true }\n                        },\n                        titleText: {\n                            displayName: 'Legend Name',\n                            description: 'Title text',\n                            type: { text: true },\n                            suppressFormatPainterCopy: true\n                        },\n                        labelColor: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: 'Text Size',\n                            type: { formatting: { fontSize: true } }\n                        }\n                    }\n                },\n                label: {\n                    displayName: 'Center Label',\n                    properties: {\n                        fill: {\n                            displayName: 'Fill',\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                },\n                labels: {\n                    displayName: 'Detail Labels',\n                    properties: {\n                        show: {\n                            type: { bool: true }\n                        },\n                        color: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        labelDisplayUnits: {\n                            displayName: 'Display Units',\n                            type: { formatting: { labelDisplayUnits: true } },\n                        },\n                        labelPrecision: {\n                            displayName: 'Decimal Places',\n                            placeHolderText: 'Auto',\n                            type: { numeric: true },\n                        },\n                        fontSize: {\n                            displayName: 'Text Size',\n                            type: { formatting: { fontSize: true } },\n                        },\n                    },\n                },\n                outerLine: {\n                    displayName: 'Outer line',\n                    properties: {\n                        show: {\n                            displayName: 'Show',\n                            type: { bool: true }\n                        },\n                        thickness: {\n                            displayName: 'Thickness',\n                            type: { numeric: true }\n                        }\n                    }\n                }\n            },\n            supportsHighlight: true,\n        };\n\n        private static Properties: any = {\n            general: {\n                formatString: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'formatString' },\n            },\n            dataPoint: {\n                fill: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'fill' },\n            },\n            legend: {\n                show: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'show' },\n                position: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'position' },\n                showTitle: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'showTitle' },\n                titleText: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'titleText' },\n                labelColor: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'labelColor' },\n                fontSize: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'fontSize' },\n            },\n            label: {\n                fill: <DataViewObjectPropertyIdentifier>{ objectName: 'label', propertyName: 'fill' },\n            },\n            labels: {\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'show' },\n                color: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'color' },\n                labelDisplayUnits: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'labelDisplayUnits' },\n                labelPrecision: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'labelPrecision' },\n                fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'fontSize' },\n            },\n            outerLine: {\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'outerLine', propertyName: 'show' },\n                thickness: <DataViewObjectPropertyIdentifier>{ objectName: 'outerLine', propertyName: 'thickness' },\n            }\n        };\n\n        private static AsterSlice: ClassAndSelector = createClassAndSelector('asterSlice');\n        private static AsterHighlightedSlice: ClassAndSelector = createClassAndSelector('asterHighlightedSlice');\n        private static OuterLine: ClassAndSelector = createClassAndSelector('outerLine');\n        private static labelGraphicsContextClass: ClassAndSelector = createClassAndSelector('labels');\n        private static linesGraphicsContextClass: ClassAndSelector = createClassAndSelector('lines');\n        private static CenterLabelClass: ClassAndSelector = createClassAndSelector('centerLabel');\n        private static CenterTextFontHeightCoefficient = 0.4;\n        private static CenterTextFontWidthCoefficient = 1.9;\n\n        private margin: IMargin = {\n            top: 10,\n            right: 10,\n            bottom: 15,\n            left: 10\n        };\n\n        private svg: D3.Selection;\n        private mainGroupElement: D3.Selection;\n        private mainLabelsElement: D3.Selection;\n        private centerText: D3.Selection;\n        private clearCatcher: D3.Selection;\n        private colors: IDataColorPalette;\n        private dataView: DataView;\n        private hostService: IVisualHostServices;\n        private interactivityService: IInteractivityService;\n        private legend: ILegend;\n        private data: AsterData;\n        private currentViewport: IViewport;\n        private behavior: IInteractiveBehavior;\n        private hasHighlights: boolean;\n\n        private getDefaultAsterData(): AsterData {\n            return <AsterData>{\n                dataPoints: [],\n                highlightedDataPoints: [],\n                legendData: <LegendData>{\n                    dataPoints: [],\n                    title: null,\n                    fontSize: AsterDefaultLegendFontSize,\n                    labelColor: LegendData.DefaultLegendLabelFillColor\n                },\n                legendSettings: {\n                    show: false,\n                    position: 'Top',\n                    showTitle: true,\n                    labelColor: LegendData.DefaultLegendLabelFillColor,\n                    titleText: '',\n                    fontSize: AsterDefaultLegendFontSize,\n                },\n                valueFormatter: null,\n                labelSettings: {\n                    show: false,\n                    displayUnits: 0,\n                    precision: dataLabelUtils.defaultLabelPrecision,\n                    labelColor: dataLabelUtils.defaultLabelColor,\n                    fontSize: dataLabelUtils.DefaultFontSizeInPt,\n                },\n                showOuterLine: false,\n                outerLineThickness: AsterDefaultOuterLineThickness,\n            };\n        }\n\n        public converter(dataView: DataView, colors: IDataColorPalette): AsterData {\n            let asterDataResult: AsterData = this.getDefaultAsterData();\n            if (!this.dataViewContainsCategory(dataView) || dataView.categorical.categories.length !== 1)\n                return asterDataResult;\n\n            let catDv: DataViewCategorical = dataView.categorical;\n            let cat = catDv.categories[0];\n            let catSource = cat.source;\n            let catValues = cat.values;\n            let values = catDv.values;\n            let catObjects: DataViewObjects[] = cat.objects;\n            let colorHelper: ColorHelper = new ColorHelper(colors, AsterPlot.Properties.dataPoint.fill);\n\n            let hasHighlights: boolean = this.hasHighlights = !!(values && values.length > 0 && values[0].highlights);\n\n            if (dataView.metadata || dataView.metadata.objects) {\n                let objects: DataViewObjects = dataView.metadata.objects;\n                asterDataResult.labelSettings = this.getLabelSettings(objects, asterDataResult.labelSettings);\n                this.updateLegendSettings(objects, catSource, asterDataResult.legendSettings);\n                asterDataResult.showOuterLine = DataViewObjects.getValue<boolean>(objects, AsterPlot.Properties.outerLine.show, asterDataResult.showOuterLine);\n                asterDataResult.outerLineThickness = DataViewObjects.getValue<number>(objects, AsterPlot.Properties.outerLine.thickness, AsterDefaultOuterLineThickness);\n            }\n\n            let labelSettings: VisualDataLabelsSettings = asterDataResult.labelSettings;\n            if (!catValues || catValues.length < 1 || !values || values.length < 1)\n                return asterDataResult;\n\n            let formatStringProp = AsterPlot.Properties.general.formatString;\n            let maxValue: number = Math.max(d3.min(values[0].values));\n            let minValue: number = Math.min(0, d3.min(values[0].values));\n            let labelFormatter: IValueFormatter = ValueFormatter.create({\n                format: ValueFormatter.getFormatString(values[0].source, formatStringProp),\n                precision: labelSettings.precision,\n                value: (labelSettings.displayUnits === 0) && (maxValue != null) ? maxValue : labelSettings.displayUnits,\n            });\n            let categorySourceFormatString = valueFormatter.getFormatString(catSource, formatStringProp);\n            let fontSizeInPx: string = PixelConverter.fromPoint(labelSettings.fontSize);\n\n            for (let i = 0; i < catValues.length; i++) {\n                let formattedCategoryValue = valueFormatter.format(catValues[i], categorySourceFormatString);\n                let currentValue = values[0].values[i];\n\n                let tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(\n                    formatStringProp,\n                    catDv,\n                    formattedCategoryValue,\n                    currentValue,\n                    null,\n                    null,\n                    0);\n\n                if (values.length > 1) {\n                    let toolTip: TooltipDataItem = TooltipBuilder.createTooltipInfo(\n                        formatStringProp,\n                        catDv,\n                        formattedCategoryValue,\n                        values[1].values[i],\n                        null,\n                        null,\n                        1)[1];\n                    if (toolTip)\n                        tooltipInfo.push(toolTip);\n\n                    currentValue += values[1].values[i];\n                }\n\n                let identity: DataViewScopeIdentity = cat.identity[i];\n                let color: string = colorHelper.getColorForMeasure(catObjects && catObjects[i], identity.key);\n                let selector: SelectionId = SelectionId.createWithId(identity);\n                let sliceWidth: number = Math.max(0, values.length > 1 ? values[1].values[i] : 1);\n\n                asterDataResult.dataPoints.push({\n                    sliceHeight: values[0].values[i] - minValue,\n                    sliceWidth: sliceWidth,\n                    label: labelFormatter.format(currentValue),\n                    color: color,\n                    identity: selector,\n                    selected: false,\n                    tooltipInfo: tooltipInfo,\n                    labelFontSize: fontSizeInPx,\n                    highlight: false,\n                });\n                \n                // Handle legend data\n                if (asterDataResult.legendSettings.show)\n                    asterDataResult.legendData.dataPoints.push({\n                        label: catValues[i],\n                        color: color,\n                        icon: LegendIcon.Box,\n                        selected: false,\n                        identity: selector\n                    });\n                \n                // Handle highlights\n                if (hasHighlights) {\n                    let highlightIdentity: SelectionId = SelectionId.createWithHighlight(selector);\n                    let notNull: boolean = values[0].highlights[i] != null;\n                    currentValue = notNull ? values[0].highlights[i] : 0;\n\n                    tooltipInfo = TooltipBuilder.createTooltipInfo(\n                        formatStringProp,\n                        catDv,\n                        formattedCategoryValue,\n                        currentValue,\n                        null,\n                        null,\n                        0);\n\n                    if (values.length > 1) {\n                        let toolTip: TooltipDataItem = TooltipBuilder.createTooltipInfo(\n                            formatStringProp,\n                            catDv,\n                            formattedCategoryValue,\n                            values[1].highlights[i],\n                            null,\n                            null,\n                            1)[1];\n                        if (toolTip)\n                            tooltipInfo.push(toolTip);\n\n                        currentValue += values[1].highlights[i] !== null ? values[1].highlights[i] : 0;\n                    }\n\n                    asterDataResult.highlightedDataPoints.push({\n                        sliceHeight: notNull ? values[0].highlights[i] - minValue : null,\n                        sliceWidth: Math.max(0, (values.length > 1 && values[1].highlights[i] !== null) ? values[1].highlights[i] : sliceWidth),\n                        label: labelFormatter.format(currentValue),\n                        color: color,\n                        identity: highlightIdentity,\n                        selected: false,\n                        tooltipInfo: tooltipInfo,\n                        labelFontSize: fontSizeInPx,\n                        highlight: true,\n                    });\n                }\n            }\n\n            return asterDataResult;\n        }\n\n        private dataViewContainsCategory(dataView: DataView) {\n            return dataView &&\n                dataView.categorical &&\n                dataView.categorical.values &&\n                dataView.categorical.categories &&\n                dataView.categorical.categories[0];\n        }\n\n        private getLabelSettings(objects: DataViewObjects, labelSettings: VisualDataLabelsSettings): VisualDataLabelsSettings {\n            let asterPlotLabelsProperties = AsterPlot.Properties;\n            let precision = DataViewObjects.getValue<number>(objects, asterPlotLabelsProperties.labels.labelPrecision, labelSettings.precision);\n            labelSettings.precision = precision === undefined ? precision : Math.min(precision, MaxPrecision);\n            labelSettings.show = DataViewObjects.getValue<boolean>(objects, asterPlotLabelsProperties.labels.show, labelSettings.show);\n            labelSettings.fontSize = DataViewObjects.getValue<number>(objects, asterPlotLabelsProperties.labels.fontSize, labelSettings.fontSize);\n            labelSettings.displayUnits = DataViewObjects.getValue<number>(objects, asterPlotLabelsProperties.labels.labelDisplayUnits, labelSettings.displayUnits);\n            let colorHelper: ColorHelper = new ColorHelper(this.colors, asterPlotLabelsProperties.labels.color, labelSettings.labelColor);\n            labelSettings.labelColor = colorHelper.getColorForMeasure(objects, \"\");\n\n            return labelSettings;\n        }\n\n        private updateLegendSettings(objects: DataViewObjects, catSource: DataViewMetadataColumn, legendSettings: AsterPlotLegendSettings): void {\n            let legendProperties = AsterPlot.Properties.legend;\n\n            legendSettings.show = DataViewObjects.getValue<boolean>(objects, legendProperties.show, legendSettings.show);\n            legendSettings.position = DataViewObjects.getValue<string>(objects, legendProperties.position, legendSettings.position);\n            legendSettings.showTitle = DataViewObjects.getValue<boolean>(objects, legendProperties.showTitle, legendSettings.showTitle);\n            let titleText = DataViewObjects.getValue<string>(objects, legendProperties.titleText, '');\n            legendSettings.titleText = _.isEmpty(titleText) && catSource ? catSource.displayName : titleText;\n            legendSettings.labelColor = <string>DataViewObjects.getFillColor(objects, legendProperties.labelColor, legendSettings.labelColor);\n            legendSettings.fontSize = DataViewObjects.getValue<number>(objects, legendProperties.fontSize, legendSettings.fontSize);\n        }\n\n        public init(options: VisualInitOptions): void {\n            this.hostService = options.host;\n            let element: JQuery = options.element;\n            let svg: D3.Selection = this.svg = d3.select(element.get(0))\n                .append('svg')\n                .classed(AsterPlotVisualClassName, true)\n                .style('position', 'absolute');\n\n            this.colors = options.style.colorPalette.dataColors;\n            this.mainGroupElement = svg.append('g');\n            this.mainLabelsElement = svg.append('g');\n            this.behavior = new AsterPlotWebBehavior();\n            this.clearCatcher = appendClearCatcher(this.mainGroupElement);\n            let interactivity = options.interactivity;\n            this.interactivityService = createInteractivityService(this.hostService);\n            this.legend = createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);\n        }\n\n        public update(options: VisualUpdateOptions) {\n            if (!options.dataViews || !options.dataViews[0]) return; // or clear the view, display an error, etc.\n\n            let duration = options.suppressAnimations ? 0 : AnimatorCommon.MinervaAnimationDuration;\n\n            this.currentViewport = {\n                height: Math.max(0, options.viewport.height),\n                width: Math.max(0, options.viewport.width)\n            };\n\n            let dataView: DataView = this.dataView = options.dataViews[0];\n            let convertedData: AsterData = this.data = this.converter(dataView, this.colors);\n\n            if (!convertedData || !convertedData.dataPoints || convertedData.dataPoints.length === 0) {\n                this.clearData();\n                return;\n            }\n\n            if (this.interactivityService) {\n                this.interactivityService.applySelectionStateToData(convertedData.dataPoints);\n                this.interactivityService.applySelectionStateToData(convertedData.highlightedDataPoints);\n            }\n\n            this.renderLegend(convertedData);\n            this.updateViewPortAccordingToLegend();\n\n            this.svg\n                .attr({\n                    height: Math.max(0, this.currentViewport.height),\n                    width: Math.max(0, this.currentViewport.width)\n                });\n\n            let margin: IMargin = this.margin;\n            let transformX: number = (this.currentViewport.width - margin.left) / 2;\n            let transformY: number = (this.currentViewport.height - margin.top) / 2;\n            this.mainGroupElement.attr('transform', SVGUtil.translate(transformX, transformY));\n            this.mainLabelsElement.attr('transform', SVGUtil.translate(transformX, transformY));\n            \n            // Move back the clearCatcher\n            this.clearCatcher.attr('transform', SVGUtil.translate(-transformX, -transformY));\n            \n            // Clear previous data\n            this.mainGroupElement.selectAll(AsterPlot.AsterSlice.selector).remove();\n            this.mainGroupElement.selectAll(AsterPlot.AsterHighlightedSlice.selector).remove();\n            dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);\n\n            let dataPoints = convertedData.dataPoints;\n            if (!dataPoints || dataPoints.length === 0)\n                return;\n\n            let selection: D3.UpdateSelection = this.renderArcsAndLabels(dataPoints, duration, convertedData.labelSettings);\n            let highlightedSelection: D3.UpdateSelection;\n\n            if (this.hasHighlights)\n                highlightedSelection = this.renderArcsAndLabels(convertedData.highlightedDataPoints, duration, convertedData.labelSettings, true);\n\n            let interactivityService = this.interactivityService;\n\n            if (interactivityService) {\n                let behaviorOptions: AsterPlotBehaviorOptions = {\n                    selection: selection,\n                    highlightedSelection: highlightedSelection,\n                    clearCatcher: this.clearCatcher,\n                    interactivityService: this.interactivityService,\n                };\n                interactivityService.bind(convertedData.dataPoints.concat(convertedData.highlightedDataPoints), this.behavior, behaviorOptions);\n            }\n        }\n\n        private renderArcsAndLabels(dataPoints: AsterDataPoint[], duration: number, labelSettings: VisualDataLabelsSettings, isHighlight: boolean = false): D3.UpdateSelection {\n            let margin: IMargin = this.margin;\n            let width: number = this.currentViewport.width - margin.left - margin.right;\n            let height: number = this.currentViewport.height - margin.top - margin.bottom;\n            let radius: number = Math.min(width, height) / 2;\n            let innerRadius: number = 0.3 * (labelSettings.show ? radius * AsterRadiusRatio : radius);\n            let maxScore: number = d3.max(dataPoints, d => d.sliceHeight);\n            let totalWeight: number = d3.sum(dataPoints, d => d.sliceWidth);\n            let hasSelection: boolean = this.interactivityService && this.interactivityService.hasSelection();\n            let hasHighlights: boolean = this.hasHighlights;\n\n            let pie: D3.Layout.PieLayout = d3.layout.pie()\n                .sort(null)\n                .value(d => (d && !isNaN(d.sliceWidth) ? d.sliceWidth : 0) / totalWeight);\n\n            let arc: D3.Svg.Arc = d3.svg.arc()\n                .innerRadius(innerRadius)\n                .outerRadius(d => {\n                    let height: number = (radius - innerRadius) * (d && d.data && !isNaN(d.data.sliceHeight) ? d.data.sliceHeight : 1) / maxScore;\n                    //The chart should shrink if data labels are on\n                    let heightIsLabelsOn = innerRadius + (labelSettings.show ? height * AsterRadiusRatio : height);\n                    // Prevent from data to be inside the inner radius\n                    return Math.max(heightIsLabelsOn, innerRadius);\n                });\n\n            let arcDescriptorDataPoints: ArcDescriptor[] = pie(dataPoints);\n            let classSelector: ClassAndSelector = isHighlight ? AsterPlot.AsterHighlightedSlice : AsterPlot.AsterSlice;\n\n            let selection = this.mainGroupElement.selectAll(classSelector.selector)\n                .data(arcDescriptorDataPoints, (d, idx) => d.data ? d.data.identity.getKey() : idx);\n\n            selection.enter()\n                .append('path')\n                .attr('stroke', '#333')\n                .classed(classSelector.class, true);\n\n            selection\n                .attr('fill', d => d.data.color)\n                .style(\"fill-opacity\", (d) => ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, hasSelection, hasHighlights))\n                .transition().duration(duration)\n                .attrTween('d', function (data) {\n                    if (!this.oldData) {\n                        this.oldData = data;\n                        return () => arc(data);\n                    }\n\n                    let interpolation = d3.interpolate(this.oldData, data);\n                    this.oldData = interpolation(0);\n                    return (x) => arc(interpolation(x));\n                });\n\n            selection\n                .exit()\n                .remove();\n\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.data.tooltipInfo);\n            \n            // Draw data labels only if they are on and there are no highlights or there are highlights and this is the highlighted data labels\n            if (labelSettings.show && (!hasHighlights || (hasHighlights && isHighlight))) {\n                let labelRadCalc = (d: AsterDataPoint) => {\n                    let height: number = radius * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore + innerRadius;\n                    return Math.max(height, innerRadius);\n                };\n                let labelArc = d3.svg.arc()\n                    .innerRadius(d => labelRadCalc(d.data))\n                    .outerRadius(d => labelRadCalc(d.data));\n\n                let lineRadCalc = (d: AsterDataPoint) => {\n                    let height: number = (radius - innerRadius) * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore;\n                    height = innerRadius + height * AsterRadiusRatio;\n                    return Math.max(height, innerRadius);\n                };\n                let outlineArc = d3.svg.arc()\n                    .innerRadius(d => lineRadCalc(d.data))\n                    .outerRadius(d => lineRadCalc(d.data));\n\n                let layout = this.getLabelLayout(labelSettings, labelArc, this.currentViewport);\n                this.drawLabels(arcDescriptorDataPoints, this.mainLabelsElement, layout, this.currentViewport, outlineArc, labelArc);\n            }\n            else\n                dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);\n            \n            // Draw center text and outline once for original data points\n            if (!isHighlight) {\n                this.drawCenterText(innerRadius);\n                this.drawOuterLine(innerRadius, radius, arcDescriptorDataPoints);\n            }\n\n            return selection;\n        }\n\n        private getLabelLayout(labelSettings: VisualDataLabelsSettings, arc: D3.Svg.Arc, viewport: IViewport): ILabelLayout {\n            let midAngle = function (d: ArcDescriptor) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };\n            let textProperties: TextProperties = {\n                fontFamily: dataLabelUtils.StandardFontFamily,\n                fontSize: PixelConverter.fromPoint(labelSettings.fontSize),\n                text: '',\n            };\n            let isLabelsHasConflict = function (d: AsterArcDescriptor) {\n                let pos = arc.centroid(d);\n                textProperties.text = d.data.label;\n                let textWidth = TextMeasurementService.measureSvgTextWidth(textProperties);\n                let horizontalSpaceAvaliableForLabels = viewport.width / 2 - Math.abs(pos[0]);\n                let textHeight = TextMeasurementService.estimateSvgTextHeight(textProperties);\n                let verticalSpaceAvaliableForLabels = viewport.height / 2 - Math.abs(pos[1]);\n                d.isLabelHasConflict = textWidth > horizontalSpaceAvaliableForLabels || textHeight > verticalSpaceAvaliableForLabels;\n                return d.isLabelHasConflict;\n            };\n\n            return {\n                labelText: (d: AsterArcDescriptor) => {\n                    textProperties.text = d.data.label;\n                    let pos = arc.centroid(d);\n                    let xPos = isLabelsHasConflict(d) ? pos[0] * AsterConflictRatio : pos[0];\n                    let spaceAvaliableForLabels = viewport.width / 2 - Math.abs(xPos);\n                    return TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);\n                },\n                labelLayout: {\n                    x: (d: AsterArcDescriptor) => {\n                        let pos = arc.centroid(d);\n                        textProperties.text = d.data.label;\n                        let xPos = d.isLabelHasConflict ? pos[0] * AsterConflictRatio : pos[0];\n                        return xPos;\n                    },\n                    y: (d: AsterArcDescriptor) => {\n                        let pos = arc.centroid(d);\n                        let yPos = d.isLabelHasConflict ? pos[1] * AsterConflictRatio : pos[1];\n                        return yPos;\n                    },\n                },\n                filter: (d: AsterArcDescriptor) => (d != null && !_.isEmpty(d.data.label)),\n                style: {\n                    'fill': labelSettings.labelColor,\n                    'font-size': textProperties.fontSize,\n                    'text-anchor': (d: AsterArcDescriptor) => midAngle(d) < Math.PI ? 'start' : 'end',\n                },\n            };\n        }\n\n        private drawLabels(data: ArcDescriptor[],\n            context: D3.Selection,\n            layout: ILabelLayout,\n            viewport: IViewport,\n            outlineArc: D3.Svg.Arc,\n            labelArc: D3.Svg.Arc): void {\n            \n            // Hide and reposition labels that overlap\n            let dataLabelManager = new DataLabelManager();\n            let filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, true /* addTransform */);\n\n            if (filteredData.length === 0) {\n                dataLabelUtils.cleanDataLabels(context, true);\n                return;\n            }\n            \n            // Draw labels\n            if (context.select(AsterPlot.labelGraphicsContextClass.selector).empty())\n                context.append('g').classed(AsterPlot.labelGraphicsContextClass.class, true);\n\n            let labels = context\n                .select(AsterPlot.labelGraphicsContextClass.selector)\n                .selectAll('.data-labels').data(filteredData, (d: ArcDescriptor) => d.data.identity.getKey());\n\n            labels.enter().append('text').classed('data-labels', true);\n\n            if (!labels)\n                return;\n\n            labels\n                .attr({ x: (d: LabelEnabledDataPoint) => d.labelX, y: (d: LabelEnabledDataPoint) => d.labelY, dy: '.35em' })\n                .text((d: LabelEnabledDataPoint) => d.labeltext)\n                .style(layout.style);\n\n            labels\n                .exit()\n                .remove();\n                \n            // Draw lines\n            if (context.select(AsterPlot.linesGraphicsContextClass.selector).empty())\n                context.append('g').classed(AsterPlot.linesGraphicsContextClass.class, true);\n\t\t\t\t\n            // Remove lines for null and zero values\n            filteredData = _.filter(filteredData, (d: ArcDescriptor) => d.data.sliceHeight !== null && d.data.sliceHeight !== 0);\n\n            let lines = context.select(AsterPlot.linesGraphicsContextClass.selector).selectAll('polyline')\n                .data(filteredData, (d: ArcDescriptor) => d.data.identity.getKey());\n\n            let labelLinePadding = 4;\n            let chartLinePadding = 1.02;\n\n            let midAngle = function (d: ArcDescriptor) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };\n\n            lines.enter()\n                .append('polyline')\n                .classed('line-label', true);\n\n            lines\n                .attr('points', function (d) {\n                    let textPoint = [d.labelX, d.labelY];\n                    textPoint[0] = textPoint[0] + ((midAngle(d) < Math.PI ? -1 : 1) * labelLinePadding);\n                    let chartPoint = outlineArc.centroid(d);\n                    chartPoint[0] *= chartLinePadding;\n                    chartPoint[1] *= chartLinePadding;\n                    return [chartPoint, textPoint];\n                }).\n                style({\n                    'opacity': 0.5,\n                    'fill-opacity': 0,\n                    'stroke': (d: ArcDescriptor) => this.data.labelSettings.labelColor,\n                });\n\n            lines\n                .exit()\n                .remove();\n\n        }\n\n        private renderLegend(asterPlotData: AsterData): void {\n            if (!asterPlotData || !asterPlotData.legendData)\n                return;\n\n            let legendData: LegendData = asterPlotData.legendData;\n            let objects: DataViewObjects = this.dataView && this.dataView.metadata ? this.dataView.metadata.objects : null;\n            let legendObjectProperties: DataViewObject = DataViewObjects.getObject(objects, AsterPlotLegendObjectName, {});\n            if (legendObjectProperties) {\n                let legendSettings = asterPlotData.legendSettings;\n                \n                // Force update for title text\n                legendObjectProperties['titleText'] = legendSettings.titleText;\n                LegendData.update(legendData, legendObjectProperties);\n                this.legend.changeOrientation(LegendPosition[legendSettings.position]);\n            }\n\n            this.legend.drawLegend(legendData, _.clone(this.currentViewport));\n            Legend.positionChartArea(this.svg, this.legend);\n        }\n\n        private updateViewPortAccordingToLegend(): void {\n            let legendSettings = this.data.legendSettings;\n            if (!legendSettings || !legendSettings.show)\n                return;\n\n            let legendMargins: IViewport = this.legend.getMargins();\n            let legendPosition: LegendPosition = LegendPosition[legendSettings.position];\n\n            switch (legendPosition) {\n                case LegendPosition.Top:\n                case LegendPosition.TopCenter:\n                case LegendPosition.Bottom:\n                case LegendPosition.BottomCenter: {\n                    this.currentViewport.height -= legendMargins.height;\n                    break;\n                }\n                case LegendPosition.Left:\n                case LegendPosition.LeftCenter:\n                case LegendPosition.Right:\n                case LegendPosition.RightCenter: {\n                    this.currentViewport.width -= legendMargins.width;\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n\n        private drawOuterLine(innerRadius: number, radius: number, data: ArcDescriptor[]): void {\n            let mainGroup = this.mainGroupElement;\n            let outlineArc = d3.svg.arc()\n                .innerRadius(innerRadius)\n                .outerRadius(radius);\n            if (this.data.showOuterLine) {\n                let OuterThickness: string = this.data.outerLineThickness + 'px';\n                let outerLine = mainGroup.selectAll(AsterPlot.OuterLine.selector).data(data);\n                outerLine.enter().append('path');\n                outerLine.attr(\"fill\", \"none\")\n                    .attr({\n                        'stroke': '#333',\n                        'stroke-width': OuterThickness,\n                        'd': outlineArc\n                    })\n                    .style('opacity', 1)\n                    .classed(AsterPlot.OuterLine.class, true);\n                outerLine.exit().remove();\n            }\n            else\n                mainGroup.selectAll(AsterPlot.OuterLine.selector).remove();\n        }\n\n        private getCenterText(dataView: DataView): string {\n            if (dataView && dataView.metadata && dataView.metadata.columns && dataView.categorical && dataView.categorical.values)\n                for (let column of dataView.metadata.columns)\n                    if (!column.isMeasure)\n                        return column.displayName;\n            return '';\n        }\n\n        private drawCenterText(innerRadius: number): void {\n            let text: string = this.getCenterText(this.dataView);\n\n            if (_.isEmpty(text)) {\n                this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove();\n                return;\n            }\n\n            let centerTextProperties: TextProperties = {\n                fontFamily: dataLabelUtils.StandardFontFamily,\n                fontWeight: 'bold',\n                fontSize: PixelConverter.toString(innerRadius * AsterPlot.CenterTextFontHeightCoefficient),\n                text: text\n            };\n\n            if (this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).empty())\n                this.centerText = this.mainGroupElement.append('text').classed(AsterPlot.CenterLabelClass.class, true);\n\n            this.centerText\n                .style({\n                    'line-height': 1,\n                    'font-weight': centerTextProperties.fontWeight,\n                    'font-size': centerTextProperties.fontSize,\n                    'fill': this.getLabelFill(this.dataView).solid.color\n                })\n                .attr({\n                    'dy': '0.35em',\n                    'text-anchor': 'middle'\n                })\n                .text(TextMeasurementService.getTailoredTextOrDefault(centerTextProperties, innerRadius * AsterPlot.CenterTextFontWidthCoefficient));\n        }\n\n        // This extracts fill color of the label from the DataView\n        private getLabelFill(dataView: DataView): Fill {\n            if (this.dataViewContainsObjects(dataView))\n                return DataViewObjects.getValue(dataView.metadata.objects, AsterPlot.Properties.label.fill, AsterDefaultLabelFill);\n\n            return AsterDefaultLabelFill;\n        }\n\n        private dataViewContainsObjects(dataView: DataView) {\n            return dataView && dataView.metadata && dataView.metadata.objects;\n        }\n\n        private enumerateLegend(instances: VisualObjectInstance[]) {\n            let legendSettings: AsterPlotLegendSettings = this.data.legendSettings;\n            let instance: VisualObjectInstance = {\n                selector: null,\n                objectName: AsterPlotLegendObjectName,\n                displayName: 'Legend',\n                properties: {\n                    show: legendSettings.show,\n                    position: legendSettings.position,\n                    showTitle: legendSettings.showTitle,\n                    titleText: legendSettings.titleText,\n                    labelColor: legendSettings.labelColor,\n                    fontSize: legendSettings.fontSize,\n                }\n            };\n\n            instances.push(instance);\n        }\n\n        private clearData(): void {\n            this.mainGroupElement.selectAll(\"path\").remove();\n            dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);\n            this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);\n        }\n\n        public onClearSelection(): void {\n            if (this.interactivityService)\n                this.interactivityService.clearSelection();\n        }\n\n        private enumerateLabels(instances: VisualObjectInstance[]): void {\n            let labelSettings = this.data.labelSettings;\n            let labels: VisualObjectInstance = {\n                objectName: 'labels',\n                displayName: 'Labels',\n                selector: null,\n                properties: {\n                    show: labelSettings.show,\n                    fontSize: labelSettings.fontSize,\n                    labelPrecision: labelSettings.precision,\n                    labelDisplayUnits: labelSettings.displayUnits,\n                    color: labelSettings.labelColor,\n                }\n            };\n            instances.push(labels);\n        }\n        \n        // This function retruns the values to be displayed in the property pane for each object.\n        // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do\n        // validation and return other values/defaults\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\n            let instances: VisualObjectInstance[] = [];\n            if (!this.dataViewContainsCategory(this.dataView))\n                return instances;\n            switch (options.objectName) {\n                case AsterPlotLegendObjectName:\n                    if (this.data)\n                        this.enumerateLegend(instances);\n                    break;\n                case 'label':\n                    let label: VisualObjectInstance = {\n                        objectName: 'label',\n                        displayName: 'Label',\n                        selector: null,\n                        properties: {\n                            fill: this.getLabelFill(this.dataView)\n                        }\n                    };\n                    instances.push(label);\n                    break;\n                case 'labels':\n                    this.enumerateLabels(instances);\n                    break;\n                case 'outerLine':\n                    let outerLine: VisualObjectInstance = {\n                        objectName: 'outerLine',\n                        displayName: 'Outer Line',\n                        selector: null,\n                        properties: {\n                            show: this.data.showOuterLine,\n                            thickness: this.data.outerLineThickness,\n                        }\n                    };\n                    instances.push(outerLine);\n                    break;\n            }\n\n            return instances;\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import IStringResourceProvider = jsCommon.IStringResourceProvider;\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n    import PixelConverter = jsCommon.PixelConverter;\n\n    export interface TornadoChartTextOptions {\n        fontFamily?: string;\n        fontSize?: number;\n        sizeUnit?: string;\n    }\n\n    export interface TornadoChartConstructorOptions {\n        svg?: D3.Selection;\n        animator?: IGenericAnimator;\n        margin?: IMargin;\n        columnPadding?: number;\n    }\n\n    export interface TornadoChartSeries {\n        fill: string;\n        name: string;\n        selectionId: SelectionId;\n        categoryAxisEnd: number;\n    }\n\n    export interface TornadoChartSettings {\n        labelOutsideFillColor: string;\n        categoriesFillColor: string;\n        labelSettings: VisualDataLabelsSettings;\n        showLegend?: boolean;\n        showCategories?: boolean;\n        legendFontSize?: number;\n        legendColor?: string;\n        labelValueFormatter?: IValueFormatter;\n    }\n\n    export interface TornadoChartDataView {\n        categories: TextData[];\n        series: TornadoChartSeries[];\n        settings: TornadoChartSettings;\n        legend: LegendData;\n        dataPoints: TornadoChartPoint[];\n        highlightedDataPoints?: TornadoChartPoint[];\n    }\n\n    export interface TornadoChartPoint extends SelectableDataPoint {\n        dx?: number;\n        dy?: number;\n        px?: number;\n        py?: number;\n        angle?: number;\n        width?: number;\n        height?: number;\n        label?: LabelData;\n        color: string;\n        tooltipData: TooltipDataItem[];\n        categoryIndex: number;\n        highlight?: boolean;\n        value: number;\n        minValue: number;\n        maxValue: number;\n        formatString: string;\n    }\n\n    export interface LabelData {\n        dx: number;\n        value: number | string;\n        source: number | string;\n        color: string;\n    }\n\n    export interface LineData {\n        x1: number;\n        y1: number;\n        x2: number;\n        y2: number;\n    }\n\n    export interface TextData {\n        text: string;\n        height: number;\n        width: number;\n        textProperties: TextProperties;\n    }\n\n    export interface TornadoBehaviorOptions {\n        columns: D3.Selection;\n        clearCatcher: D3.Selection;\n        interactivityService: IInteractivityService;\n    }\n\n    class TornadoWebBehavior implements IInteractiveBehavior {\n        private columns: D3.Selection;\n        private clearCatcher: D3.Selection;\n        private interactivityService: IInteractivityService;\n\n        public bindEvents(options: TornadoBehaviorOptions, selectionHandler: ISelectionHandler) {\n            this.columns = options.columns;\n            this.clearCatcher = options.clearCatcher;\n            this.interactivityService = options.interactivityService;\n\n            this.columns.on('click', (d: SelectableDataPoint, i: number) => {\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\n            });\n\n            this.clearCatcher.on('click', () => {\n                selectionHandler.handleClearSelection();\n            });\n        }\n\n        public renderSelection(hasSelection: boolean) {\n            let hasHighlights = this.interactivityService.hasSelection();\n            this.columns.style(\"fill-opacity\", (d: TornadoChartPoint) => ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights));\n        }\n    }\n\n    class TornadoChartScrolling {\n        public isScrollable: boolean;\n        public scrollViewport: IViewport;\n\n        private static ScrollBarMinLength = 15;\n        private isYScrollBarVisible: boolean;\n        private brushGraphicsContextY: D3.Selection;\n        private scrollYBrush: D3.Svg.Brush = d3.svg.brush();\n\n        private getRoot: () => D3.Selection;\n        private getViewport: () => IViewport;\n\n        private get root(): D3.Selection {\n            return this.getRoot();\n        }\n\n        private get viewport(): IViewport {\n            return this.getViewport();\n        }\n\n        constructor(getRoot: () => D3.Selection, getViewport: () => IViewport, getMargin: () => IMargin, isScrollable: boolean) {\n            this.getRoot = getRoot;\n            this.getViewport = getViewport;\n            this.isScrollable = isScrollable;\n        }\n\n        public renderY(data: TornadoChartDataView, prefferedHeight: number, onScroll: () => {}): void {\n            this.isYScrollBarVisible = prefferedHeight > this.viewport.height\n                && this.viewport.height > 0\n                && this.viewport.width > 0;\n\n            this.brushGraphicsContextY = this.createOrRemoveScrollbar(this.isYScrollBarVisible, this.brushGraphicsContextY, 'y brush');\n            this.updateScrollViewport();\n\n            if (!this.isYScrollBarVisible) {\n                onScroll.call(this, jQuery.extend(true, {}, data), 0, 1);\n                return;\n            }\n\n            let scrollSpaceLength: number = this.viewport.height;\n            let extentData: any = this.getExtentData(prefferedHeight, scrollSpaceLength);\n\n            let onRender = (wheelDelta: number = 0) => {\n                let position: number[] = this.scrollYBrush.extent();\n                if (wheelDelta !== 0) {\n\n                    // Handle mouse wheel manually by moving the scrollbar half of its size\n                    let halfScrollsize: number = (position[1] - position[0]) / 2;\n                    position[0] += (wheelDelta > 0) ? halfScrollsize : -halfScrollsize;\n                    position[1] += (wheelDelta > 0) ? halfScrollsize : -halfScrollsize;\n\n                    if (position[0] < 0) {\n                        let offset: number = 0 - position[0];\n                        position[0] += offset;\n                        position[1] += offset;\n                    }\n                    if (position[1] > scrollSpaceLength) {\n                        let offset: number = position[1] - scrollSpaceLength;\n                        position[0] -= offset;\n                        position[1] -= offset;\n                    }\n\n                    // Update the scroll bar accordingly and redraw\n                    this.scrollYBrush.extent(position);\n                    this.brushGraphicsContextY.select('.extent').attr('y', position[0]);\n                }\n                let scrollPosition = extentData.toScrollPosition(position, scrollSpaceLength);\n                onScroll.call(this, jQuery.extend(true, {}, data), scrollPosition[0], scrollPosition[1]);\n                this.setScrollBarSize(this.brushGraphicsContextY, extentData.value[1], true);\n            };\n\n            let scrollYScale: D3.Scale.OrdinalScale = d3.scale.ordinal().rangeBands([0, scrollSpaceLength]);\n            this.scrollYBrush.y(scrollYScale).extent(extentData.value);\n\n            this.renderScrollbar(\n                this.scrollYBrush,\n                this.brushGraphicsContextY,\n                this.viewport.width,\n                onRender);\n\n            onRender();\n        }\n\n        private updateScrollViewport() {\n            this.scrollViewport = { height: this.viewport.height, width: this.viewport.width };\n\n            if (this.isYScrollBarVisible && this.isScrollable) {\n                this.scrollViewport.width -= TornadoChart.ScrollBarWidth;\n            }\n        }\n\n        private createOrRemoveScrollbar(isVisible, brushGraphicsContext, brushClass) {\n            if (isVisible && this.isScrollable) {\n                return brushGraphicsContext || this.root.append(\"g\").classed(brushClass, true);\n            }\n\n            return brushGraphicsContext ? void brushGraphicsContext.remove() : undefined;\n        }\n\n        private renderScrollbar(brush: D3.Svg.Brush,\n            brushGraphicsContext: D3.Selection,\n            brushX: number,\n            onRender: (number) => void): void {\n\n            brush.on(\"brush\", () => window.requestAnimationFrame(() => onRender(0)));\n            this.root.on('wheel', () => {\n                if (!this.isYScrollBarVisible) return;\n                let wheelEvent: any = d3.event; // Casting to any to avoid compilation errors\n                onRender(wheelEvent.deltaY);\n            });\n\n            brushGraphicsContext.attr({\n                \"transform\": visuals.SVGUtil.translate(brushX, 0),\n                \"drag-resize-disabled\": \"true\" /*disables resizing of the visual when dragging the scrollbar in edit mode*/\n            });\n\n            brushGraphicsContext.call(brush); /*call the brush function, causing it to create the rectangles   */\n            /* Disabling the zooming feature */\n            brushGraphicsContext.selectAll(\".resize\").remove();\n            brushGraphicsContext.select(\".background\").remove();\n            brushGraphicsContext.selectAll(\".extent\").style({\n                \"fill-opacity\": 0.125,\n                \"cursor\": \"default\",\n            });\n        }\n\n        private setScrollBarSize(brushGraphicsContext: D3.Selection, minExtent: number, isVertical: boolean): void {\n            brushGraphicsContext.selectAll(\"rect\").attr(isVertical ? \"width\" : \"height\", TornadoChart.ScrollBarWidth);\n            brushGraphicsContext.selectAll(\"rect\").attr(isVertical ? \"height\" : \"width\", minExtent);\n        }\n\n        private getExtentData(svgLength: number, scrollSpaceLength: number): any {\n            let value: number = scrollSpaceLength * scrollSpaceLength / svgLength;\n\n            let scaleMultipler: number = TornadoChartScrolling.ScrollBarMinLength <= value\n                ? 1\n                : value / TornadoChartScrolling.ScrollBarMinLength;\n\n            value = Math.max(value, TornadoChartScrolling.ScrollBarMinLength);\n\n            let toScrollPosition = (extent: number[], scrollSpaceLength: number) => {\n                let scrollSize: number = extent[1] - extent[0];\n                let scrollPosition: number = extent[0] / (scrollSpaceLength - scrollSize);\n\n                scrollSize *= scaleMultipler;\n\n                let start: number = (scrollPosition * (scrollSpaceLength - scrollSize));\n                let end: number = (start + scrollSize);\n\n                return [start / scrollSpaceLength, end / scrollSpaceLength];\n            };\n\n            return { value: [0, value], toScrollPosition: toScrollPosition };\n        }\n\n        public clearData(): void {\n            if (this.brushGraphicsContextY)\n                this.brushGraphicsContextY.selectAll(\"*\").remove();\n        }\n    }\n\n    export class TornadoChartWarning implements IVisualWarning {\n        public get code(): string {\n            return \"TornadoChartWarning\";\n        }\n\n        public getMessages(resourceProvider: IStringResourceProvider): IVisualErrorMessage {\n            let message: string = \"This visual requires two distinct values to be returned for the Legend field.\",\n                titleKey: string = \"\",\n                detailKey: string = \"\",\n                visualMessage: IVisualErrorMessage;\n\n            visualMessage = {\n                message: message,\n                title: resourceProvider.get(titleKey),\n                detail: resourceProvider.get(detailKey)\n            };\n\n            return visualMessage;\n        }\n    }\n\n    export function getTornadoChartWarning(): IVisualWarning {\n        return new TornadoChartWarning();\n    }\n\n    export class TornadoChart implements IVisual {\n        private static ClassName: string = \"tornado-chart\";\n\n        private static Properties: any = {\n            general: {\n                formatString: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"general\",\n                    propertyName: \"formatString\"\n                }\n            },\n            labels: {\n                show: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"labels\",\n                    propertyName: \"show\"\n                },\n                fontSize: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"labels\",\n                    propertyName: \"fontSize\"\n                },\n                labelPrecision: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"labels\",\n                    propertyName: \"labelPrecision\"\n                },\n                labelDisplayUnits: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"labels\",\n                    propertyName: \"labelDisplayUnits\"\n                },\n                insideFill: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"labels\",\n                    propertyName: \"insideFill\"\n                },\n                outsideFill: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"labels\",\n                    propertyName: \"outsideFill\"\n                }\n            },\n            dataPoint: {\n                fill: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"dataPoint\",\n                    propertyName: \"fill\"\n                }\n            },\n            legend: {\n                show: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"legend\",\n                    propertyName: \"show\"\n                },\n                labelColor: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"legend\",\n                    propertyName: \"labelColor\"\n                },\n                fontSize: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"legend\",\n                    propertyName: \"fontSize\"\n                },\n            },\n            categories: {\n                show: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"categories\",\n                    propertyName: \"show\"\n                },\n                fill: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"categories\",\n                    propertyName: \"fill\"\n                }\n            }\n        };\n\n        private static Columns: ClassAndSelector = {\n            \"class\": \"columns\",\n            selector: \".columns\"\n        };\n\n        private static Column: ClassAndSelector = {\n            \"class\": \"column\",\n            selector: \".column\"\n        };\n\n        private static Axes: ClassAndSelector = {\n            \"class\": \"axes\",\n            selector: \".axes\"\n        };\n\n        private static Axis: ClassAndSelector = {\n            \"class\": \"axis\",\n            selector: \".axis\"\n        };\n\n        private static Labels: ClassAndSelector = {\n            \"class\": \"labels\",\n            selector: \".labels\"\n        };\n\n        private static Label: ClassAndSelector = {\n            \"class\": \"label\",\n            selector: \".label\"\n        };\n\n        private static LabelTitle: ClassAndSelector = {\n            \"class\": \"label-title\",\n            selector: \".label-title\"\n        };\n\n        private static LabelText: ClassAndSelector = {\n            \"class\": \"label-text\",\n            selector: \".label-text\"\n        };\n\n        private static Categories: ClassAndSelector = {\n            \"class\": \"categories\",\n            selector: \".categories\"\n        };\n\n        private static Category: ClassAndSelector = {\n            \"class\": \"category\",\n            selector: \".category\"\n        };\n\n        private static CategoryTitle: ClassAndSelector = {\n            \"class\": \"category-title\",\n            selector: \".category-title\"\n        };\n\n        private static CategoryText: ClassAndSelector = {\n            \"class\": \"category-text\",\n            selector: \".category-text\"\n        };\n\n        private static MaxSeries: number = 2;\n        private static MaxPrecision: number = 17; // max number of decimals in float\n        private static LabelPadding: number = 2.5;\n        private static CategoryMinHeight: number = 25;\n        private static DefaultFontSize: number = 9;\n        private static DefaultLegendFontSize: number = 8;\n        private static HighlightedShapeFactor: number = 0.5;\n\n        public static ScrollBarWidth = 10;\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [{\n                name: \"Category\",\n                kind: VisualDataRoleKind.Grouping,\n                displayName: data.createDisplayNameGetter(\"Role_DisplayName_Group\")\n            }, {\n                    name: \"Series\",\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Legend')\n                }, {\n                    name: \"Values\",\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: data.createDisplayNameGetter(\"Role_DisplayName_Values\")\n                }],\n            dataViewMappings: [{\n                conditions: [\n                    { \"Category\": { max: 1 }, \"Values\": { min: 0, max: 1 }, \"Series\": { min: 0, max: 1 } },\n                    { \"Category\": { max: 1 }, \"Values\": { min: 2, max: 2 }, \"Series\": { max: 0 } }\n                ],\n                categorical: {\n                    categories: {\n                        for: {\n                            in: \"Category\"\n                        }\n                    },\n                    values: {\n                        group: {\n                            by: \"Series\",\n                            select: [{ for: { in: \"Values\" } }],\n                            dataReductionAlgorithm: { top: {} }\n                        }\n                    }\n                }\n            }],\n            objects: {\n                general: {\n                    displayName: 'General',\n                    properties: {\n                        formatString: {\n                            type: {\n                                formatting: {\n                                    formatString: true\n                                }\n                            },\n                        }\n                    }\n                },\n                dataPoint: {\n                    displayName: 'Data Colors',\n                    properties: {\n                        fill: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                },\n                categoryAxis: {\n                    displayName: 'X-Axis',\n                    properties: {\n                        end: {\n                            displayName: 'End',\n                            type: { numeric: true },\n                            suppressFormatPainterCopy: true,\n                        },\n                    }\n                },\n                labels: {\n                    displayName: 'Data Labels',\n                    properties: {\n                        show: {\n                            displayName: 'Show',\n                            type: { bool: true }\n                        },\n                        labelPrecision: {\n                            displayName: 'Decimal Places',\n                            placeHolderText: 'Auto',\n                            type: { numeric: true }\n                        },\n                        fontSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { formatting: { fontSize: true } }\n                        },\n                        labelDisplayUnits: {\n                            displayName: 'Display Units',\n                            type: { formatting: { labelDisplayUnits: true } },\n                        },\n                        insideFill: {\n                            displayName: 'Inside fill',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        outsideFill: {\n                            displayName: 'Outside fill',\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                },\n                legend: {\n                    displayName: 'Legend',\n                    properties: {\n                        show: {\n                            displayName: 'Show',\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: 'Position',\n                            description: data.createDisplayNameGetter('Visual_LegendPositionDescription'),\n                            type: { enumeration: legendPosition.type }\n                        },\n                        showTitle: {\n                            displayName: 'Title',\n                            description: data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),\n                            type: { bool: true }\n                        },\n                        titleText: {\n                            displayName: 'Legend Name',\n                            description: data.createDisplayNameGetter('Visual_LegendNameDescription'),\n                            type: { text: true }\n                        },\n                        labelColor: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: 'TextSize',\n                            type: { formatting: { fontSize: true } }\n                        },\n                    }\n                },\n                categories: {\n                    displayName: 'Group',\n                    properties: {\n                        show: {\n                            displayName: 'Show',\n                            type: { bool: true }\n                        },\n                        fill: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                }\n            },\n            supportsHighlight: true,\n        };\n\n        private DefaultTornadoChartSettings: TornadoChartSettings = {\n            labelOutsideFillColor: dataLabelUtils.defaultLabelColor,\n            labelSettings: {\n                show: true,\n                precision: null,\n                fontSize: TornadoChart.DefaultFontSize,\n                displayUnits: 0,\n                labelColor: dataLabelUtils.defaultInsideLabelColor,\n            },\n            showCategories: true,\n            showLegend: true,\n            legendFontSize: TornadoChart.DefaultLegendFontSize,\n            legendColor: LegendData.DefaultLegendLabelFillColor,\n            categoriesFillColor: \"#777\"\n        };\n\n        private DefaultFillColors: string[] = [\n            \"purple\", \"teal\"\n        ];\n\n        private columnPadding: number = 5;\n        private leftLabelMargin: number = 4;\n        private durationAnimations: number;\n        private InnerTextHeightDelta: number = 2;\n        private textOptions: TornadoChartTextOptions = {};\n\n        private margin: IMargin = {\n            top: 10,\n            right: 5,\n            bottom: 10,\n            left: 10\n        };\n\n        private root: D3.Selection;\n        private svg: D3.Selection;\n        private main: D3.Selection;\n        private columns: D3.Selection;\n        private axes: D3.Selection;\n        private labels: D3.Selection;\n        private categories: D3.Selection;\n        private clearCatcher: D3.Selection;\n\n        private legendObjectProperties: DataViewObject;\n        private legend: ILegend;\n        private hasDynamicSeries: boolean;\n        private hasHighlights: boolean;\n        private behavior: IInteractiveBehavior;\n        private colors: IDataColorPalette;\n        private interactivityService: IInteractivityService;\n        private animator: IGenericAnimator;\n        private hostService: IVisualHostServices;\n        private scrolling: TornadoChartScrolling;\n\n        private viewport: IViewport;\n        private tornadoChartDataView: TornadoChartDataView;\n        private defaultTornadoChartDataView: TornadoChartDataView;\n        private labelHeight: number;\n        private heightColumn: number = 0;\n        private widthLeftSection: number = 0;\n        private widthRightSection: number = 0;\n\n        constructor(tornadoChartConstructorOptions?: TornadoChartConstructorOptions) {\n            if (tornadoChartConstructorOptions) {\n                this.svg = tornadoChartConstructorOptions.svg || this.svg;\n                this.margin = tornadoChartConstructorOptions.margin || this.margin;\n                this.columnPadding = tornadoChartConstructorOptions.columnPadding || this.columnPadding;\n                this.animator = tornadoChartConstructorOptions.animator;\n            }\n        }\n\n        public init(visualInitOptions: VisualInitOptions): void {\n            let style: IVisualStyle = visualInitOptions.style,\n                fontSize: string;\n\n            this.hostService = visualInitOptions.host;\n            let element: JQuery = visualInitOptions.element;\n            this.colors = style.colorPalette.dataColors;\n            let interactivity = visualInitOptions.interactivity;\n            this.interactivityService = createInteractivityService(this.hostService);\n\n            let root: D3.Selection;\n            if (this.svg)\n                this.root = root = this.svg;\n            else\n                this.root = root = d3.select(element.get(0))\n                    .append(\"svg\");\n\n            root\n                .classed(TornadoChart.ClassName, true)\n                .style('position', 'absolute');\n\n            fontSize = root.style(\"font-size\");\n\n            this.textOptions.sizeUnit = fontSize.slice(fontSize.length - 2);\n            this.textOptions.fontSize = Number(fontSize.slice(0, fontSize.length - 2));\n            this.textOptions.fontFamily = root.style(\"font-family\");\n            this.scrolling = new TornadoChartScrolling(() => root, () => this.viewport, () => this.margin, true);\n            let main: D3.Selection = this.main = root.append(\"g\");\n            this.clearCatcher = appendClearCatcher(main);\n            this.columns = main\n                .append(\"g\")\n                .classed(TornadoChart.Columns.class, true);\n\n            this.axes = main\n                .append(\"g\")\n                .classed(TornadoChart.Axes.class, true);\n\n            this.labels = main\n                .append(\"g\")\n                .classed(TornadoChart.Labels.class, true);\n\n            this.categories = main\n                .append(\"g\")\n                .classed(TornadoChart.Categories.class, true);\n\n            this.behavior = new TornadoWebBehavior();\n            this.defaultTornadoChartDataView = {\n                categories: [],\n                series: [],\n                settings: null,\n                legend: null,\n                dataPoints: [],\n                highlightedDataPoints: [],\n            };\n\n            this.legend = createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);\n        }\n\n        public update(visualUpdateOptions: VisualUpdateOptions): void {\n            if (!visualUpdateOptions ||\n                !visualUpdateOptions.dataViews ||\n                !visualUpdateOptions.dataViews[0]) {\n                return;\n            }\n\n            this.viewport = {\n                height: Math.max(0, visualUpdateOptions.viewport.height - this.margin.top - this.margin.bottom),\n                width: Math.max(0, visualUpdateOptions.viewport.width - this.margin.left - this.margin.right)\n            };\n\n            if (this.animator)\n                this.durationAnimations = AnimatorCommon.GetAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);\n            else\n                this.durationAnimations = visualUpdateOptions.suppressAnimations ? 0 : 250;\n\n            this.tornadoChartDataView = this.converter(visualUpdateOptions.dataViews[0]);\n\n            if (this.interactivityService) {\n                this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.dataPoints);\n                this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.highlightedDataPoints);\n            }\n\n            this.render();\n        }\n\n        private updateElements(): void {\n            let elementsTranslate: string = SVGUtil.translate(this.widthLeftSection, 0);\n\n            this.root.attr({\n                \"height\": this.viewport.height + this.margin.top + this.margin.bottom,\n                \"width\": this.viewport.width + this.margin.left + this.margin.right\n            });\n\n            this.columns\n                .attr(\"transform\", elementsTranslate);\n\n            this.labels\n                .attr(\"transform\", elementsTranslate);\n\n            this.axes\n                .attr(\"transform\", elementsTranslate);\n        }\n\n        public converter(dataView: DataView): TornadoChartDataView {\n            if (!dataView ||\n                !dataView.categorical ||\n                !dataView.categorical.categories ||\n                !dataView.categorical.categories[0] ||\n                !dataView.categorical.categories[0].source ||\n                !dataView.categorical.values ||\n                !dataView.categorical.values[0]) {\n                return this.defaultTornadoChartDataView;\n            }\n\n            let categorical: DataViewCategorical = dataView.categorical;\n            let categories: DataViewCategoryColumn[] = categorical.categories || [];\n            let values: DataViewValueColumns = categorical.values;\n            if (values.length > TornadoChart.MaxSeries) {\n                this.hostService.setWarnings([getTornadoChartWarning()]);\n                return this.defaultTornadoChartDataView;\n            }\n            let category: DataViewCategoricalColumn = categories[0];\n            let categoryValues: number[] = category.values;\n            let categoryValuesLength: number = categoryValues.length;\n            let objects: DataViewObjects = this.getObjectsFromDataView(dataView);\n\n            let formatStringProp: DataViewObjectPropertyIdentifier = TornadoChart.Properties.general.formatString;\n            let valuesSourceFormatString: string = valueFormatter.getFormatString(values[0].source, formatStringProp);\n            let maxValue: number = d3.max(values[0].values);\n            let settings: TornadoChartSettings = this.parseSettings(objects, valuesSourceFormatString, maxValue);\n            this.hasDynamicSeries = !!values.source;\n            let hasHighlights: boolean = this.hasHighlights = !!(values.length > 0 && values[0].highlights);\n            this.labelHeight = TextMeasurementService.estimateSvgTextHeight({\n                fontFamily: dataLabelUtils.StandardFontFamily,\n                fontSize: PixelConverter.fromPoint(settings.labelSettings.fontSize),\n            });\n\n            let series: TornadoChartSeries[] = [];\n            let dataPoints: TornadoChartPoint[] = [];\n            let highlightedDataPoints: TornadoChartPoint[] = [];\n            let categoriesLabels: TextData[] = [];\n\n            let groupedValues: DataViewValueColumnGroup[] = [];\n            if (values.grouped)\n                groupedValues = values.grouped();\n\n            // Parse category labels and compute maximum category length\n            let maxCategoryLength: number = 0;\n            let showCategories = settings.showCategories;\n            let categorySourceFormatString: string = valueFormatter.getFormatString(category.source, formatStringProp);\n            for (let i = 0; i < categoryValuesLength; i++) {\n                let formattedCategoryValue = valueFormatter.format(categoryValues[i], categorySourceFormatString);\n                let textData = this.getTextData(formattedCategoryValue, true);\n                categoriesLabels.push(textData);\n                if (showCategories && textData.width > maxCategoryLength)\n                    maxCategoryLength = textData.width;\n            }\n\n            let scrollBarWidth: number = (categoryValuesLength * TornadoChart.CategoryMinHeight > this.viewport.height) ? TornadoChart.ScrollBarWidth : 0;\n            this.widthLeftSection = maxCategoryLength + TornadoChart.LabelPadding;\n            let maxColumnWidth = this.widthRightSection = this.viewport.width - this.widthLeftSection - scrollBarWidth;\n            this.updateElements();\n\n            let minValue: number = Math.min(d3.min(values[0].values), 0);\n            if (values.length === TornadoChart.MaxSeries) {\n                minValue = d3.min([minValue, d3.min(values[1].values)]);\n                maxValue = d3.max([maxValue, d3.max(values[1].values)]);\n                maxColumnWidth = maxColumnWidth / TornadoChart.MaxSeries;\n            }\n\n            for (let seriesIndex = 0; seriesIndex < values.length; seriesIndex++) {\n                let parsedSeries: TornadoChartSeries = this.parseSeries(values, seriesIndex, this.hasDynamicSeries, groupedValues);\n                series.push(parsedSeries);\n                let currentSeries = values[seriesIndex];\n                let measureName = currentSeries.source.queryName;\n\n                for (let i = 0; i < categoryValuesLength; i++) {\n                    let value = currentSeries.values[i] == null || isNaN(currentSeries.values[i]) ? 0 : currentSeries.values[i];\n                    let identity = SelectionIdBuilder.builder()\n                        .withCategory(category, i)\n                        .withSeries(values, currentSeries)\n                        .withMeasure(measureName)\n                        .createSelectionId();\n                    let formattedCategoryValue = categoriesLabels[i].text;\n                    let tooltipInfo: TooltipDataItem[];\n                    tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null);\n\n                    // Limit maximum value with what the user choose\n                    let currentMaxValue = parsedSeries.categoryAxisEnd ? Math.min(parsedSeries.categoryAxisEnd, maxValue) : maxValue;\n                    let formatString = dataView.categorical.values[seriesIndex].source.format;\n\n                    dataPoints.push({\n                        value: value,\n                        minValue: minValue,\n                        maxValue: currentMaxValue,\n                        formatString: formatString,\n                        color: parsedSeries.fill,\n                        selected: false,\n                        identity: identity,\n                        tooltipData: tooltipInfo,\n                        categoryIndex: i,\n                    });\n\n                    if (hasHighlights) {\n                        let highlightIdentity = SelectionId.createWithHighlight(identity);\n                        let highlight = currentSeries.highlights[i];\n                        let highlightedValue = highlight != null ? highlight : 0;\n                        tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue);\n\n                        highlightedDataPoints.push({\n                            value: highlightedValue,\n                            minValue: minValue,\n                            maxValue: currentMaxValue,\n                            formatString: formatString,\n                            color: parsedSeries.fill,\n                            selected: false,\n                            identity: highlightIdentity,\n                            tooltipData: tooltipInfo,\n                            categoryIndex: i,\n                            highlight: true,\n                        });\n                    }\n                }\n            }\n\n            return {\n                categories: categoriesLabels,\n                series: series,\n                settings: settings,\n                legend: this.getLegendData(series),\n                dataPoints: dataPoints,\n                highlightedDataPoints: highlightedDataPoints,\n            };\n        }\n\n        private parseSettings(objects: DataViewObjects, formatString: string, value: number): TornadoChartSettings {\n            let precision: number = this.getPrecision(objects);\n\n            let displayUnits: number = DataViewObjects.getValue<number>(\n                objects,\n                TornadoChart.Properties.labels.labelDisplayUnits,\n                this.DefaultTornadoChartSettings.labelSettings.displayUnits);\n\n            let labelSettings = this.DefaultTornadoChartSettings.labelSettings;\n\n            let labelValueFormatter = valueFormatter.create({\n                format: formatString,\n                precision: precision,\n                value: (displayUnits === 0) && (value != null) ? value : displayUnits,\n            });\n\n            return {\n                labelOutsideFillColor: this.getColor(TornadoChart.Properties.labels.outsideFill, this.DefaultTornadoChartSettings.labelOutsideFillColor, objects),\n                labelSettings: {\n                    show: DataViewObjects.getValue<boolean>(objects, TornadoChart.Properties.labels.show, labelSettings.show),\n                    precision: precision,\n                    fontSize: DataViewObjects.getValue<number>(objects, TornadoChart.Properties.labels.fontSize, labelSettings.fontSize),\n                    displayUnits: displayUnits,\n                    labelColor: this.getColor(TornadoChart.Properties.labels.insideFill, labelSettings.labelColor, objects),\n                },\n                showCategories: DataViewObjects.getValue<boolean>(objects, TornadoChart.Properties.categories.show, this.DefaultTornadoChartSettings.showCategories),\n                showLegend: DataViewObjects.getValue<boolean>(objects, TornadoChart.Properties.legend.show, this.DefaultTornadoChartSettings.showLegend),\n                legendFontSize: DataViewObjects.getValue<number>(objects, TornadoChart.Properties.legend.fontSize, this.DefaultTornadoChartSettings.legendFontSize),\n                legendColor: this.getColor(TornadoChart.Properties.legend.labelColor, this.DefaultTornadoChartSettings.legendColor, objects),\n                categoriesFillColor: this.getColor(TornadoChart.Properties.categories.fill, this.DefaultTornadoChartSettings.categoriesFillColor, objects),\n                labelValueFormatter: labelValueFormatter\n            };\n        }\n\n        private getColor(properties: any, defaultColor: string, objects: DataViewObjects): string {\n            let colorHelper: ColorHelper = new ColorHelper(this.colors, properties, defaultColor);\n            return colorHelper.getColorForMeasure(objects, \"\");\n        }\n\n        private getPrecision(objects: DataViewObjects): number {\n            let precision: number = DataViewObjects.getValue<number>(\n                objects,\n                TornadoChart.Properties.labels.labelPrecision,\n                this.DefaultTornadoChartSettings.labelSettings.precision);\n\n            if (precision >= TornadoChart.MaxPrecision) {\n                return TornadoChart.MaxPrecision;\n            }\n\n            return precision;\n        }\n\n        private getObjectsFromDataView(dataView: DataView): DataViewObjects {\n            if (!dataView ||\n                !dataView.metadata ||\n                !dataView.metadata.columns ||\n                !dataView.metadata.objects) {\n                this.legendObjectProperties = {};\n                return null;\n            }\n            this.legendObjectProperties = DataViewObjects.getObject(dataView.metadata.objects, \"legend\", {});\n            return dataView.metadata.objects;\n        }\n\n        private parseSeries(dataViewValueColumns: DataViewValueColumns, index: number, isGrouped: boolean, grouped: DataViewValueColumnGroup[]): TornadoChartSeries {\n            let dataViewValueColumn: DataViewValueColumn = dataViewValueColumns[index];\n            let seriesGroup: DataViewValueColumnGroup | DataViewValueColumn = isGrouped ? grouped[index] : grouped[0].values[index];\n            let source: DataViewMetadataColumn = dataViewValueColumn.source;\n\n            let selectionId: SelectionId = seriesGroup.identity\n                ? SelectionId.createWithId(seriesGroup.identity)\n                : SelectionIdBuilder.builder()\n                    .withSeries(dataViewValueColumns, seriesGroup)\n                    .withMeasure(source.queryName)\n                    .createSelectionId();\n\n            let displayName: string = source.groupName ? source.groupName : source.displayName;\n            let objects;\n            let categoryAxisObject: DataViewObject | DataViewObjectWithId[];\n\n            if (isGrouped) {\n                categoryAxisObject = seriesGroup.objects ? seriesGroup.objects['categoryAxis'] : null;\n                objects = seriesGroup.objects;\n            }\n            else {\n                objects = source.objects;\n                categoryAxisObject = objects ? objects['categoryAxis'] : null;\n            }\n\n            let color: string = this.getColor(\n                TornadoChart.Properties.dataPoint.fill,\n                this.DefaultFillColors[index],\n                objects);\n            let categoryAxisEnd: number = categoryAxisObject ? categoryAxisObject['end'] : null;\n\n            return <TornadoChartSeries>{\n                fill: color,\n                name: displayName,\n                selectionId: selectionId,\n                categoryAxisEnd: categoryAxisEnd,\n            };\n        }\n\n        private getLegendData(series: TornadoChartSeries[]): LegendData {\n            let legendDataPoints: LegendDataPoint[] = [];\n\n            if (this.hasDynamicSeries)\n                legendDataPoints = series.map((series: TornadoChartSeries) => {\n                    return <LegendDataPoint>{\n                        label: series.name,\n                        color: series.fill,\n                        icon: LegendIcon.Box,\n                        selected: false,\n                        identity: series.selectionId\n                    };\n                });\n\n            return {\n                dataPoints: legendDataPoints\n            };\n        }\n\n        private clearData(): void {\n            this.columns.selectAll(\"*\").remove();\n            this.axes.selectAll(\"*\").remove();\n            this.labels.selectAll(\"*\").remove();\n            this.categories.selectAll(\"*\").remove();\n            this.legend.drawLegend({ dataPoints: [] }, this.viewport);\n            this.scrolling.clearData();\n        }\n\n        public onClearSelection(): void {\n            if (this.interactivityService)\n                this.interactivityService.clearSelection();\n        }\n\n        private render(): void {\n            let tornadoChartDataView: TornadoChartDataView = this.tornadoChartDataView;\n            if (!tornadoChartDataView ||\n                !tornadoChartDataView.settings) {\n                this.clearData();\n                return;\n            }\n\n            this.renderLegend();\n\n            this.scrolling.renderY(\n                tornadoChartDataView,\n                tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight,\n                this.renderWithScrolling.bind(this));\n        }\n\n        private renderWithScrolling(tornadoChartDataView: TornadoChartDataView, scrollStart: number, scrollEnd: number): void {\n            if (!this.tornadoChartDataView || !this.tornadoChartDataView.settings)\n                return;\n            let categoriesLength = tornadoChartDataView.categories.length;\n            let startIndex: number = scrollStart * categoriesLength;\n            let endIndex: number = scrollEnd * categoriesLength;\n\n            let startIndexRound: number = Math.floor(startIndex);\n            let endIndexRound: number = Math.floor(endIndex);\n\n            let maxValues: number = Math.floor(this.scrolling.scrollViewport.height / TornadoChart.CategoryMinHeight);\n\n            if (scrollEnd - scrollStart < 1 && maxValues < endIndexRound - startIndexRound) {\n                if (startIndex - startIndexRound > endIndex - endIndexRound) {\n                    startIndexRound++;\n                }\n                else {\n                    endIndex--;\n                }\n            }\n\n            if (this.interactivityService) {\n                this.interactivityService.applySelectionStateToData(tornadoChartDataView.dataPoints);\n                this.interactivityService.applySelectionStateToData(tornadoChartDataView.highlightedDataPoints);\n            }\n\n            let scrollBarWidth: number = (tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight > this.viewport.height) ? TornadoChart.ScrollBarWidth : 0;\n\n            // Filter data according to the visible visual area\n            tornadoChartDataView.categories = tornadoChartDataView.categories.slice(startIndexRound, endIndexRound);\n            tornadoChartDataView.dataPoints = _.filter(tornadoChartDataView.dataPoints, (d: TornadoChartPoint) => d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound);\n            tornadoChartDataView.highlightedDataPoints = _.filter(tornadoChartDataView.highlightedDataPoints, (d: TornadoChartPoint) => d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound);\n\n            this.tornadoChartDataView = tornadoChartDataView;\n            this.computeHeightColumn();\n            this.renderMiddleSection(scrollBarWidth);\n            this.renderAxes();\n            this.renderCategories();\n        }\n\n        private updateViewport(): void {\n            let legendMargins: IViewport = this.legend.getMargins(),\n                legendPosition: LegendPosition;\n\n            legendPosition = LegendPosition[<string>this.legendObjectProperties[legendProps.position]];\n\n            switch (legendPosition) {\n                case LegendPosition.Top:\n                case LegendPosition.TopCenter:\n                case LegendPosition.Bottom:\n                case LegendPosition.BottomCenter: {\n                    this.viewport.height -= legendMargins.height;\n\n                    break;\n                }\n                case LegendPosition.Left:\n                case LegendPosition.LeftCenter:\n                case LegendPosition.Right:\n                case LegendPosition.RightCenter: {\n                    this.viewport.width -= legendMargins.width;\n\n                    break;\n                }\n            }\n        }\n\n        private computeHeightColumn(): void {\n            let length: number = this.tornadoChartDataView.categories.length;\n            this.heightColumn = (this.scrolling.scrollViewport.height - ((length - 1) * this.columnPadding)) / length;\n        }\n\n        private renderMiddleSection(scrollBarWidth: number): void {\n            let tornadoChartDataView: TornadoChartDataView = this.tornadoChartDataView;\n            this.calculateDataPoints(tornadoChartDataView.dataPoints, scrollBarWidth);\n            this.calculateDataPoints(tornadoChartDataView.highlightedDataPoints, scrollBarWidth);\n            let dataPointsWithHighlights: TornadoChartPoint[] = tornadoChartDataView.dataPoints.concat(tornadoChartDataView.highlightedDataPoints);\n            this.renderColumns(dataPointsWithHighlights, tornadoChartDataView.series.length === 2);\n            this.renderLabels(this.hasHighlights ? tornadoChartDataView.highlightedDataPoints : tornadoChartDataView.dataPoints, tornadoChartDataView.settings.labelSettings);\n        }\n\n        /**\n         * Calculate the width, dx value and label info for every data point\n         */\n        private calculateDataPoints(dataPoints: TornadoChartPoint[], scrollBarWidth: number): void {\n            let maxColumnWidth: number = this.widthRightSection = (this.viewport.width - this.widthLeftSection - scrollBarWidth);\n            let categoriesLength: number = this.tornadoChartDataView.categories.length;\n            let settings: TornadoChartSettings = this.tornadoChartDataView.settings;\n            let hasHighlights: boolean = this.hasHighlights;\n            let heightColumn = Math.max(this.heightColumn, 0);\n            let py = heightColumn / 2;\n            let pyHighlighted = heightColumn * TornadoChart.HighlightedShapeFactor / 2;\n            let maxSeries: boolean = this.tornadoChartDataView.series.length === TornadoChart.MaxSeries;\n\n            if (maxSeries)\n                maxColumnWidth /= 2;\n\n            for (let i = 0; i < dataPoints.length; i++) {\n                let dataPoint = dataPoints[i];\n\n                let shiftToMiddle = i < categoriesLength && maxSeries;\n                let shiftToRight: boolean = i > categoriesLength - 1;\n                let widthOfColumn: number = this.getColumnWidth(dataPoint.value, dataPoint.minValue, dataPoint.maxValue, maxColumnWidth);\n                let dx: number = (maxColumnWidth - widthOfColumn) * Number(shiftToMiddle) + maxColumnWidth * Number(shiftToRight) - scrollBarWidth;\n                dx = Math.max(dx, 0);\n\n                let highlighted: boolean = hasHighlights && dataPoint.highlight;\n                let highlightOffset: number = highlighted ? heightColumn * (1 - TornadoChart.HighlightedShapeFactor) / 2 : 0;\n                let dy: number = (heightColumn + this.columnPadding) * (i % categoriesLength) + highlightOffset;\n\n                let label: LabelData = this.getLabelData(\n                    dataPoint.value,\n                    dx,\n                    widthOfColumn,\n                    shiftToMiddle,\n                    dataPoint.formatString,\n                    settings);\n\n                dataPoint.dx = dx;\n                dataPoint.dy = dy;\n                dataPoint.px = widthOfColumn / 2;\n                dataPoint.py = highlighted ? pyHighlighted : py;\n                dataPoint.angle = shiftToMiddle ? 180 : 0;\n                dataPoint.width = widthOfColumn;\n                dataPoint.height = highlighted ? heightColumn * TornadoChart.HighlightedShapeFactor : heightColumn;\n                dataPoint.label = label;\n            }\n        }\n\n        private renderColumns(columnsData: TornadoChartPoint[], selectSecondSeries: boolean = false): void {\n            let hasSelection: boolean = this.interactivityService && this.interactivityService.hasSelection();\n            let hasHighlights: boolean = this.hasHighlights;\n\n            let columnsSelection: D3.UpdateSelection = this.columns\n                .selectAll(TornadoChart.Column.selector)\n                .data(columnsData);\n\n            columnsSelection\n                .enter()\n                .append(\"svg:rect\")\n                .classed(TornadoChart.Column.class, true);\n\n            columnsSelection\n                .style(\"fill\", (p: TornadoChartPoint) => p.color)\n                .style(\"fill-opacity\", (p: TornadoChartPoint) => ColumnUtil.getFillOpacity(p.selected, p.highlight, hasSelection, hasHighlights))\n                .attr(\"transform\", (p: TornadoChartPoint) => SVGUtil.translateAndRotate(p.dx, p.dy, p.px, p.py, p.angle))\n                .attr(\"height\", (p: TornadoChartPoint) => p.height)\n                .attr(\"width\", (p: TornadoChartPoint) => p.width);\n\n            columnsSelection\n                .exit()\n                .remove();\n\n            let interactivityService = this.interactivityService;\n\n            if (interactivityService) {\n                interactivityService.applySelectionStateToData(columnsData);\n                let behaviorOptions: TornadoBehaviorOptions = {\n                    columns: columnsSelection,\n                    clearCatcher: this.clearCatcher,\n                    interactivityService: this.interactivityService,\n                };\n                interactivityService.bind(columnsData, this.behavior, behaviorOptions);\n            }\n\n            this.renderTooltip(columnsSelection);\n        }\n\n        private renderTooltip(selection: D3.UpdateSelection): void {\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) => {\n                return (<TornadoChartPoint>tooltipEvent.data).tooltipData;\n            });\n        }\n\n        private getColumnWidth(value: number, minValue: number, maxValue: number, width: number): number {\n            if (minValue === maxValue) {\n                return width;\n            }\n            let columnWidth = width * (value - minValue) / (maxValue - minValue);\n\n            // In case the user specifies a custom category axis end we limit the\n            // column width to the maximum available width\n            return Math.max(0, Math.min(width, columnWidth));\n        }\n\n        private getLabelData(\n            value: number,\n            dxColumn: number,\n            columnWidth: number,\n            isColumnPositionLeft: boolean,\n            formatStringProp: string,\n            settings?: TornadoChartSettings): LabelData {\n\n            let dx: number,\n                tornadoChartSettings: TornadoChartSettings = settings ? settings : this.tornadoChartDataView.settings,\n                labelSettings: VisualDataLabelsSettings = tornadoChartSettings.labelSettings,\n                fontSize: number = labelSettings.fontSize,\n                color: string = labelSettings.labelColor;\n\n            let maxOutsideLabelWidth = isColumnPositionLeft\n                ? dxColumn - this.leftLabelMargin\n                : this.widthRightSection - (dxColumn + columnWidth + this.leftLabelMargin);\n            let maxLabelWidth = Math.max(maxOutsideLabelWidth, columnWidth - this.leftLabelMargin);\n\n            let textProperties: TextProperties = {\n                fontFamily: dataLabelUtils.StandardFontFamily,\n                fontSize: PixelConverter.fromPoint(fontSize),\n                text: tornadoChartSettings.labelValueFormatter.format(value)\n            };\n            let valueAfterValueFormatter: string = TextMeasurementService.getTailoredTextOrDefault(textProperties, maxLabelWidth);\n            let textDataAfterValueFormatter: TextData = this.getTextData(valueAfterValueFormatter, true, false, fontSize);\n\n            if (columnWidth > textDataAfterValueFormatter.width + TornadoChart.LabelPadding) {\n                dx = dxColumn + columnWidth / 2 - textDataAfterValueFormatter.width / 2;\n            } else {\n                if (isColumnPositionLeft) {\n                    dx = dxColumn - this.leftLabelMargin - textDataAfterValueFormatter.width;\n                } else {\n                    dx = dxColumn + columnWidth + this.leftLabelMargin;\n                }\n                color = tornadoChartSettings.labelOutsideFillColor;\n            }\n\n            return {\n                dx: dx,\n                source: value,\n                value: valueAfterValueFormatter,\n                color: color\n            };\n        }\n\n        private renderAxes(): void {\n            let linesData: LineData[],\n                axesSelection: D3.UpdateSelection,\n                axesElements: D3.Selection = this.main\n                    .select(TornadoChart.Axes.selector)\n                    .selectAll(TornadoChart.Axis.selector);\n\n            if (this.tornadoChartDataView.series.length !== TornadoChart.MaxSeries) {\n                axesElements.remove();\n                return;\n            }\n\n            linesData = this.generateAxesData();\n\n            axesSelection = axesElements.data(linesData);\n\n            axesSelection\n                .enter()\n                .append(\"svg:line\")\n                .classed(TornadoChart.Axis.class, true);\n\n            axesSelection\n                .transition()\n                .duration(this.durationAnimations)\n                .attr(\"x1\", (data: LineData) => data.x1)\n                .attr(\"y1\", (data: LineData) => data.y1)\n                .attr(\"x2\", (data: LineData) => data.x2)\n                .attr(\"y2\", (data: LineData) => data.y2);\n\n            axesSelection\n                .exit()\n                .remove();\n        }\n\n        private generateAxesData(): LineData[] {\n            let x: number,\n                y1: number,\n                y2: number;\n\n            x = this.widthRightSection / 2;\n            y1 = 0;\n            y2 = this.scrolling.scrollViewport.height;\n\n            return [{\n                x1: x,\n                y1: y1,\n                x2: x,\n                y2: y2\n            }];\n        }\n\n        private renderLabels(dataPoints: TornadoChartPoint[], labelsSettings: VisualDataLabelsSettings): void {\n            let labelEnterSelection: D3.Selection,\n                labelSelection: D3.UpdateSelection = this.main\n                    .select(TornadoChart.Labels.selector)\n                    .selectAll(TornadoChart.Label.selector)\n                    .data(_.filter(dataPoints, (p: TornadoChartPoint) => p.label.dx >= 0));\n\n            // Check if labels can be displayed\n            if (!labelsSettings.show || this.labelHeight >= this.heightColumn) {\n                this.labels.selectAll(\"*\").remove();\n                return;\n            }\n\n            let fontSizeInPx: string = PixelConverter.fromPoint(labelsSettings.fontSize);\n            let labelYOffset: number = this.heightColumn / 2 + this.labelHeight / 2 - this.InnerTextHeightDelta;\n            let categoriesLength: number = this.tornadoChartDataView.categories.length;\n\n            labelEnterSelection = labelSelection\n                .enter()\n                .append(\"g\");\n\n            labelEnterSelection\n                .append(\"svg:title\")\n                .classed(TornadoChart.LabelTitle.class, true);\n\n            labelEnterSelection\n                .append(\"svg:text\")\n                .attr(\"dy\", dataLabelUtils.DefaultDy)\n                .classed(TornadoChart.LabelText.class, true);\n\n            labelSelection\n                .attr(\"pointer-events\", \"none\")\n                .classed(TornadoChart.Label.class, true);\n\n            labelSelection\n                .select(TornadoChart.LabelTitle.selector)\n                .text((p: TornadoChartPoint) => p.label.source);\n\n            labelSelection\n                .attr(\"transform\", (p: TornadoChartPoint, index: number) => {\n                    let dy = (this.heightColumn + this.columnPadding) * (index % categoriesLength);\n                    return SVGUtil.translate(p.label.dx, dy + labelYOffset);\n                });\n\n            labelSelection\n                .select(TornadoChart.LabelText.selector)\n                .attr(\"fill\", (p: TornadoChartPoint) => p.label.color)\n                .attr(\"font-size\", (p: TornadoChartPoint) => fontSizeInPx)\n                .text((p: TornadoChartPoint) => p.label.value);\n\n            labelSelection\n                .exit()\n                .remove();\n        }\n\n        private renderCategories(): void {\n            let settings: TornadoChartSettings = this.tornadoChartDataView.settings,\n                color: string = settings.categoriesFillColor,\n                categoriesEnterSelection: D3.Selection,\n                categoriesSelection: D3.UpdateSelection,\n                categoryElements: D3.Selection = this.main\n                    .select(TornadoChart.Categories.selector)\n                    .selectAll(TornadoChart.Category.selector),\n                self: TornadoChart = this;\n\n            if (!settings.showCategories) {\n                categoryElements.remove();\n                return;\n            }\n\n            categoriesSelection = categoryElements.data(this.tornadoChartDataView.categories);\n\n            categoriesEnterSelection = categoriesSelection\n                .enter()\n                .append(\"g\");\n\n            categoriesEnterSelection\n                .append(\"svg:title\")\n                .classed(TornadoChart.CategoryTitle.class, true);\n\n            categoriesEnterSelection\n                .append(\"svg:text\")\n                .classed(TornadoChart.CategoryText.class, true);\n\n            categoriesSelection\n                .attr(\"transform\", (text: string, index: number) => {\n                    let shift: number = (this.heightColumn + this.columnPadding) * index + this.heightColumn / 2,\n                        textData: TextData = this.getTextData(text, false, true);\n\n                    shift = shift + textData.height / 2 - this.InnerTextHeightDelta;\n\n                    return SVGUtil.translate(0, shift);\n                })\n                .classed(TornadoChart.Category.class, true);\n\n            categoriesSelection\n                .select(TornadoChart.CategoryTitle.selector)\n                .text((text: TextData) => text.text);\n\n            categoriesSelection\n                .select(TornadoChart.CategoryText.selector)\n                .attr(\"fill\", color)\n                .text((data: TextData) => {\n                    let textData: TextData = self.getTextData(data.text);\n\n                    return TextMeasurementService.getTailoredTextOrDefault(textData.textProperties, self.widthLeftSection);\n                });\n\n            categoriesSelection\n                .exit()\n                .remove();\n        }\n\n        private renderLegend(): void {\n            let legend = this.tornadoChartDataView.legend;\n            if (!legend) {\n                return;\n            }\n            let settings: TornadoChartSettings = this.tornadoChartDataView.settings;\n\n            let legendData: LegendData = {\n                title: legend.title,\n                dataPoints: legend.dataPoints,\n                fontSize: settings.legendFontSize,\n                labelColor: settings.legendColor,\n            };\n\n            if (this.legendObjectProperties) {\n                let position: string;\n\n                LegendData.update(legendData, this.legendObjectProperties);\n\n                position = <string>this.legendObjectProperties[legendProps.position];\n\n                if (position) {\n                    this.legend.changeOrientation(LegendPosition[position]);\n                }\n            }\n\n            // Draw the legend on a viewport with the original height and width\n            let viewport: IViewport = {\n                height: this.viewport.height + this.margin.top + this.margin.bottom,\n                width: this.viewport.width + this.margin.left + this.margin.right,\n            };\n            this.legend.drawLegend(legendData, viewport);\n            Legend.positionChartArea(this.root, this.legend);\n\n            if (legendData.dataPoints.length > 0 && settings.showLegend)\n                this.updateViewport();\n        }\n\n        private getTextData(text: string, measureWidth: boolean = false, measureHeight: boolean = false, overrideFontSize?: number): TextData {\n            let width: number = 0,\n                height: number = 0,\n                fontSize: string,\n                textProperties: TextProperties;\n\n            text = text || \"\";\n\n            fontSize = overrideFontSize\n                ? PixelConverter.fromPoint(overrideFontSize)\n                : `${this.textOptions.fontSize}${this.textOptions.sizeUnit}`;\n\n            textProperties = {\n                text: text,\n                fontFamily: this.textOptions.fontFamily,\n                fontSize: fontSize\n            };\n\n            if (measureWidth) {\n                width = TextMeasurementService.measureSvgTextWidth(textProperties);\n            }\n\n            if (measureHeight) {\n                height = TextMeasurementService.estimateSvgTextHeight(textProperties);\n            }\n\n            return {\n                text: text,\n                width: width,\n                height: height,\n                textProperties: textProperties\n            };\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\n            let enumeration = new ObjectEnumerationBuilder(),\n                settings: TornadoChartSettings;\n\n            if (!this.tornadoChartDataView ||\n                !this.tornadoChartDataView.settings) {\n                return [];\n            }\n\n            settings = this.tornadoChartDataView.settings;\n\n            switch (options.objectName) {\n                case \"dataPoint\": {\n                    this.enumerateDataPoint(enumeration);\n                    break;\n                }\n                case \"categoryAxis\": {\n                    this.enumerateCategoryAxis(enumeration);\n                    break;\n                }\n                case \"labels\": {\n                    let labelSettings = settings.labelSettings;\n                    let labels: VisualObjectInstance = {\n                        objectName: \"labels\",\n                        displayName: \"Labels\",\n                        selector: null,\n                        properties: {\n                            show: labelSettings.show,\n                            fontSize: labelSettings.fontSize,\n                            labelPrecision: labelSettings.precision,\n                            labelDisplayUnits: labelSettings.displayUnits,\n                            insideFill: labelSettings.labelColor,\n                            outsideFill: settings.labelOutsideFillColor\n                        }\n                    };\n\n                    enumeration.pushInstance(labels);\n                    break;\n                }\n                case \"legend\": {\n                    if (!this.hasDynamicSeries)\n                        return;\n\n                    let showTitle: boolean = true,\n                        titleText: string = \"\",\n                        legend: VisualObjectInstance;\n\n                    showTitle = DataViewObject.getValue<boolean>(\n                        this.legendObjectProperties,\n                        legendProps.showTitle,\n                        showTitle);\n\n                    titleText = DataViewObject.getValue<string>(\n                        this.legendObjectProperties,\n                        legendProps.titleText,\n                        titleText);\n\n                    legend = {\n                        objectName: \"legend\",\n                        displayName: \"Legend\",\n                        selector: null,\n                        properties: {\n                            show: settings.showLegend,\n                            position: LegendPosition[this.legend.getOrientation()],\n                            showTitle: showTitle,\n                            titleText: titleText,\n                            fontSize: settings.legendFontSize,\n                            labelColor: settings.legendColor,\n                        }\n                    };\n\n                    enumeration.pushInstance(legend);\n                    break;\n                }\n                case \"categories\": {\n                    let categories: VisualObjectInstance = {\n                        objectName: \"categories\",\n                        displayName: \"Categories\",\n                        selector: null,\n                        properties: {\n                            show: settings.showCategories,\n                            fill: settings.categoriesFillColor\n                        }\n                    };\n\n                    enumeration.pushInstance(categories);\n                    break;\n                }\n            }\n\n            return enumeration.complete();\n        }\n\n        private enumerateDataPoint(enumeration: ObjectEnumerationBuilder): void {\n            if (!this.tornadoChartDataView ||\n                !this.tornadoChartDataView.series) {\n                return;\n            }\n\n            let series: TornadoChartSeries[] = this.tornadoChartDataView.series;\n\n            for (let currentSeries of series) {\n                enumeration.pushInstance({\n                    objectName: \"dataPoint\",\n                    displayName: currentSeries.name,\n                    selector: ColorHelper.normalizeSelector(currentSeries.selectionId.getSelector(), false),\n                    properties: {\n                        fill: { solid: { color: currentSeries.fill } }\n                    }\n                });\n            }\n        }\n\n        private enumerateCategoryAxis(enumeration: ObjectEnumerationBuilder): void {\n            if (!this.tornadoChartDataView || !this.tornadoChartDataView.series)\n                return;\n\n            let series: TornadoChartSeries[] = this.tornadoChartDataView.series;\n\n            for (let currentSeries of series) {\n                enumeration.pushInstance({\n                    objectName: \"categoryAxis\",\n                    displayName: currentSeries.name,\n                    selector: currentSeries.selectionId ? currentSeries.selectionId.getSelector() : null,\n                    properties: {\n                        end: currentSeries.categoryAxisEnd,\n                    }\n                });\n            }\n        }\n\n        public destroy(): void {\n            this.root = null;\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n    import createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n    import NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;\n    import ISize = shapes.ISize;\n\n    export const enum MekkoChartType {\n        HundredPercentStackedColumn,\n    }\n\n    export interface MekkoColumnChartDrawInfo /*extends ColumnChartDrawInfo*/ {\n        shapesSelection: D3.Selection;\n        viewport: IViewport;\n        axisOptions: MekkoColumnAxisOptions;\n\n        labelDataPoints: MekkoLabelDataPoint[];\n    }\n\n    export interface MekkoLabelDataPointsGroup/* extends LabelDataPointsGroup */ {\n        labelDataPoints: MekkoLabelDataPoint[];\n        maxNumberOfLabels: number;\n    }\n\n    export interface MekkoLabelParentRect {\n        /** The rectangle this data label belongs to */\n        rect: IRect;\n        /** The orientation of the parent rectangle */\n        orientation: NewRectOrientation;\n        /** Valid positions to place the label ordered by preference */\n        validPositions: RectLabelPosition[];\n    }\n\n    export interface MekkoLabelDataPoint/* extends LabelDataPoint*/ {\n        isParentRect?: boolean;\n        /** Text to be displayed in the label */\n        text: string;\n        /** The measured size of the text */\n        textSize: ISize;\n        /** Is data label preferred? Preferred labels will be rendered first */\n        isPreferred: boolean;\n        /** Color to use for the data label if drawn inside */\n        insideFill: string;\n        /** Color to use for the data label if drawn outside */\n        outsideFill: string;\n        /** Whether or not the data label has been rendered */\n        hasBeenRendered?: boolean;\n        /** Whether the parent type is a rectangle, point or polygon */\n        parentType: LabelDataPointParentType;\n        /** The parent geometry for the data label */\n        parentShape: MekkoLabelParentRect;//LabelParentRect | LabelParentPoint | LabelParentPolygon;\n        /** The identity of the data point associated with the data label */\n        identity: powerbi.visuals.SelectionId;\n        /** The font size of the data point associated with the data label */\n        fontSize?: number;\n        /** Second row of text to be displayed in the label, for additional information */\n        secondRowText?: string;\n        /** The calculated weight of the data point associated with the data label */\n        weight?: number;\n    }\n\n    export interface MekkoVisualRenderResult {\n        dataPoints: SelectableDataPoint[];\n        behaviorOptions: any;\n        labelDataPoints: MekkoLabelDataPoint[];\n        labelsAreNumeric: boolean;\n        labelDataPointGroups?: MekkoLabelDataPointsGroup[];\n    }\n\n    export interface MekkoCalculateScaleAndDomainOptions extends CalculateScaleAndDomainOptions {\n    }\n\n    export interface MekkoConstructorOptions {\n        chartType: MekkoChartType;\n        isScrollable?: boolean;\n        animator?: IGenericAnimator;\n        cartesianSmallViewPortProperties?: CartesianSmallViewPortProperties;\n        behavior?: IInteractiveBehavior;\n    }\n\n    export interface MekkoColumnChartData extends ColumnChartData {\n        borderSettings: MekkoBorderSettings;\n        categoriesWidth: number[];\n    }\n\n    export interface MekkoBorderSettings {\n        show: boolean;\n        color: any;\n        width: number;\n        maxWidth?: number;\n    }\n\n    export interface MekkoLabelSettings {\n       maxPrecision: number;\n       minPrecision: number;\n    }\n\n    export interface MekkoColumnAxisOptions extends ColumnAxisOptions {\n    }\n\n    export interface IMekkoColumnLayout extends IColumnLayout {\n        shapeBorder?: {\n            width: (d: ColumnChartDataPoint) => number;\n            x: (d: ColumnChartDataPoint) => number;\n            y: (d: ColumnChartDataPoint) => number;\n            height: (d: ColumnChartDataPoint) => number;\n        };\n        shapeXAxis?: {\n            width: (d: ColumnChartDataPoint) => number;\n            x: (d: ColumnChartDataPoint) => number;\n            y: (d: ColumnChartDataPoint) => number;\n            height: (d: ColumnChartDataPoint) => number;\n        };\n    }\n\n    export interface MekkoAxisRenderingOptions {\n        axisLabels: ChartAxesLabels;\n        legendMargin: number;\n        viewport: IViewport;\n        margin: IMargin;\n        hideXAxisTitle: boolean;\n        hideYAxisTitle: boolean;\n        hideY2AxisTitle?: boolean;\n        xLabelColor?: Fill;\n        yLabelColor?: Fill;\n        y2LabelColor?: Fill;\n    }\n\n    export interface MekkoDataPoints {\n        categoriesWidth: number[];\n        series: ColumnChartSeries[];\n        hasHighlights: boolean;\n        hasDynamicSeries: boolean;\n    }\n\n    export interface MekkoLegendDataPoint extends LegendDataPoint {\n        fontSize?: number;\n    }\n\n    export interface MekkoCreateAxisOptions extends CreateAxisOptions {\n        formatString: string;\n        is100Pct?: boolean;\n        shouldClamp?: boolean;\n        formatStringProp?: DataViewObjectPropertyIdentifier;\n    }\n\n    export interface MekkoColumnChartContext extends ColumnChartContext {\n        height: number;\n        width: number;\n        duration: number;\n        margin: IMargin;\n        mainGraphicsContext: D3.Selection;\n        labelGraphicsContext: D3.Selection;\n        layout: CategoryLayout;\n        animator: IColumnChartAnimator;\n        onDragStart?: (datum: ColumnChartDataPoint) => void;\n        interactivityService: IInteractivityService;\n        viewportHeight: number;\n        viewportWidth: number;\n        is100Pct: boolean;\n        hostService: IVisualHostServices;\n        isComboChart: boolean;\n    }\n\n    export class MekkoDataWrapper {\n        private data: CartesianData;\n        private isScalar: boolean;\n\n        public constructor(columnChartData: CartesianData, isScalar: boolean) {\n            this.data = columnChartData;\n            this.isScalar = isScalar;\n        }\n\n        public lookupXValue(index: number, type: ValueType): any {\n            debug.assertValue(this.data, 'this.data');\n\n            var isDateTime: boolean = AxisHelper.isDateTime(type);\n            if (isDateTime && this.isScalar) {\n                return new Date(index);\n            }\n\n            var data = this.data;\n            if (type.text) {\n                debug.assert(index < data.categories.length, 'category index out of range');\n                return data.categories[index];\n            }\n            else {\n                var firstSeries = data.series[0];\n                if (firstSeries) {\n                    var seriesValues = firstSeries.data;\n                    if (seriesValues) {\n                        if (this.data.hasHighlights) {\n                            index = index * 2;\n                        }\n                        var dataPoint = seriesValues[index];\n                        if (dataPoint) {\n                            if (isDateTime) {\n                                return new Date(dataPoint.categoryValue);\n                            }\n                            return dataPoint.categoryValue;\n                        }\n                    }\n                }\n            }\n\n            return index;\n        }\n    }\n\n    export class MekkoColumnChartStrategy implements IMekkoColumnChartStrategy {\n        private static classes = {\n            item: <ClassAndSelector>createClassAndSelector('column'),\n            highlightItem: <ClassAndSelector>createClassAndSelector('highlightColumn')\n        };\n\n        private layout: IMekkoColumnLayout;\n        private data: MekkoColumnChartData;\n        private graphicsContext: MekkoColumnChartContext;\n        private width: number;\n        private height: number;\n        private margin: IMargin;\n        private xProps: IAxisProperties;\n        private yProps: IAxisProperties;\n        private categoryLayout: CategoryLayout;\n        private columnsCenters: number[];\n        private columnSelectionLineHandle: D3.Selection;\n        private animator: IColumnChartAnimator;\n        private interactivityService: IInteractivityService;\n        private viewportHeight: number;\n        private viewportWidth: number;\n\n        private static validLabelPositions = [1];\n\n        public setupVisualProps(columnChartProps: MekkoColumnChartContext): void {\n            this.graphicsContext = columnChartProps;\n            this.margin = columnChartProps.margin;\n            this.width = this.graphicsContext.width;\n            this.height = this.graphicsContext.height;\n            this.categoryLayout = columnChartProps.layout;\n            this.animator = columnChartProps.animator;\n            this.interactivityService = columnChartProps.interactivityService;\n            this.viewportHeight = columnChartProps.viewportHeight;\n            this.viewportWidth = columnChartProps.viewportWidth;\n        }\n\n        public setData(data: MekkoColumnChartData) {\n            this.data = data;\n        }\n\n        private static createFormatter(\n            scaleDomain: any[],\n            dataDomain: any[],\n            dataType,\n            isScalar: boolean,\n            formatString: string,\n            bestTickCount: number,\n            tickValues: any[],\n            getValueFn: any,\n            useTickIntervalForDisplayUnits: boolean = false): IValueFormatter {\n\n            var formatter: IValueFormatter;\n            if (dataType.dateTime) {\n                if (isScalar) {\n                    var value = new Date(scaleDomain[0]);\n                    var value2 = new Date(scaleDomain[1]);\n                    // datetime with only one value needs to pass the same value\n                    // (from the original dataDomain value, not the adjusted scaleDomain)\n                    // so formatting works correctly.\n                    if (bestTickCount === 1)\n                        value = value2 = new Date(dataDomain[0]);\n                    formatter = valueFormatter.create({ format: formatString, value: value, value2: value2, tickCount: bestTickCount });\n                }\n                else {\n                    if (getValueFn == null) {\n                        debug.assertFail('getValueFn must be supplied for ordinal datetime tickValues');\n                    }\n                    var minDate: Date = getValueFn(0, dataType);\n                    var maxDate: Date = getValueFn(scaleDomain.length - 1, dataType);\n                    formatter = valueFormatter.create({ format: formatString, value: minDate, value2: maxDate, tickCount: bestTickCount });\n                }\n            }\n            else {\n                if (getValueFn == null && !isScalar) {\n                    debug.assertFail('getValueFn must be supplied for ordinal tickValues');\n                }\n                if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {\n                    var domainMin = tickValues[1] - tickValues[0];\n                    var domainMax = 0; //force tickInterval to be used with display units\n                    formatter = valueFormatter.create({ format: formatString, value: domainMin, value2: domainMax, allowFormatBeautification: true });\n                }\n                else {\n                    // do not use display units, just the basic value formatter\n                    // datetime is handled above, so we are ordinal and either boolean, numeric, or text.\n                    formatter = valueFormatter.createDefaultFormatter(formatString, true);\n                }\n            }\n\n            return formatter;\n        }\n\n        /**\n         * Format the linear tick labels or the category labels.\n         */\n        private static formatAxisTickValues(\n            axis: D3.Svg.Axis,\n            tickValues: any[],\n            formatter: IValueFormatter,\n            dataType: ValueType,\n            isScalar: boolean,\n            getValueFn?: (index: number, type: ValueType) => any) {\n\n            var formattedTickValues = [];\n            if (formatter) {\n                // getValueFn takes an ordinal axis index or builds DateTime from milliseconds, do not pass a numeric scalar value.\n                if (getValueFn && !(dataType.numeric && isScalar)) {\n                    axis.tickFormat(d => formatter.format(getValueFn(d, dataType)));\n                    formattedTickValues = tickValues.map(d => formatter.format(getValueFn(d, dataType)));\n                }\n                else {\n                    axis.tickFormat(d => formatter.format(d));\n                    formattedTickValues = tickValues.map((d) => formatter.format(d));\n                }\n            }\n            else {\n                formattedTickValues = tickValues.map((d) => getValueFn(d, dataType));\n            }\n\n            return formattedTickValues;\n        }\n\n        /**\n         * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.\n         * @param options The properties used to create the axis.\n         */\n        private createAxis(options): IAxisProperties {\n            var pixelSpan = options.pixelSpan,\n                dataDomain = options.dataDomain,\n                metaDataColumn = options.metaDataColumn,\n                formatStringProp = options.formatStringProp,\n                outerPadding = options.outerPadding || 0,\n                isCategoryAxis = !!options.isCategoryAxis,\n                isScalar = !!options.isScalar,\n                isVertical = !!options.isVertical,\n                useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?\n                getValueFn = options.getValueFn,\n                categoryThickness = options.categoryThickness;\n\n            var formatString = valueFormatter.getFormatString(metaDataColumn, formatStringProp);\n            var dataType: ValueType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar);\n            var isLogScaleAllowed = AxisHelper.isLogScalePossible(dataDomain, dataType);\n\n            var scale = d3.scale.linear();\n            var scaleDomain = [0, 1];\n            var bestTickCount = dataDomain.length || 1;\n\n            var borderWidth: number = MekkoColumnChart.getBorderWidth(options.borderSettings);\n            var chartWidth = pixelSpan - borderWidth * (bestTickCount - 1);\n\n            if (chartWidth < MekkoChart.MinOrdinalRectThickness) {\n                chartWidth = MekkoChart.MinOrdinalRectThickness;\n            }\n\n            scale.domain(scaleDomain)\n                .range([0, chartWidth]);\n            var tickValues = dataDomain;\n\n            var formatter = MekkoColumnChartStrategy.createFormatter(\n                scaleDomain,\n                dataDomain,\n                dataType,\n                isScalar,\n                formatString,\n                bestTickCount,\n                tickValues,\n                getValueFn,\n                useTickIntervalForDisplayUnits);\n\n            // sets default orientation only, cartesianChart will fix y2 for comboChart\n            // tickSize(pixelSpan) is used to create gridLines\n            var axis = d3.svg.axis()\n                .scale(scale)\n                .tickSize(6, 0)\n                .orient(isVertical ? 'left' : 'bottom')\n                .ticks(bestTickCount)\n                .tickValues(dataDomain);\n\n            var formattedTickValues = [];\n            if (metaDataColumn) {\n                formattedTickValues = MekkoColumnChartStrategy.formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn);\n            }\n\n            var xLabelMaxWidth;\n            // Use category layout of labels if specified, otherwise use scalar layout of labels\n            if (!isScalar && categoryThickness) {\n                xLabelMaxWidth = Math.max(1, categoryThickness - CartesianChart.TickLabelPadding * 2);\n            }\n            else {\n                // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan\n                // When there is > 1 ticks then we need to +1 so that their widths don't overlap\n                // Example: 2 ticks are drawn at 33.33% and 66.66%, their width needs to be 33.33% so they don't overlap.\n                var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;\n                xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan;\n                xLabelMaxWidth = Math.max(1, xLabelMaxWidth - CartesianChart.TickLabelPadding * 2);\n            }\n\n            return {\n                scale: scale,\n                axis: axis,\n                formatter: formatter,\n                values: formattedTickValues,\n                axisType: dataType,\n                axisLabel: null,\n                isCategoryAxis: isCategoryAxis,\n                xLabelMaxWidth: xLabelMaxWidth,\n                categoryThickness: categoryThickness,\n                outerPadding: outerPadding,\n                usingDefaultDomain: false,//scaleResult.usingDefaultDomain,\n                isLogScaleAllowed: isLogScaleAllowed\n            };\n        }\n\n        private getCategoryAxis(\n            data: MekkoColumnChartData,\n            size: number,\n            layout: CategoryLayout,\n            isVertical: boolean,\n            forcedXMin?: DataViewPropertyValue,\n            forcedXMax?: DataViewPropertyValue,\n            axisScaleType?: string): IAxisProperties {\n\n            var categoryThickness = layout.categoryThickness;\n            var isScalar: boolean  = layout.isScalar;\n            var outerPaddingRatio = layout.outerPaddingRatio;\n            var dw = new MekkoDataWrapper(data, isScalar);\n            var domain: number[] = [];\n\n            if (data.series &&\n                (data.series.length > 0) &&\n                data.series[0].data &&\n                (data.series[0].data.length > 0)\n            ) {\n                var domainDoubles = data.series[0].data.map((item: ColumnChartDataPoint) => {\n                    return item.originalPosition + (item.value / 2);\n                });\n\n                domain = domainDoubles.filter(function(item, pos) {\n                    return domainDoubles.indexOf(item) === pos;\n                });\n            }\n\n            var axisProperties: IAxisProperties = this.createAxis({\n                pixelSpan: size,\n                dataDomain: domain,\n                metaDataColumn: data.categoryMetadata,\n                formatStringProp: columnChartProps.general.formatString,\n                outerPadding: categoryThickness * outerPaddingRatio,\n                isCategoryAxis: true,\n                isScalar: isScalar,\n                isVertical: isVertical,\n                categoryThickness: categoryThickness,\n                useTickIntervalForDisplayUnits: true,\n                getValueFn: (index, type) => {\n                    var domainIndex = domain.indexOf(index);\n                    var value = dw.lookupXValue(domainIndex, type);\n                    return value;\n                },\n                scaleType: axisScaleType,\n                borderSettings: data.borderSettings\n            });\n            // intentionally updating the input layout by ref\n            layout.categoryThickness = axisProperties.categoryThickness;\n            return axisProperties;\n        }\n\n        public setXScale(is100Pct: boolean, forcedTickCount?: number, forcedXDomain?: any[], axisScaleType?: string): IAxisProperties {\n            var width = this.width;\n            var forcedXMin, forcedXMax;\n\n            if (forcedXDomain && forcedXDomain.length === 2) {\n                forcedXMin = forcedXDomain[0];\n                forcedXMax = forcedXDomain[1];\n            }\n\n            var props = this.xProps = this.getCategoryAxis(\n                this.data,\n                width,\n                this.categoryLayout,\n                false,\n                forcedXMin,\n                forcedXMax,\n                axisScaleType);\n\n            return props;\n        }\n\n        public setYScale(is100Pct: boolean, forcedTickCount?: number, forcedYDomain?: any[], axisScaleType?: string): IAxisProperties {\n            var height = this.viewportHeight;\n            var valueDomain = StackedUtil.calcValueDomain(this.data.series, is100Pct);\n            var valueDomainArr = [valueDomain.min, valueDomain.max];\n            var combinedDomain = AxisHelper.combineDomain(forcedYDomain, valueDomainArr);\n            var shouldClamp = AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);\n            var metadataColumn = this.data.valuesMetadata[0];\n            var formatString = is100Pct ?\n                this.graphicsContext.hostService.getLocalizedString('Percentage')\n                : valueFormatter.getFormatString(metadataColumn, columnChartProps.general.formatString);\n\n            var mekkoMekkoCreateAxisOptions: MekkoCreateAxisOptions = {\n                pixelSpan: height,\n                dataDomain: combinedDomain,\n                metaDataColumn: metadataColumn,\n                formatString: formatString,\n                outerPadding: 0,\n                isScalar: true,\n                isVertical: true,\n                forcedTickCount: forcedTickCount,\n                useTickIntervalForDisplayUnits: true,\n                isCategoryAxis: false,\n                scaleType: axisScaleType,\n                axisDisplayUnits: 0,\n                axisPrecision: 0,\n                is100Pct: is100Pct,\n                shouldClamp: shouldClamp,\n                formatStringProp: undefined,\n            };\n\n            this.yProps = AxisHelper.createAxis(mekkoMekkoCreateAxisOptions);\n            return this.yProps;\n        }\n\n        public drawColumns(useAnimation: boolean): MekkoColumnChartDrawInfo {\n            var data = this.data;\n            debug.assertValue(data, 'data should not be null or undefined');\n            this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again\n\n            var axisOptions: MekkoColumnAxisOptions = {\n                columnWidth: 0,\n                xScale: this.xProps.scale,\n                yScale: this.yProps.scale,\n                isScalar: this.categoryLayout.isScalar,\n                margin: this.margin,\n            };\n            var stackedColumnLayout = this.layout = MekkoColumnChartStrategy.getLayout(data, axisOptions);\n            //var dataLabelSettings = data.labelSettings;\n            var labelDataPoints: MekkoLabelDataPoint[] = this.createMekkoLabelDataPoints();\n            var result: ColumnChartAnimationResult;\n            var shapes: D3.UpdateSelection;\n            var series = ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);\n            if (this.animator && useAnimation) {\n                result = this.animator.animate({\n                    viewModel: data,\n                    series: series,\n                    layout: stackedColumnLayout,\n                    itemCS: MekkoColumnChartStrategy.classes.item,\n                    interactivityService: this.interactivityService,\n                    mainGraphicsContext: this.graphicsContext.mainGraphicsContext,\n                    viewPort: { height: this.height, width: this.width },\n                });\n                shapes = result.shapes;\n            }\n            if (!this.animator || !useAnimation || result.failed) {\n                shapes = MekkoColumnChartStrategy.drawDefaultShapes(data,\n                    series,\n                    stackedColumnLayout,\n                    MekkoColumnChartStrategy.classes.item,\n                    !this.animator,\n                    this.interactivityService && this.interactivityService.hasSelection());\n            }\n\n            ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);\n\n            return {\n                shapesSelection: shapes,\n                viewport: { height: this.height, width: this.width },\n                axisOptions,\n                labelDataPoints: labelDataPoints,\n            };\n        }\n\n        private static drawDefaultShapes(data: MekkoColumnChartData,\n            series: D3.UpdateSelection,\n            layout: IMekkoColumnLayout,\n            itemCS: ClassAndSelector,\n            filterZeros: boolean,\n            hasSelection: boolean): D3.UpdateSelection {\n            // We filter out invisible (0, null, etc.) values from the dataset\n            // based on whether animations are enabled or not, Dashboard and\n            // Exploration mode, respectively.\n\n            var rectName: string = 'rect';\n            filterZeros = false;\n\n            var dataSelector: (d: ColumnChartSeries) => any[];\n            if (filterZeros) {\n                dataSelector = (d: ColumnChartSeries) => {\n                    var filteredData = _.filter(d.data, (datapoint: ColumnChartDataPoint) => !!datapoint.value);\n                    return filteredData;\n                };\n            }\n            else {\n                dataSelector = (d: ColumnChartSeries) => d.data;\n            }\n\n            var shapeSelection = series.selectAll(itemCS.selector);\n            var shapes = shapeSelection.data(dataSelector, (d: ColumnChartDataPoint) => d.key);\n\n            shapes.enter()\n                .append(rectName)\n                .attr(\"class\", (d: ColumnChartDataPoint) => itemCS.class.concat(d.highlight ? \" highlight\" : \"\"));\n\n            shapes\n                .style(\"fill\", (d: ColumnChartDataPoint) => d.color)\n                .style(\"fill-opacity\", (d: ColumnChartDataPoint) => ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights))\n                .attr(layout.shapeLayout);\n\n            shapes\n                .exit()\n                .remove();\n\n            var borderSelection = series.selectAll(MekkoColumnChart.BorderClass.selector);\n            var borders = borderSelection.data(dataSelector, (d: ColumnChartDataPoint) => d.key);\n\n            var borderColor = MekkoColumnChart.getBorderColor(data.borderSettings);\n\n            borders.enter()\n                .append(rectName)\n                .classed(MekkoColumnChart.BorderClass.class, true);\n\n            borders\n                .style(\"fill\", (d: ColumnChartDataPoint) => borderColor)\n                .style(\"fill-opacity\", (d: ColumnChartDataPoint) => {\n                    return data.hasHighlights ? ColumnUtil.DimmedOpacity : ColumnUtil.DefaultOpacity;\n                })\n                .attr(layout.shapeBorder);\n\n            borders\n                .exit()\n                .remove();\n\n            return shapes;\n        }\n\n        public selectColumn(selectedColumnIndex: number, lastSelectedColumnIndex: number): void {\n            ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, MekkoColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);\n            this.moveHandle(selectedColumnIndex);\n        }\n\n        public getClosestColumnIndex(x: number, y: number): number {\n            return ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());\n        }\n\n        /**\n         * Get the chart's columns centers (x value).\n         */\n        private getColumnsCenters(): number[] {\n            if (!this.columnsCenters) { // lazy creation\n                var categoryWidth: number = this.categoryLayout.categoryThickness * (1 - CartesianChart.InnerPaddingRatio);\n                // use the axis scale and first series data to get category centers\n                if (this.data.series.length > 0) {\n                    var xScaleOffset = 0;\n                    if (!this.categoryLayout.isScalar) {\n                        xScaleOffset = categoryWidth / 2;\n                    }\n                    var firstSeries = this.data.series[0];\n                    if (firstSeries &&\n                        firstSeries.data) {\n                        this.columnsCenters = firstSeries.data.map(d => this.xProps.scale(this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset);\n                    }\n                }\n            }\n            return this.columnsCenters;\n        }\n\n        private moveHandle(selectedColumnIndex: number) {\n            var columnCenters = this.getColumnsCenters();\n            var x = columnCenters[selectedColumnIndex];\n\n            if (!this.columnSelectionLineHandle) {\n                var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');\n                handle.append('line')\n                    .classed('interactive-hover-line', true)\n                    .attr({\n                        x1: x,\n                        x2: x,\n                        y1: 0,\n                        y2: this.height,\n                    });\n\n                handle.append('circle')\n                    .attr({\n                        cx: x,\n                        cy: this.height,\n                        r: '6px',\n                    })\n                    .classed('drag-handle', true);\n            }\n            else {\n                var handle = this.columnSelectionLineHandle;\n                handle.select('line').attr({ x1: x, x2: x });\n                handle.select('circle').attr({ cx: x });\n            }\n        }\n\n        public static getLayout(data: MekkoColumnChartData, axisOptions: MekkoColumnAxisOptions): IMekkoColumnLayout {\n            var xScale = axisOptions.xScale;\n            var yScale = axisOptions.yScale;\n            var scaledY0 = yScale(0);\n            var scaledX0 = xScale(0);\n\n            var borderWidth: number = MekkoColumnChart.getBorderWidth(data.borderSettings);\n\n            var columnWidthScale = (d: ColumnChartDataPoint) => {\n                var value: number = AxisHelper.diffScaled(xScale, d.value, 0);\n                return value;\n            };\n\n            var columnStart = (d: ColumnChartDataPoint) => {\n                var value: number = scaledX0 +\n                                    AxisHelper.diffScaled(xScale, d.originalPosition, 0) +\n                                    borderWidth * d.categoryIndex;\n                return value;\n            };\n\n            var borderStart = (d: ColumnChartDataPoint) => {\n                var value: number = scaledX0 +\n                            AxisHelper.diffScaled(xScale, d.originalPosition, 0) +\n                            AxisHelper.diffScaled(xScale, d.value, 0) +\n                            borderWidth * d.categoryIndex;\n\n                return value;\n            };\n\n            return {\n                shapeLayout: {\n                    width: columnWidthScale,\n                    x: columnStart,\n                    y: (d: ColumnChartDataPoint) => scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0),\n                    height: (d: ColumnChartDataPoint) => StackedUtil.getSize(yScale, d.valueAbsolute)\n                },\n                shapeBorder: {\n                    width: (d: ColumnChartDataPoint) => borderWidth,\n                    x: borderStart,\n                    y: (d: ColumnChartDataPoint) => scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0),\n                    height: (d: ColumnChartDataPoint) => StackedUtil.getSize(yScale, d.valueAbsolute)\n                },\n                shapeLayoutWithoutHighlights: {\n                    width: columnWidthScale,\n                    x: columnStart,\n                    y: (d: ColumnChartDataPoint) => scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0),\n                    height: (d: ColumnChartDataPoint) => StackedUtil.getSize(yScale, d.originalValueAbsolute)\n                },\n                zeroShapeLayout: {\n                    width: columnWidthScale,\n                    x: columnStart,\n                    y: (d: ColumnChartDataPoint) => scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0) + StackedUtil.getSize(yScale, d.valueAbsolute),\n                    height: (d: ColumnChartDataPoint) => 0\n                },\n                shapeXAxis: {\n                    width: columnWidthScale,\n                    x: columnStart,\n                    y: (d: ColumnChartDataPoint) => scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0),\n                    height: (d: ColumnChartDataPoint) => StackedUtil.getSize(yScale, d.valueAbsolute)\n                },\n            };\n        }\n\n        private createMekkoLabelDataPoints(): MekkoLabelDataPoint[] {\n            var labelDataPoints: MekkoLabelDataPoint[] = [];\n            var data = this.data;\n            var series = data.series;\n            var formattersCache = NewDataLabelUtils.createColumnFormatterCacheManager();\n            var shapeLayout = this.layout.shapeLayout;\n\n            for (var i: number = 0, ilen = series.length; i < ilen; i++) {\n                var currentSeries = series[i];\n                var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;\n\n                if (!labelSettings.show) {\n                    continue;\n                }\n\n                if (!currentSeries.data) {\n                    continue;\n                }\n\n                var axisFormatter: number = NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);\n\n                for (var j: number = 0; j < currentSeries.data.length; j++) {\n                    var dataPoint: ColumnChartDataPoint = currentSeries.data[j];\n                    if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {\n                        continue;\n                    }\n\n                    // Calculate parent rectangle\n                    var parentRect: IRect = {\n                        left: shapeLayout.x(dataPoint),\n                        top: shapeLayout.y(dataPoint),\n                        width: shapeLayout.width(dataPoint),\n                        height: shapeLayout.height(dataPoint),\n                    };\n\n                    // Calculate label text\n                    var formatString = null;\n                    var value: number = dataPoint.valueOriginal;\n\n                    if (!labelSettings.displayUnits) {\n                        formatString = NewDataLabelUtils.hundredPercentFormat;\n                        value = dataPoint.valueAbsolute;\n                    }\n\n                    var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);\n                    var text = NewDataLabelUtils.getLabelFormattedText(formatter.format(value));\n\n                    // Calculate text size\n                    var properties: TextProperties = {\n                        text: text,\n                        fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,\n                        fontSize: NewDataLabelUtils.LabelTextProperties.fontSize,\n                        fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight,\n                    };\n                    var textWidth = TextMeasurementService.measureSvgTextWidth(properties);\n                    var textHeight = TextMeasurementService.estimateSvgTextHeight(properties);\n\n                    labelDataPoints.push({\n                        isPreferred: true,\n                        text: text,\n                        textSize: {\n                            width: textWidth,\n                            height: textHeight,\n                        },\n                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultLabelColor,\n                        insideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultInsideLabelColor,\n                        isParentRect: true,\n                        parentShape: {\n                            rect: parentRect,\n                            orientation: 1,\n                            validPositions: MekkoColumnChartStrategy.validLabelPositions,\n                        },\n                        identity: dataPoint.identity,\n                        parentType: 1,//LabelDataPointParentType.Rectangle,\n                    });\n                }\n            }\n\n            return labelDataPoints;\n        }\n    }\n\n    export interface MekkoChartSettings {\n        columnBorder: MekkoBorderSettings;\n        labelSettings: MekkoLabelSettings;\n    }\n\n    /**\n     * Renders a data series as a cartestian visual.\n     */\n    export class MekkoChart implements IVisual {\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: 'Category',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'Category',\n                }, {\n                    name: 'Series',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'Series',\n                }, {\n                    name: 'Y',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Y Axis',\n                }, {\n                    name: 'Width',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Axis width',\n                }\n            ],\n            objects: {\n                columnBorder: {\n                    displayName: 'Column Border',\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        color: {\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\n                            description: data.createDisplayNameGetter('Visual_LabelsFillDescription'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        width: {\n                            displayName: 'Width',\n                            type: { numeric: true }\n                        },\n                    },\n                },\n                labels: {\n                    displayName: data.createDisplayNameGetter('Visual_DataPointsLabels'),\n                    description: data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        showSeries: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        color: {\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\n                            description: data.createDisplayNameGetter('Visual_LabelsFillDescription'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        labelDisplayUnits: {\n                            displayName: data.createDisplayNameGetter('Visual_DisplayUnits'),\n                            description: data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),\n                            type: { formatting: { labelDisplayUnits: true } },\n                            suppressFormatPainterCopy: true\n                        },\n                        labelPrecision: {\n                            displayName: data.createDisplayNameGetter('Visual_Precision'),\n                            description: data.createDisplayNameGetter('Visual_PrecisionDescription'),\n                            placeHolderText: data.createDisplayNameGetter('Visual_Precision_Auto'),\n                            type: { numeric: true },\n                            suppressFormatPainterCopy: true\n                        },\n                        showAll: {\n                            displayName: data.createDisplayNameGetter('Visual_ShowAll'),\n                            type: { bool: true }\n                        },\n                        fontSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { formatting: { fontSize: true } }\n                        },\n                    },\n                },\n                legend: {\n                    displayName: data.createDisplayNameGetter('Visual_Legend'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendPosition'),\n                            type: { formatting: { legendPosition: true } }\n                        },\n                        showTitle: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendShowTitle'),\n                            type: { bool: true }\n                        },\n                        titleText: {\n                            displayName: 'Title text',\n                            type: { text: true }\n                        },\n                        fontSize: {\n                            displayName: 'Text size',\n                            type: { formatting: { fontSize: true } }\n                        },\n                    }\n                },\n                categoryAxis: {\n                    displayName: data.createDisplayNameGetter('Visual_XAxis'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: data.createDisplayNameGetter('Visual_YAxis_Position'),\n                            type: { formatting: { yAxisPosition: true } }\n                        },\n                        axisScale: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Scale'),\n                            type: { formatting: { axisScale: true } }\n                        },\n                        /*start: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Start'),\n                            type: { numeric: true }\n                        },\n                        end: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_End'),\n                            type: { numeric: true }\n                        },*/\n                        axisType: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Type'),\n                            type: { formatting: { axisType: true } }\n                        },\n                        showAxisTitle: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Title'),\n                            type: { bool: true }\n                        },\n                        axisStyle: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Style'),\n                            type: { formatting: { axisStyle: true } }\n                        },\n                        labelColor: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_LabelColor'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { formatting: { fontSize: true } }\n                        },\n                    }\n                },\n                valueAxis: {\n                    displayName: data.createDisplayNameGetter('Visual_YAxis'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: data.createDisplayNameGetter('Visual_YAxis_Position'),\n                            type: { formatting: { yAxisPosition: true } }\n                        },\n                        axisScale: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Scale'),\n                            type: { formatting: { axisScale: true } }\n                        },\n                        /*start: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Start'),\n                            type: { numeric: true }\n                        },\n                        end: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_End'),\n                            type: { numeric: true }\n                        },*/\n                        intersection: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Intersection'),\n                            type: { numeric: true }\n                        },\n                        showAxisTitle: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Title'),\n                            type: { bool: true }\n                        },\n                        axisStyle: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Style'),\n                            type: { formatting: { axisStyle: true } }\n                        },\n                        labelColor: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_LabelColor'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { formatting: { fontSize: true } }\n                        },\n\n                    }\n                },\n                dataPoint: {\n                    displayName: data.createDisplayNameGetter('Visual_DataPoint'),\n                    properties: {\n                        defaultColor: {\n                            displayName: data.createDisplayNameGetter('Visual_DefaultColor'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        showAllDataPoints: {\n                            displayName: data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\n                            type: { bool: true }\n                        },\n                        fill: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fillRule: {\n                            displayName: data.createDisplayNameGetter('Visual_Gradient'),\n                            type: { fillRule: {} },\n                            rule: {\n                                inputRole: 'Gradient',\n                                output: {\n                                    property: 'fill',\n                                    selector: ['Category'],\n                                },\n                            },\n                        }\n                    }\n                },\n\n            },\n            dataViewMappings: [{\n                conditions: [\n                    { 'Category': { min: 0, max: 1 }, 'Series': { min: 0, max: 1 }, 'Y': { min: 0, max: 1 }, 'Width': { min: 0, max: 1 } },\n                ],\n                categorical: {\n                    categories: {\n                        for: { in: 'Category' },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: {\n                        group: {\n                            by: 'Series',\n                            select: [{ for: { in: 'Y' } }, { for: { in: 'Width' } }],\n                            dataReductionAlgorithm: { top: {} }\n                        }\n                    },\n                    rowCount: { preferred: { min: 1, max: 1 }, supported: { min: 0 } }\n                },\n            }],\n            supportsHighlight: true,\n            sorting: {\n                default: {},\n            },\n            drilldown: {\n                roles: ['Category']\n            },\n        };\n\n        private static properties = {\n            general: {\n                formatString: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"general\",\n                    propertyName: \"formatString\"\n                }\n            },\n            columnBorder: {\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'columnBorder', propertyName: 'show', },\n                color: <DataViewObjectPropertyIdentifier>{ objectName: 'columnBorder', propertyName: 'color' },\n                width: <DataViewObjectPropertyIdentifier>{ objectName: 'columnBorder', propertyName: 'width' },\n            },\n        };\n\n        public static DefaultSettings: MekkoChartSettings = {\n            columnBorder: {\n                show: true,\n                color: '#fff',\n                width: 2,\n                maxWidth: 5,\n            },\n            labelSettings: {\n                maxPrecision: 4,\n                minPrecision: 0,\n            }\n        };\n\n        private static getTextProperties(fontSize: number = MekkoChart.FontSize): TextProperties {\n            return {\n                fontFamily: 'wf_segoe-ui_normal',\n                fontSize: jsCommon.PixelConverter.toString(fontSize),\n            };\n        }\n\n        public static MinOrdinalRectThickness = 20;\n        public static MinScalarRectThickness = 2;\n        public static OuterPaddingRatio = 0.4;\n        public static InnerPaddingRatio = 0.2;\n        public static TickLabelPadding = 2;\n\n        private static ClassName = 'cartesianChart';\n        private static AxisGraphicsContextClassName = 'axisGraphicsContext';\n        private static MaxMarginFactor = 0.25;\n        private static MinBottomMargin = 50;\n        private static LeftPadding = 10;\n        private static RightPadding = 10;\n        private static BottomPadding = 16;\n        private static YAxisLabelPadding = 20;\n        private static XAxisLabelPadding = 20;\n        private static TickPaddingY = 10;\n        private static TickPaddingRotatedX = 5;\n        private static FontSize = 11;\n\n        public static MaxNumberOfLabels = 100;\n\n        private static MinWidth: number = 100;\n        private static MinHeight: number = 100;\n\n        private axisGraphicsContext: D3.Selection;\n        private xAxisGraphicsContext: D3.Selection;\n        private y1AxisGraphicsContext: D3.Selection;\n        private y2AxisGraphicsContext: D3.Selection;\n        private element: JQuery;\n        private svg: D3.Selection;\n        private clearCatcher: D3.Selection;\n        private margin: IMargin;\n        private type: MekkoChartType;\n        private hostServices: IVisualHostServices;\n        private layers: IMekkoColumnChartVisual[];\n        private legend: ILegend;\n        private legendMargins: IViewport;\n        private layerLegendData: LegendData;\n        private hasSetData: boolean;\n        private visualInitOptions: VisualInitOptions;\n\n        private borderObjectProperties: DataViewObject;\n        private legendObjectProperties: DataViewObject;\n        private categoryAxisProperties: DataViewObject;\n\n        private valueAxisProperties: DataViewObject;\n        private cartesianSmallViewPortProperties: CartesianSmallViewPortProperties;\n        private interactivityService: IInteractivityService;\n        private behavior: IInteractiveBehavior;\n        private y2AxisExists: boolean;\n        private categoryAxisHasUnitType: boolean;\n        private valueAxisHasUnitType: boolean;\n        private hasCategoryAxis: boolean;\n        private yAxisIsCategorical: boolean;\n        private secValueAxisHasUnitType: boolean;\n        private axes: CartesianAxisProperties;\n        private yAxisOrientation: string;\n        private bottomMarginLimit: number;\n        private leftRightMarginLimit: number;\n        private sharedColorPalette: SharedColorPalette;\n\n        public animator: IGenericAnimator;\n\n        // Scrollbar related\n        private isScrollable: boolean;\n        private scrollY: boolean;\n        private scrollX: boolean;\n        private isXScrollBarVisible: boolean;\n        private isYScrollBarVisible: boolean;\n        private svgScrollable: D3.Selection;\n        private axisGraphicsContextScrollable: D3.Selection;\n        private labelGraphicsContextScrollable: D3.Selection;\n        private brushGraphicsContext: D3.Selection;\n        private brush: D3.Svg.Brush;\n        private static ScrollBarWidth = 10;\n        // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.\n        private dataViews: DataView[];\n        private currentViewport: IViewport;\n\n        constructor(options: MekkoConstructorOptions) {\n            this.isScrollable = false;\n            if (options) {\n                this.type = options.chartType;\n                if (options.isScrollable)\n                    this.isScrollable = options.isScrollable;\n                this.animator = options.animator;\n                if (options.cartesianSmallViewPortProperties) {\n                    this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;\n                }\n\n                if (options.behavior) {\n                    this.behavior = options.behavior;\n                }\n            } else {\n                this.behavior = new MekkoChartBehavior([new ColumnChartWebBehavior()]);\n            }\n        }\n\n        public init(options: VisualInitOptions) {\n            this.visualInitOptions = options;\n            this.layers = [];\n\n            var element = this.element = options.element;\n            var viewport = this.currentViewport = options.viewport;\n            this.hostServices = options.host;\n            this.brush = d3.svg.brush();\n            element.addClass(MekkoChart.ClassName);\n            this.margin = {\n                top: 1,\n                right: 1,\n                bottom: 1,\n                left: 1\n            };\n            this.yAxisOrientation = yAxisPosition.left;\n            this.adjustMargins(viewport);\n\n            this.sharedColorPalette = new SharedColorPalette(options.style.colorPalette.dataColors);\n\n            var showLinesOnX = true;\n            var showLinesOnY = true;\n\n            var svg = this.svg = d3.select(element.get(0)).append('svg');\n            svg.style('position', 'absolute');\n\n            var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')\n                .classed(MekkoChart.AxisGraphicsContextClassName, true);\n\n            this.svgScrollable = svg.append('svg')\n                .classed('svgScrollable', true)\n                .style('overflow', 'hidden');\n\n            var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')\n                .classed(MekkoChart.AxisGraphicsContextClassName, true);\n\n            this.labelGraphicsContextScrollable = this.svgScrollable.append('g')\n                .classed(NewDataLabelUtils.labelGraphicsContextClass.class, true);\n\n            if (this.behavior) {\n                this.clearCatcher = appendClearCatcher(this.axisGraphicsContextScrollable);\n            }\n\n            var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;\n\n            this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');\n            this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');\n            this.y2AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');\n\n            this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);\n            this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);\n            this.y2AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);\n\n            this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);\n            this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);\n            this.y2AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);\n\n            if (this.behavior) {\n                this.interactivityService = createInteractivityService(this.hostServices);\n            }\n            this.legend = createLegend(\n                element,\n                options.interactivity && options.interactivity.isInteractiveLegend,\n                this.interactivityService,\n                true);\n        }\n\n        private renderAxesLabels(options: MekkoAxisRenderingOptions): void {\n            debug.assertValue(options, 'options');\n            debug.assertValue(options.viewport, 'options.viewport');\n            debug.assertValue(options.axisLabels, 'options.axisLabels');\n\n            this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\n            this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\n\n            var margin = this.margin;\n            var width = options.viewport.width - (margin.left + margin.right);\n            var height = options.viewport.height;\n            var fontSize = MekkoChart.FontSize;\n            var heightOffset = fontSize;\n\n            var showOnRight = this.yAxisOrientation === yAxisPosition.right;\n\n            if (!options.hideXAxisTitle) {\n                var xAxisLabel = this.axisGraphicsContext.append(\"text\")\n                    .style(\"text-anchor\", \"middle\")\n                    .text(options.axisLabels.x)\n                    .call((text: D3.Selection) => {\n                        text.each(function() {\n                            var text = d3.select(this);\n                            text.attr({\n                                \"class\": \"xAxisLabel\",\n                                \"transform\": SVGUtil.translate(width / 2, height - heightOffset)\n                            });\n                        });\n                    });\n\n                xAxisLabel.style(\"fill\", options.xLabelColor ? options.xLabelColor.solid.color : null);\n\n                xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\n                    width,\n                    TextMeasurementService.svgEllipsis);\n            }\n\n            if (!options.hideYAxisTitle) {\n                var yAxisLabel = this.axisGraphicsContext.append(\"text\")\n                    .style(\"text-anchor\", \"middle\")\n                    .text(options.axisLabels.y)\n                    .call((text: D3.Selection) => {\n                        text.each(function() {\n                            var text = d3.select(this);\n                            text.attr({\n                                \"class\": \"yAxisLabel\",\n                                \"transform\": \"rotate(-90)\",\n                                \"y\": showOnRight ? width + margin.right - fontSize : -margin.left,\n                                \"x\": -((height - margin.top - options.legendMargin) / 2),\n                                \"dy\": \"1em\"\n                            });\n                        });\n                    });\n\n                yAxisLabel.style(\"fill\", options.yLabelColor ? options.yLabelColor.solid.color : null);\n\n                yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\n                    height - (margin.bottom + margin.top),\n                    TextMeasurementService.svgEllipsis);\n            }\n\n            if (!options.hideY2AxisTitle && options.axisLabels.y2) {\n                var y2AxisLabel = this.axisGraphicsContext.append(\"text\")\n                    .style(\"text-anchor\", \"middle\")\n                    .text(options.axisLabels.y2)\n                    .call((text: D3.Selection) => {\n                        text.each(function() {\n                            var text = d3.select(this);\n                            text.attr({\n                                \"class\": \"yAxisLabel\",\n                                \"transform\": \"rotate(-90)\",\n                                \"y\": showOnRight ? -margin.left : width + margin.right - fontSize,\n                                \"x\": -((height - margin.top - options.legendMargin) / 2),\n                                \"dy\": \"1em\"\n                            });\n                        });\n                    });\n\n                y2AxisLabel.style(\"fill\", options.y2LabelColor ? options.y2LabelColor.solid.color : null);\n\n                y2AxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\n                    height - (margin.bottom + margin.top),\n                    TextMeasurementService.svgEllipsis);\n            }\n        }\n\n        private adjustMargins(viewport: IViewport): void {\n            var margin = this.margin;\n\n            var width = viewport.width - (margin.left + margin.right);\n            var height = viewport.height - (margin.top + margin.bottom);\n\n            // Adjust margins if ticks are not going to be shown on either axis\n            var xAxis = this.element.find('.x.axis');\n\n            if (AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0\n                && AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {\n                this.margin = {\n                    top: 0,\n                    right: 0,\n                    bottom: 0,\n                    left: 0\n                };\n                xAxis.hide();\n            } else {\n                xAxis.show();\n            }\n        }\n\n        private translateAxes(viewport: IViewport): void {\n            this.adjustMargins(viewport);\n            var margin = this.margin;\n\n            var width = viewport.width - (margin.left + margin.right);\n            var height = viewport.height - (margin.top + margin.bottom);\n\n            var showY1OnRight = this.yAxisOrientation === yAxisPosition.right;\n\n            this.xAxisGraphicsContext\n                .attr('transform', SVGUtil.translate(0, height));\n\n            this.y1AxisGraphicsContext\n                .attr('transform', SVGUtil.translate(showY1OnRight ? width : 0, 0));\n\n            this.y2AxisGraphicsContext\n                .attr('transform', SVGUtil.translate(showY1OnRight ? 0 : width, 0));\n\n            this.svg.attr({\n                'width': viewport.width,\n                'height': viewport.height\n            });\n\n            this.svg.style('top', this.legend.isVisible() ? this.legend.getMargins().height + 'px' : 0);\n\n            this.svgScrollable.attr({\n                'width': viewport.width,\n                'height': viewport.height\n            });\n\n            this.svgScrollable.attr({\n                'x': 0\n            });\n\n            this.axisGraphicsContext.attr('transform', SVGUtil.translate(margin.left, margin.top));\n            this.axisGraphicsContextScrollable.attr('transform', SVGUtil.translate(margin.left, margin.top));\n            this.labelGraphicsContextScrollable.attr('transform', SVGUtil.translate(margin.left, margin.top));\n\n            if (this.isXScrollBarVisible) {\n                this.svgScrollable.attr({\n                    'x': this.margin.left\n                });\n                this.axisGraphicsContextScrollable.attr('transform', SVGUtil.translate(0, margin.top));\n                this.labelGraphicsContextScrollable.attr('transform', SVGUtil.translate(0, margin.top));\n                this.svgScrollable.attr('width', width);\n                this.svg.attr('width', viewport.width)\n                    .attr('height', viewport.height + MekkoChart.ScrollBarWidth);\n            }\n            else if (this.isYScrollBarVisible) {\n                this.svgScrollable.attr('height', height + margin.top);\n                this.svg.attr('width', viewport.width + MekkoChart.ScrollBarWidth)\n                    .attr('height', viewport.height);\n            }\n        }\n\n        public static getIsScalar(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, type: ValueType): boolean {\n            var axisTypeValue = DataViewObjects.getValue(objects, propertyId);\n\n            if (!objects || axisTypeValue === undefined) {\n                // If we don't have anything set (Auto), show charts as Scalar if the category type is numeric or time.\n                // If we have the property, it will override the type.\n                return !AxisHelper.isOrdinal(type);\n            }\n\n            // also checking type here to be in sync with AxisHelper, which ignores scalar if the type is non-numeric.\n            return (axisTypeValue === axisType.scalar) && !AxisHelper.isOrdinal(type);\n        }\n\n        private populateObjectProperties(dataViews: DataView[]) {\n            if (dataViews && dataViews.length > 0) {\n                var dataViewMetadata = dataViews[0].metadata;\n\n                if (dataViewMetadata) {\n                    this.legendObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});\n                    this.borderObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, 'columnBorder', {});\n                }\n                else {\n                    this.legendObjectProperties = {};\n                    this.borderObjectProperties = {};\n                }\n\n                this.categoryAxisProperties = CartesianHelper.getCategoryAxisProperties(dataViewMetadata);\n                this.valueAxisProperties = CartesianHelper.getValueAxisProperties(dataViewMetadata);\n\n                if (dataViewMetadata &&\n                    dataViewMetadata.objects) {\n                    var categoryAxis = dataViewMetadata.objects['categoryAxis'];\n                    var valueAxis = dataViewMetadata.objects['valueAxis'];\n\n                    if (categoryAxis) {\n                        this.categoryAxisProperties['showBorder'] = categoryAxis['showBorder'];\n                        this.categoryAxisProperties['fontSize'] = categoryAxis['fontSize'];\n                    }\n\n                    if (valueAxis) {\n                        this.valueAxisProperties['fontSize'] = valueAxis['fontSize'];\n                    }\n                }\n                var axisPosition = this.valueAxisProperties['position'];\n                this.yAxisOrientation = axisPosition ? axisPosition.toString() : yAxisPosition.left;\n            }\n        }\n\n        public update(options: VisualUpdateOptions) {\n            debug.assertValue(options, 'options');\n\n            var dataViews = this.dataViews = options.dataViews;\n            this.currentViewport = options.viewport;\n\n            if (!dataViews) {\n                return;\n            }\n\n            if ((this.currentViewport.width < MekkoChart.MinWidth) ||\n                (this.currentViewport.height < MekkoChart.MinHeight)) {\n                return;\n            }\n\n            if (this.layers.length === 0) {\n                // Lazily instantiate the chart layers on the first data load.\n                this.layers = this.createAndInitLayers(dataViews);\n\n                debug.assert(this.layers.length > 0, 'createAndInitLayers should update the layers.');\n            }\n            var layers = this.layers;\n\n            if (dataViews && dataViews.length > 0) {\n                var warnings = getInvalidValueWarnings(\n                    dataViews,\n                    false /*supportsNaN*/,\n                    false /*supportsNegativeInfinity*/,\n                    false /*supportsPositiveInfinity*/);\n\n                if (warnings && warnings.length > 0) {\n                    this.hostServices.setWarnings(warnings);\n                }\n                this.populateObjectProperties(dataViews);\n            }\n\n            this.sharedColorPalette.clearPreferredScale();\n            for (var i: number = 0, len: number = layers.length; i < len; i++) {\n                layers[i].setData(getLayerData(dataViews, i, len));\n\n                if (len > 1) {\n                    this.sharedColorPalette.rotateScale();\n\t\t\t\t}\n            }\n\n            // Note: interactive legend shouldn't be rendered explicitly here\n            // The interactive legend is being rendered in the render method of ICartesianVisual\n            if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {\n                this.renderLegend();\n            }\n            this.render(!this.hasSetData || options.suppressAnimations);\n            this.hasSetData = this.hasSetData || (dataViews && dataViews.length > 0);\n        }\n\n        public static parseLabelSettings(objects: DataViewObjects): VisualDataLabelsSettings {\n            var labelSettings: VisualDataLabelsSettings = dataLabelUtils.getDefaultColumnLabelSettings(true);\n            var labelsObj: DataLabelObject = <DataLabelObject>objects['labels'];\n            var minPrecision = MekkoChart.DefaultSettings.labelSettings.minPrecision,\n                maxPrecision = MekkoChart.DefaultSettings.labelSettings.maxPrecision;\n\n            dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);\n\n            if (labelSettings.precision < minPrecision) {\n                labelSettings.precision = minPrecision;\n            }\n\n            if (labelSettings.precision > maxPrecision) {\n                labelSettings.precision = maxPrecision;\n            }\n\n            return labelSettings;\n        }\n\n        public static parseBorderSettings(objects: DataViewObjects): MekkoBorderSettings {\n            var show: boolean = DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show);\n            var color = DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color);\n            var width: number = DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width);\n            var maxWidth: number = MekkoChart.DefaultSettings.columnBorder.maxWidth;\n\n            if (width > maxWidth) {\n                width = maxWidth;\n            } else if (width < 0) {\n                width = 0;\n            }\n\n            if (!show) {\n                width = 0;\n            }\n\n            return {\n                show: show,\n                color: color,\n                width: width,\n            };\n        }\n\n        private enumerateBorder(enumeration: ObjectEnumerationBuilder): void {\n            var objects: DataViewObjects = {\n                columnBorder: this.borderObjectProperties\n            };\n\n            var show = DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show);\n            var color = DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color);\n            var width = DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width);\n\n            var maxWidth: number = MekkoChart.DefaultSettings.columnBorder.maxWidth;\n\n            if (width > maxWidth) {\n                width = maxWidth;\n            } else if (width < 0) {\n                width = 0;\n            }\n\n            var instance: VisualObjectInstance = {\n                objectName: 'columnBorder',\n                selector: null,\n                properties: {\n                    show: show,\n                    color: color,\n                    width: width,\n                },\n            };\n            enumeration\n                .pushInstance(instance);\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\n            var enumeration = new ObjectEnumerationBuilder();\n            var layersLength = this.layers ? this.layers.length : 0;\n\n            if (options.objectName === 'columnBorder') {\n                this.enumerateBorder(enumeration);\n            }\n            else if (options.objectName === 'legend') {\n                if (!this.shouldShowLegendCard()) {\n                    return;\n                }\n\n                var show = DataViewObject.getValue(this.legendObjectProperties, legendProps.show, this.legend.isVisible());\n                var showTitle = DataViewObject.getValue(this.legendObjectProperties, legendProps.showTitle, true);\n                var titleText = DataViewObject.getValue(this.legendObjectProperties, legendProps.titleText, this.layerLegendData && this.layerLegendData.title ? this.layerLegendData.title : '');\n                var fontSize = DataViewObject.getValue(this.legendObjectProperties, legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt);\n\n                enumeration.pushInstance({\n                    selector: null,\n                    properties: {\n                        show: show,\n                        position: LegendPosition[this.legend.getOrientation()],\n                        showTitle: showTitle,\n                        titleText: titleText,\n                        fontSize: fontSize\n                    },\n                    objectName: options.objectName\n                });\n            }\n            else if (options.objectName === 'categoryAxis' && this.hasCategoryAxis) {\n                this.getCategoryAxisValues(enumeration);\n            }\n            else if (options.objectName === 'valueAxis') {\n                this.getValueAxisValues(enumeration);\n            }\n\n            for (var i: number = 0, len: number = layersLength; i < len; i++) {\n                var layer = this.layers[i];\n                if (layer.enumerateObjectInstances) {\n                    layer.enumerateObjectInstances(enumeration, options);\n                }\n            }\n\n            return enumeration.complete();\n        }\n\n        private shouldShowLegendCard(): boolean {\n            var layers = this.layers;\n            var dataViews = this.dataViews;\n\n            if (layers && dataViews) {\n                var layersLength = layers.length;\n                var layersWithValuesCtr = 0;\n\n                for (var i: number = 0; i < layersLength; i++) {\n                    if (layers[i].hasLegend()) {\n                        return true;\n                    }\n\n                    // if there are at least two layers with values legend card should be shown (even if each of the individual layers don't have legend)\n                    var dataView = dataViews[i];\n                    if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0) {\n                        layersWithValuesCtr++;\n                        if (layersWithValuesCtr > 1) {\n                            return true;\n                        }\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private getCategoryAxisValues(enumeration: ObjectEnumerationBuilder): void {\n            var supportedType: string = axisType.both;\n            var isScalar: boolean = false;\n            var logPossible: boolean = !!this.axes.x.isLogScaleAllowed;\n            var scaleOptions: string[] = [axisScale.log, axisScale.linear];//until options can be update in propPane, show all options\n\n            if (this.layers && this.layers[0].getSupportedCategoryAxisType) {\n                supportedType = this.layers[0].getSupportedCategoryAxisType();\n                if (supportedType === axisType.scalar) {\n                    isScalar = true;\n                }\n                else {\n                    isScalar = CartesianHelper.isScalar(supportedType === axisType.both, this.categoryAxisProperties);\n                }\n            }\n\n            if (!isScalar) {\n                if (this.categoryAxisProperties) {\n                    this.categoryAxisProperties['start'] = null;\n                    this.categoryAxisProperties['end'] = null;\n                }\n            }\n\n            var instance: VisualObjectInstance = {\n                selector: null,\n                properties: {},\n                objectName: 'categoryAxis',\n                validValues: {\n                    axisScale: scaleOptions\n                }\n            };\n\n            instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;\n            if (this.yAxisIsCategorical)//in case of e.g. barChart\n                instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : yAxisPosition.left;\n            if (supportedType === axisType.both) {\n                instance.properties['axisType'] = isScalar ? axisType.scalar : axisType.categorical;\n            }\n            if (isScalar) {\n                instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : axisScale.linear;\n                instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;\n                instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;\n            }\n            instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;\n            instance.properties['showBorder'] = this.categoryAxisProperties && this.categoryAxisProperties['showBorder'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;\n\n            instance.properties['fontSize'] = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n\n            enumeration\n                .pushInstance(instance)\n                .pushInstance({\n                    selector: null,\n                    properties: {\n                        axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : axisStyle.showTitleOnly,\n                        labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null,\n                        fontSize: this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt\n                    },\n                    objectName: 'categoryAxis',\n                    validValues: {\n                        axisStyle: this.categoryAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly],\n                    }\n                });\n        }\n\n        //todo: wrap all these object getters and other related stuff into an interface\n        private getValueAxisValues(enumeration: ObjectEnumerationBuilder): void {\n            var scaleOptions: string[] = [axisScale.log, axisScale.linear];  //until options can be update in propPane, show all options\n            var logPossible: boolean = !!this.axes.y1.isLogScaleAllowed;\n            //var secLogPossible = this.axes.y2 != null && this.axes.y2.isLogScaleAllowed;\n\n            var instance: VisualObjectInstance = {\n                selector: null,\n                properties: {},\n                objectName: 'valueAxis',\n                validValues: {\n                    axisScale: scaleOptions,\n                    secAxisScale: scaleOptions\n                }\n            };\n\n            instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;\n\n            if (!this.yAxisIsCategorical) {\n                instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : yAxisPosition.left;\n            }\n            instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : axisScale.linear;\n            instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;\n            instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;\n            instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : false;\n\n            instance.properties['fontSize'] = this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n\n            enumeration\n                .pushInstance(instance)\n                .pushInstance({\n                    selector: null,\n                    properties: {\n                        axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : axisStyle.showTitleOnly,\n                        labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null,\n                        fontSize: this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt\n                    },\n                    objectName: 'valueAxis',\n                    validValues: {\n                        axisStyle: this.valueAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly]\n                    },\n                });\n\n            if (this.layers.length === 2) {\n                instance.properties['secShow'] = this.valueAxisProperties && this.valueAxisProperties['secShow'] != null ? this.valueAxisProperties['secShow'] : this.y2AxisExists;\n                if (instance.properties['secShow']) {\n                    instance.properties['axisLabel'] = '';//this.layers[0].getVisualType();//I will keep or remove this, depending on the decision made\n                }\n            }\n        }\n\n        public onClearSelection(): void {\n            if (this.hasSetData) {\n                for (var i: number = 0, len: number = this.layers.length; i < len; i++) {\n                    var layer = this.layers[i];\n                    layer.onClearSelection();\n                    layer.render(true /* suppressAnimations */);\n                }\n            }\n        }\n\n        private createAndInitLayers(dataViews: DataView[]): IMekkoColumnChartVisual[] {\n            var objects: DataViewObjects;\n            if (dataViews && dataViews.length > 0) {\n                var dataViewMetadata = dataViews[0].metadata;\n                if (dataViewMetadata)\n                    objects = dataViewMetadata.objects;\n            }\n\n            // Create the layers\n            var layers: IMekkoColumnChartVisual[] = createLayers(this.type, objects, this.interactivityService, this.animator, this.isScrollable);\n\n            // Initialize the layers\n            var cartesianOptions = <CartesianVisualInitOptions>Prototype.inherit(this.visualInitOptions);\n            cartesianOptions.svg = this.axisGraphicsContextScrollable;\n            cartesianOptions.cartesianHost = {\n                updateLegend: data => this.legend.drawLegend(data, this.currentViewport),\n                getSharedColors: () => this.sharedColorPalette,\n                triggerRender: undefined,\n            };\n\n            for (var i: number = 0, len: number = layers.length; i < len; i++) {\n                layers[i].init(cartesianOptions);\n            }\n\n            return layers;\n        }\n\n        private renderLegend(): void {\n            var layers: IMekkoColumnChartVisual[] = this.layers;\n            var legendData: LegendData = { title: \"\", dataPoints: [] };\n\n            for (var i: number = 0, len: number = layers.length; i < len; i++) {\n                this.layerLegendData = layers[i].calculateLegend();\n                if (this.layerLegendData) {\n                    legendData.title = i === 0 ? this.layerLegendData.title || \"\"\n                        : legendData.title;\n                    legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);\n                    if (this.layerLegendData.grouped) {\n                        legendData.grouped = true;\n                    }\n                }\n            }\n\n            var legendProperties: DataViewObject = this.legendObjectProperties;\n            if (legendProperties) {\n                if (!legendProperties['fontSize']) {\n                    legendProperties['fontSize'] = NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                }\n\n                LegendData.update(legendData, legendProperties);\n                var position = <string>legendProperties[legendProps.position];\n\n                if (position) {\n                    this.legend.changeOrientation(LegendPosition[position]);\n                }\n            }\n            else {\n                this.legend.changeOrientation(LegendPosition.Top);\n            }\n\n            if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {\n                legendData.dataPoints = [];\n            }\n\n            this.legend.drawLegend(legendData, this.currentViewport);\n        }\n\n        private hideLegends(): boolean {\n            if (this.cartesianSmallViewPortProperties) {\n                if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private addUnitTypeToAxisLabel(axes: CartesianAxisProperties): void {\n            var unitType = MekkoChart.getUnitType(axes, (axis: CartesianAxisProperties): IAxisProperties => axis.x);\n            if (axes.x.isCategoryAxis) {\n                this.categoryAxisHasUnitType = unitType !== null;\n            }\n            else {\n                this.valueAxisHasUnitType = unitType !== null;\n            }\n\n            if (axes.x.axisLabel && unitType) {\n                if (axes.x.isCategoryAxis) {\n                    axes.x.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType);\n                }\n                else {\n                    axes.x.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType);\n                }\n            }\n\n            unitType = MekkoChart.getUnitType(axes, (axis: CartesianAxisProperties): IAxisProperties => axis.y1);\n\n            if (!axes.y1.isCategoryAxis) {\n                this.valueAxisHasUnitType = unitType !== null;\n            }\n            else {\n                this.categoryAxisHasUnitType = unitType !== null;\n            }\n\n            if (axes.y1.axisLabel && unitType) {\n                if (!axes.y1.isCategoryAxis) {\n                    axes.y1.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType);\n                }\n                else {\n                    axes.y1.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType);\n                }\n            }\n\n            if (axes.y2) {\n                var unitType = MekkoChart.getUnitType(axes, (axis: CartesianAxisProperties): IAxisProperties => axis.y2);\n                this.secValueAxisHasUnitType = unitType !== null;\n                if (axes.y2.axisLabel && unitType) {\n                    if (this.valueAxisProperties && this.valueAxisProperties['secAxisStyle']) {\n                        if (this.valueAxisProperties['secAxisStyle'] === axisStyle.showBoth) {\n                            axes.y2.axisLabel = axes.y2.axisLabel + ' (' + unitType + ')';\n                        }\n                        else if (this.valueAxisProperties['secAxisStyle'] === axisStyle.showUnitOnly) {\n                            axes.y2.axisLabel = unitType;\n                        }\n                    }\n                }\n            }\n        }\n\n        private shouldRenderSecondaryAxis(axisProperties: IAxisProperties): boolean {\n            if (!axisProperties) {\n                return false;\n            }\n            if (!this.valueAxisProperties || this.valueAxisProperties[\"secShow\"] == null || this.valueAxisProperties[\"secShow\"]) {\n                return axisProperties.values && axisProperties.values.length > 0;\n            }\n            return false;\n        }\n\n        private shouldRenderAxis(axisProperties: IAxisProperties, propertyName: string = \"show\"): boolean {\n            if (!axisProperties) {\n                return false;\n            }\n            else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {\n                return axisProperties.values && axisProperties.values.length > 0;\n            }\n            else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {\n                return axisProperties.values && axisProperties.values.length > 0;\n            }\n            return false;\n        }\n\n        private render(suppressAnimations: boolean): void {\n            var legendMargins: IViewport = this.legendMargins = this.legend.getMargins();\n            var viewport: IViewport = {\n                height: this.currentViewport.height - legendMargins.height,\n                width: this.currentViewport.width - legendMargins.width\n            };\n\n            var maxMarginFactor = this.getMaxMarginFactor();\n            var leftRightMarginLimit = this.leftRightMarginLimit = viewport.width * maxMarginFactor;\n            this.bottomMarginLimit = Math.max(MekkoChart.MinBottomMargin, Math.ceil(viewport.height * maxMarginFactor));\n\n            var xAxisTextProperties = MekkoChart.getTextProperties(parseFloat(<any>this.categoryAxisProperties['fontSize']) || undefined);\n            var y1AxisTextProperties = MekkoChart.getTextProperties(parseFloat(<any>this.valueAxisProperties['fontSize']) || undefined);\n\n            var margin = this.margin;\n            // reset defaults\n            margin.top = parseFloat(y1AxisTextProperties.fontSize) / 2;\n            margin.bottom = MekkoChart.MinBottomMargin;\n            margin.right = 0;\n\n            var axes: CartesianAxisProperties = this.axes = calculateAxes(\n                this.layers,\n                viewport,\n                margin,\n                this.categoryAxisProperties,\n                this.valueAxisProperties,\n                this.isXScrollBarVisible || this.isYScrollBarVisible,\n                null);\n\n            this.yAxisIsCategorical = axes.y1.isCategoryAxis;\n            this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;\n\n            var renderXAxis = this.shouldRenderAxis(axes.x);\n            var renderY1Axis = this.shouldRenderAxis(axes.y1);\n            var renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2);\n\n            var width: number = viewport.width - (margin.left + margin.right);\n            var isScalar: boolean = false;\n            var mainAxisScale;\n            var preferredViewport: IViewport;\n            this.isXScrollBarVisible = false;\n            this.isYScrollBarVisible = false;\n\n            var yAxisOrientation = this.yAxisOrientation;\n            var showY1OnRight = yAxisOrientation === yAxisPosition.right;\n\n            if (this.layers) {\n                if (this.layers[0].getVisualCategoryAxisIsScalar) {\n                    isScalar = this.layers[0].getVisualCategoryAxisIsScalar();\n                }\n\n                if (!isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea) {\n                    var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness;\n                    var categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;\n                    preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);\n                    if (this.scrollX && preferredViewport && preferredViewport.width > viewport.width) {\n                        this.isXScrollBarVisible = true;\n                        viewport.height -= MekkoChart.ScrollBarWidth;\n                    }\n\n                    if (this.scrollY && preferredViewport && preferredViewport.height > viewport.height) {\n                        this.isYScrollBarVisible = true;\n                        viewport.width -= MekkoChart.ScrollBarWidth;\n                        width = viewport.width - (margin.left + margin.right);\n                    }\n                }\n            }\n\n            // Only create the g tag where there is a scrollbar\n            if (this.isXScrollBarVisible || this.isYScrollBarVisible) {\n                if (!this.brushGraphicsContext) {\n                    this.brushGraphicsContext = this.svg.append(\"g\")\n                        .classed('x brush', true);\n                }\n            }\n            else {\n                // clear any existing brush if no scrollbar is shown\n                this.svg.selectAll('.brush').remove();\n                this.brushGraphicsContext = undefined;\n            }\n\n            // Recalculate axes now that scrollbar visible variables have been set\n            axes = calculateAxes(\n                this.layers,\n                viewport,\n                margin,\n                this.categoryAxisProperties,\n                this.valueAxisProperties,\n                this.isXScrollBarVisible || this.isYScrollBarVisible,\n                null);\n\n            // we need to make two passes because the margin changes affect the chosen tick values, which then affect the margins again.\n            // after the second pass the margins are correct.\n            var doneWithMargins: boolean = false,\n                maxIterations: number = 2,\n                numIterations: number = 0;\n            var tickLabelMargins = undefined;\n            var chartHasAxisLabels = undefined;\n            var axisLabels: ChartAxesLabels = undefined;\n            while (!doneWithMargins && numIterations < maxIterations) {\n                numIterations++;\n                tickLabelMargins = getTickLabelMargins(\n                    { width: width, height: viewport.height },\n                    leftRightMarginLimit,\n                    TextMeasurementService.measureSvgTextWidth,\n                    TextMeasurementService.estimateSvgTextHeight,\n                    axes,\n                    this.bottomMarginLimit,\n                    xAxisTextProperties,\n                    y1AxisTextProperties,\n                    null,\n                    false,\n                    this.isXScrollBarVisible || this.isYScrollBarVisible,\n                    showY1OnRight,\n                    renderXAxis,\n                    renderY1Axis,\n                    renderY2Axis);\n\n                // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side\n                var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft,\n                    maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight,\n                    xMax = renderXAxis ? (tickLabelMargins.xMax/1.8) : 0;\n\n                maxMainYaxisSide += MekkoChart.LeftPadding;\n                maxSecondYaxisSide += MekkoChart.RightPadding;\n                xMax += MekkoChart.BottomPadding;\n\n                if (this.hideAxisLabels(legendMargins)) {\n                    axes.x.axisLabel = null;\n                    axes.y1.axisLabel = null;\n                    if (axes.y2) {\n                        axes.y2.axisLabel = null;\n                    }\n                }\n\n                this.addUnitTypeToAxisLabel(axes);\n\n                axisLabels = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };\n                chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);\n\n                if (axisLabels.x != null) {\n                    xMax += MekkoChart.XAxisLabelPadding;\n                }\n                if (axisLabels.y != null) {\n                    maxMainYaxisSide += MekkoChart.YAxisLabelPadding;\n                }\n                if (axisLabels.y2 != null) {\n                    maxSecondYaxisSide += MekkoChart.YAxisLabelPadding;\n                }\n\n                margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;\n                margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;\n                margin.bottom = xMax;\n                this.margin = margin;\n\n                width = viewport.width - (margin.left + margin.right);\n\n                // re-calculate the axes with the new margins\n                var previousTickCountY1 = axes.y1.values.length;\n                var previousTickCountY2 = axes.y2 && axes.y2.values.length;\n                axes = calculateAxes(\n                    this.layers,\n                    viewport,\n                    margin,\n                    this.categoryAxisProperties,\n                    this.valueAxisProperties,\n                    this.isXScrollBarVisible || this.isYScrollBarVisible,\n                    axes);\n\n                // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again\n                // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.\n                if (axes.y1.values.length === previousTickCountY1 && (!axes.y2 || axes.y2.values.length === previousTickCountY2))\n                    doneWithMargins = true;\n            }\n\n            this.renderChart(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations);\n        }\n\n        private hideAxisLabels(legendMargins: IViewport): boolean {\n            if (this.cartesianSmallViewPortProperties) {\n                if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && ((this.currentViewport.height + legendMargins.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) && !this.visualInitOptions.interactivity.isInteractiveLegend) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private static getUnitType(axis: CartesianAxisProperties, axisPropertiesLookup: (axis: CartesianAxisProperties) => IAxisProperties) {\n            if (axisPropertiesLookup(axis).formatter &&\n                axisPropertiesLookup(axis).formatter.displayUnit &&\n                axisPropertiesLookup(axis).formatter.displayUnit.value > 1) {\n                    return axisPropertiesLookup(axis).formatter.displayUnit.title;\n                }\n            return null;\n        }\n\n        private getMaxMarginFactor(): number {\n            return this.visualInitOptions.style.maxMarginFactor || MekkoChart.MaxMarginFactor;\n        }\n\n        private static getChartViewport(viewport: IViewport, margin: IMargin): IViewport {\n            return {\n                width: viewport.width - margin.left - margin.right,\n                height: viewport.height - margin.top - margin.bottom,\n            };\n        }\n\n        private static wordBreak(\n            text: D3.Selection,\n            axisProperties: IAxisProperties,\n            columnsWidth: number[],\n            maxHeight: number,\n            borderWidth: number): void {\n\n            //var allowedLength = axisProperties.xLabelMaxWidth;\n            text.each(function(data: any, index: number) {\n                var width: number, allowedLength: number;\n                var node = d3.select(this);\n                if (columnsWidth.length >= index) {\n                    width = columnsWidth[index];\n                    allowedLength = axisProperties.scale(width);\n                } else {\n                    allowedLength = axisProperties.xLabelMaxWidth;\n                }\n                // Reset style of text node\n                node\n                    .style('text-anchor', 'middle')\n                    .attr({\n                        'dx': '0em',\n                        'dy': '1em',\n                        'transform': 'rotate(0)'\n                    });\n\n                TextMeasurementService.wordBreak(this, allowedLength, axisProperties.willLabelsWordBreak ? maxHeight : 0);\n            });\n        }\n\n        private renderChart(\n            mainAxisScale: any,\n            axes: CartesianAxisProperties,\n            width: number,\n            tickLabelMargins: any,\n            chartHasAxisLabels: boolean,\n            axisLabels: ChartAxesLabels,\n            viewport: IViewport,\n            suppressAnimations: boolean,\n            scrollScale?: any,\n            extent?: number[]) {\n\n            var bottomMarginLimit: number = this.bottomMarginLimit;\n            var leftRightMarginLimit: number = this.leftRightMarginLimit;\n            var layers: IMekkoColumnChartVisual[] = this.layers;\n            var duration: number = AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);\n            var chartViewport: IViewport = MekkoChart.getChartViewport(viewport, this.margin);\n\n            debug.assertValue(layers, 'layers');\n\n            var xLabelColor: Fill;\n            var yLabelColor: Fill;\n            var y2LabelColor: Fill;\n\n            var xFontSize: any;\n            var yFontSize: any;\n            //hide show x-axis here\n            if (this.shouldRenderAxis(axes.x)) {\n                if (axes.x.isCategoryAxis) {\n                    xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;\n                    xFontSize =   this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                } else {\n                    xLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;\n                    xFontSize = this.valueAxisProperties && this.valueAxisProperties['fontSize'] ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                }\n                axes.x.axis.orient(\"bottom\");\n                if (!axes.x.willLabelsFit) {\n                    axes.x.axis.tickPadding(MekkoChart.TickPaddingRotatedX);\n                }\n\n                var xAxisGraphicsElement: D3.Selection = this.xAxisGraphicsContext;\n                if (duration) {\n                    xAxisGraphicsElement\n                        .transition()\n                        .duration(duration)\n                        .call(axes.x.axis);\n                }\n                else {\n                    xAxisGraphicsElement\n                        .call(axes.x.axis);\n                }\n\n                xAxisGraphicsElement\n                    .call(MekkoChart.darkenZeroLine)\n                    .call(MekkoChart.setAxisLabelColor, xLabelColor)\n                    .call(MekkoChart.setAxisLabelFontSize, xFontSize);\n\n                var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');\n\n                var columnWidth: number[] = [];\n                var borderWidth: number = 0;\n                if (this.layers && this.layers.length) {\n                    columnWidth = this.layers[0].getColumnsWidth();\n                    borderWidth = this.layers[0].getBorderWidth();\n                }\n\n                xAxisGraphicsElement\n                    .call(MekkoChart.moveBorder, axes.x.scale, borderWidth, xFontSize / 2 - 8);\n\n                xAxisTextNodes\n                    .call(MekkoChart.wordBreak, axes.x, columnWidth, bottomMarginLimit, borderWidth);\n            }\n            else {\n                this.xAxisGraphicsContext.selectAll('*').remove();\n            }\n\n            if (this.shouldRenderAxis(axes.y1)) {\n                if (axes.y1.isCategoryAxis) {\n                    yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;\n                    yFontSize =   this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                } else {\n                    yLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;\n                    yFontSize =   this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\n                }\n                var yAxisOrientation = this.yAxisOrientation;\n                var showY1OnRight = yAxisOrientation === yAxisPosition.right;\n                axes.y1.axis\n                    .tickSize(-width)\n                    .tickPadding(MekkoChart.TickPaddingY)\n                    .orient(yAxisOrientation.toLowerCase());\n\n                var y1AxisGraphicsElement: D3.Selection = this.y1AxisGraphicsContext;\n                if (duration) {\n                    y1AxisGraphicsElement\n                        .transition()\n                        .duration(duration)\n                        .call(axes.y1.axis);\n                }\n                else {\n                    y1AxisGraphicsElement\n                        .call(axes.y1.axis);\n                }\n\n                y1AxisGraphicsElement\n                    .call(MekkoChart.darkenZeroLine)\n                    .call(MekkoChart.setAxisLabelColor, yLabelColor)\n                    .call(MekkoChart.setAxisLabelFontSize, yFontSize);\n\n                if (tickLabelMargins.yLeft >= leftRightMarginLimit) {\n                    y1AxisGraphicsElement.selectAll('text')\n                        .call(AxisHelper.LabelLayoutStrategy.clip,\n                        // Can't use padding space to render text, so subtract that from available space for ellipses calculations\n                        leftRightMarginLimit - MekkoChart.LeftPadding,\n                        TextMeasurementService.svgEllipsis);\n                }\n\n                if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties['secShow'] == null || this.valueAxisProperties['secShow'])) {\n                    y2LabelColor = this.valueAxisProperties && this.valueAxisProperties['secLabelColor'] ? this.valueAxisProperties['secLabelColor'] : null;\n\n                    axes.y2.axis\n                        .tickPadding(MekkoChart.TickPaddingY)\n                        .orient(showY1OnRight ? yAxisPosition.left.toLowerCase() : yAxisPosition.right.toLowerCase());\n\n                    if (duration) {\n                        this.y2AxisGraphicsContext\n                            .transition()\n                            .duration(duration)\n                            .call(axes.y2.axis);\n                    }\n                    else {\n                        this.y2AxisGraphicsContext\n                            .call(axes.y2.axis);\n                    }\n\n                    this.y2AxisGraphicsContext\n                        .call(MekkoChart.darkenZeroLine)\n                        .call(MekkoChart.setAxisLabelColor, y2LabelColor);\n\n                    if (tickLabelMargins.yRight >= leftRightMarginLimit) {\n                        this.y2AxisGraphicsContext.selectAll('text')\n                            .call(AxisHelper.LabelLayoutStrategy.clip,\n                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations\n                            leftRightMarginLimit - MekkoChart.RightPadding,\n                            TextMeasurementService.svgEllipsis);\n                    }\n                }\n                else {\n                    this.y2AxisGraphicsContext.selectAll('*').remove();\n                }\n            }\n            else {\n                this.y1AxisGraphicsContext.selectAll('*').remove();\n                this.y2AxisGraphicsContext.selectAll('*').remove();\n            }\n\n            // Axis labels\n            if (chartHasAxisLabels) {\n                var hideXAxisTitle: boolean = !this.shouldRenderAxis(axes.x, \"showAxisTitle\");\n                var hideYAxisTitle: boolean = !this.shouldRenderAxis(axes.y1, \"showAxisTitle\");\n                var hideY2AxisTitle: boolean = this.valueAxisProperties && this.valueAxisProperties[\"secShowAxisTitle\"] != null && this.valueAxisProperties[\"secShowAxisTitle\"] === false;\n\n                var renderAxisOptions: MekkoAxisRenderingOptions = {\n                    axisLabels: axisLabels,\n                    legendMargin: this.legendMargins.height,\n                    viewport: viewport,\n                    hideXAxisTitle: hideXAxisTitle,\n                    hideYAxisTitle: hideYAxisTitle,\n                    hideY2AxisTitle: hideY2AxisTitle,\n                    xLabelColor: xLabelColor,\n                    yLabelColor: yLabelColor,\n                    y2LabelColor: y2LabelColor,\n                    margin: undefined,\n                };\n\n                this.renderAxesLabels(renderAxisOptions);\n            }\n            else {\n                this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\n                this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\n            }\n\n            this.translateAxes(viewport);\n\n            var dataPoints: SelectableDataPoint[] = [];\n            var layerBehaviorOptions: any[] = [];\n            var labelDataPointsGroup: MekkoLabelDataPointsGroup[] = [];\n\n            //Render chart columns\n            if (this.behavior) {\n                for (var i: number = 0, len: number = layers.length; i < len; i++) {\n                    var result: MekkoVisualRenderResult = layers[i].render(suppressAnimations);\n                    if (result) {\n                        dataPoints = dataPoints.concat(result.dataPoints);\n                        layerBehaviorOptions.push(result.behaviorOptions);\n\n                        if (result.labelDataPointGroups) {\n                            var resultLabelDataPointsGroups = result.labelDataPointGroups;\n                            for (var j: number = 0, jlen = resultLabelDataPointsGroups.length; j < jlen; j++) {\n                                var resultLabelDataPointsGroup = resultLabelDataPointsGroups[j];\n                                labelDataPointsGroup.push({\n                                    labelDataPoints: resultLabelDataPointsGroup.labelDataPoints,\n                                    maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels,\n                                });\n                            }\n                        }\n                        else {\n                            var resultsLabelDataPoints: MekkoLabelDataPoint[] = result.labelDataPoints;\n                            var reducedDataPoints: MekkoLabelDataPoint[] = resultsLabelDataPoints;\n                            labelDataPointsGroup.push({\n                                labelDataPoints: reducedDataPoints,\n                                maxNumberOfLabels: reducedDataPoints.length,\n                            });\n                        }\n                    }\n                }\n\n                var labelLayoutOptions: DataLabelLayoutOptions = {\n                    maximumOffset: NewDataLabelUtils.maxLabelOffset,\n                    startingOffset: NewDataLabelUtils.startingLabelOffset\n                };\n\n                var labelLayout: LabelLayout = new LabelLayout(labelLayoutOptions);\n                var dataLabels: Label[] = labelLayout.layout(labelDataPointsGroup, chartViewport);\n\n                if (layers.length > 1) {\n                    NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContextScrollable, dataLabels, \"#FFFFFF\", 0.7);\n                }\n                if (this.animator && !suppressAnimations) {\n                    NewDataLabelUtils.animateDefaultLabels(this.labelGraphicsContextScrollable, dataLabels, this.animator.getDuration());\n                }\n                else {\n                    NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContextScrollable, dataLabels);\n                }\n                this.labelGraphicsContextScrollable.selectAll(\"text.label\").style(\"pointer-events\", \"none\");\n                if (this.interactivityService) {\n                    var behaviorOptions: MekkoBehaviorOptions = {\n                        layerOptions: layerBehaviorOptions,\n                        clearCatcher: this.clearCatcher,\n                    };\n                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);\n                }\n            }\n\n        }\n\n        /**\n         * Within the context of the given selection (g), find the offset of\n         * the zero tick using the d3 attached datum of g.tick elements.\n         * 'Classed' is undefined for transition selections\n         */\n        private static darkenZeroLine(g: D3.Selection): void {\n            var zeroTick = g.selectAll('g.tick').filter((data) => data === 0).node();\n            if (zeroTick) {\n                d3.select(zeroTick).select('line').classed('zero-line', true);\n            }\n        }\n\n        private static setAxisLabelColor(g: D3.Selection, fill: Fill): void {\n            g.selectAll('g.tick text').style('fill', fill ? fill.solid.color : null);\n        }\n\n        private static setAxisLabelFontSize(g: D3.Selection, fontSize: number): void {\n            var value = jsCommon.PixelConverter.toString(fontSize);\n            g.selectAll('g.tick text').attr('font-size', value);\n        }\n\n        private static moveBorder(g: D3.Selection, scale: D3.Scale.LinearScale, borderWidth: number, yOffset: number = 0): void {\n            g.selectAll('g.tick')\n                .attr(\"transform\", function(value: number, index: number) {\n                     return SVGUtil.translate(scale(value) + (borderWidth * index), yOffset);\n            });\n        }\n    }\n\n    function getTickLabelMargins(\n        viewport: IViewport,\n        yMarginLimit: number,\n        textWidthMeasurer: ITextAsSVGMeasurer,\n        textHeightMeasurer: ITextAsSVGMeasurer,\n        axes: CartesianAxisProperties,\n        bottomMarginLimit: number,\n        xAxisTextProperties: TextProperties,\n        y1AxisTextProperties: TextProperties,\n        y2AxisTextProperties: TextProperties,\n        enableOverflowCheck: boolean,\n        scrollbarVisible?: boolean,\n        showOnRight?: boolean,\n        renderXAxis?: boolean,\n        renderY1Axis?: boolean,\n        renderY2Axis?: boolean): TickLabelMargins {\n\n        var XLabelMaxAllowedOverflow = 35;\n\n        debug.assertValue(axes, 'axes');\n        var xAxisProperties: IAxisProperties = axes.x;\n        var y1AxisProperties: IAxisProperties = axes.y1;\n        var y2AxisProperties: IAxisProperties = axes.y2;\n\n        debug.assertValue(viewport, 'viewport');\n        debug.assertValue(textWidthMeasurer, 'textWidthMeasurer');\n        debug.assertValue(textHeightMeasurer, 'textHeightMeasurer');\n        debug.assertValue(xAxisProperties, 'xAxis');\n        debug.assertValue(y1AxisProperties, 'yAxis');\n\n        var xLabels = xAxisProperties.values;\n        var y1Labels = y1AxisProperties.values;\n\n        var leftOverflow = 0;\n        var rightOverflow = 0;\n        var maxWidthY1 = 0;\n        var maxWidthY2 = 0;\n        var xMax = 0; // bottom margin\n        var ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0;\n        var scaleIsOrdinal = AxisHelper.isOrdinalScale(xAxisProperties.scale);\n\n        var xLabelOuterPadding = 0;\n        if (xAxisProperties.outerPadding !== undefined) {\n            xLabelOuterPadding = xAxisProperties.outerPadding;\n        }\n        else if (xAxisProperties.xLabelMaxWidth !== undefined) {\n            xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);\n        }\n\n        if (AxisHelper.getRecommendedNumberOfTicksForXAxis(viewport.width) !== 0\n            ||AxisHelper. getRecommendedNumberOfTicksForYAxis(viewport.height) !== 0) {\n            var rotation;\n            if (scrollbarVisible)\n                rotation = AxisHelper.LabelLayoutStrategy.DefaultRotationWithScrollbar;\n            else\n                rotation = AxisHelper.LabelLayoutStrategy.DefaultRotation;\n\n            if (renderY1Axis) {\n                for (var i = 0, len = y1Labels.length; i < len; i++) {\n                    y1AxisTextProperties.text = y1Labels[i];\n                    maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(y1AxisTextProperties));\n                }\n            }\n\n            if (y2AxisProperties && renderY2Axis) {\n                var y2Labels = y2AxisProperties.values;\n                for (var i = 0, len = y2Labels.length; i < len; i++) {\n                    y2AxisTextProperties.text = y2Labels[i];\n                    maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(y2AxisTextProperties));\n                }\n            }\n\n            var textHeight = textHeightMeasurer(xAxisTextProperties);\n            var maxNumLines = Math.floor(bottomMarginLimit / textHeight);\n            var xScale = xAxisProperties.scale;\n            var xDomain = xScale.domain();\n            if (renderXAxis && xLabels.length > 0) {\n                for (var i = 0, len = xLabels.length; i < len; i++) {\n                    // find the max height of the x-labels, perhaps rotated or wrapped\n                    var height: number;\n                    xAxisTextProperties.text = xLabels[i];\n                    var width = textWidthMeasurer(xAxisTextProperties);\n                    if (xAxisProperties.willLabelsWordBreak) {\n                        // Split label and count rows\n                        var wordBreaks = jsCommon.WordBreaker.splitByWidth(xAxisTextProperties.text, xAxisTextProperties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);\n                        height = wordBreaks.length * textHeight;\n                        // word wrapping will truncate at xLabelMaxWidth\n                        width = xAxisProperties.xLabelMaxWidth;\n                    }\n                    else if (!xAxisProperties.willLabelsFit && scaleIsOrdinal) {\n                        height = width * rotation.sine;\n                        width = width * rotation.cosine;\n                    }\n                    else {\n                        height = textHeight;\n                    }\n\n                    // calculate left and right overflow due to wide X labels\n                    // (Note: no right overflow when rotated)\n                    if (i === 0) {\n                        if (scaleIsOrdinal) {\n                            if (!xAxisProperties.willLabelsFit /*rotated text*/)\n                                leftOverflow = width - ordinalLabelOffset - xLabelOuterPadding;\n                            else\n                                leftOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;\n                            leftOverflow = Math.max(leftOverflow, 0);\n                        }\n                        else if (xDomain.length > 1) {\n                            // Scalar - do some math\n                            var xPos = xScale(xDomain[0]);\n                            // xPos already incorporates xLabelOuterPadding, don't subtract it twice\n                            leftOverflow = (width / 2) - xPos;\n                            leftOverflow = Math.max(leftOverflow, 0);\n                        }\n                    } else if (i === len - 1) {\n                        if (scaleIsOrdinal) {\n                            // if we are rotating text (!willLabelsFit) there won't be any right overflow\n                            if (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) {\n                                // assume this label is placed near the edge\n                                rightOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;\n                                rightOverflow = Math.max(rightOverflow, 0);\n                            }\n                        }\n                        else if (xDomain.length > 1) {\n                            // Scalar - do some math\n                            var xPos = xScale(xDomain[1]);\n                            // xPos already incorporates xLabelOuterPadding, don't subtract it twice\n                            rightOverflow = (width / 2) - (viewport.width - xPos);\n                            rightOverflow = Math.max(rightOverflow, 0);\n                        }\n                    }\n\n                    xMax = Math.max(xMax, height);\n                }\n                // trim any actual overflow to the limit\n                leftOverflow = enableOverflowCheck ? Math.min(leftOverflow, XLabelMaxAllowedOverflow) : 0;\n                rightOverflow = enableOverflowCheck ? Math.min(rightOverflow, XLabelMaxAllowedOverflow) : 0;\n            }\n        }\n\n        var rightMargin = 0,\n            leftMargin = 0,\n            bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);\n\n        if (showOnRight) {\n            leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit);\n            rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit);\n        }\n        else {\n            leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit);\n            rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit);\n        }\n\n        return {\n            xMax: Math.ceil(bottomMargin),\n            yLeft: Math.ceil(leftMargin),\n            yRight: Math.ceil(rightMargin),\n        };\n    }\n\n    function getLayerData(dataViews: DataView[], currentIdx: number, totalLayers: number): DataView[] {\n        if (totalLayers > 1) {\n            if (dataViews && dataViews.length > currentIdx)\n                return [dataViews[currentIdx]];\n            return [];\n        }\n\n        return dataViews;\n    }\n\n    /**\n     * Returns a boolean, that indicates if y axis title should be displayed.\n     * @return True if y axis title should be displayed,\n     * otherwise false.\n     */\n    function shouldShowYAxisLabel(layerNumber: number, valueAxisProperties: DataViewObject, yAxisWillMerge: boolean): boolean {\n        return ((layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties['showAxisTitle']) ||\n            (layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties['secShowAxisTitle']));\n    }\n\n    /**\n     * Computes the Cartesian Chart axes from the set of layers.\n     */\n    function calculateAxes(\n        layers: IMekkoColumnChartVisual[],\n        viewport: IViewport,\n        margin: IMargin,\n        categoryAxisProperties: DataViewObject,\n        valueAxisProperties: DataViewObject,\n        scrollbarVisible: boolean,\n        existingAxisProperties: CartesianAxisProperties): CartesianAxisProperties {\n        debug.assertValue(layers, 'layers');\n\n        var visualOptions: MekkoCalculateScaleAndDomainOptions = {\n            viewport: viewport,\n            margin: margin,\n            forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],\n            forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,\n            showCategoryAxisLabel: false,\n            showValueAxisLabel: false,\n            categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? <string>categoryAxisProperties['axisScale'] : axisScale.linear,\n            valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? <string>valueAxisProperties['axisScale'] : axisScale.linear,\n            trimOrdinalDataOnOverflow: false\n        };\n\n        var yAxisWillMerge = false;\n\n        if (valueAxisProperties) {\n            visualOptions.forcedYDomain = AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);\n        }\n\n        var result: CartesianAxisProperties;\n        for (var layerNumber: number = 0, len: number = layers.length; layerNumber < len; layerNumber++) {\n            var currentlayer = layers[layerNumber];\n            visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']);//here\n            //visualOptions.showBorder = (!!categoryAxisProperties && !!categoryAxisProperties['showBorder']);//here\n            visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);\n\n            var axes = currentlayer.calculateAxesProperties(visualOptions);\n\n            if (layerNumber === 0) {\n                result = {\n                    x: axes[0],\n                    y1: axes[1]\n                };\n            }\n\n            result.x.willLabelsFit = false;\n            result.x.willLabelsWordBreak = false;\n        }\n\n        return result;\n    }\n\n    export function createLayers(\n        type: MekkoChartType,\n        objects: DataViewObjects,\n        interactivityService: IInteractivityService,\n        animator?: any,\n        isScrollable: boolean = true): IMekkoColumnChartVisual[] {\n\n        var layers: IMekkoColumnChartVisual[] = [];\n\n        var cartesianOptions: CartesianVisualConstructorOptions = {\n            isScrollable: isScrollable,\n            animator: animator,\n            interactivityService: interactivityService\n        };\n\n        layers.push(createMekkoChartLayer(ColumnChartType.hundredPercentStackedColumn, cartesianOptions));\n\n        return layers;\n    }\n\n    function createMekkoChartLayer(type: ColumnChartType, defaultOptions: CartesianVisualConstructorOptions): MekkoColumnChart {\n        var options: ColumnChartConstructorOptions = {\n            animator: <IColumnChartAnimator>defaultOptions.animator,\n            interactivityService: defaultOptions.interactivityService,\n            isScrollable: defaultOptions.isScrollable,\n            chartType: type\n        };\n        return new MekkoColumnChart(options);\n    }\n\n    import EnumExtensions = jsCommon.EnumExtensions;\n    import ArrayExtensions = jsCommon.ArrayExtensions;\n\n    var flagBar: number = 1 << 1;\n    //var flagColumn: number = 1 << 2;\n    var flagStacked: number = 1 << 4;\n\n    var RoleNames = {\n        category: 'Category',\n        series: 'Series',\n        y: 'Y',\n        width: 'Width'\n    };\n\n    /**\n     * Renders a stacked and clustered column chart.\n     */\n    export interface IMekkoColumnChartVisual /*extends ICartesianVisual*/ {\n        getColumnsWidth(): number[];\n        getBorderWidth(): number;\n\n\t\tinit(options: CartesianVisualInitOptions): void;\n        setData(dataViews: DataView[], resized?: boolean): void;\n        calculateAxesProperties(options: CalculateScaleAndDomainOptions): IAxisProperties[];\n        overrideXScale(xProperties: IAxisProperties): void;\n        render(suppressAnimations: boolean): MekkoVisualRenderResult;\n        calculateLegend(): LegendData;\n        hasLegend(): boolean;\n        onClearSelection(): void;\n        enumerateObjectInstances?(enumeration: ObjectEnumerationBuilder, options: EnumerateVisualObjectInstancesOptions): void;\n        getVisualCategoryAxisIsScalar?(): boolean;\n        getSupportedCategoryAxisType?(): string;\n        getPreferredPlotArea?(isScalar: boolean, categoryCount: number, categoryThickness: number): IViewport;\n        setFilteredData?(startIndex: number, endIndex: number): CartesianData;\n    }\n\n    export interface IMekkoColumnChartStrategy /*extends IColumnChartStrategy*/ {\n\t\tdrawColumns(useAnimation: boolean): MekkoColumnChartDrawInfo;\n\n\t\tsetData(data: ColumnChartData): void;\n        setupVisualProps(columnChartProps: ColumnChartContext): void;\n        setXScale(is100Pct: boolean, forcedTickCount?: number, forcedXDomain?: any[], axisScaleType?: string, axisDisplayUnits?: number, axisPrecision?: number): IAxisProperties;\n        setYScale(is100Pct: boolean, forcedTickCount?: number, forcedYDomain?: any[], axisScaleType?: string, axisDisplayUnits?: number, axisPrecision?: number): IAxisProperties;\n\n        selectColumn(selectedColumnIndex: number, lastSelectedColumnIndex: number): void;\n        getClosestColumnIndex(x: number, y: number): number;\n    }\n\n    export class MekkoColumnChart implements IMekkoColumnChartVisual {\n        private static ColumnChartClassName = 'columnChart';\n\n        public static SeriesClasses: ClassAndSelector = createClassAndSelector(\"series\");\n        public static BorderClass: ClassAndSelector = createClassAndSelector(\"mekkoborder\");\n\n        private svg: D3.Selection;\n        private unclippedGraphicsContext: D3.Selection;\n        private mainGraphicsContext: D3.Selection;\n        private labelGraphicsContext: D3.Selection;\n        private xAxisProperties: IAxisProperties;\n        private yAxisProperties: IAxisProperties;\n        private currentViewport: IViewport;\n        private data: MekkoColumnChartData;\n        private style: IVisualStyle;\n        private colors: IDataColorPalette;\n        private chartType: ColumnChartType;\n        private columnChart: IMekkoColumnChartStrategy;\n        private hostService: IVisualHostServices;\n        private cartesianVisualHost: ICartesianVisualHost;\n        private interactivity: InteractivityOptions;\n        private margin: IMargin;\n        private options: CartesianVisualInitOptions;\n        private lastInteractiveSelectedColumnIndex: number;\n        private supportsOverflow: boolean;\n        private interactivityService: IInteractivityService;\n        private dataViewCat: DataViewCategorical;\n        private categoryAxisType: string;\n        private animator: IColumnChartAnimator;\n        private isScrollable: boolean;\n        private element: JQuery;\n\n        constructor(options: ColumnChartConstructorOptions) {\n            debug.assertValue(options, 'options');\n\n            var chartType: ColumnChartType = options.chartType;\n            debug.assertValue(chartType, 'chartType');\n            this.chartType = chartType;\n            this.categoryAxisType = null;\n            this.animator = options.animator;\n            this.isScrollable = options.isScrollable;\n            this.interactivityService = options.interactivityService;\n        }\n\n        public init(options: CartesianVisualInitOptions) {\n            this.svg = options.svg;\n            this.unclippedGraphicsContext = this.svg.append('g').classed('columnChartUnclippedGraphicsContext', true);\n            this.mainGraphicsContext = this.unclippedGraphicsContext.append('svg').classed('columnChartMainGraphicsContext', true);\n            this.labelGraphicsContext = this.svg.append('g').classed(NewDataLabelUtils.labelGraphicsContextClass.class, true);\n\n            this.style = options.style;\n            this.currentViewport = options.viewport;\n            this.hostService = options.host;\n            this.interactivity = options.interactivity;\n            this.colors = this.style.colorPalette.dataColors;\n            this.cartesianVisualHost = options.cartesianHost;\n            this.options = options;\n            this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);\n            var element = this.element = options.element;\n            element.addClass(MekkoColumnChart.ColumnChartClassName);\n\n            this.columnChart = new MekkoColumnChartStrategy();\n        }\n\n        private getCategoryLayout(numCategoryValues: number, options: MekkoCalculateScaleAndDomainOptions): CategoryLayout {\n            var availableWidth: number = this.currentViewport.width - (this.margin.left + this.margin.right);\n            var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;\n            var categoryDataType: ValueType = AxisHelper.getCategoryValueType(metaDataColumn);\n            var isScalar = this.data ? this.data.scalarCategoryAxis : false;\n            var domain = AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);\n\n            return CartesianChart.getLayout(\n                this.data,\n                {\n                    availableWidth: availableWidth,\n                    categoryCount: numCategoryValues,\n                    domain: domain,\n                    isScalar: isScalar,\n                    isScrollable: this.isScrollable,\n                    trimOrdinalDataOnOverflow: false\n                });\n        }\n\n        public static getBorderWidth(border: MekkoBorderSettings) {\n            if (!border ||\n                !border.show ||\n                !border.width) {\n                return 0;\n            }\n\n            var width: number = border.width;\n\n            if (width < 0) {\n                return 0;\n            }\n            if (width > border.maxWidth) {\n                return border.maxWidth;\n            }\n\n            return width;\n        }\n\n        public static getBorderColor(border: MekkoBorderSettings) {\n            if (!border) {\n                return MekkoChart.DefaultSettings.columnBorder.color;\n            }\n            return border.color;\n        }\n\n        public static converter(dataView: DataViewCategorical,\n                                colors: IDataColorPalette,\n                                is100PercentStacked: boolean = false,\n                                isScalar: boolean = false,\n                                supportsOverflow: boolean = false,\n                                dataViewMetadata: DataViewMetadata = null,\n                                chartType?: ColumnChartType): MekkoColumnChartData {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(colors, 'colors');\n\n            var xAxisCardProperties = CartesianHelper.getCategoryAxisProperties(dataViewMetadata);\n            var valueAxisProperties = CartesianHelper.getValueAxisProperties(dataViewMetadata);\n            isScalar = CartesianHelper.isScalar(isScalar, xAxisCardProperties);\n            dataView = ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);\n\n            var converterStrategy = new ColumnChartConverterHelper(dataView);\n\n            var categoryInfo = converterHelper.getPivotedCategories(dataView, columnChartProps.general.formatString);\n            var categories = categoryInfo.categories,\n                categoryFormatter: IValueFormatter = categoryInfo.categoryFormatter,\n                categoryIdentities: DataViewScopeIdentity[] = categoryInfo.categoryIdentities,\n                categoryMetadata: DataViewMetadataColumn = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;\n            //labelFormatString: string = dataView.values && dataView.values[0] ? valueFormatter.getFormatString(dataView.values[0].source, columnChartProps.general.formatString) : undefined;\n\n            var borderSettings: MekkoBorderSettings = MekkoChart.DefaultSettings.columnBorder;\n            var labelSettings: VisualDataLabelsSettings = dataLabelUtils.getDefaultColumnLabelSettings(true);\n\n            var defaultDataPointColor = undefined;\n            var showAllDataPoints = undefined;\n            if (dataViewMetadata && dataViewMetadata.objects) {\n                var objects = dataViewMetadata.objects;\n\n                defaultDataPointColor = DataViewObjects.getFillColor(objects, columnChartProps.dataPoint.defaultColor);\n                showAllDataPoints = DataViewObjects.getValue<boolean>(objects, columnChartProps.dataPoint.showAllDataPoints);\n\n                labelSettings = MekkoChart.parseLabelSettings(objects);\n                borderSettings = MekkoChart.parseBorderSettings(objects);\n            }\n\n            // Allocate colors\n            var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor);\n            var legend: MekkoLegendDataPoint[] = legendAndSeriesInfo.legend.dataPoints;\n            var seriesSources: DataViewMetadataColumn[] = legendAndSeriesInfo.seriesSources;\n\n            // Determine data points\n            var result: MekkoDataPoints = MekkoColumnChart.createDataPoints(\n                dataView,\n                categories,\n                categoryIdentities,\n                legend,\n                legendAndSeriesInfo.seriesObjects,\n                converterStrategy,\n                labelSettings,\n                is100PercentStacked,\n                isScalar,\n                supportsOverflow,\n                converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category),\n                categoryInfo.categoryObjects,\n                defaultDataPointColor,\n                chartType,\n                categoryMetadata);\n            var columnSeries: ColumnChartSeries[] = result.series;\n\n            var valuesMetadata: DataViewMetadataColumn[] = [];\n            for (var j = 0, jlen = legend.length; j < jlen; j++) {\n                valuesMetadata.push(seriesSources[j]);\n            }\n\n            var labels = converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);\n\n            return {\n                categories: categories,\n                categoriesWidth: result.categoriesWidth,\n                categoryFormatter: categoryFormatter,\n                series: columnSeries,\n                valuesMetadata: valuesMetadata,\n                legendData: legendAndSeriesInfo.legend,\n                hasHighlights: result.hasHighlights,\n                categoryMetadata: categoryMetadata,\n                scalarCategoryAxis: isScalar,\n                borderSettings: borderSettings,\n                labelSettings: labelSettings,\n                axesLabels: { x: labels.xAxisLabel, y: labels.yAxisLabel },\n                hasDynamicSeries: result.hasDynamicSeries,\n                defaultDataPointColor: defaultDataPointColor,\n                showAllDataPoints: showAllDataPoints,\n                isMultiMeasure: false,\n            };\n        }\n\n        private static getStackedMultiplier(\n            rawValues: number[][],\n            rowIdx: number,\n            seriesCount: number,\n            categoryCount: number): ValueMultiplers {\n\n            var pos: number = 0,\n                neg: number = 0;\n\n            for (var i = 0; i < seriesCount; i++) {\n                var value: number = rawValues[i][rowIdx];\n                value = AxisHelper.normalizeNonFiniteNumber(value);\n\n                if (value > 0) {\n                    pos += value;\n                } else if (value < 0) {\n                    neg -= value;\n                }\n            }\n\n            var absTotal: number = pos + neg;\n            return {\n                pos: pos ? (pos / absTotal) / pos : 1,\n                neg: neg ? (neg / absTotal) / neg : 1,\n            };\n        }\n\n        private static createDataPoints(\n            dataViewCat: DataViewCategorical,\n            categories: any[],\n            categoryIdentities: DataViewScopeIdentity[],\n            legend: MekkoLegendDataPoint[],\n            seriesObjectsList: DataViewObjects[][],\n            converterStrategy: ColumnChartConverterHelper,\n\n            defaultLabelSettings: VisualDataLabelsSettings,\n            is100PercentStacked: boolean = false,\n            isScalar: boolean = false,\n            supportsOverflow: boolean = false,\n            isCategoryAlsoSeries?: boolean,\n            categoryObjectsList?: DataViewObjects[],\n            defaultDataPointColor?: string,\n            chartType?: ColumnChartType,\n            categoryMetadata?: DataViewMetadataColumn): MekkoDataPoints {\n\n            var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;\n\n            var categoryCount = categories.length;\n            var seriesCount = legend.length;\n            var columnSeries: ColumnChartSeries[] = [];\n\n            if (seriesCount < 1 || categoryCount < 1 || categories[0] === null) {\n                return { series: columnSeries,\n                         hasHighlights: false,\n                         hasDynamicSeries: false,\n                         categoriesWidth: [],\n                        };\n\t\t\t}\n\n            var dvCategories = dataViewCat.categories;\n            categoryMetadata = (dvCategories && dvCategories.length > 0)\n                ? dvCategories[0].source\n                : null;\n            var categoryType = AxisHelper.getCategoryValueType(categoryMetadata);\n            var isDateTime = AxisHelper.isDateTime(categoryType);\n            var baseValuesPos = [], baseValuesNeg = [];\n\n            var rawValues: number[][] = [];\n            var rawHighlightValues: number[][] = [];\n\n            var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);\n            var widthColumns: number[] = [];\n            var widthIndex = -1;\n\n\t\t\tvar seriesIndex: number = 0;\n            var highlightsOverflow = false; // Overflow means the highlight larger than value or the signs being different\n            var hasHighlights = converterStrategy.hasHighlightValues(0);\n            for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {\n                if (dataViewCat.values[seriesIndex].source.roles &&\n                    dataViewCat.values[seriesIndex].source.roles[RoleNames.width] &&\n                    !dataViewCat.values[seriesIndex].source.roles[RoleNames.y]) {\n\n                    widthIndex = seriesIndex;\n                    var widthValues: number[] = dataViewCat.values[seriesIndex].values;\n                    for (var i: number = 0, valuesLen = widthValues.length; i < valuesLen; i++) {\n                        widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);\n                    }\n                    continue;\n                }\n                var seriesValues = [];\n                var seriesHighlightValues = [];\n                for (var categoryIndex: number = 0; categoryIndex < categoryCount; categoryIndex++) {\n                    var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);\n                    seriesValues[categoryIndex] = value;\n                    if (hasHighlights) {\n                        var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);\n                        seriesHighlightValues[categoryIndex] = highlightValue;\n                        // There are two cases where we don't use overflow logic; if all are false, use overflow logic appropriate for the chart.\n                        if (!((value >= 0 && highlightValue >= 0 && value >= highlightValue) || // Both positive; value greater than highlight\n                            (value <= 0 && highlightValue <= 0 && value <= highlightValue))) { // Both negative; value less than highlight\n                            highlightsOverflow = true;\n                        }\n                    }\n                }\n                rawValues.push(seriesValues);\n                if (hasHighlights) {\n                    rawHighlightValues.push(seriesHighlightValues);\n                }\n            }\n\n\t\t\t//console.log(dataViewCat);\n\n            if (highlightsOverflow && !supportsOverflow) {\n                highlightsOverflow = false;\n                hasHighlights = false;\n                rawValues = rawHighlightValues;\n            }\n\n            if (widthColumns.length < 1) {\n                for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {\n                    if (dataViewCat.values[seriesIndex].source.roles &&\n                        dataViewCat.values[seriesIndex].source.roles[RoleNames.width]) {\n\n                        widthIndex = seriesIndex;\n                        var widthValues: number[] = dataViewCat.values[seriesIndex].values;\n                        for (var i: number = 0, valuesLen: number = widthValues.length; i < valuesLen; i++) {\n                            widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);\n                        }\n                        continue;\n                    }\n                }\n            }\n\n            if (widthColumns.length < 1) {\n                for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {\n                    widthColumns.push(1);\n                }\n            }\n\n            var totalSum: number = d3.sum(widthColumns);\n            var linearScale = d3.scale.linear()\n                .domain([0, totalSum])\n                .range([0, 1]);\n\n            var columnStartX: number[] = [0];\n            var columnWidth: number[] = [];\n            for (seriesIndex = 0; seriesIndex < (categoryCount - 1); seriesIndex++) {\n                var stepWidth: number = columnStartX[columnStartX.length - 1] + (widthColumns[seriesIndex] || 0);\n                columnStartX.push(stepWidth);\n            }\n\n            for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {\n                columnStartX[seriesIndex] = linearScale(columnStartX[seriesIndex]);\n                columnWidth[seriesIndex] = linearScale(widthColumns[seriesIndex]);\n            }\n\n            var dataPointObjects: DataViewObjects[] = categoryObjectsList,\n                formatStringProp = columnChartProps.general.formatString;\n            for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\n                var seriesDataPoints: ColumnChartDataPoint[] = [],\n                    legendItem = legend[seriesIndex],\n                    seriesLabelSettings: VisualDataLabelsSettings;\n\n                if (!hasDynamicSeries) {\n                    var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;\n                    var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? <DataLabelObject>labelsSeriesGroup.source.objects['labels'] : null;\n                    if (labelObjects) {\n                        seriesLabelSettings = Prototype.inherit(defaultLabelSettings);\n                        dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);\n                    }\n                }\n\n                var series: ColumnChartSeries = {\n                    displayName: legendItem.label,\n                    key: 'series' + seriesIndex,\n                    index: seriesIndex,\n                    data: seriesDataPoints,\n                    identity: legendItem.identity,\n                    color: legendItem.color,\n                    labelSettings: seriesLabelSettings,\n                };\n\n                if (seriesCount > 1) {\n                    dataPointObjects = seriesObjectsList[seriesIndex];\n                }\n                var metadata = dataViewCat.values[seriesIndex].source;\n\n                for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {\n                    if (seriesIndex === 0) {\n                        baseValuesPos.push(0);\n                        baseValuesNeg.push(0);\n                    }\n\n                    var value = AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);\n                    if (value == null) {\n                        // Optimization: Ignore null dataPoints from the fabricated category/series combination in the self cross-join.\n                        // However, we must retain the first series because it is used to compute things like axis scales, and value lookups.\n                        if (seriesIndex > 0) {\n                            continue;\n                        }\n                    }\n\n                    var originalValue: number = value;\n                    var categoryValue = categories[categoryIndex];\n                    if (isDateTime && categoryValue) {\n                        categoryValue = categoryValue.getTime();\n                    }\n                    if (isScalar && (categoryValue == null || isNaN(categoryValue))) {\n                        continue;\n                    }\n\n                    var multipliers: ValueMultiplers;\n                    if (is100PercentStacked) {\n                        //multipliers = StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy);\n                        multipliers = MekkoColumnChart.getStackedMultiplier(rawValues, categoryIndex, seriesCount, categoryCount);\n                    }\n                    var unadjustedValue = value,\n                        isNegative = value < 0;\n\n                    if (multipliers) {\n                        if (isNegative) {\n                            value *= multipliers.neg;\n                        } else {\n                            value *= multipliers.pos;\n                        }\n                    }\n\n                    var valueAbsolute = Math.abs(value);\n                    var position: number;\n                    if (isNegative) {\n                        position = baseValuesNeg[categoryIndex];\n\n                        if (!isNaN(valueAbsolute)) {\n                            baseValuesNeg[categoryIndex] -= valueAbsolute;\n                        }\n                    }\n                    else {\n                        if (!isNaN(valueAbsolute)) {\n                            baseValuesPos[categoryIndex] += valueAbsolute;\n                        }\n\n                        position = baseValuesPos[categoryIndex];\n                    }\n\n                    var columnGroup: DataViewValueColumnGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex] : null;\n                    var category: DataViewCategoryColumn = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null;\n                    var identity = SelectionIdBuilder.builder()\n                        .withCategory(category, categoryIndex)\n                        .withSeries(dataViewCat.values, columnGroup)\n                        .withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex))\n                        .createSelectionId();\n\n                    var rawCategoryValue = categories[categoryIndex];\n                    var color = MekkoColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);\n\n                    var seriesData: TooltipSeriesDataItem[] = [];\n\n                    if (columnGroup) {\n\n                        var seriesValueColumn: DataViewValueColumn = {\n                            values: [],\n                            source: dataViewCat.values.source,\n                        };\n                        seriesData.push({\n                            value: columnGroup.name,\n                            metadata: seriesValueColumn,\n                        });\n\n                        for (var columnIndex: number = 0; columnIndex < columnGroup.values.length; columnIndex++) {\n                            var columnValues: DataViewValueColumn = columnGroup.values[columnIndex];\n                            seriesData.push({\n                                value: columnValues.values[categoryIndex],\n                                metadata: columnValues,\n                            });\n                        }\n                    }\n\n                    var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, null/*dataViewCat*/, rawCategoryValue, originalValue, [category], seriesData, null/*seriesIndex*/, categoryIndex);\n\n                    var dataPointLabelSettings = (series && series.labelSettings) ? series.labelSettings : defaultLabelSettings;\n                    var labelColor = dataPointLabelSettings.labelColor;\n                    var lastValue = undefined;\n                    //Stacked column/bar label color is white by default (except last series)\n                    if ((EnumExtensions.hasFlag(chartType, flagStacked))) {\n                        lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);\n                        labelColor = (lastValue || (seriesIndex === seriesCount - 1 && !isNegative)) ? labelColor : dataLabelUtils.defaultInsideLabelColor;\n                    }\n\n                    value = columnWidth[categoryIndex];\n                    var originalPosition: number = columnStartX[categoryIndex];\n\n                    var dataPoint: ColumnChartDataPoint = {\n                        categoryValue: categoryValue,\n                        value: value,\n                        position: position,\n                        valueAbsolute: valueAbsolute,\n                        valueOriginal: unadjustedValue,\n                        seriesIndex: seriesIndex,\n                        labelSettings: dataPointLabelSettings,\n                        categoryIndex: categoryIndex,\n                        color: color,\n                        selected: false,\n                        originalValue: value,\n                        originalPosition: originalPosition,//position,\n                        originalValueAbsolute: valueAbsolute,\n                        identity: identity,\n                        key: identity.getKey(),\n                        tooltipInfo: tooltipInfo,\n                        labelFill: labelColor,\n                        labelFormatString: metadata.format,\n                        lastSeries: lastValue,\n                        chartType: chartType,\n                    };\n\n                    seriesDataPoints.push(dataPoint);\n\n                    if (hasHighlights) {\n                        var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex];\n                        var unadjustedValueHighlight = valueHighlight;\n\n                        var highlightedTooltip: boolean = true;\n                        if (valueHighlight === null) {\n                            valueHighlight = 0;\n                            highlightedTooltip = false;\n                        }\n\n                        if (is100PercentStacked) {\n                            valueHighlight *= multipliers.pos;\n                        }\n                        var absoluteValueHighlight = Math.abs(valueHighlight);\n                        var highlightPosition = position;\n\n                        if (valueHighlight > 0) {\n                            highlightPosition -= valueAbsolute - absoluteValueHighlight;\n                        }\n                        else if (valueHighlight === 0 && value > 0) {\n                            highlightPosition -= valueAbsolute;\n                        }\n\n                        var highlightIdentity = SelectionId.createWithHighlight(identity);\n                        var rawCategoryValue = categories[categoryIndex];\n                        //var highlightedValue: number = highlightedTooltip ? valueHighlight : undefined;\n                        //var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue, originalValue, null, null, seriesIndex, categoryIndex, highlightedValue);\n\n                        if (highlightedTooltip) {\n                            // Override non highlighted data point\n                            dataPoint.tooltipInfo = tooltipInfo;\n                        }\n\n                        var highlightDataPoint: ColumnChartDataPoint = {\n                            categoryValue: categoryValue,\n                            value: value,\n                            position: highlightPosition,\n                            valueAbsolute: absoluteValueHighlight,\n                            valueOriginal: unadjustedValueHighlight,\n                            seriesIndex: seriesIndex,\n                            labelSettings: dataPointLabelSettings,\n                            categoryIndex: categoryIndex,\n                            color: color,\n                            selected: false,\n                            highlight: true,\n                            originalValue: value,\n                            originalPosition: originalPosition,\n                            originalValueAbsolute: valueAbsolute,\n                            drawThinner: highlightsOverflow,\n                            identity: highlightIdentity,\n                            key: highlightIdentity.getKey(),\n                            tooltipInfo: tooltipInfo,\n                            labelFormatString: metadata.format,\n                            labelFill: labelColor,\n                            lastSeries: lastValue,\n                            chartType: chartType,\n                        };\n\n                        seriesDataPoints.push(highlightDataPoint);\n                    }\n                }\n\n                columnSeries.push(series);\n            }\n\n            return {\n                series: columnSeries,\n                categoriesWidth: columnWidth,\n                hasHighlights: hasHighlights,\n                hasDynamicSeries: hasDynamicSeries,\n            };\n        }\n\n        private static getDataPointColor(\n            legendItem: MekkoLegendDataPoint,\n            categoryIndex: number,\n            dataPointObjects?: DataViewObjects[]): string {\n            debug.assertValue(legendItem, 'legendItem');\n            debug.assertValue(categoryIndex, 'categoryIndex');\n            debug.assertAnyValue(dataPointObjects, 'dataPointObjects');\n\n            if (dataPointObjects) {\n                var colorOverride = DataViewObjects.getFillColor(dataPointObjects[categoryIndex], columnChartProps.dataPoint.fill);\n                if (colorOverride) {\n                    return colorOverride;\n                }\n            }\n\n            return legendItem.color;\n        }\n\n        private static getStackedLabelColor(isNegative: boolean, seriesIndex: number, seriesCount: number, categoryIndex: number, rawValues: number[][]): boolean {\n            var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);\n            //run for the next series and check if current series is last\n            for (var i: number = seriesIndex + 1; i < seriesCount; i++) {\n                var nextValues: number = AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);\n                if ((nextValues !== null) && (((!isNegative || (isNegative && seriesIndex === 0)) && nextValues > 0) || (isNegative && seriesIndex !== 0))) {\n                    lastValue = false;\n                    break;\n                }\n            }\n            return lastValue;\n        }\n\n        public static sliceSeries(series: ColumnChartSeries[], endIndex: number, startIndex: number = 0): ColumnChartSeries[] {\n            var newSeries: ColumnChartSeries[] = [];\n            if (series && series.length > 0) {\n                for (var i = 0, len = series.length; i < len; i++) {\n                    var iNewSeries = newSeries[i] = Prototype.inherit(series[i]);\n                    iNewSeries.data = series[i].data.filter(d => d.categoryIndex >= startIndex && d.categoryIndex < endIndex);\n                }\n            }\n            return newSeries;\n        }\n        public static getInteractiveColumnChartDomElement(element: JQuery): HTMLElement {\n            return element.children(\"svg\").get(0);\n        }\n\n        public getColumnsWidth(): number[] {\n            var data: MekkoColumnChartData = this.data;\n            if (!data ||\n                !data.series ||\n                !data.series[0] ||\n                !data.series[0].data) {\n                return [];\n            }\n\n            return data.categoriesWidth;\n        }\n\n        public getBorderWidth(): number {\n            return MekkoColumnChart.getBorderWidth(this.data.borderSettings);\n        }\n\n        public setData(dataViews: DataView[]): void {\n            debug.assertValue(dataViews, \"dataViews\");\n            var is100PctStacked: boolean = true;\n            this.data = {\n                categories: [],\n                categoriesWidth: [],\n                categoryFormatter: null,\n                series: [],\n                valuesMetadata: [],\n                legendData: null,\n                hasHighlights: false,\n                categoryMetadata: null,\n                scalarCategoryAxis: false,\n                borderSettings: null,\n                labelSettings: dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),\n                axesLabels: { x: null, y: null },\n                hasDynamicSeries: false,\n                defaultDataPointColor: null,\n                isMultiMeasure: false,\n            };\n\n            if (dataViews.length > 0) {\n                var dataView = dataViews[0];\n\n                if (dataView && dataView.categorical) {\n                    var dataViewCat = this.dataViewCat = dataView.categorical;\n                    /*\n                    var dvCategories = dataViewCat.categories;\n                    var categoryMetadata = (dvCategories && dvCategories.length > 0)\n                        ? dvCategories[0].source\n                        : null;\n                    var categoryType = AxisHelper.getCategoryValueType(categoryMetadata);\n                    */\n                    this.data = MekkoColumnChart.converter(\n                        dataViewCat,\n                        this.cartesianVisualHost.getSharedColors(),\n                        true,//s100PctStacked,\n                        false,//CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, columnChartProps.categoryAxis.axisType, categoryType),\n                        this.supportsOverflow,\n                        dataView.metadata,\n                        this.chartType);\n\n                    var series: ColumnChartSeries[] = this.data.series;\n                    for (var i: number = 0, ilen: number = series.length; i < ilen; i++) {\n                        var currentSeries: ColumnChartSeries = series[i];\n                        if (this.interactivityService) {\n                            this.interactivityService.applySelectionStateToData(currentSeries.data);\n                        }\n                    }\n                }\n            }\n        }\n\n        public calculateLegend(): LegendData {\n            // if we're in interactive mode, return the interactive legend\n            if (this.interactivity && this.interactivity.isInteractiveLegend) {\n                return this.createInteractiveMekkoLegendDataPoints(0);\n            }\n            var legendData = this.data ? this.data.legendData : null;\n            var MekkoLegendDataPoints = legendData ? legendData.dataPoints : [];\n\n            if (ArrayExtensions.isUndefinedOrEmpty(MekkoLegendDataPoints))\n                return null;\n\n            return legendData;\n        }\n\n        public hasLegend(): boolean {\n            return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));\n        }\n\n        public enumerateObjectInstances(enumeration: ObjectEnumerationBuilder, options: EnumerateVisualObjectInstancesOptions): void {\n            switch (options.objectName) {\n                case 'dataPoint':\n                    if (!GradientUtils.hasGradientRole(this.dataViewCat))\n                        this.enumerateDataPoints(enumeration);\n                    break;\n                case 'labels':\n                    this.enumerateDataLabels(enumeration);\n                    break;\n            }\n        }\n\n        private enumerateDataLabels(enumeration: ObjectEnumerationBuilder): void {\n            var data = this.data,\n                labelSettings = this.data.labelSettings,\n                seriesCount = data.series.length;\n\n            //Draw default settings\n            dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, false));\n\n            if (seriesCount === 0) {\n                return;\n            }\n\n            //Draw series settings\n            if (!data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata)) {\n                for (var i = 0; i < seriesCount; i++) {\n                    var series: ColumnChartSeries = data.series[i],\n                        labelSettings: VisualDataLabelsSettings = (series.labelSettings) ? series.labelSettings : this.data.labelSettings;\n\n                    //enumeration.pushContainer({ displayName: series.displayName });\n                    dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, true, series));\n                    //enumeration.popContainer();\n                }\n            }\n        }\n\n        private getLabelSettingsOptions(enumeration: ObjectEnumerationBuilder, labelSettings: VisualDataLabelsSettings, isSeries: boolean, series?: ColumnChartSeries): VisualDataLabelsSettingsOptions {\n            var is100PctStacked: boolean = true;\n            return {\n                enumeration: enumeration,\n                dataLabelsSettings: labelSettings,\n                show: !isSeries,\n                displayUnits: is100PctStacked,\n                precision: true,\n                selector: series && series.identity ? series.identity.getSelector() : null\n            };\n        }\n\n        private enumerateDataPoints(enumeration: ObjectEnumerationBuilder): void {\n            var data: MekkoColumnChartData = this.data;\n            if (!data || !data.series) {\n                return;\n            }\n\n            var seriesCount = data.series.length;\n\n            if (seriesCount === 0) {\n                return;\n            }\n\n            if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) {\n                for (var i: number = 0; i < seriesCount; i++) {\n                    var series: ColumnChartSeries = data.series[i];\n                    enumeration.pushInstance({\n                        objectName: 'dataPoint',\n                        displayName: series.displayName,\n                        selector: ColorHelper.normalizeSelector(series.identity.getSelector()),\n                        properties: {\n                            fill: { solid: { color: series.color } }\n                        },\n                    });\n                }\n            }\n            else {\n                // For single-category, single-measure column charts, the user can color the individual bars.\n                var singleSeriesData: ColumnChartDataPoint[] = data.series[0].data;\n                var categoryFormatter: IValueFormatter = data.categoryFormatter;\n\n                // Add default color and show all slices\n                enumeration.pushInstance({\n                    objectName: 'dataPoint',\n                    selector: null,\n                    properties: {\n                        defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }\n                    }\n                }).pushInstance({\n                    objectName: 'dataPoint',\n                    selector: null,\n                    properties: {\n                        showAllDataPoints: !!data.showAllDataPoints\n                    }\n                });\n\n                for (var i: number = 0; i < singleSeriesData.length; i++) {\n                    var singleSeriesDataPoints = singleSeriesData[i],\n                        categoryValue: any = data.categories[i];\n                    enumeration.pushInstance({\n                        objectName: 'dataPoint',\n                        displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,\n                        selector: ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), /*isSingleSeries*/true),\n                        properties: {\n                            fill: { solid: { color: singleSeriesDataPoints.color } }\n                        },\n                    });\n                }\n            }\n        }\n\n        public calculateAxesProperties(options: MekkoCalculateScaleAndDomainOptions): IAxisProperties[] {\n            var data: MekkoColumnChartData = this.data;\n            this.currentViewport = options.viewport;\n            var margin: IMargin = this.margin = options.margin;\n\n            var origCatgSize = (data && data.categories) ? data.categories.length : 0;\n            var chartLayout: CategoryLayout = data ? this.getCategoryLayout(origCatgSize, options) : {\n                categoryCount: 0,\n                categoryThickness: CartesianChart.MinOrdinalRectThickness,\n                outerPaddingRatio: CartesianChart.OuterPaddingRatio,\n                isScalar: false\n            };\n            this.categoryAxisType = chartLayout.isScalar ? axisType.scalar : null;\n            this.columnChart.setData(data);\n\n            var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);\n\n            /* preferredPlotArea would be same as currentViewport width when there is no scrollbar.\n             In that case we want to calculate the available plot area for the shapes by subtracting the margin from available viewport */\n            if (preferredPlotArea.width === this.currentViewport.width) {\n                preferredPlotArea.width -= (margin.left + margin.right);\n            }\n            preferredPlotArea.height -= (margin.top + margin.bottom);\n\n            var is100Pct: boolean = true;\n\n            // When the category axis is scrollable the height of the category axis and value axis will be different\n            // The height of the value axis would be same as viewportHeight\n            var chartContext: MekkoColumnChartContext = {\n                height: preferredPlotArea.height,\n                width: preferredPlotArea.width,\n                duration: 0,\n                hostService: this.hostService,\n                unclippedGraphicsContext: this.unclippedGraphicsContext,\n                mainGraphicsContext: this.mainGraphicsContext,\n                labelGraphicsContext: this.labelGraphicsContext,\n                margin: this.margin,\n                layout: chartLayout,\n                animator: this.animator,\n                interactivityService: this.interactivityService,\n                viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),\n                viewportWidth: this.currentViewport.width - (margin.left + margin.right),\n                is100Pct: is100Pct,\n                isComboChart: true,\n            };\n            this.ApplyInteractivity(chartContext);\n            this.columnChart.setupVisualProps(chartContext);\n\n            var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);\n\n            if (isBarChart) {\n                var temp = options.forcedXDomain;\n                options.forcedXDomain = options.forcedYDomain;\n                options.forcedYDomain = temp;\n            }\n\n            this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType);\n            this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType);\n\n            if (options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis) {\n                this.xAxisProperties.axisLabel = data.axesLabels.x;\n            }\n            else {\n                this.xAxisProperties.axisLabel = null;\n            }\n            if (options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis) {\n                this.yAxisProperties.axisLabel = data.axesLabels.y;\n            }\n            else {\n                this.yAxisProperties.axisLabel = null;\n            }\n\n            return [this.xAxisProperties, this.yAxisProperties];\n        }\n\n        public getPreferredPlotArea(isScalar: boolean, categoryCount: number, categoryThickness: number): IViewport {\n            var viewport: IViewport = {\n                height: this.currentViewport.height,\n                width: this.currentViewport.width\n            };\n\n            if (this.isScrollable && !isScalar) {\n                var preferredWidth = CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);\n                if (EnumExtensions.hasFlag(this.chartType, flagBar)) {\n                    viewport.height = Math.max(preferredWidth, viewport.height);\n                }\n                else\n                    viewport.width = Math.max(preferredWidth, viewport.width);\n            }\n            return viewport;\n        }\n\n        private ApplyInteractivity(chartContext: MekkoColumnChartContext): void {\n            var interactivity = this.interactivity;\n            if (interactivity) {\n                if (interactivity.dragDataPoint) {\n                    chartContext.onDragStart = (datum: ColumnChartDataPoint) => {\n                        if (!datum.identity)\n                            return;\n\n                        this.hostService.onDragStart({\n                            event: <any>d3.event,\n                            data: {\n                                data: datum.identity.getSelector()\n                            }\n                        });\n                    };\n                }\n\n                if (interactivity.isInteractiveLegend) {\n                    var dragMove = () => {\n                        var mousePoint = d3.mouse(this.mainGraphicsContext[0][0]); // get the x and y for the column area itself\n                        var x: number = mousePoint[0];\n                        var y: number = mousePoint[1];\n                        var index: number = this.columnChart.getClosestColumnIndex(x, y);\n                        this.selectColumn(index);\n                    };\n\n                    var ColumnChartSvg: EventTarget = ColumnChart.getInteractiveColumnChartDomElement(this.element);\n\n                    //set click interaction on the visual\n                    this.svg.on('click', dragMove);\n                    //set click interaction on the background\n                    d3.select(ColumnChartSvg).on('click', dragMove);\n                    var drag = d3.behavior.drag()\n                        .origin(Object)\n                        .on(\"drag\", dragMove);\n                    //set drag interaction on the visual\n                    this.svg.call(drag);\n                    //set drag interaction on the background\n                    d3.select(ColumnChartSvg).call(drag);\n                }\n            }\n        }\n\n        private selectColumn(indexOfColumnSelected: number, force: boolean = false): void {\n            if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected) return; // same column, nothing to do here\n\n            var legendData: LegendData = this.createInteractiveMekkoLegendDataPoints(indexOfColumnSelected);\n            var MekkoLegendDataPoints: MekkoLegendDataPoint[] = legendData.dataPoints;\n            this.cartesianVisualHost.updateLegend(legendData);\n            if (MekkoLegendDataPoints.length > 0) {\n                this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);\n            }\n            this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;\n        }\n\n        private createInteractiveMekkoLegendDataPoints(columnIndex: number): LegendData {\n            var data: MekkoColumnChartData = this.data;\n            if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) {\n                return { dataPoints: [] };\n            }\n\n            var formatStringProp = columnChartProps.general.formatString;\n            var MekkoLegendDataPoints: MekkoLegendDataPoint[] = [];\n            var category = data.categories && data.categories[columnIndex];\n            var allSeries: ColumnChartSeries[] = data.series;\n            var dataPoints = data.legendData && data.legendData.dataPoints;\n            var converterStrategy = new ColumnChartConverterHelper(this.dataViewCat);\n\n            for (var i: number = 0, len = allSeries.length; i < len; i++) {\n                var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex);\n                var valueMetadata = data.valuesMetadata[i];\n                var formattedLabel = converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);\n                var dataPointColor: string;\n                if (allSeries.length === 1) {\n                    var series = allSeries[0];\n                    dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;\n                } else {\n                    dataPointColor = dataPoints.length > i && dataPoints[i].color;\n                }\n\n                MekkoLegendDataPoints.push({\n                    color: dataPointColor,\n                    icon: LegendIcon.Box,\n                    label: formattedLabel,\n                    category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,\n                    measure: valueFormatter.format(measure, valueFormatter.getFormatString(valueMetadata, formatStringProp)),\n                    identity: SelectionId.createNull(),\n                    selected: false,\n                });\n            }\n\n            return { dataPoints: MekkoLegendDataPoints };\n        }\n\n        public overrideXScale(xProperties: IAxisProperties): void {\n            this.xAxisProperties = xProperties;\n        }\n\n        public render(suppressAnimations: boolean): MekkoVisualRenderResult {\n            var MekkoColumnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations /* useAnimations */);\n            var data: MekkoColumnChartData = this.data;\n\n            var margin = this.margin;\n            var viewport = this.currentViewport;\n            var height = viewport.height - (margin.top + margin.bottom);\n            var width = viewport.width - (margin.left + margin.right);\n\n            this.mainGraphicsContext\n                .attr('height', height)\n                .attr('width', width);\n\n            TooltipManager.addTooltip(MekkoColumnChartDrawInfo.shapesSelection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo);\n            var allDataPoints: ColumnChartDataPoint[] = [];\n            var behaviorOptions: ColumnBehaviorOptions = undefined;\n            if (this.interactivityService) {\n                for (var i: number = 0, ilen = data.series.length; i < ilen; i++) {\n                    allDataPoints = allDataPoints.concat(data.series[i].data);\n                }\n                behaviorOptions = {\n                    datapoints: allDataPoints,\n                    bars: MekkoColumnChartDrawInfo.shapesSelection,\n                    hasHighlights: data.hasHighlights,\n                    eventGroup: this.mainGraphicsContext,\n                    mainGraphicsContext: this.mainGraphicsContext,\n                    viewport: MekkoColumnChartDrawInfo.viewport,\n                    axisOptions: MekkoColumnChartDrawInfo.axisOptions,\n                    showLabel: data.labelSettings.show\n                };\n            }\n\n            if (this.interactivity && this.interactivity.isInteractiveLegend) {\n                if (this.data.series.length > 0) {\n                    this.selectColumn(0, true); // start with the first column\n                }\n            }\n            SVGUtil.flushAllD3TransitionsIfNeeded(this.options);\n            return {\n                dataPoints: allDataPoints,\n                behaviorOptions: behaviorOptions,\n                labelDataPoints: MekkoColumnChartDrawInfo.labelDataPoints,\n                labelsAreNumeric: true\n            };\n        }\n\n        public onClearSelection(): void {\n            if (this.interactivityService) {\n                this.interactivityService.clearSelection();\n            }\n        }\n\n        public getVisualCategoryAxisIsScalar(): boolean {\n            return this.data ? this.data.scalarCategoryAxis : false;\n        }\n\n        public getSupportedCategoryAxisType(): string {\n            var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;\n            var valueType = AxisHelper.getCategoryValueType(metaDataColumn);\n            var isOrdinal = AxisHelper.isOrdinal(valueType);\n            return isOrdinal ? axisType.categorical : axisType.both;\n        }\n\n        public setFilteredData(startIndex: number, endIndex: number): CartesianData {\n            var data = Prototype.inherit(this.data);\n            data.series = ColumnChart.sliceSeries(data.series, endIndex, startIndex);\n            data.categories = data.categories.slice(startIndex, endIndex);\n            this.columnChart.setData(data);\n            return data;\n        }\n    }\n\n    class ColumnChartConverterHelper implements IColumnChartConverterStrategy {\n        private dataView: DataViewCategorical;\n\n        constructor(dataView: DataViewCategorical) {\n            this.dataView = dataView;\n        }\n\n\t\t  private static hasRole(column: DataViewMetadataColumn, name: string): boolean {\n            var roles = column.roles;\n            return roles && roles[name];\n        }\n\n        public getLegend(colors: IDataColorPalette, defaultColor?: string): LegendSeriesInfo {\n            var legend: MekkoLegendDataPoint[] = [];\n            var seriesSources: DataViewMetadataColumn[] = [];\n            var seriesObjects: DataViewObjects[][] = [];\n            var grouped: boolean = false;\n\n            var colorHelper = new ColorHelper(colors, columnChartProps.dataPoint.fill, defaultColor);\n            var legendTitle = undefined;\n            if (this.dataView && this.dataView.values) {\n                var allValues = this.dataView.values;\n                var valueGroups = allValues.grouped();\n\n                var hasDynamicSeries = !!(allValues && allValues.source);\n\n                var formatStringProp = columnChartProps.general.formatString;\n                for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {\n                    var valueGroup = valueGroups[valueGroupsIndex],\n                        valueGroupObjects = valueGroup.objects,\n                        values = valueGroup.values;\n\n                    for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {\n                        var series: DataViewValueColumn = values[valueIndex];\n                        var source: DataViewMetadataColumn = series.source;\n                        // Gradient measures do not create series.\n                        if (ColumnChartConverterHelper.hasRole(source, 'Width') && !ColumnChartConverterHelper.hasRole(source, 'Y')) {\n                            continue;\n                        }\n\n                        seriesSources.push(source);\n                        seriesObjects.push(series.objects);\n\n                        var selectionId = series.identity ?\n                            SelectionId.createWithIdAndMeasure(series.identity, source.queryName) :\n                            SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex));\n\n                        var label = converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);\n\n                        var color = hasDynamicSeries\n                            ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName)\n                            : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);\n\n                        legend.push({\n                            icon: LegendIcon.Box,\n                            color: color,\n                            label: label,\n                            identity: selectionId,\n                            selected: false,\n                        });\n\n                        if (series.identity && source.groupName !== undefined) {\n                            grouped = true;\n                        }\n                    }\n                }\n\n                var dvValues: DataViewValueColumns = this.dataView.values;\n                legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : \"\";\n            }\n\n            var legendData = {\n                title: legendTitle,\n                dataPoints: legend,\n                grouped: grouped,\n            };\n\n            return {\n                legend: legendData,\n                seriesSources: seriesSources,\n                seriesObjects: seriesObjects,\n            };\n        }\n\n        public getValueBySeriesAndCategory(series: number, category: number): number {\n            return this.dataView.values[series].values[category];\n        }\n\n        public getMeasureNameByIndex(index: number): string {\n            return this.dataView.values[index].source.queryName;\n        }\n\n        public hasHighlightValues(series: number): boolean {\n            var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;\n            return column && !!column.highlights;\n        }\n\n        public getHighlightBySeriesAndCategory(series: number, category: number): number {\n            return this.dataView.values[series].highlights[category];\n        }\n    }\n\n    export interface MekkoBehaviorOptions {\n        layerOptions: any[];\n        clearCatcher: D3.Selection;\n    }\n\n    export class MekkoChartBehavior implements IInteractiveBehavior {\n        private behaviors: IInteractiveBehavior[];\n\n        constructor(behaviors: IInteractiveBehavior[]) {\n            this.behaviors = behaviors;\n        }\n\n        public bindEvents(options: MekkoBehaviorOptions, selectionHandler: ISelectionHandler): void {\n            var behaviors = this.behaviors;\n            for (var i: number = 0, ilen: number = behaviors.length; i < ilen; i++) {\n                behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);\n            }\n\n            options.clearCatcher.on('click', () => {\n                selectionHandler.handleClearSelection();\n            });\n        }\n\n        public renderSelection(hasSelection: boolean) {\n            for (var i: number = 0; i < this.behaviors.length; i++) {\n                this.behaviors[i].renderSelection(hasSelection);\n            }\n        }\n    }\n}\n","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import SelectionManager = utility.SelectionManager;\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n    import ValueFormatter = powerbi.visuals.valueFormatter;\n\n    export interface SankeyDiagramConstructorOptions {\n        svg?: D3.Selection;\n        margin?: IMargin;\n        curvatureOfLinks?: number;\n    }\n\n    export interface SankeyDiagramLabel {\n        name: string;\n        formattedName: string;\n        width: number;\n        height: number;\n        colour: string;\n    }\n\n    export interface SankeyDiagramTooltipData {\n        tooltipData: TooltipDataItem[];\n    }\n\n    export interface SankeyDiagramScale {\n        x: number;\n        y: number;\n    }\n\n    export interface SankeyDiagramSettings {\n        scale?: SankeyDiagramScale;\n        fontSize: number;\n        isVisibleLabels?: boolean;\n        colourOfLabels: string;\n    }\n\n    export interface SankeyDiagramNode extends SankeyDiagramTooltipData {\n        label: SankeyDiagramLabel;\n        inputWeight: number;\n        outputWeight: number;\n        links: SankeyDiagramLink[];\n        x?: number;\n        y?: number;\n        width?: number;\n        height?: number;\n        colour: string;\n        selectionIds: SelectionId[];\n    }\n\n    export interface SankeyDiagramLink extends SankeyDiagramTooltipData {\n        source: SankeyDiagramNode;\n        destination: SankeyDiagramNode;\n        weigth: number;\n        height?: number;\n        dySource?: number;\n        dyDestination?: number;\n        colour: string;\n        selectionId: SelectionId;\n    }\n\n    export interface SankeyDiagramDataView {\n        nodes: SankeyDiagramNode[];\n        links: SankeyDiagramLink[];\n        settings: SankeyDiagramSettings;\n    }\n\n    export interface SankeyDiagramRoleNames {\n        rows: string;\n        columns: string;\n        values: string;\n    }\n\n    interface SankeyDiagramDataPoint {\n        source: any;\n        destination: any;\n        weigth: number;\n    }\n\n    interface SankeyDiagramProperty {\n        [propertyName: string]: DataViewObjectPropertyIdentifier;\n    }\n\n    interface SankeyDiagramProperties {\n        [objectName: string]: SankeyDiagramProperty;\n    }\n\n    export class SankeyDiagram implements IVisual {\n        private static ClassName: string = \"sankeyDiagram\";\n\n        private static Nodes: ClassAndSelector = {\n            \"class\": \"nodes\",\n            selector: \".nodes\"\n        };\n\n        private static Node: ClassAndSelector = {\n            \"class\": \"node\",\n            selector: \".node\"\n        };\n\n        private static NodeRect: ClassAndSelector = {\n            \"class\": \"nodeRect\",\n            selector: \".nodeRect\"\n        };\n\n        private static NodeLabel: ClassAndSelector = {\n            \"class\": \"nodeLabel\",\n            selector: \".nodeLabel\"\n        };\n\n        private static Links: ClassAndSelector = {\n            \"class\": \"links\",\n            selector: \".links\"\n        };\n\n        private static Link: ClassAndSelector = {\n            \"class\": \"link\",\n            selector: \".link\"\n        };\n\n        private static DefaultColourOfNode: string = \"rgb(62, 187, 162)\";\n        private static DefaultColourOfLink: string = \"black\";\n\n        private static DefaultSettings: SankeyDiagramSettings = {\n            isVisibleLabels: true,\n            scale: { x: 1, y: 1 },\n            colourOfLabels: \"black\",\n            fontSize: 12\n        };\n\n        private static MinWidthOfLabel: number = 35;\n\n        private static NodePadding: number = 5;\n        private static LabelPadding: number = 4;\n\n        public static RoleNames: SankeyDiagramRoleNames = {\n            rows: \"Source\",\n            columns: \"Destination\",\n            values: \"Weight\"\n        };\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [{\n                name: SankeyDiagram.RoleNames.rows,\n                kind: VisualDataRoleKind.Grouping,\n                displayName: SankeyDiagram.RoleNames.rows\n            }, {\n                name: SankeyDiagram.RoleNames.columns,\n                kind: VisualDataRoleKind.Grouping,\n                displayName: SankeyDiagram.RoleNames.columns\n            }, {\n                name: SankeyDiagram.RoleNames.values,\n                kind: VisualDataRoleKind.Measure,\n                displayName: SankeyDiagram.RoleNames.values\n            }],\n            dataViewMappings: [{\n                conditions: [\n                    { \"Source\": { min: 0, max: 1 }, \"Destination\": { min: 0, max: 1 }, \"Weight\": { min: 0, max: 0 } },\n                    { \"Source\": { min: 0, max: 1 }, \"Destination\": { min: 0, max: 1 }, \"Weight\": { min: 1, max: 1 } }\n                ],\n                categorical: {\n                    categories: { \n                        for: { in: SankeyDiagram.RoleNames.rows },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: {\n                        select: [\n                            { bind: { to: SankeyDiagram.RoleNames.columns } },\n                            { bind: { to: SankeyDiagram.RoleNames.values } }\n                        ]\n                    }\n                }\n            }],\n            objects: {\n                general: {\n                    displayName: data.createDisplayNameGetter(\"Visual_General\"),\n                    properties: {\n                        formatString: { type: { formatting: { formatString: true } } }\n                    }\n                },\n                labels: {\n                    displayName: data.createDisplayNameGetter('Visual_DataPointsLabels'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter(\"Visual_Show\"),\n                            type: { bool: true }\n                        },\n                        fill: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { formatting: { fontSize: true } }\n                        }\n                    }\n                },\n                links: {\n                    displayName: \"Links\",\n                    properties: {\n                        fill: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                }\n            }\n        };\n\n        private static Properties: SankeyDiagramProperties = SankeyDiagram.getProperties(SankeyDiagram.capabilities);\n        public static getProperties(capabilities: VisualCapabilities): any {\n            var result = {};\n            for(var objectKey in capabilities.objects) {\n                result[objectKey] = {};\n                for(var propKey in capabilities.objects[objectKey].properties) {\n                    result[objectKey][propKey] = <DataViewObjectPropertyIdentifier> { \n                        objectName: objectKey,\n                        propertyName: propKey\n                    };\n                }\n            }\n\n            return result;\n        }\n\n        private margin: IMargin = {\n            top: 10,\n            right: 10,\n            bottom: 10,\n            left: 10\n        };\n\n        private nodeWidth: number = 21.5;\n        private curvatureOfLinks: number = 0.5;\n\n        private root: D3.Selection;\n        private svg: D3.Selection;\n        private main: D3.Selection;\n        private nodes: D3.Selection;\n        private links: D3.Selection;\n\n        private colours: IDataColorPalette;\n\n        private viewport: IViewport;\n\n        private get textProperties(): TextProperties{\n            return {\n                fontFamily: this.root.style(\"font-family\"),\n                fontSize: jsCommon.PixelConverter.fromPoint(this.dataView ? this.dataView.settings.fontSize : SankeyDiagram.DefaultSettings.fontSize)\n            };\n        }\n\n        private dataView: SankeyDiagramDataView;\n\n        private selectionManager: SelectionManager;\n\n        constructor(constructorOptions?: SankeyDiagramConstructorOptions) {\n            if (constructorOptions) {\n                this.svg = constructorOptions.svg;\n                this.margin = constructorOptions.margin || this.margin;\n                this.curvatureOfLinks = constructorOptions.curvatureOfLinks || this.curvatureOfLinks;\n            }\n        }\n\n        public init(visualsInitOptions: VisualInitOptions): void {\n            if (this.svg) {\n                this.root = this.svg;\n            } else {\n                this.root = d3.select(visualsInitOptions.element.get(0))\n                    .append(\"svg\");\n            }\n\n            this.selectionManager = new SelectionManager({ hostServices: visualsInitOptions.host });\n\n            var style: IVisualStyle = visualsInitOptions.style;\n\n            this.colours = style && style.colorPalette\n                ? style.colorPalette.dataColors\n                : new DataColorPalette();\n\n            this.root.classed(SankeyDiagram.ClassName, true);\n\n            this.main = this.root.append(\"g\");\n\n            this.links = this.main\n                .append(\"g\")\n                .classed(SankeyDiagram.Links[\"class\"], true);\n\n            this.nodes = this.main\n                .append(\"g\")\n                .classed(SankeyDiagram.Nodes[\"class\"], true);\n        }\n\n        public update(visualUpdateOptions: VisualUpdateOptions): void {\n            if (!visualUpdateOptions ||\n                !visualUpdateOptions.dataViews) {\n                return;\n            }\n\n            var dataView: DataView = visualUpdateOptions.dataViews[0],\n                sankeyDiagramDataView: SankeyDiagramDataView;\n\n            this.updateViewport(visualUpdateOptions.viewport);\n\n            sankeyDiagramDataView = this.converter(dataView);\n\n            this.findNodePosition(sankeyDiagramDataView);\n\n            this.dataView = sankeyDiagramDataView;\n\n            this.render(sankeyDiagramDataView);\n        }\n\n        private updateViewport(viewport: IViewport): void {\n            var height: number,\n                width: number;\n\n            height = this.getPositiveNumber(viewport.height);\n            width = this.getPositiveNumber(viewport.width);\n\n            this.viewport = {\n                height: this.getPositiveNumber(height - this.margin.top - this.margin.bottom),\n                width: this.getPositiveNumber(width - this.margin.left - this.margin.right)\n            };\n\n            this.updateElements(height, width);\n        }\n\n        private getPositiveNumber(value: number): number {\n            return value < 0 || isNaN(value) || value === Infinity || value === -Infinity\n                ? 0\n                : value;\n        }\n\n        private updateElements(height: number, width: number): void {\n            this.root.attr({\n                \"height\": height,\n                \"width\": width\n            });\n\n            this.main.attr(\"transform\", SVGUtil.translate(this.margin.left, this.margin.top));\n        }\n\n        public converter(dataView: DataView): SankeyDiagramDataView {\n            if (!dataView ||\n                !dataView.categorical ||\n                !dataView.categorical.categories ||\n                !dataView.categorical.categories[0] ||\n                !dataView.categorical.categories[1] ||\n                !dataView.categorical.categories[0].values ||\n                !dataView.categorical.categories[1].values) {\n                return {\n                    nodes: [],\n                    links: [],\n                    settings: {\n                        scale: { x: 1, y: 1 },\n                        colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,\n                        fontSize: SankeyDiagram.DefaultSettings.fontSize\n                    }\n                };\n            }\n\n            var nodes: SankeyDiagramNode[] = [],\n                links: SankeyDiagramLink[] = [],\n                dataPoints: SankeyDiagramDataPoint[] = [],\n                categories: any[] = dataView.categorical.categories[0].values,\n                secondCategories: any[] = dataView.categorical.categories[1].values,\n                valuesColumn: DataViewValueColumn = dataView.categorical.values && dataView.categorical.values[0],\n                weightValues: number[] = valuesColumn && valuesColumn.values && valuesColumn.values.map(x=> x || 0) || [],\n                allCategories: any[],\n                valueFormatterForCategories: IValueFormatter,\n                formatOfWeigth: string = \"g\",\n                valuesFormatterForWeigth: IValueFormatter,\n                objects: DataViewObjects,\n                linksObjects: DataViewObjects[] = dataView.categorical.categories[0].objects || [],\n                labelColour: string,\n                settings: SankeyDiagramSettings,\n                shiftOfColour: number,\n                identities: DataViewScopeIdentity[] = [];\n\n            if (dataView.categorical.categories[0].identity) {\n                identities = identities.concat(dataView.categorical.categories[0].identity);\n            }\n\n            if (dataView.categorical.categories[1].identity) {\n                identities = identities.concat(dataView.categorical.categories[1].identity);\n            }\n\n            objects = this.getObjectsFromDataView(dataView);\n\n            labelColour = this.getColour(\n                SankeyDiagram.Properties[\"labels\"][\"fill\"],\n                SankeyDiagram.DefaultSettings.colourOfLabels,\n                objects);\n\n            if (valuesColumn && valuesColumn.source) {\n                formatOfWeigth = ValueFormatter.getFormatString(\n                    valuesColumn.source,\n                    SankeyDiagram.Properties[\"general\"][\"formatString\"]);\n            }\n\n            dataPoints = categories.map((item: any, index: number) => {\n                return {\n                    source: item,\n                    destination: secondCategories[index],\n                    weigth: valuesColumn ? Math.max(weightValues[index] || 0, 0) : 1\n                };\n            });\n\n            allCategories = categories.concat(secondCategories);\n\n            valueFormatterForCategories = ValueFormatter.create({\n                format: ValueFormatter.getFormatString(\n                    dataView.categorical.categories[0].source,\n                    SankeyDiagram.Properties[\"general\"][\"formatString\"]),\n                value: allCategories[0],\n                value2: allCategories[allCategories.length - 1]\n            });\n\n            valuesFormatterForWeigth = ValueFormatter.create({\n                format: formatOfWeigth,\n                value: Math.max(d3.max(weightValues) || 1, 1),\n            });\n\n            allCategories.forEach((item: any, index: number) => {\n                if (!nodes.some((node: SankeyDiagramNode) => {\n                    if (item === node.label.name) {\n                        node.selectionIds.push(SelectionId.createWithId(identities[index]));\n\n                        return true;\n                    }\n\n                    return false;\n                })) {\n                    var formattedValue: string = valueFormatterForCategories.format(item),\n                        label: SankeyDiagramLabel,\n                        selectionId: SelectionId,\n                        textProperties: TextProperties = {\n                            text: formattedValue,\n                            fontFamily: this.textProperties.fontFamily,\n                            fontSize: this.textProperties.fontSize\n                        };\n\n                    label = {\n                        name: item,\n                        formattedName: valueFormatterForCategories.format(item),\n                        width: TextMeasurementService.measureSvgTextWidth(textProperties),\n                        height: TextMeasurementService.estimateSvgTextHeight(textProperties),\n                        colour: labelColour\n                    };\n\n                    selectionId = SelectionId.createWithId(identities[index]);\n\n                    nodes.push({\n                        label: label,\n                        links: [],\n                        inputWeight: 0,\n                        outputWeight: 0,\n                        width: this.nodeWidth,\n                        height: 0,\n                        colour: SankeyDiagram.DefaultColourOfNode,\n                        tooltipData: [],\n                        selectionIds: [selectionId]\n                    });\n                }\n            });\n\n            shiftOfColour = this.colours.getAllColors().length / nodes.length;\n\n            nodes.forEach((node: SankeyDiagramNode, index: number) => {\n                node.colour = this.colours.getColorByIndex(Math.floor(index * shiftOfColour)).value;\n            });\n\n            dataPoints.forEach((dataPoint: SankeyDiagramDataPoint, index: number) => {\n                var sourceNode: SankeyDiagramNode,\n                    destinationNode: SankeyDiagramNode,\n                    link: SankeyDiagramLink,\n                    linkColour: string;\n\n                if (dataPoint.source === dataPoint.destination) {\n                    return;\n                }\n\n                nodes.forEach((node: SankeyDiagramNode) => {\n                    if (node.label.name === dataPoint.source) {\n                        sourceNode = node;\n                    }\n\n                    if (node.label.name === dataPoint.destination) {\n                        destinationNode = node;\n                    }\n                });\n\n                linkColour = this.getColour(\n                    SankeyDiagram.Properties[\"links\"][\"fill\"],\n                    SankeyDiagram.DefaultColourOfLink,\n                    linksObjects[index]);\n\n                link = {\n                    source: sourceNode,\n                    destination: destinationNode,\n                    weigth: dataPoint.weigth,\n                    height: dataPoint.weigth,\n                    colour: linkColour,\n                    tooltipData: this.getTooltipDataForLink(\n                        valuesFormatterForWeigth,\n                        sourceNode.label.formattedName,\n                        destinationNode.label.formattedName,\n                        dataPoint.weigth),\n                    selectionId: SelectionId.createWithId(identities[index])\n                };\n\n                links.push(link);\n\n                sourceNode.links.push(link);\n                destinationNode.links.push(link);\n\n                this.updateValueOfNode(sourceNode);\n                this.updateValueOfNode(destinationNode);\n\n                sourceNode.tooltipData = this.getTooltipForNode(\n                    valuesFormatterForWeigth,\n                    sourceNode.label.formattedName,\n                    sourceNode.inputWeight ? sourceNode.inputWeight : sourceNode.outputWeight);\n\n                destinationNode.tooltipData = this.getTooltipForNode(\n                    valuesFormatterForWeigth,\n                    destinationNode.label.formattedName,\n                    destinationNode.inputWeight ? destinationNode.inputWeight : destinationNode.outputWeight);\n            });\n\n            settings = this.parseSettings(objects);\n\n            settings.colourOfLabels = labelColour;\n\n            return {\n                nodes: nodes,\n                links: links,\n                settings: settings\n            };\n        }\n\n        private getObjectsFromDataView(dataView: DataView): DataViewObjects {\n            if (!dataView ||\n                    !dataView.metadata ||\n                    !dataView.metadata.columns ||\n                    !dataView.metadata.objects) {\n                return null;\n            }\n\n            return dataView.metadata.objects;\n        }\n\n        private getColour(properties: DataViewObjectPropertyIdentifier, defaultColor: string, objects: DataViewObjects): string {\n            var colorHelper: ColorHelper;\n\n            colorHelper = new ColorHelper(this.colours, properties, defaultColor);\n\n            return colorHelper.getColorForMeasure(objects, \"\");\n        }\n\n        private getTooltipDataForLink(\n            valueFormatter: IValueFormatter,\n            sourceNodeName: string,\n            destinationNodeName: string,\n            linkWeight: number): TooltipDataItem[] {\n\n            var formattedLinkWeight: string;\n\n            if (valueFormatter && valueFormatter.format) {\n                formattedLinkWeight = valueFormatter.format(linkWeight);\n            } else {\n                formattedLinkWeight = linkWeight.toString();\n            }\n\n            return [{\n                displayName: SankeyDiagram.RoleNames.rows,\n                value: sourceNodeName\n            }, {\n                displayName: SankeyDiagram.RoleNames.columns,\n                value: destinationNodeName\n            }, {\n                displayName: SankeyDiagram.RoleNames.values,\n                value: formattedLinkWeight\n            }];\n        }\n\n        private updateValueOfNode(node: SankeyDiagramNode): void {\n            node.inputWeight = node.links.reduce((previousValue: number, currentValue: SankeyDiagramLink) => {\n                return previousValue + (currentValue.destination === node ? currentValue.weigth : 0);\n            }, 0);\n\n            node.outputWeight = node.links.reduce((previousValue: number, currentValue: SankeyDiagramLink) => {\n                return previousValue + (currentValue.source === node ? currentValue.weigth : 0);\n            }, 0);\n        }\n\n        private getTooltipForNode(\n            valueFormatter: IValueFormatter,\n            nodeName: string,\n            nodeWeight: number): TooltipDataItem[] {\n\n            var formattedNodeWeigth: string;\n\n            if (valueFormatter && valueFormatter.format) {\n                formattedNodeWeigth = valueFormatter.format(nodeWeight);\n            } else {\n                formattedNodeWeigth = nodeWeight.toString();\n            }\n\n            return [{\n                displayName: \"Name\",\n                value: nodeName\n            }, {\n                displayName: SankeyDiagram.RoleNames.values,\n                value: formattedNodeWeigth\n            }];\n        }\n\n        private parseSettings(objects: DataViewObjects): SankeyDiagramSettings {\n            var isVisibleLabels: boolean = false;\n\n            isVisibleLabels = DataViewObjects.getValue(\n                objects,\n                SankeyDiagram.Properties[\"labels\"][\"show\"],\n                SankeyDiagram.DefaultSettings.isVisibleLabels);\n\n            return {\n                isVisibleLabels: isVisibleLabels,\n                scale: {\n                    x: SankeyDiagram.DefaultSettings.scale.x,\n                    y: SankeyDiagram.DefaultSettings.scale.y\n                },\n                colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,\n                fontSize: DataViewObjects.getValue<number>(objects, \n                    SankeyDiagram.Properties[\"labels\"][\"fontSize\"],\n                    SankeyDiagram.DefaultSettings.fontSize)\n            };\n        }\n\n        private findNodePosition(sankeyDiagramDataView: SankeyDiagramDataView): void {\n            this.findNodePositionByX(sankeyDiagramDataView);\n            this.findNodePositionByY(sankeyDiagramDataView);\n        }\n\n        private findNodePositionByX(sankeyDiagramDataView: SankeyDiagramDataView): void {\n            var nodes: SankeyDiagramNode[] = sankeyDiagramDataView.nodes,\n                nextNodes: SankeyDiagramNode[] = [],\n                previousNodes: SankeyDiagramNode[] = [],\n                x: number = 0,\n                isRecursiveDependencies: boolean = false;\n\n            while (nodes.length > 0) {\n                nextNodes = [];\n\n                nodes.forEach((node: SankeyDiagramNode) => {\n                    node.x = x;\n\n                    node.links.forEach((link: SankeyDiagramLink) => {\n                        if (node === link.source && node !== link.destination) {\n                            if (nextNodes.every((item: SankeyDiagramNode) => {\n                                return item !== link.destination;\n                            })) {\n                                nextNodes.push(link.destination);\n                            }\n                        }\n                    });\n                });\n\n                isRecursiveDependencies = nextNodes.length === previousNodes.length && \n                    previousNodes.every((previousNode: SankeyDiagramNode) => {\n                        return nextNodes.some((nextNode: SankeyDiagramNode) => {\n                            return nextNode === previousNode;\n                        });\n                    });\n\n                if (isRecursiveDependencies) {\n                    previousNodes.forEach((element: SankeyDiagramNode) => {\n                        element.x = x;\n\n                        x++;\n                    });\n\n                    nodes = [];\n                } else {\n                    nodes = nextNodes;\n\n                    previousNodes = nodes;\n\n                    x++;\n                }\n            }\n\n            sankeyDiagramDataView.settings.scale.x = this.getScaleByAxisX(x - 1);\n\n            this.scaleByAxisX(sankeyDiagramDataView.nodes, sankeyDiagramDataView.settings.scale.x);\n        }\n\n        private scaleByAxisX(nodes: SankeyDiagramNode[], scale: number): void {\n            nodes.forEach((node: SankeyDiagramNode) => {\n                node.x *= scale;\n            });\n        }\n\n        private getScaleByAxisX(numberOfColumns: number = 1): number {\n            return this.getPositiveNumber((this.viewport.width - this.nodeWidth) / numberOfColumns);\n        }\n\n        private findNodePositionByY(sankeyDiagramDataView: SankeyDiagramDataView): void {\n            var nodes: SankeyDiagramNode[] = sankeyDiagramDataView.nodes,\n                links: SankeyDiagramLink[] = sankeyDiagramDataView.links,\n                currentX: number = 0,\n                index: number = 0,\n                maxIndex: number = 0,\n                sumValueOfNodes: number = 0,\n                maxValueOfNodes: number = 0;\n \n            nodes = nodes.sort((firstNode: SankeyDiagramNode, secondNode: SankeyDiagramNode) => {\n                return firstNode.x - secondNode.x;\n            });\n\n            nodes.forEach((node: SankeyDiagramNode) => {\n                if (currentX !== node.x) {\n                    index = 0;\n                    currentX = node.x;\n                    sumValueOfNodes = 0;\n                }\n\n                sumValueOfNodes += Math.max(node.inputWeight, node.outputWeight);\n\n                if (sumValueOfNodes > maxValueOfNodes) {\n                    maxValueOfNodes = sumValueOfNodes;\n                }\n\n                if (index > maxIndex) {\n                    maxIndex = index;\n                }\n\n                index++;\n            });\n\n            sankeyDiagramDataView.settings.scale.y = this.getScaleByAxisY(maxIndex + 1, maxValueOfNodes);\n\n            this.scaleByAxisY(nodes, links, sankeyDiagramDataView.settings.scale.y);\n        }\n\n        private getScaleByAxisY(numberOfRows: number, sumValueOfNodes: number): number {\n            return this.getPositiveNumber((this.viewport.height - numberOfRows * SankeyDiagram.NodePadding) / sumValueOfNodes);\n        }\n\n        private scaleByAxisY(\n            nodes: SankeyDiagramNode[],\n            links: SankeyDiagramLink[],\n            scale: number): void {\n\n            var shiftByAxisY: number = 0,\n                currentX: number = 0,\n                index: number = 0;\n\n            nodes.forEach((node: SankeyDiagramNode) => {\n                if (currentX !== node.x) {\n                    currentX = node.x;\n                    shiftByAxisY = 0;\n                    index = 0;\n                }\n\n                node.height = Math.max(node.inputWeight, node.outputWeight) * scale;\n\n                node.y = shiftByAxisY + SankeyDiagram.NodePadding * index;\n\n                shiftByAxisY += node.height;\n\n                index++;\n            });\n\n            nodes.forEach((node: SankeyDiagramNode) => {\n                node.links = node.links.sort((firstLink: SankeyDiagramLink, secondLink: SankeyDiagramLink) => {\n                    var firstY: number,\n                        secondY: number;\n\n                    firstY = firstLink.source === node\n                        ? firstLink.destination.y\n                        : firstLink.source.y;\n\n                    secondY = secondLink.source === node\n                        ? secondLink.destination.y\n                        : secondLink.source.y;\n\n                    return firstY - secondY;\n                });\n\n                var shiftByAxisYOfLeftLink: number = 0,\n                    shiftByAxisYOfRightLink: number = 0;\n\n                node.links.forEach((link: SankeyDiagramLink) => {\n                    var shiftByAxisY: number = 0;\n\n                    link.height = link.weigth * scale;\n\n                    if (link.source.x < node.x || link.destination.x < node.x) {\n                        shiftByAxisY = shiftByAxisYOfLeftLink;\n\n                        shiftByAxisYOfLeftLink += link.height;\n                    } else if (link.source.x > node.x || link.destination.x > node.x) {\n                        shiftByAxisY = shiftByAxisYOfRightLink;\n\n                        shiftByAxisYOfRightLink += link.height;\n                    }\n\n                    if (link.source === node) {\n                        link.dySource = shiftByAxisY;\n                    } else if (link.destination === node) {\n                        link.dyDestination = shiftByAxisY;\n                    }\n                });\n            });\n        }\n\n        private render(sankeyDiagramDataView: SankeyDiagramDataView): void {\n            var nodesSelection: D3.UpdateSelection,\n                linksSelection: D3.UpdateSelection;\n\n            linksSelection = this.renderLinks(sankeyDiagramDataView);\n            nodesSelection = this.renderNodes(sankeyDiagramDataView);\n\n            this.bindSelectionHandler(sankeyDiagramDataView, nodesSelection, linksSelection);\n        }\n\n        private renderNodes(sankeyDiagramDataView: SankeyDiagramDataView): D3.UpdateSelection {\n            var nodesEnterSelection: D3.Selection,\n                nodesSelection: D3.UpdateSelection,\n                nodeElements: D3.Selection;\n\n            nodeElements = this.main\n                .select(SankeyDiagram.Nodes.selector)\n                .selectAll(SankeyDiagram.Node.selector);\n\n            nodesSelection = nodeElements.data(sankeyDiagramDataView.nodes.filter(x => x.height > 0));\n\n            nodesEnterSelection = nodesSelection\n                .enter()\n                .append(\"g\");\n\n            nodesSelection\n                .attr(\"transform\", (node: SankeyDiagramNode) => {\n                    return SVGUtil.translate(node.x, node.y);\n                })\n                .classed(SankeyDiagram.Node[\"class\"], true);\n\n            nodesEnterSelection\n                .append(\"rect\")\n                .classed(SankeyDiagram.NodeRect[\"class\"], true);\n\n            nodesEnterSelection\n                .append(\"text\")\n                .classed(SankeyDiagram.NodeLabel[\"class\"], true);\n\n            nodesSelection\n                .select(SankeyDiagram.NodeRect.selector)\n                .style({\n                    \"fill\": (node: SankeyDiagramNode) => node.colour,\n                    \"stroke\": (node: SankeyDiagramNode) => d3.rgb(node.colour).darker(1.5)\n                })\n                .attr({\n                    x: 0,\n                    y: 0,\n                    height: (node: SankeyDiagramNode) => node.height,\n                    width: (node: SankeyDiagramNode) => node.width\n                });\n\n            nodesSelection\n                .select(SankeyDiagram.NodeLabel.selector)\n                .attr({\n                    x: (node: SankeyDiagramNode) => this.getLabelPositionByAxisX(node),\n                    y: (node: SankeyDiagramNode) => node.height / 2,\n                    dy: \"0.35em\"\n                })\n                .style(\"fill\", (node: SankeyDiagramNode) => node.label.colour)\n                .style(\"font-size\", this.textProperties.fontSize)\n                .style(\"display\", (node: SankeyDiagramNode) => {\n                    var isNotVisibleLabel: boolean = false, \n                        labelPositionByAxisX: number = this.getCurrentPositionOfLabelByAxisX(node);\n\n                    isNotVisibleLabel = \n                        labelPositionByAxisX >= this.viewport.width ||\n                        labelPositionByAxisX <= 0 ||\n                        (node.height + SankeyDiagram.NodePadding) < node.label.height;\n\n                    if (isNotVisibleLabel || !sankeyDiagramDataView.settings.isVisibleLabels\n                        || sankeyDiagramDataView.settings.scale.x / 2 <  SankeyDiagram.MinWidthOfLabel) {\n                        return \"none\";\n                    }\n\n                    return null;\n                })\n                .style(\"text-anchor\", (node: SankeyDiagramNode) => {\n                    if (this.isLabelLargerWidth(node)) {\n                        return \"end\";\n                    }\n\n                    return null;\n                })\n                .text((node: SankeyDiagramNode) => {\n                    var maxWidth: number = sankeyDiagramDataView.settings.scale.x / 2 - node.width - SankeyDiagram.NodePadding;\n\n                    if (this.getCurrentPositionOfLabelByAxisX(node) > maxWidth) {\n                        return TextMeasurementService.getTailoredTextOrDefault({\n                            text: node.label.formattedName,\n                            fontFamily: this.textProperties.fontFamily,\n                            fontSize: this.textProperties.fontSize\n                        }, maxWidth);\n                    }\n\n                    return node.label.formattedName;\n                });\n\n            nodesSelection\n                .exit()\n                .remove();\n\n            this.renderTooltip(nodesSelection);\n\n            return nodesSelection;\n        }\n\n        private getLabelPositionByAxisX(node: SankeyDiagramNode): number {\n            if (this.isLabelLargerWidth(node)) {\n                return -(SankeyDiagram.LabelPadding);\n            }\n\n            return node.width + SankeyDiagram.LabelPadding;\n        }\n\n        private isLabelLargerWidth(node: SankeyDiagramNode): boolean {\n            var shiftByAxisX: number = node.x + node.width + SankeyDiagram.LabelPadding;\n\n            return shiftByAxisX + node.label.width > this.viewport.width;\n        }\n\n        private getCurrentPositionOfLabelByAxisX(node: SankeyDiagramNode): number {\n            var labelPositionByAxisX: number = this.getLabelPositionByAxisX(node);\n\n            labelPositionByAxisX = labelPositionByAxisX > 0\n                ? labelPositionByAxisX + node.x + node.label.width + node.width\n                : node.x + labelPositionByAxisX - node.label.width - node.width;\n\n            return labelPositionByAxisX;\n        }\n\n        private renderLinks(sankeyDiagramDataView: SankeyDiagramDataView): D3.UpdateSelection {\n            var linksSelection: D3.UpdateSelection,\n                linksElements: D3.Selection;\n\n            linksElements = this.main\n                .select(SankeyDiagram.Links.selector)\n                .selectAll(SankeyDiagram.Link.selector);\n\n            linksSelection = linksElements.data(sankeyDiagramDataView.links.filter(x => x.height > 0));\n\n            linksSelection\n                .enter()\n                .append(\"path\")\n                .classed(SankeyDiagram.Link[\"class\"], true);\n\n            linksSelection\n                .attr(\"d\", (link: SankeyDiagramLink) => {\n                    return this.getSvgPath(link);\n                })\n                .style({\n                    \"stroke-width\": (link: SankeyDiagramLink) => link.height,\n                    \"stroke\": (link: SankeyDiagramLink) => link.colour\n                });\n\n            linksSelection\n                .exit()\n                .remove();\n\n            this.renderTooltip(linksSelection);\n\n            return linksSelection;\n        }\n\n        private getSvgPath(link: SankeyDiagramLink): string {\n            var x0: number,\n                x1: number,\n                xi: D3.Transition.BaseInterpolate,\n                x2: number,\n                x3: number,\n                y0: number,\n                y1: number;\n\n            if (link.destination.x < link.source.x) {\n                x0 = link.source.x;\n                x1 = link.destination.x + link.destination.width;\n            } else {\n                x0 = link.source.x + link.source.width;\n                x1 = link.destination.x;\n            }\n\n            xi = d3.interpolateNumber(x0, x1);\n            x2 = xi(this.curvatureOfLinks);\n            x3 = xi(1 - this.curvatureOfLinks);\n            y0 = link.source.y + link.dySource + link.height / 2;\n            y1 = link.destination.y + link.dyDestination + link.height / 2;\n\n            return `M ${x0} ${y0} C ${x2} ${y0}, ${x3} ${y1}, ${x1} ${y1}`;\n        }\n\n        private renderTooltip(selection: D3.UpdateSelection): void {\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) => {\n                return (<SankeyDiagramTooltipData> tooltipEvent.data).tooltipData;\n            });\n        }\n\n        private bindSelectionHandler(\n            sankeyDiagramDataView: SankeyDiagramDataView,\n            nodesSelection: D3.UpdateSelection,\n            linksSelection: D3.UpdateSelection): void {\n\n            nodesSelection.on(\"click\", (node: SankeyDiagramNode) => {\n                var selectionIds = _.isEqual(\n                        node.selectionIds.map(x=>x.getKey()),\n                        this.selectionManager.getSelectionIds().map(x=>x.getKey()))\n                    ? []\n                    : node.selectionIds;\n\n                this.selectMany(selectionIds, true).then(() => this.setSelection(nodesSelection, linksSelection));\n\n                d3.event.stopPropagation();\n            });\n\n            linksSelection.on(\"click\", (link: SankeyDiagramLink) => {\n                this.selectionManager.select(link.selectionId, d3.event.ctrlKey).then(() =>\n                    this.setSelection(nodesSelection, linksSelection));\n\n                d3.event.stopPropagation();\n            });\n\n            this.root.on(\"click\", () => {\n                this.selectionManager.clear().then(() => this.setSelection(nodesSelection, linksSelection));\n            });\n\n            this.setSelection(nodesSelection, linksSelection);\n        }\n\n        private selectMany(selectionIds: SelectionId[], clear: boolean = false): JQueryPromise<{}> {\n            if(clear) {\n                return this.selectionManager.clear().then(() => this.selectMany(selectionIds, false));\n            }\n\n            var selectionDeffered = selectionIds.map(id => this.selectionManager.select(id, true));\n            return (<JQueryPromise<{}>>$.when.apply(null, selectionDeffered));\n        }\n\n        private setSelection(nodes: D3.UpdateSelection, links: D3.UpdateSelection): void {\n\n            var selectionIds: SelectionId[] = this.selectionManager.getSelectionIds();\n\n            nodes.classed(\"selected\", selectionIds.length > 0);\n            links.classed(\"selected\", false);\n\n            if (selectionIds.length === 0) {\n                return;\n            }\n\n            var selectedNodesSelection = nodes.filter((node: SankeyDiagramNode) => selectionIds\n                .some((selectedId: SelectionId) => node.selectionIds\n                .some( x => x.getKey() === selectedId.getKey())));\n\n            var selectedLinksSelection = links.filter((link: SankeyDiagramLink) =>\n                 selectionIds.some((selectionId: SelectionId) => selectionId.getKey() === link.selectionId.getKey()));\n\n            selectedNodesSelection.classed(\"selected\", false);\n            selectedLinksSelection.classed(\"selected\", true);\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\n            var enumeration = new ObjectEnumerationBuilder();\n\n            if (!this.dataView) {\n                return [];\n            }\n\n            switch (options.objectName) {\n                case \"labels\": {\n                    this.enumerateLabels(enumeration);\n                    break;\n                }\n                case \"links\": {\n                    this.enumerateLinks(enumeration);\n                    break;\n                }\n            }\n\n            return enumeration.complete();\n        }\n\n        private enumerateLabels(enumeration: ObjectEnumerationBuilder): void {\n            var settings: SankeyDiagramSettings = this.dataView.settings,\n                labels: VisualObjectInstance;\n\n            if (!settings) {\n                return;\n            }\n\n            labels = {\n                objectName: \"labels\",\n                displayName: \"labels\",\n                selector: null,\n                properties: {\n                    show: settings.isVisibleLabels,\n                    fill: settings.colourOfLabels,\n                    fontSize: settings.fontSize\n                }\n            };\n\n            enumeration.pushInstance(labels);\n        }\n\n        private enumerateLinks(enumeration: ObjectEnumerationBuilder): void {\n            var links: SankeyDiagramLink[] = this.dataView.links;\n\n            if (!links || !(links.length > 0)) {\n                return;\n            }\n\n            links.forEach((link: SankeyDiagramLink) => {\n                enumeration.pushInstance({\n                    objectName: \"links\",\n                    displayName: `${link.source.label.formattedName} - ${link.destination.label.formattedName}`,\n                    selector: ColorHelper.normalizeSelector(link.selectionId.getSelector(), false),\n                    properties: {\n                        fill: { solid: { color: link.colour } }\n                    }\n                });\n            });\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *   \n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *   \n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import PixelConverter = jsCommon.PixelConverter;\n\n    export let bulletChartProps = {\n        values: {\n            targetValue: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'targetValue' },\n            minimumPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'minimumPercent' },\n            needsImprovementPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'needsImprovementPercent' },\n            satisfactoryPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'satisfactoryPercent' },\n            goodPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'goodPercent' },\n            veryGoodPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'veryGoodPercent' },\n            maximumPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'maximumPercent' },\n            targetValue2: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'targetValue2' },\n        },\n        orientation: {\n            orientation: <DataViewObjectPropertyIdentifier>{ objectName: 'orientation', propertyName: 'orientation' },\n        },\n        colors: {\n            badColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'badColor' },\n            needsImprovementColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'needsImprovementColor' },\n            satisfactoryColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'satisfactoryColor' },\n            goodColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'goodColor' },\n            veryGoodColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'veryGoodColor' },\n            bulletColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'bulletColor' },\n        },\n        axis: {\n            axis: <DataViewObjectPropertyIdentifier>{ objectName: 'axis', propertyName: 'axis' },\n            axisColor: <DataViewObjectPropertyIdentifier>{ objectName: 'axis', propertyName: 'axisColor' },\n            measureUnits: <DataViewObjectPropertyIdentifier>{ objectName: 'axis', propertyName: 'measureUnits' },\n            unitsColor: <DataViewObjectPropertyIdentifier>{ objectName: 'axis', propertyName: 'unitsColor' },\n        },\n        formatString: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'formatString' },\n        labels: {\n            fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'fontSize' },\n            show: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'show' },\n            labelColor: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'labelColor' }\n        }\n    };\n\n    export interface BarData {\n        scale: any;\n        barIndex: number;\n        categoryLabel: string;\n        axis: any;\n        x: number;\n        y: number;\n        key: string;\n    }\n\n    export interface BarRect extends SelectableDataPoint {\n        barIndex: number;\n        start: number;\n        end: number;\n        fill: string;\n        tooltipInfo?: TooltipDataItem[];\n        key: string;\n    }\n\n    export interface TargetValue {\n        barIndex: number;\n        value: number;\n        value2: number;\n        fill: string;\n        key: string;\n    }\n\n    export interface ScaledValues {\n        firstScale: number;\n        secondScale: number;\n        thirdScale: number;\n        fourthScale: number;\n        fifthScale: number;\n    }\n\n    export interface BarValueRect extends BarRect {\n    }\n\n    export interface BulletChartSettings {\n        values: {\n            targetValue: number;\n            minimumPercent: number;\n            needsImprovementPercent: number;\n            satisfactoryPercent: number;\n            goodPercent: number;\n            veryGoodPercent: number;\n            maximumPercent: number;\n            targetValue2: number;\n        };\n        orientation: {\n            orientation: string;\n            reverse: boolean;\n            vertical: boolean;\n        };\n        colors: {\n            badColor: string;\n            needsImprovementColor: string;\n            satisfactoryColor: string;\n            goodColor: string;\n            veryGoodColor: string;\n            bulletColor: string;\n        };\n\n        axis: {\n            axis: boolean;\n            axisColor: string;\n            measureUnits: string;\n            unitsColor: string;\n        };\n        labelSettings: VisualDataLabelsSettings;\n    }\n\n    //Model\n    export interface BulletChartModel {\n        bars: BarData[];\n        bulletChartSettings: BulletChartSettings;\n        bulletValueFormatString: string;\n        barRects: BarRect[];\n        valueRects: BarValueRect[];\n        targetValues: TargetValue[];\n    }\n\n    export let bulletChartRoleNames = {\n        value: 'Value',\n        targetValue: 'TargetValue',\n        minValue: 'Minimum',\n        needsImprovementValue: 'NeedsImprovement',\n        satisfactoryValue: 'Satisfactory',\n        goodValue: 'Good',\n        veryGoodValue: 'VeryGood',\n        maxValue: 'Maximum',\n        targetValue2: 'TargetValue2',\n    };\n\n    module Orientation {\n        export const HORIZONTALLEFT: string = 'Horizontal Left';\n        export const HORIZONTALRIGHT: string = 'Horizontal Right';\n        export const VERTICALTOP: string = 'Vertical Top';\n        export const VERTICALBOTTOM: string = 'Vertical Bottom';\n\n        export var type: IEnumType = createEnumType([\n            { value: HORIZONTALLEFT, displayName: HORIZONTALLEFT },\n            { value: HORIZONTALRIGHT, displayName: HORIZONTALRIGHT },\n            { value: VERTICALTOP, displayName: VERTICALTOP },\n            { value: VERTICALBOTTOM, displayName: VERTICALBOTTOM }\n        ]);\n    }\n\n    export class BulletChart implements IVisual {\n        private static ScrollBarSize = 13;\n        private static SpaceRequiredForBar = 60;\n        private static SpaceRequiredForBarVertically = 100;\n        private static StartMarginHorizontal = 30;\n        private static StartMarginVertical = 50;\n        private static BulletSize = 25;\n        private static DefaultSubtitleFontSizeInPt = 9;\n        private static BarMargin = 10;\n        private static MaxLabelWidth = 80;\n        private static MaxLabelHeight = 60;\n        private static SubtitleMargin = 10;\n        private static AxisFontSizeInPt = 8;\n\n        private static BiggestLabelWidth = 0;\n        private static BiggestLabelHeight = 0;\n        private static MarkerMarginHorizontal = BulletChart.BulletSize / 3;\n        private static MarkerMarginVertical = BulletChart.BulletSize / 4;\n\n        private static FontFamily: string = \"Segoe UI\";\n        private baselineDelta: number = 0;\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: 'Category',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'Category',\n                }, {\n                    name: 'Value',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Value',\n                }, {\n                    name: 'TargetValue',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Target Value',\n                }, {\n                    name: 'Minimum',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Minimum',\n                }, {\n                    name: 'NeedsImprovement',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Needs Improvement',\n                }, {\n                    name: 'Satisfactory',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Satisfactory',\n                }, {\n                    name: 'Good',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Good',\n                }, {\n                    name: 'VeryGood',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Very Good',\n                }, {\n                    name: 'Maximum',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Maximum',\n                }, {\n                    name: 'TargetValue2',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Target Value 2'\n                }\n            ],\n            objects: {\n                general: {\n                    displayName: data.createDisplayNameGetter('Visual_General'),\n                    properties: {\n                        formatString: {\n                            type: { formatting: { formatString: true } },\n                        },\n                    },\n                },\n                values: {\n                    displayName: 'Data values',\n                    properties: {\n                        targetValue: {\n                            displayName: 'Target Value',\n                            type: { numeric: true }\n                        },\n                        targetValue2: {\n                            displayName: 'Target Value 2',\n                            type: { numeric: true },\n                        },\n                        minimumPercent: {\n                            displayName: 'Minimum %',\n                            type: { numeric: true }\n                        },\n                        needsImprovementPercent: {\n                            displayName: 'Needs Improvement %',\n                            type: { numeric: true },\n                        },\n                        satisfactoryPercent: {\n                            displayName: 'Satisfactory %',\n                            type: { numeric: true }\n                        },\n                        goodPercent: {\n                            displayName: 'Good %',\n                            type: { numeric: true }\n                        },\n                        veryGoodPercent: {\n                            displayName: 'Very Good %',\n                            type: { numeric: true },\n                        },\n                        maximumPercent: {\n                            displayName: 'Maximum %',\n                            type: { numeric: true }\n                        },\n                    }\n                },\n                labels: {\n                    displayName: 'Category labels',\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true },\n                        },\n                        labelColor: {\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\n                            description: data.createDisplayNameGetter('Visual_LabelsFillDescription'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { formatting: { fontSize: true } },\n                        },\n                    },\n                },\n                orientation: {\n                    displayName: 'Orientation',\n                    properties: {\n                        orientation: {\n                            displayName: 'Orientation',\n                            type: { enumeration: Orientation.type }\n                        }\n                    }\n                },\n                colors: {\n                    displayName: 'Colors',\n                    properties: {\n                        badColor: {\n                            type: { fill: { solid: { color: true } } },\n                            displayName: 'Bad Color'\n                        },\n                        needsImprovementColor: {\n                            type: { fill: { solid: { color: true } } },\n                            displayName: 'Needs Improvement Color',\n                        },\n                        satisfactoryColor: {\n                            type: { fill: { solid: { color: true } } },\n                            displayName: 'Satisfactory Color'\n                        },\n                        goodColor: {\n                            type: { fill: { solid: { color: true } } },\n                            displayName: 'Good Color'\n                        },\n                        veryGoodColor: {\n                            type: { fill: { solid: { color: true } } },\n                            displayName: 'Very Good Color',\n                        },\n                        bulletColor: {\n                            type: { fill: { solid: { color: true } } },\n                            displayName: 'Bullet Color'\n                        }\n                    },\n                },\n                axis: {\n                    displayName: 'Axis',\n                    properties: {\n                        axis: {\n                            displayName: 'Axis',\n                            type: { bool: true }\n                        },\n                        axisColor: {\n                            type: { fill: { solid: { color: true } } },\n                            displayName: 'Axis Color'\n                        },\n                        measureUnits: {\n                            type: { text: true },\n                            displayName: 'Measure Units '\n                        },\n                        unitsColor: {\n                            type: { fill: { solid: { color: true } } },\n                            displayName: 'Units Color'\n                        },\n                    }\n                }\n            },\n            dataViewMappings: [{\n                conditions: [\n                    {\n                        'Category': { max: 1 }, 'Value': { max: 1 }, 'TargetValue': { max: 1 }, 'Minimum': { max: 1 }, 'NeedsImprovement': { max: 1 },\n                        'Satisfactory': { max: 1 }, 'Good': { max: 1 }, 'VeryGood': { max: 1 }, 'Maximum': { max: 1 }, 'TargetValue2': { max: 1 },\n                    },\n                ],\n                categorical: {\n                    categories: {\n                        for: { in: 'Category' },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: {\n                        select: [\n                            { bind: { to: 'Value' } },\n                            { bind: { to: 'TargetValue' } },\n                            { bind: { to: 'TargetValue2' } },\n                            { bind: { to: 'Minimum' } },\n                            { bind: { to: 'NeedsImprovement' } },\n                            { bind: { to: 'Satisfactory' } },\n                            { bind: { to: 'Good' } },\n                            { bind: { to: 'VeryGood' } },\n                            { bind: { to: 'Maximum' } },\n                        ]\n                    },\n                },\n            }],\n            supportsHighlight: true,\n            sorting: {\n                default: {},\n            },\n            drilldown: {\n                roles: ['Category']\n            }\n        };\n\n        //Variables\n        private clearCatcher: D3.Selection;\n        private bulletBody: D3.Selection;\n        private scrollContainer: D3.Selection;\n        private labelGraphicsContext: D3.Selection;\n        private bulletGraphicsContext: D3.Selection;\n        private model: BulletChartModel;\n        private behavior: BulletWebBehavior;\n        private interactivityService: IInteractivityService;\n        private hostService: IVisualHostServices;\n\n        private get reverse(): boolean {\n            return this.model.bulletChartSettings.orientation.reverse;\n        }\n\n        private get vertical(): boolean {\n            return this.model.bulletChartSettings.orientation.vertical;\n        }\n\n        public static DefaultStyleProperties(): BulletChartSettings {\n            return {\n                values: {\n                    targetValue: 0,\n                    targetValue2: 0,\n                    minimumPercent: 0,\n                    needsImprovementPercent: 25,\n                    satisfactoryPercent: 50,\n                    goodPercent: 100,\n                    veryGoodPercent: 125,\n                    maximumPercent: 200,\n                },\n                orientation: {\n                    orientation: Orientation.HORIZONTALLEFT,\n                    reverse: false,\n                    vertical: false\n                },\n                colors: {\n                    badColor: 'Darkred',\n                    needsImprovementColor: 'Red',\n                    satisfactoryColor: 'Yellow',\n                    goodColor: 'Green',\n                    veryGoodColor: 'Darkgreen',\n                    bulletColor: 'Black'\n                },\n                axis: {\n                    axis: true,\n                    axisColor: 'Grey',\n                    measureUnits: '',\n                    unitsColor: 'Grey',\n                },\n                labelSettings: {\n                    fontSize: 11,\n                    show: true,\n                    labelColor: 'Black',\n                },\n            };\n        }\n\n        private viewport: IViewport;\n\n        private get viewportIn(): IViewport {\n            return <IViewport>{\n                width: this.viewport.width,\n                height: this.viewport.height\n            };\n        }\n\n        private get viewportScroll(): IViewport {\n            let viewportIn = this.viewportIn;\n            return <IViewport>{\n                width: viewportIn.width - BulletChart.ScrollBarSize,\n                height: viewportIn.height - BulletChart.ScrollBarSize\n            };\n        }\n\n        private static getTextProperties(text: string, fontSize: number): TextProperties {\n            return <TextProperties>{\n                fontFamily: BulletChart.FontFamily,\n                fontSize: PixelConverter.fromPoint(fontSize),\n                text: text,\n            };\n        }\n        \n        // Convert a DataView into a view model\n        public static converter(dataView: DataView, options: VisualUpdateOptions): BulletChartModel {\n            let defaultSettings = BulletChart.DefaultStyleProperties();\n            let bulletModel: BulletChartModel = <BulletChartModel>{\n                bulletValueFormatString: null,\n                bulletChartSettings: defaultSettings,\n                bars: [],\n                barRects: [],\n                valueRects: [],\n                targetValues: [],\n            };\n\n            if (!dataView || !dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length === 0\n                || !dataView.metadata || !dataView.metadata.columns || dataView.metadata.columns.length === 0) {\n                return bulletModel;\n            }\n\n            let objects = dataView.metadata.objects;\n            let settings = bulletModel.bulletChartSettings;\n\n            if (objects) {\n                settings.values.targetValue = DataViewObjects.getValue<number>(objects, bulletChartProps.values.targetValue, defaultSettings.values.targetValue);\n                settings.values.targetValue2 = DataViewObjects.getValue<number>(objects, bulletChartProps.values.targetValue2, defaultSettings.values.targetValue2);\n                settings.values.minimumPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.minimumPercent, defaultSettings.values.minimumPercent);\n                settings.values.needsImprovementPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.needsImprovementPercent, defaultSettings.values.needsImprovementPercent);\n                settings.values.satisfactoryPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.satisfactoryPercent, defaultSettings.values.satisfactoryPercent);\n                settings.values.goodPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.goodPercent, defaultSettings.values.goodPercent);\n                settings.values.veryGoodPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.veryGoodPercent, defaultSettings.values.veryGoodPercent);\n                settings.values.maximumPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.maximumPercent, defaultSettings.values.maximumPercent);\n\n                settings.orientation.orientation = DataViewObjects.getValue<string>(objects, bulletChartProps.orientation.orientation, defaultSettings.orientation.orientation);\n\n                settings.colors.badColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.badColor, defaultSettings.colors.badColor);\n                settings.colors.needsImprovementColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.needsImprovementColor, defaultSettings.colors.needsImprovementColor);\n                settings.colors.satisfactoryColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.satisfactoryColor, defaultSettings.colors.satisfactoryColor);\n                settings.colors.goodColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.goodColor, defaultSettings.colors.goodColor);\n                settings.colors.veryGoodColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.veryGoodColor, defaultSettings.colors.veryGoodColor);\n                settings.colors.bulletColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.bulletColor, defaultSettings.colors.bulletColor);\n\n                settings.axis.axis = DataViewObjects.getValue<boolean>(objects, bulletChartProps.axis.axis, defaultSettings.axis.axis);\n                settings.axis.axisColor = DataViewObjects.getFillColor(objects, bulletChartProps.axis.axisColor, defaultSettings.axis.axisColor);\n                settings.axis.measureUnits = TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(\n                    DataViewObjects.getValue<string>(objects, bulletChartProps.axis.measureUnits, defaultSettings.axis.measureUnits), BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxLabelWidth);\n                settings.axis.unitsColor = DataViewObjects.getFillColor(objects, bulletChartProps.axis.unitsColor, defaultSettings.axis.unitsColor);\n\n                settings.labelSettings.fontSize = DataViewObjects.getValue<number>(objects, bulletChartProps.labels.fontSize, defaultSettings.labelSettings.fontSize);\n                settings.labelSettings.show = DataViewObjects.getValue<boolean>(objects, bulletChartProps.labels.show, defaultSettings.labelSettings.show);\n                settings.labelSettings.labelColor = DataViewObjects.getFillColor(objects, bulletChartProps.labels.labelColor, defaultSettings.labelSettings.labelColor);\n            }\n            if (settings.orientation.orientation === Orientation.HORIZONTALRIGHT || settings.orientation.orientation === Orientation.VERTICALBOTTOM)\n                settings.orientation.reverse = true;\n\n            if (settings.orientation.orientation === Orientation.VERTICALTOP || settings.orientation.orientation === Orientation.VERTICALBOTTOM)\n                settings.orientation.vertical = true;\n\n            let categories: DataViewCategoryColumn,\n                categoryValues: any[],\n                categoryValuesLen: number = 1,\n                categoryFormatString: string;\n\n            if (dataView.categorical.categories) {\n                categories = dataView.categorical.categories[0];\n                categoryValues = categories.values;\n                categoryValuesLen = categoryValues.length;\n                categoryFormatString = valueFormatter.getFormatString(categories.source, bulletChartProps.formatString);\n            }\n\n            bulletModel.bulletValueFormatString = valueFormatter.getFormatString(dataView.categorical.values[0].source, bulletChartProps.formatString);\n\n            for (let idx = 0; idx < categoryValuesLen; idx++) {\n                let toolTipItems = [];\n                let category: string, value: number, targetValue: number, targetValue2: number, minimum: number, satisfactory: number,\n                    good: number, maximum: number, needsImprovement: number, veryGood: number;\n                let highlight: boolean = false,\n                    categoryIdentity: DataViewScopeIdentity;\n\n                if (categoryValues) {\n                    let categoryValue = categoryValues[idx];\n\n                    category = valueFormatter.format(categoryValue, categoryFormatString);\n                    categoryIdentity = categories.identity ? categories.identity[idx] : null;\n\n                    let textProperties = BulletChart.getTextProperties(category, settings.labelSettings.fontSize);\n                    category = TextMeasurementService.getTailoredTextOrDefault(textProperties, BulletChart.MaxLabelWidth - BulletChart.StartMarginHorizontal);\n\n                    let labelWidth = TextMeasurementService.measureSvgTextWidth(textProperties);\n                    let labelHeight = TextMeasurementService.estimateSvgTextHeight(textProperties);\n\n                    BulletChart.BiggestLabelWidth = Math.max(BulletChart.BiggestLabelWidth, labelWidth);\n                    BulletChart.BiggestLabelHeight = Math.max(BulletChart.BiggestLabelHeight, labelHeight);\n                }\n\n                let values = dataView.categorical.values;\n                targetValue = settings.values.targetValue;\n                targetValue2 = settings.values.targetValue2;\n\n                for (let i = 0; i < values.length; i++) {\n                    let col = values[i].source;\n                    let currentVal = values[i].values[idx] || 0;\n\n                    if (col && col.roles) {\n                        if (col.roles[bulletChartRoleNames.value]) {\n                            if (values[i].highlights)\n                                highlight = values[i].highlights[idx] !== null;\n                            toolTipItems.push({ value: currentVal, metadata: values[i] });\n                            value = currentVal;\n                        } else if (col.roles[bulletChartRoleNames.targetValue]) {\n                            toolTipItems.push({ value: currentVal, metadata: values[i] });\n                            targetValue = currentVal;\n                        } else if (col.roles[bulletChartRoleNames.targetValue2]) {\n                            toolTipItems.push({ value: currentVal, metadata: values[i] });\n                            targetValue2 = currentVal;\n                        } else if (col.roles[bulletChartRoleNames.minValue])\n                            minimum = currentVal;\n                        else if (col.roles[bulletChartRoleNames.needsImprovementValue])\n                            needsImprovement = currentVal;\n                        else if (col.roles[bulletChartRoleNames.satisfactoryValue])\n                            satisfactory = currentVal;\n                        else if (col.roles[bulletChartRoleNames.goodValue])\n                            good = currentVal;\n                        else if (col.roles[bulletChartRoleNames.veryGoodValue])\n                            veryGood = currentVal;\n                        else if (col.roles[bulletChartRoleNames.maxValue])\n                            maximum = currentVal;\n                    }\n                }\n\n                if (!minimum)\n                    minimum = settings.values.minimumPercent * targetValue / 100;\n                if (!needsImprovement)\n                    needsImprovement = settings.values.needsImprovementPercent * targetValue / 100;\n                if (!satisfactory)\n                    satisfactory = settings.values.satisfactoryPercent * targetValue / 100;\n                if (!good)\n                    good = settings.values.goodPercent * targetValue / 100;\n                if (!veryGood)\n                    veryGood = settings.values.veryGoodPercent * targetValue / 100;\n                if (!maximum)\n                    maximum = settings.values.maximumPercent * targetValue / 100;\n\n                let viewportLength = (settings.orientation.vertical ? (options.viewport.height - BulletChart.MaxLabelHeight) : (options.viewport.width - BulletChart.MaxLabelWidth)) -\n                    BulletChart.StartMarginHorizontal - BulletChart.ScrollBarSize;\n                let sortedRanges = [minimum, needsImprovement, satisfactory, good, veryGood, maximum].sort(d3.descending);\n                let scale = (d3.scale.linear()\n                    .clamp(true)\n                    .domain([minimum, Math.max(sortedRanges[0], targetValue, value)])\n                    .range(settings.orientation.vertical ? [viewportLength, 0] : [0, viewportLength]));\n\n                // Scalles without\n                let firstScale = scale(minimum);\n                let secondScale = scale(needsImprovement);\n                let thirdScale = scale(satisfactory);\n                let fourthScale = scale(good);\n                let fifthScale = scale(veryGood);\n                let lastScale = scale(maximum);\n                let valueScale = scale(value);\n\n                let firstColor = settings.colors.badColor, secondColor = settings.colors.needsImprovementColor,\n                    thirdColor = settings.colors.satisfactoryColor, fourthColor = settings.colors.goodColor, lastColor = settings.colors.veryGoodColor;\n\n                BulletChart.addItemToBarArray(bulletModel.barRects, idx, firstScale, secondScale, firstColor, toolTipItems, categoryIdentity);\n                BulletChart.addItemToBarArray(bulletModel.barRects, idx, secondScale, thirdScale, secondColor, toolTipItems, categoryIdentity);\n                BulletChart.addItemToBarArray(bulletModel.barRects, idx, thirdScale, fourthScale, thirdColor, toolTipItems, categoryIdentity);\n                BulletChart.addItemToBarArray(bulletModel.barRects, idx, fourthScale, fifthScale, fourthColor, toolTipItems, categoryIdentity);\n                BulletChart.addItemToBarArray(bulletModel.barRects, idx, fifthScale, lastScale, lastColor, toolTipItems, categoryIdentity);\n                BulletChart.addItemToBarArray(bulletModel.valueRects, idx, firstScale, valueScale, settings.colors.bulletColor, toolTipItems, categoryIdentity);\n\n                // markerValue\n                bulletModel.targetValues.push({\n                    barIndex: idx,\n                    value: scale(targetValue),\n                    fill: settings.colors.bulletColor,\n                    key: SelectionId.createWithIdAndMeasure(categoryIdentity, scale(targetValue).toString()).getKey(),\n                    value2: scale(targetValue2),\n                });\n\n                let xAxis = null;\n                if (settings.axis.axis) {\n                    xAxis = d3.svg.axis();\n                    xAxis.orient(settings.orientation.vertical ? \"left\" : \"bottom\");\n                    let minTickSize = Math.round(Math.max(3, viewportLength / 100));\n                    let axisValues = [value, targetValue, good, satisfactory, maximum, minimum, needsImprovement, veryGood]\n                        .filter(x => !isNaN(x));\n                    xAxis.tickFormat(valueFormatter.create({\n                        format: bulletModel.bulletValueFormatString,\n                        value: axisValues.length ? Math.max.apply(null, axisValues) : 0\n                    }).format);\n                    xAxis.ticks(minTickSize);\n                    xAxis.scale(scale);\n                }\n\n                let bar: BarData = {\n                    scale: scale,\n                    barIndex: idx,\n                    categoryLabel: category,\n                    x: (settings.orientation.vertical) ? BulletChart.StartMarginVertical + BulletChart.SpaceRequiredForBarVertically * idx : BulletChart.StartMarginHorizontal,\n                    y: (settings.orientation.vertical) ? BulletChart.StartMarginVertical : BulletChart.StartMarginHorizontal + BulletChart.SpaceRequiredForBar * idx,\n                    axis: xAxis,\n                    key: SelectionId.createWithIdAndMeasure(categoryIdentity, idx.toString()).getKey(),\n                };\n\n                bulletModel.bars.push(bar);\n            }\n\n            return bulletModel;\n        }\n\n        private static addItemToBarArray(collection: BarRect[], barIndex: number, start: number, end: number, fill: string, tooltipInfo?: any[], categoryIdentity?: any): void {\n            collection.push({\n                barIndex: barIndex,\n                start: start,\n                end: end,\n                fill: fill,\n                tooltipInfo: TooltipBuilder.createTooltipInfo(bulletChartProps.formatString, null, null, null, null, tooltipInfo),\n                selected: false,\n                identity: SelectionId.createWithId(categoryIdentity),\n                key: SelectionId.createWithIdAndMeasure(categoryIdentity, start + \" \" + end).getKey(),\n            });\n        }\n \n        /* One time setup*/\n        public init(options: VisualInitOptions): void {\n            let body = d3.select(options.element.get(0));\n            this.hostService = options.host;\n\n            this.bulletBody = body\n                .append('div')\n                .classed('bulletChart', true);\n\n            this.scrollContainer = this.bulletBody.append('svg')\n                .classed('bullet-scroll-region', true);\n            this.clearCatcher = appendClearCatcher(this.scrollContainer);\n\n            this.labelGraphicsContext = this.scrollContainer.append('g');\n            this.bulletGraphicsContext = this.scrollContainer.append('g');\n\n            this.behavior = new BulletWebBehavior();\n\n            this.interactivityService = createInteractivityService(options.host);\n        }\n\n        /* Called for data, size, formatting changes*/\n        public update(options: VisualUpdateOptions) {\n            if (!options.dataViews || !options.dataViews[0]) return;\n            BulletChart.BiggestLabelHeight = BulletChart.BiggestLabelWidth = 0;\n            let dataView = options.dataViews[0];\n            this.viewport = options.viewport;\n            this.model = BulletChart.converter(dataView, options);\n\n            //TODO: Calculating the baseline delta of the text. needs to be removed once the TExtMeasurementService.estimateSVGTextBaselineDelta is available.\n            this.baselineDelta = TextMeasurementHelper.estimateSvgTextBaselineDelta(BulletChart.getTextProperties(\"1\", this.model.bulletChartSettings.labelSettings.fontSize));\n\n            this.ClearViewport();\n            if (!this.model) {\n                return;\n            }\n\n            if (this.interactivityService) {\n                this.interactivityService.applySelectionStateToData(this.model.barRects);\n            }\n\n            this.bulletBody.style({\n                'height': this.viewportIn.height + 'px',\n                'width': this.viewportIn.width + 'px',\n            });\n            if (this.vertical) {\n                this.scrollContainer.attr({\n                    width: (this.model.bars.length * BulletChart.SpaceRequiredForBarVertically) + 'px',\n                    height: this.viewportScroll.height + 'px'\n                });\n            }\n            else {\n                this.scrollContainer.attr({\n                    height: (this.model.bars.length * BulletChart.SpaceRequiredForBar) + 'px',\n                    width: this.viewportScroll.width + 'px'\n                });\n            }\n\n            if (this.vertical)\n                this.setUpBulletsVertically(this.bulletBody, this.model, this.reverse);\n            else\n                this.setUpBulletsHorizontally(this.bulletBody, this.model, this.reverse);\n        }\n\n        private ClearViewport() {\n            this.labelGraphicsContext.selectAll(\"text\").remove();\n            this.bulletGraphicsContext.selectAll(\"rect\").remove();\n            this.bulletGraphicsContext.selectAll('axis').remove();\n            this.bulletGraphicsContext.selectAll('path').remove();\n            this.bulletGraphicsContext.selectAll('line').remove();\n            this.bulletGraphicsContext.selectAll('tick').remove();\n            this.bulletGraphicsContext.selectAll('g').remove();\n        }\n\n        private calculateLabelWidth(barData: BarData, bar?: BarRect, reversed?: boolean) {\n            if (reversed)\n                return BulletChart.StartMarginHorizontal + ((bar) ? bar.start : 0);\n\n            let textSize = TextMeasurementService.measureSvgTextWidth(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));\n            if (textSize > BulletChart.BiggestLabelWidth)\n                return barData.x + BulletChart.MaxLabelWidth + ((bar) ? bar.start : 0);\n            return barData.x + BulletChart.BiggestLabelWidth + BulletChart.BarMargin + ((bar) ? bar.start : 0);\n        }\n\n        private calculateLabelHeight(barData: BarData, bar?: BarRect, reversed?: boolean) {\n            if (reversed)\n                return BulletChart.StartMarginVertical + ((bar) ? bar.end : 0);\n\n            let textSize = TextMeasurementService.measureSvgTextHeight(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));\n            if (textSize > BulletChart.BiggestLabelHeight)\n                return barData.y + BulletChart.MaxLabelHeight + ((bar) ? bar.end : 0);\n            return barData.y + textSize + BulletChart.BarMargin + ((bar) ? bar.end : 0);\n        }\n\n        private setUpBulletsHorizontally(bulletBody: D3.Selection, model: BulletChartModel, reveresed: boolean) {\n            let bars = model.bars;\n            let rects = model.barRects;\n            let valueRects = model.valueRects;\n            let targetValues = model.targetValues;\n            let barSelection = this.labelGraphicsContext.selectAll('text').data(bars, (d: BarData) => d.key);\n            let rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, (d: BarRect) => d.key);\n\n            // Draw bullets\n            let bullets = rectSelection.enter().append('rect').attr({\n                'x': ((d: BarRect) => { return this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),\n                'y': ((d: BarRect) => bars[d.barIndex].y - BulletChart.BulletSize / 2),\n                'width': ((d: BarRect) => d.end - d.start),\n                'height': BulletChart.BulletSize,\n            }).classed('range', true).style({\n                'fill': ((d: BarRect) => d.fill)\n            });\n\n            rectSelection.exit();\n\n            // Draw value rects\n            let valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, (d: BarValueRect) => d.key);\n            valueSelection.enter().append('rect').attr({\n                'x': ((d: BarValueRect) => { return this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),\n                'y': ((d: BarValueRect) => bars[d.barIndex].y - BulletChart.BulletSize / 8),\n                'width': ((d: BarValueRect) => d.end - d.start),\n                'height': BulletChart.BulletSize * 1 / 4,\n            }).classed('value', true).style({\n                'fill': ((d: BarValueRect) => d.fill),\n            });\n\n            valueSelection.exit();\n            // Draw markers\n            let markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, (d: TargetValue) => d.key);\n            markerSelection.enter().append('line').attr({\n                'x1': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),\n                'x2': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),\n                'y1': ((d: TargetValue) => bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal),\n                'y2': ((d: TargetValue) => bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal),\n            }).style({\n                'stroke': ((d: TargetValue) => d.fill),\n                'stroke-width': 2,\n            });\n\n            markerSelection.enter().append('line').attr({\n                'x1': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\n                'x2': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\n                'y1': ((d: TargetValue) => bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal),\n                'y2': ((d: TargetValue) => bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal),\n            }).style({\n                'stroke': ((d: TargetValue) => d.fill),\n                'stroke-width': 2,\n                'transform': 'rotate(45deg)',\n                'transform-origin': '50% 50% 0',\n            });\n\n            markerSelection.enter().append('line').attr({\n                'x1': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\n                'x2': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\n                'y1': ((d: TargetValue) => bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal),\n                'y2': ((d: TargetValue) => bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal),\n            }).style({\n                'stroke': ((d: TargetValue) => d.fill),\n                'stroke-width': 2,\n                'transform': 'rotate(315deg)',\n                'transform-origin': '50% 50% 0',\n            });\n\n            markerSelection.exit();\n\n            // Draw axes\n            if (model.bulletChartSettings.axis.axis) {\n                // Using var instead of let since you can't pass let parameters to functions inside loops.\n                // needs to be changed to let when typescript 1.8 comes out.\n                for (var idx = 0; idx < bars.length; idx++) {\n                    var bar = bars[idx];\n                    this.bulletGraphicsContext.append(\"g\").attr({\n                        'transform': () => {\n                            let xLocation = this.calculateLabelWidth(bar, null, reveresed);\n                            let yLocation = bar.y + BulletChart.BulletSize / 2;\n\n                            return 'translate(' + xLocation + ',' + yLocation + ')';\n                        },\n                    }).classed(\"axis\", true).call(bar.axis.scale(bar.scale)).style({\n                        'fill': model.bulletChartSettings.axis.axisColor,\n                        'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)\n                    }).selectAll('line').style({\n                        'stroke': model.bulletChartSettings.axis.axisColor,\n                    });\n                }\n            }\n\n            // Draw Labels\n            if (model.bulletChartSettings.labelSettings.show) {\n                barSelection.enter().append('text').classed(\"title\", true).attr({\n                    'x': ((d: BarData) => {\n                        if (reveresed)\n                            return this.bulletGraphicsContext.node<SVGElement>().getBoundingClientRect().width + BulletChart.StartMarginHorizontal;\n                        return d.x;\n                    }),\n                    'y': ((d: BarData) => d.y + this.baselineDelta),\n                    'fill': model.bulletChartSettings.labelSettings.labelColor,\n                    'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),\n                }).text((d: BarData) => d.categoryLabel);\n            }\n\n            // Draw measure label\n            if (model.bulletChartSettings.axis.measureUnits) {\n                barSelection.enter().append('text').attr({\n                    'x': ((d: BarData) => {\n                        if (reveresed)\n                            return this.bulletGraphicsContext.node<SVGElement>().getBoundingClientRect().width - BulletChart.StartMarginHorizontal + BulletChart.SubtitleMargin;\n                        return d.x - BulletChart.SubtitleMargin;\n                    }),\n                    'y': ((d: BarData) => d.y + BulletChart.BulletSize),\n                    'fill': model.bulletChartSettings.axis.unitsColor,\n                    'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)\n                }).text(model.bulletChartSettings.axis.measureUnits);\n            }\n\n            if (this.interactivityService) {\n                let behaviorOptions: BulletBehaviorOptions = {\n                    rects: bullets,\n                    valueRects: valueSelection,\n                    clearCatcher: this.clearCatcher,\n                    interactivityService: this.interactivityService,\n                    bulletChartSettings: this.model.bulletChartSettings,\n                    hasHighlights: false,\n                };\n\n                let targetCollection = this.model.barRects.concat(this.model.valueRects);\n                this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);\n            }\n\n            barSelection.exit();\n            TooltipManager.addTooltip(valueSelection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo, true);\n            TooltipManager.addTooltip(rectSelection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo, true);\n        }\n\n        private setUpBulletsVertically(bulletBody: D3.Selection, model: BulletChartModel, reveresed: boolean) {\n            let bars = model.bars;\n            let rects = model.barRects;\n            let valueRects = model.valueRects;\n            let targetValues = model.targetValues;\n            let barSelection = this.labelGraphicsContext.selectAll('text').data(bars, (d: BarData) => d.key);\n            let rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, (d: BarRect) => d.key);\n\n            // Draw bullets\n            let bullets = rectSelection.enter().append('rect').attr({\n                'x': ((d: BarRect) => bars[d.barIndex].x),\n                'y': ((d: BarRect) => { return this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),\n                'height': ((d: BarRect) => d.start - d.end),\n                'width': BulletChart.BulletSize,\n            }).classed('range', true).style({\n                'fill': ((d: BarRect) => d.fill)\n            });\n\n            rectSelection.exit();\n\n            // Draw value rects\n            let valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, (d: BarValueRect) => d.key);\n            valueSelection.enter().append('rect').attr({\n                'x': ((d: BarValueRect) => bars[d.barIndex].x + BulletChart.BulletSize / 3),\n                'y': ((d: BarValueRect) => { return this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),\n                'height': ((d: BarValueRect) => d.start - d.end),\n                'width': BulletChart.BulletSize * 1 / 4,\n            }).classed('value', true).style({\n                'fill': ((d: BarValueRect) => d.fill),\n            });\n\n            valueSelection.exit();\n\n            // Draw markers\n            let markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, (d: TargetValue) => d.key);\n            markerSelection.enter().append('line').attr({\n                'x2': ((d: TargetValue) => bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3)),\n                'x1': ((d: TargetValue) => bars[d.barIndex].x + BulletChart.MarkerMarginVertical),\n                'y2': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),\n                'y1': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),\n            }).style({\n                'stroke': ((d: TargetValue) => d.fill),\n                'stroke-width': 2,\n            });\n\n            markerSelection.enter().append('line').attr({\n                'y1': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\n                'y2': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\n                'x1': ((d: TargetValue) => bars[d.barIndex].x + BulletChart.MarkerMarginVertical),\n                'x2': ((d: TargetValue) => bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3)),\n            }).style({\n                'stroke': ((d: TargetValue) => d.fill),\n                'stroke-width': 2,\n                'transform': 'rotate(45deg)',\n                'transform-origin': '50% 50% 0',\n            });\n\n            markerSelection.enter().append('line').attr({\n                'y1': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\n                'y2': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\n                'x1': ((d: TargetValue) => bars[d.barIndex].x + BulletChart.MarkerMarginVertical),\n                'x2': ((d: TargetValue) => bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3)),\n            }).style({\n                'stroke': ((d: TargetValue) => d.fill),\n                'stroke-width': 2,\n                'transform': 'rotate(315deg)',\n                'transform-origin': '50% 50% 0',\n            });\n\n            markerSelection.exit();\n\n            // // Draw axes\n            if (model.bulletChartSettings.axis.axis) {\n\n                // Using var instead of let since you can't pass let parameters to functions inside loops.\n                // needs to be changed to let when typescript 1.8 comes out.\n                for (var idx = 0; idx < bars.length; idx++) {\n                    var bar = bars[idx];\n                    this.bulletGraphicsContext.append(\"g\").attr({\n                        'transform': () => {\n                            let xLocation = bar.x;\n                            let yLocation = this.calculateLabelHeight(bar, null, reveresed);\n                            // let yLocation = bar.y + BulletChart.BulletSize / 2;\n                            return 'translate(' + xLocation + ',' + yLocation + ')';\n                        },\n                    }).classed(\"axis\", true).call(bar.axis.scale(bar.scale)).style({\n                        'fill': model.bulletChartSettings.axis.axisColor,\n                        'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt),\n                    }).selectAll('line').style({\n                        'stroke': model.bulletChartSettings.axis.axisColor,\n                    });\n                }\n            }\n\n            // Draw Labels\n            if (model.bulletChartSettings.labelSettings.show) {\n                barSelection.enter().append('text').classed(\"title\", true).attr({\n                    'x': ((d: BarData) => d.x),\n                    'y': ((d: BarData) => {\n                        if (reveresed)\n                            return this.bulletGraphicsContext.node<SVGElement>().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.BulletSize;\n                        return d.y + TextMeasurementService.estimateSvgTextHeight(BulletChart.getTextProperties(d.categoryLabel,\n                            model.bulletChartSettings.labelSettings.fontSize)) / 2;\n                    }),\n                    'fill': model.bulletChartSettings.labelSettings.labelColor,\n                    'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),\n                }).text((d: BarData) => d.categoryLabel);\n            }\n\n            // Draw measure label\n            if (model.bulletChartSettings.axis.measureUnits) {\n                barSelection.enter().append('text').attr({\n                    'x': ((d: BarData) => d.x + BulletChart.BulletSize),\n                    'y': ((d: BarData) => {\n                        if (reveresed)\n                            return this.bulletGraphicsContext.node<SVGElement>().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;\n                        return d.y + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;\n                    }),\n                    'fill': model.bulletChartSettings.axis.unitsColor,\n                    'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)\n                }).text(model.bulletChartSettings.axis.measureUnits);\n            }\n\n            if (this.interactivityService) {\n                let behaviorOptions: BulletBehaviorOptions = {\n                    rects: bullets,\n                    valueRects: valueSelection,\n                    clearCatcher: this.clearCatcher,\n                    interactivityService: this.interactivityService,\n                    bulletChartSettings: this.model.bulletChartSettings,\n                    hasHighlights: false,\n                };\n\n                let targetCollection = this.model.barRects.concat(this.model.valueRects);\n                this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);\n            }\n\n            barSelection.exit();\n            TooltipManager.addTooltip(valueSelection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo, true);\n            TooltipManager.addTooltip(rectSelection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo, true);\n        }\n\n        /*About to remove your visual, do clean up here */\n        public destroy() { }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\n            let data = this.model;\n            if (!data) {\n                return;\n            }\n\n            let objectName = options.objectName;\n            switch (objectName) {\n                case 'labels':\n                    return this.enumerateLabels(data);\n                case 'values':\n                    return this.enumerateValues(data);\n                case 'orientation':\n                    return this.enumerateOrientation(data);\n                case 'axis':\n                    return this.enumerateAxis(data);\n                case 'colors':\n                    return this.enumerateColors(data);\n            }\n        }\n\n        private enumerateLabels(data: BulletChartModel): VisualObjectInstance[] {\n            return [{\n                selector: null,\n                objectName: 'labels',\n                properties: {\n                    show: this.model.bulletChartSettings.labelSettings.show,\n                    labelColor: this.model.bulletChartSettings.labelSettings.labelColor,\n                    fontSize: this.model.bulletChartSettings.labelSettings.fontSize,\n                }\n            }];\n        }\n\n        private enumerateValues(data: BulletChartModel): VisualObjectInstance[] {\n            return [{\n                selector: null,\n                objectName: 'values',\n                properties: {\n                    targetValue: this.model.bulletChartSettings.values.targetValue,\n                    targetValue2: this.model.bulletChartSettings.values.targetValue2,\n                    minimumPercent: this.model.bulletChartSettings.values.minimumPercent,\n                    needsImprovementPercent: this.model.bulletChartSettings.values.needsImprovementPercent,\n                    satisfactoryPercent: this.model.bulletChartSettings.values.satisfactoryPercent,\n                    goodPercent: this.model.bulletChartSettings.values.goodPercent,\n                    veryGoodPercent: this.model.bulletChartSettings.values.veryGoodPercent,\n                    maximumPercent: this.model.bulletChartSettings.values.maximumPercent,\n                }\n            }];\n        }\n\n        private enumerateOrientation(data: BulletChartModel): VisualObjectInstance[] {\n            return [{\n                selector: null,\n                objectName: 'orientation',\n                properties: {\n                    orientation: this.model.bulletChartSettings.orientation.orientation\n                }\n            }];\n        }\n\n        private enumerateAxis(data: BulletChartModel): VisualObjectInstance[] {\n            return [{\n                selector: null,\n                objectName: 'axis',\n                properties: {\n                    axis: this.model.bulletChartSettings.axis.axis,\n                    axisColor: this.model.bulletChartSettings.axis.axisColor,\n                    measureUnits: this.model.bulletChartSettings.axis.measureUnits,\n                    unitsColor: this.model.bulletChartSettings.axis.unitsColor,\n                }\n            }];\n        }\n\n        private enumerateColors(data: BulletChartModel): VisualObjectInstance[] {\n            return [{\n                selector: null,\n                objectName: 'colors',\n                properties: {\n                    badColor: this.model.bulletChartSettings.colors.badColor,\n                    needsImprovementColor: this.model.bulletChartSettings.colors.needsImprovementColor,\n                    satisfactoryColor: this.model.bulletChartSettings.colors.satisfactoryColor,\n                    goodColor: this.model.bulletChartSettings.colors.goodColor,\n                    veryGoodColor: this.model.bulletChartSettings.colors.veryGoodColor,\n                    bulletColor: this.model.bulletChartSettings.colors.bulletColor,\n                }\n            }];\n        }\n    }\n\n    //TODO: This module should be removed once TextMeasruementService exports the \"estimateSvgTextBaselineDelta\" function.\n    export module TextMeasurementHelper {\n\n        interface CanvasContext {\n            font: string;\n            measureText(text: string): { width: number };\n        }\n\n        interface CanvasElement extends HTMLElement {\n            getContext(name: string);\n        }\n\n        let spanElement: JQuery;\n        let svgTextElement: D3.Selection;\n        let canvasCtx: CanvasContext;\n\n        export function estimateSvgTextBaselineDelta(textProperties: TextProperties): number {\n            let rect = estimateSvgTextRect(textProperties);\n            return rect.y + rect.height;\n        }\n\n        function ensureDOM(): void {\n            if (spanElement)\n                return;\n\n            spanElement = $('<span/>');\n            $('body').append(spanElement);\n            //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.\n            svgTextElement = d3.select($('body').get(0))\n                .append('svg')\n                .style({\n                    'height': '0px',\n                    'width': '0px',\n                    'position': 'absolute'\n                })\n                .append('text');\n            canvasCtx = (<CanvasElement>$('<canvas/>').get(0)).getContext(\"2d\");\n        }\n\n        function measureSvgTextRect(textProperties: TextProperties): SVGRect {\n            debug.assertValue(textProperties, 'textProperties');\n\n            ensureDOM();\n\n            svgTextElement.style(null);\n            svgTextElement\n                .text(textProperties.text)\n                .attr({\n                    'visibility': 'hidden',\n                    'font-family': textProperties.fontFamily,\n                    'font-size': textProperties.fontSize,\n                    'font-weight': textProperties.fontWeight,\n                    'font-style': textProperties.fontStyle,\n                    'white-space': textProperties.whiteSpace || 'nowrap'\n                });\n\n            // We're expecting the browser to give a synchronous measurement here\n            // We're using SVGTextElement because it works across all browsers \n            return svgTextElement.node<SVGTextElement>().getBBox();\n        }\n\n        function estimateSvgTextRect(textProperties: TextProperties): SVGRect {\n            debug.assertValue(textProperties, 'textProperties');\n\n            let estimatedTextProperties: TextProperties = {\n                fontFamily: textProperties.fontFamily,\n                fontSize: textProperties.fontSize,\n                text: \"M\",\n            };\n\n            let rect = measureSvgTextRect(estimatedTextProperties);\n\n            return rect;\n        }\n    }\n\n    export interface BulletBehaviorOptions {\n        rects: D3.Selection;\n        valueRects: D3.Selection;\n        clearCatcher: D3.Selection;\n        interactivityService: IInteractivityService;\n        bulletChartSettings: BulletChartSettings;\n        hasHighlights: boolean;\n    }\n\n    export class BulletWebBehavior implements IInteractiveBehavior {\n        private options: BulletBehaviorOptions;\n\n        public bindEvents(options: BulletBehaviorOptions, selectionHandler: ISelectionHandler) {\n            this.options = options;\n            let clearCatcher = options.clearCatcher;\n\n            options.valueRects.on('click', (d: BarValueRect, i: number) => {\n                d3.event.stopPropagation();\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\n            });\n\n            options.rects.on('click', (d: BarRect, i: number) => {\n                d3.event.stopPropagation();\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\n            });\n\n            clearCatcher.on('click', () => {\n                selectionHandler.handleClearSelection();\n            });\n        }\n\n        public renderSelection(hasSelection: boolean) {\n            let options = this.options;\n\n            options.valueRects.style(\"opacity\", (d: BarValueRect) => {\n                return hasSelection ? (d.selected ? '1' : '0.4') : '1';\n            });\n\n            options.rects.style(\"opacity\", (d: BarRect) => {\n                return hasSelection ? (d.selected ? '1' : '0.4') : '1';\n            });\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/ https://github.com/jasondavies/d3-cloud\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\n\nmodule powerbi.visuals.samples {\n    import ValueFormatter = powerbi.visuals.valueFormatter;\n    import getAnimationDuration = AnimatorCommon.GetAnimationDuration;\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n\n    type D3Element =\n        D3.UpdateSelection\n        | D3.Selection\n        | D3.Selectors\n        | D3.Transition.Transition;\n\n    export enum WordCloudScaleType {\n        logn,\n        sqrt,\n        value\n    };\n\n    export interface WordCloudText {\n        text: string;\n        count: number;\n        index: number;\n        selectionId: SelectionId;\n        color: string;\n    }\n\n    export interface WordCloudDataPoint extends IPoint {\n        text: string;\n        xOff: number;\n        yOff: number;\n        rotate?: number;\n        size: number;\n        padding: number;\n        width: number;\n        height: number;\n        sprite?: number[];\n        x0: number;\n        y0: number;\n        x1: number;\n        y1: number;\n        color: string;\n        selectionId: SelectionId;\n        wordIndex: number;\n    }\n\n    export interface WordCloudData {\n        settings: WordCloudSettings;\n        texts: WordCloudText[];\n    }\n\n    export interface WordCloudDataView {\n        data: WordCloudDataPoint[];\n        leftBorder: IPoint;\n        rightBorder: IPoint;\n    }\n\n    export interface WordCloudConstructorOptions {\n        svg?: D3.Selection;\n        animator?: IGenericAnimator;\n        margin?: IMargin;\n    }\n\n    export interface WordCloudSettings {\n        minFontSize: number;\n        maxFontSize: number;\n        minAngle?: number;\n        maxAngle?: number;\n        maxNumberOfOrientations?: number;\n        valueFormatter?: IValueFormatter;\n        isRotateText: boolean;\n        isBrokenText: boolean;\n        isRemoveStopWords: boolean;\n        stopWords: string;\n        isDefaultStopWords: boolean;\n        stopWordsArray: string[];\n        maxNumberOfWords: number;\n    }\n\n    class VisualLayout {\n        private marginValue: IMargin;\n        private viewportValue: IViewport;\n        private viewportInValue: IViewport;\n\n        public defaultMargin: IMargin;\n        public defaultViewport: IViewport;\n\n        constructor(defaultViewport?: IViewport, defaultMargin?: IMargin) {\n            this.defaultViewport = defaultViewport || { width: 0, height: 0 };\n            this.defaultMargin = defaultMargin || { top: 0, bottom: 0, right: 0, left: 0 };\n        }\n\n        public get margin(): IMargin {\n            return this.marginValue || (this.margin = this.defaultMargin);\n        }\n\n        public set margin(value: IMargin) {\n            this.marginValue = VisualLayout.restrictToMinMax(value);\n            this.update();\n        }\n\n        public get viewport(): IViewport {\n            return this.viewportValue || (this.viewportValue = this.defaultViewport);\n        }\n\n        public set viewport(value: IViewport) {\n            this.viewportValue = VisualLayout.restrictToMinMax(value);\n            this.update();\n        }\n\n        public get viewportIn(): IViewport {\n            return this.viewportInValue || this.viewport;\n        }\n\n        public get viewportInIsZero(): boolean {\n            return this.viewportIn.width === 0 || this.viewportIn.height === 0;\n        }\n\n        private update(): void {\n            this.viewportInValue = VisualLayout.restrictToMinMax({\n                width: this.viewport.width - (this.margin.left + this.margin.right),\n                height: this.viewport.height - (this.margin.top + this.margin.bottom)\n            });\n        }\n\n        private static restrictToMinMax<T>(value: T): T {\n            let result = $.extend({}, value);\n            d3.keys(value).forEach(x => result[x] = Math.max(0, value[x]));\n            return result;\n        }\n    }\n\n    export class WordCloud implements IVisual {\n        private static ClassName: string = \"wordCloud\";\n\n        private static Properties: any = {\n            general: {\n                formatString: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"general\",\n                    propertyName: \"formatString\"\n                },\n                maxNumberOfWords: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"general\",\n                    propertyName: \"maxNumberOfWords\"\n                },\n                minFontSize: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"general\",\n                    propertyName: \"minFontSize\"\n                },\n                maxFontSize: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"general\",\n                    propertyName: \"maxFontSize\"\n                },\n                isBrokenText: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"general\",\n                    propertyName: \"isBrokenText\"\n                },\n            },\n            dataPoint: {\n                fill: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"dataPoint\",\n                    propertyName: \"fill\"\n                }\n            },\n            stopWords: {\n                show: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"stopWords\",\n                    propertyName: \"show\"\n                },\n                isDefaultStopWords: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"stopWords\",\n                    propertyName: \"isDefaultStopWords\"\n                },\n                words: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"stopWords\",\n                    propertyName: \"words\"\n                },\n            },\n            rotateText: {\n                show: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"rotateText\",\n                    propertyName: \"show\"\n                },\n                minAngle: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"rotateText\",\n                    propertyName: \"minAngle\"\n                },\n                maxAngle: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"rotateText\",\n                    propertyName: \"maxAngle\"\n                },\n                maxNumberOfOrientations: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"rotateText\",\n                    propertyName: \"maxNumberOfOrientations\"\n                }\n            }\n        };\n\n        private static Words: ClassAndSelector = {\n            \"class\": \"words\",\n            selector: \".words\"\n        };\n\n        private static Word: ClassAndSelector = {\n            \"class\": \"word\",\n            selector: \".word\"\n        };\n\n        private static Size: string = \"px\";\n        private static StopWordsDelemiter: string = \" \";\n\n        private static Radians: number = Math.PI / 180;\n\n        private static MinAngle: number = -180;\n        private static MaxAngle: number = 180;\n\n        private static MaxNumberOfWords: number = 2500;\n\n        private static MinOpacity: number = 0.2;\n        private static MaxOpacity: number = 1;\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [{\n                name: \"Category\",\n                kind: VisualDataRoleKind.Grouping,\n                displayName: \"Category\"\n            }, {\n                    name: \"Values\",\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: \"Values\"\n                }],\n            dataViewMappings: [{\n                conditions: [{\n                    \"Category\": {\n                        min: 1,\n                        max: 1\n                    },\n                    \"Values\": {\n                        min: 0,\n                        max: 1\n                    }\n                }],\n                categorical: {\n                    categories: {\n                        for: { in: \"Category\" },\n                        dataReductionAlgorithm: { top: { count: WordCloud.MaxNumberOfWords } }\n                    },\n                    values: {\n                        for: { in: \"Values\" }\n                    }\n                }\n            }],\n            sorting: {\n                implicit: {\n                    clauses: [{\n                        role: \"Values\",\n                        direction: 2 /*SortDirection.Descending*/ //Constant SortDirection.Descending currently is not supported on the msit\n                    }]\n                }\n            },\n            objects: {\n                general: {\n                    displayName: \"General\",\n                    properties: {\n                        formatString: {\n                            type: {\n                                formatting: {\n                                    formatString: true\n                                }\n                            }\n                        },\n                        maxNumberOfWords: {\n                            displayName: \"Max number of words\",\n                            type: { numeric: true }\n                        },\n                        minFontSize: {\n                            displayName: \"Min Font\",\n                            type: { numeric: true }\n                        },\n                        maxFontSize: {\n                            displayName: \"Max Font\",\n                            type: { numeric: true }\n                        },\n                        isBrokenText: {\n                            displayName: \"Word-breaking\",\n                            type: { bool: true }\n                        },\n                        isRemoveStopWords: {\n                            displayName: \"Stop Words\",\n                            type: { bool: true }\n                        }\n                    }\n                },\n                dataPoint: {\n                    displayName: \"Data colors\",\n                    properties: {\n                        fill: {\n                            displayName: \"Fill\",\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                },\n                stopWords: {\n                    displayName: \"Stop Words\",\n                    properties: {\n                        show: {\n                            displayName: \"Show\",\n                            type: { bool: true }\n                        },\n                        isDefaultStopWords: {\n                            displayName: \"Default Stop Words\",\n                            type: { bool: true }\n                        },\n                        words: {\n                            displayName: \"Words\",\n                            type: { text: true }\n                        }\n                    }\n                },\n                rotateText: {\n                    displayName: \"Rotate Text\",\n                    properties: {\n                        show: {\n                            displayName: \"Show\",\n                            type: { bool: true }\n                        },\n                        minAngle: {\n                            displayName: \"Min Angle\",\n                            type: { numeric: true }\n                        },\n                        maxAngle: {\n                            displayName: \"Max Angle\",\n                            type: { numeric: true }\n                        },\n                        maxNumberOfOrientations: {\n                            displayName: \"Max number of orientations\",\n                            type: { numeric: true }\n                        }\n                    }\n                }\n            }\n        };\n\n        private static Punctuation: string[] = [\n            \"!\", \".\", \":\", \"'\", \";\", \",\", \"!\",\n            \"@\", \"#\", \"$\", \"%\", \"^\", \"&\", \"*\",\n            \"(\", \")\", \"[\", \"]\", \"\\\"\", \"\\\\\", \"/\",\n            \"-\", \"_\", \"+\", \"=\"\n        ];\n\n        private static StopWords: string[] = [\n            \"a\", \"able\", \"about\", \"across\", \"after\", \"all\", \"almost\", \"also\", \"am\", \"among\", \"an\",\n            \"and\", \"any\", \"are\", \"as\", \"at\", \"be\", \"because\", \"been\", \"but\", \"by\", \"can\", \"cannot\",\n            \"could\", \"did\", \"do\", \"does\", \"either\", \"else\", \"ever\", \"every\", \"for\", \"from\", \"get\",\n            \"got\", \"had\", \"has\", \"have\", \"he\", \"her\", \"hers\", \"him\", \"his\", \"how\", \"however\", \"i\",\n            \"if\", \"in\", \"into\", \"is\", \"it\", \"its\", \"just\", \"least\", \"let\", \"like\", \"likely\", \"may\",\n            \"me\", \"might\", \"most\", \"must\", \"my\", \"neither\", \"no\", \"nor\", \"not\", \"of\", \"off\", \"often\",\n            \"on\", \"only\", \"or\", \"other\", \"our\", \"own\", \"rather\", \"said\", \"say\", \"says\", \"she\", \"should\",\n            \"since\", \"so\", \"some\", \"than\", \"that\", \"the\", \"their\", \"them\", \"then\", \"there\", \"these\",\n            \"they\", \"this\", \"tis\", \"to\", \"too\", \"twas\", \"us\", \"wants\", \"was\", \"we\", \"were\", \"what\",\n            \"when\", \"where\", \"which\", \"while\", \"who\", \"whom\", \"why\", \"will\", \"with\", \"would\", \"yet\",\n            \"you\", \"your\"\n        ];\n\n        private static DefaultSettings: WordCloudSettings = {\n            minFontSize: 20,\n            maxFontSize: 100,\n            minAngle: -60,\n            maxAngle: 90,\n            maxNumberOfOrientations: 2,\n            isRotateText: false,\n            isBrokenText: true,\n            isRemoveStopWords: false,\n            stopWordsArray: [],\n            stopWords: undefined,\n            isDefaultStopWords: false,\n            maxNumberOfWords: 200\n        };\n\n        private static RenderDelay: number = 50;\n\n        private static DefaultMargin: IMargin = {\n            top: 10,\n            right: 10,\n            bottom: 10,\n            left: 10\n        };\n\n        private settings: WordCloudSettings;\n        private wordCloudTexts: WordCloudText[];\n        private wordCloudDataView: WordCloudDataView;\n        private data: WordCloudData;\n        private dataBeforeRender: WordCloudDataPoint[];\n\n        private durationAnimations: number = 500;\n\n        private specialViewport: IViewport;\n\n        private fakeViewport: IViewport = {\n            width: 1500,\n            height: 1000\n        };\n\n        private canvasViewport: IViewport = {\n            width: 128,\n            height: 2048\n        };\n\n        public static colors: IDataColorPalette;\n        private root: D3.Selection;\n        private svg: D3.Selection;\n        private main: D3.Selection;\n        private wordsContainerSelection: D3.Selection;\n        private wordsSelection: D3.UpdateSelection;\n\n        private canvas: HTMLCanvasElement;\n\n        private fontFamily: string;\n\n        private animator: IGenericAnimator;\n\n        private layout: VisualLayout;\n\n        private hostService: IVisualHostServices;\n        private selectionManager: utility.SelectionManager;\n\n        private visualUpdateOptions: VisualUpdateOptions;\n\n        constructor(options?: WordCloudConstructorOptions) {\n            if (options) {\n                this.svg = options.svg || this.svg;\n                this.layout = new VisualLayout(null, options.margin || WordCloud.DefaultMargin);\n\n                if (options.animator)\n                    this.animator = options.animator;\n            }\n        }\n\n        public init(options: VisualInitOptions): void {\n            if (this.svg)\n                this.root = this.svg;\n            else\n                this.root = d3.select(options.element.get(0)).append(\"svg\");\n\n            WordCloud.colors = options.style.colorPalette.dataColors;\n            this.hostService = options.host;\n            this.selectionManager = new utility.SelectionManager({ hostServices: this.hostService });\n\n            if (!this.layout)\n                this.layout = new VisualLayout(null, WordCloud.DefaultMargin);\n\n            this.root.classed(WordCloud.ClassName, true);\n\n            this.root.on(\"click\", () => {\n                this.selectionManager.clear();\n                this.setSelection(this.wordsSelection);\n            });\n\n            this.fontFamily = this.root.style(\"font-family\");\n\n            this.main = this.root.append(\"g\");\n\n            this.wordsContainerSelection = this.main\n                .append(\"g\")\n                .classed(WordCloud.Words[\"class\"], true);\n\n            this.canvas = document.createElement(\"canvas\");\n        }\n\n        public converter(dataView: DataView): WordCloudData {\n            if (!dataView ||\n                !dataView.categorical ||\n                !dataView.categorical.categories ||\n                !dataView.categorical.categories[0] ||\n                !dataView.categorical.categories[0].values ||\n                !dataView.categorical.categories[0].values.length ||\n                !(dataView.categorical.categories[0].values.length > 0))\n                return null;\n\n            let categories: string[] = dataView.categorical.categories[0].values,\n                settings: WordCloudSettings = WordCloud.parseSettings(dataView, categories[0]),\n                frequencies: number[],\n                texts: WordCloudText[];\n            if (!settings)\n                return null;\n\n            if (!_.isEmpty(dataView.categorical.values) &&\n                !_.isEmpty(dataView.categorical.values[0]) &&\n                !_.isEmpty(dataView.categorical.values[0].values))\n                frequencies = dataView.categorical.values[0].values;\n\n            texts = categories.map((item: string, index: number) => {\n                let color, categoryObject = dataView.categorical.categories[0];\n                if (categoryObject.objects && categoryObject.objects[index])\n                    color = this.getColor(WordCloud.Properties.dataPoint.fill, explore.util.getRandomColor(), categoryObject.objects[index]);\n                else {\n                    if (this.wordCloudTexts && this.wordCloudTexts[index])\n                        color = this.wordCloudTexts[index].color;\n                    else\n                        color = explore.util.getRandomColor();\n                }\n\n                return <WordCloudText>{\n                    text: item,\n                    count: (frequencies && frequencies[index] && !isNaN(frequencies[index])) ? frequencies[index] : 1,\n                    index: index,\n                    selectionId: SelectionId.createWithId(dataView.categorical.categories[0].identity[index]),\n                    color: color,\n                };\n            });\n\n            return <WordCloudData>{\n                settings: settings,\n                texts: texts\n            };\n        }\n\n        private getColor(properties: any, defaultColor: string, objects: DataViewObjects): string {\n            let colorHelper: ColorHelper;\n\n            colorHelper = new ColorHelper(WordCloud.colors, properties, defaultColor);\n\n            return explore.util.hexToRgb(colorHelper.getColorForMeasure(objects, \"\"));\n        }\n\n        private static parseSettings(dataView: DataView, value: any): WordCloudSettings {\n            if (!dataView ||\n                !dataView.metadata ||\n                !dataView.metadata.columns ||\n                !dataView.metadata.columns[0])\n                return null;\n\n            let objects: DataViewObjects = dataView.metadata.objects,\n                valueFormatter: IValueFormatter,\n                minFontSize: number,\n                maxFontSize: number,\n                minAngle: number,\n                maxAngle: number,\n                maxNumberOfOrientations: number,\n                isRotateText: boolean = false,\n                isBrokenText: boolean = true,\n                isRemoveStopWords: boolean = true,\n                stopWords: string,\n                stopWordsArray: string[],\n                isDefaultStopWords: boolean = false,\n                maxNumberOfWords: number;\n\n            maxNumberOfWords = WordCloud.getNumberFromObjects(\n                objects,\n                WordCloud.Properties.general.maxNumberOfWords,\n                WordCloud.DefaultSettings.maxNumberOfWords);\n\n            minFontSize = WordCloud.getNumberFromObjects(\n                objects,\n                WordCloud.Properties.general.minFontSize,\n                WordCloud.DefaultSettings.minFontSize);\n\n            maxFontSize = WordCloud.getNumberFromObjects(\n                objects,\n                WordCloud.Properties.general.maxFontSize,\n                WordCloud.DefaultSettings.maxFontSize);\n\n            minAngle = WordCloud.getNumberFromObjects(\n                objects,\n                WordCloud.Properties.rotateText.minAngle,\n                WordCloud.DefaultSettings.minAngle);\n\n            maxAngle = WordCloud.getNumberFromObjects(\n                objects,\n                WordCloud.Properties.rotateText.maxAngle,\n                WordCloud.DefaultSettings.maxAngle);\n\n            isRotateText = DataViewObjects.getValue<boolean>(\n                objects,\n                WordCloud.Properties.rotateText.show,\n                WordCloud.DefaultSettings.isRotateText);\n\n            maxNumberOfOrientations = WordCloud.getNumberFromObjects(\n                objects,\n                WordCloud.Properties.rotateText.maxNumberOfOrientations,\n                WordCloud.DefaultSettings.maxNumberOfOrientations);\n\n            valueFormatter = ValueFormatter.create({\n                format: ValueFormatter.getFormatString(\n                    dataView.categorical.categories[0].source,\n                    WordCloud.Properties.general.formatString),\n                value: value\n            });\n\n            isBrokenText = DataViewObjects.getValue<boolean>(\n                objects,\n                WordCloud.Properties.general.isBrokenText,\n                WordCloud.DefaultSettings.isBrokenText);\n\n            isRemoveStopWords = DataViewObjects.getValue<boolean>(\n                objects,\n                WordCloud.Properties.stopWords.show,\n                WordCloud.DefaultSettings.isRemoveStopWords);\n\n            stopWords = DataViewObjects.getValue(\n                objects,\n                WordCloud.Properties.stopWords.words,\n                WordCloud.DefaultSettings.stopWords);\n\n            if (typeof stopWords === \"string\")\n                stopWordsArray = stopWords.split(WordCloud.StopWordsDelemiter);\n            else\n                stopWordsArray = WordCloud.DefaultSettings.stopWordsArray;\n\n            isDefaultStopWords = DataViewObjects.getValue<boolean>(\n                objects,\n                WordCloud.Properties.stopWords.isDefaultStopWords,\n                WordCloud.DefaultSettings.isDefaultStopWords);\n\n            return {\n                minFontSize: minFontSize,\n                maxFontSize: maxFontSize,\n                minAngle: minAngle,\n                maxAngle: maxAngle,\n                maxNumberOfOrientations: maxNumberOfOrientations,\n                valueFormatter: valueFormatter,\n                isRotateText: isRotateText,\n                isBrokenText: isBrokenText,\n                isRemoveStopWords: isRemoveStopWords,\n                stopWords: stopWords,\n                stopWordsArray: stopWordsArray,\n                isDefaultStopWords: isDefaultStopWords,\n                maxNumberOfWords: maxNumberOfWords\n            };\n        }\n\n        private static getNumberFromObjects(objects: DataViewObjects, properties: any, defaultValue: number): number {\n            return objects ? DataViewObjects.getValue<number>(objects, properties, defaultValue) : defaultValue;\n        }\n\n        private parseNumber(\n            value: number | string,\n            defaultValue: number = 0,\n            minValue: number = -Number.MAX_VALUE,\n            maxValue: number = Number.MAX_VALUE): number {\n            let parsedValue: number = Number(value);\n\n            if (isNaN(parsedValue) || (typeof value === \"string\" && value.length === 0))\n                return defaultValue;\n\n            if (parsedValue < minValue)\n                return minValue;\n\n            if (parsedValue > maxValue)\n                return maxValue;\n\n            return parsedValue;\n        }\n\n        private computePositions(words: WordCloudDataPoint[], onPositionsComputed: (WordCloudDataView) => void): void {\n            let context: CanvasRenderingContext2D = this.getCanvasContext(),\n                surface: number[] = [],\n                borders: IPoint[] = null,\n                maxNumberOfWords: number;\n\n            if (!words || !(words.length > 0))\n                return null;\n\n            maxNumberOfWords = Math.abs(this.parseNumber(\n                this.settings.maxNumberOfWords,\n                WordCloud.DefaultSettings.maxNumberOfWords,\n                words.length * -1,\n                words.length));\n\n            if (words.length > maxNumberOfWords)\n                words = words.slice(0, maxNumberOfWords);\n\n            for (let i: number; i < (this.specialViewport.width >> 5) * this.specialViewport.height; i++) {\n                surface[i] = 0;\n            }\n\n            setTimeout(() => this.computeCycle(words, context, surface, borders, onPositionsComputed, [], 0), 0);\n        }\n\n        private computeCycle(\n            words: WordCloudDataPoint[],\n            context: CanvasRenderingContext2D,\n            surface: number[],\n            borders: IPoint[],\n            onPositionsComputed: (WordCloudDataView) => void,\n            wordsForDraw: WordCloudDataPoint[] = [],\n            index: number = 0): void {\n            let word: WordCloudDataPoint = words[index],\n                ratio: number = 1;\n\n            if (words.length <= 10)\n                ratio = 5;\n            else if (words.length <= 25)\n                ratio = 3;\n            else if (words.length <= 75)\n                ratio = 1.5;\n            else if (words.length <= 100)\n                ratio = 1.25;\n\n            word.x = (this.specialViewport.width / ratio * (Math.random() + 0.5)) >> 1;\n            word.y = (this.specialViewport.height / ratio * (Math.random() + 0.5)) >> 1;\n\n            this.generateSprites(context, word, words, index);\n\n            if (word.sprite && this.findPosition(surface, word, borders)) {\n                wordsForDraw.push(word);\n\n                borders = this.updateBorders(word, borders);\n                word.x -= this.specialViewport.width >> 1;\n                word.y -= this.specialViewport.height >> 1;\n            }\n\n            if (++index < words.length && this.root)\n                this.computeCycle(words, context, surface, borders, onPositionsComputed, wordsForDraw, index);\n            else {\n                onPositionsComputed({\n                    data: wordsForDraw,\n                    leftBorder: borders && borders[0],\n                    rightBorder: borders && borders[1]\n                });\n            }\n        }\n\n        private updateBorders(word: WordCloudDataPoint, borders: IPoint[]): IPoint[] {\n            if (borders && borders.length === 2) {\n                let leftBorder: IPoint = borders[0],\n                    rightBorder: IPoint = borders[1];\n\n                if (word.x + word.x0 < leftBorder.x)\n                    leftBorder.x = word.x + word.x0;\n\n                if (word.y + word.y0 < leftBorder.y)\n                    leftBorder.y = word.y + word.y0;\n\n                if (word.x + word.x1 > rightBorder.x)\n                    rightBorder.x = word.x + word.x1;\n\n                if (word.y + word.y1 > rightBorder.y)\n                    rightBorder.y = word.y + word.y1;\n            } else {\n                borders = [\n                    {\n                        x: word.x + word.x0,\n                        y: word.y + word.y0\n                    }, {\n                        x: word.x + word.x1,\n                        y: word.y + word.y1\n                    }\n                ];\n            }\n\n            return borders;\n        }\n\n        private generateSprites(\n            context: CanvasRenderingContext2D,\n            currentWord: WordCloudDataPoint,\n            words: WordCloudDataPoint[],\n            index: number): void {\n            if (currentWord.sprite)\n                return;\n\n            context.clearRect(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height);\n\n            let x: number = 0,\n                y: number = 0,\n                maxHeight: number = 0,\n                quantityOfWords: number = words.length,\n                pixels: Uint8ClampedArray,\n                sprite: number[] = [];\n\n            for (let i: number = index; i < quantityOfWords; i++) {\n                let currentWordData: WordCloudDataPoint = words[i],\n                    widthOfWord: number = 0,\n                    heightOfWord: number = 0;\n\n                context.save();\n                context.font = \"normal normal \" + (currentWordData.size + 1) + WordCloud.Size + \" \" + this.fontFamily;\n\n                widthOfWord = context.measureText(currentWordData.text + \"m\").width;\n                heightOfWord = currentWordData.size << 1;\n\n                if (currentWordData.rotate) {\n                    let sr: number = Math.sin(currentWordData.rotate * WordCloud.Radians),\n                        cr: number = Math.cos(currentWordData.rotate * WordCloud.Radians),\n                        widthCr: number = widthOfWord * cr,\n                        widthSr: number = widthOfWord * sr,\n                        heightCr: number = heightOfWord * cr,\n                        heightSr: number = heightOfWord * sr;\n\n                    widthOfWord = (Math.max(Math.abs(widthCr + heightSr), Math.abs(widthCr - heightSr)) + 31) >> 5 << 5;\n                    heightOfWord = Math.floor(Math.max(Math.abs(widthSr + heightCr), Math.abs(widthSr - heightCr)));\n                } else\n                    widthOfWord = (widthOfWord + 31) >> 5 << 5;\n\n                if (heightOfWord > maxHeight)\n                    maxHeight = heightOfWord;\n\n                if (x + widthOfWord >= (this.canvasViewport.width << 5)) {\n                    x = 0;\n                    y += maxHeight;\n                    maxHeight = 0;\n                }\n\n                context.translate((x + (widthOfWord >> 1)), (y + (heightOfWord >> 1)));\n\n                if (currentWordData.rotate)\n                    context.rotate(currentWordData.rotate * WordCloud.Radians);\n\n                context.fillText(currentWordData.text, 0, 0);\n\n                if (currentWordData.padding) {\n                    context.lineWidth = 2 * currentWordData.padding;\n                    context.strokeText(currentWordData.text, 0, 0);\n                }\n\n                context.restore();\n\n                currentWordData.width = widthOfWord;\n                currentWordData.height = heightOfWord;\n                currentWordData.xOff = x;\n                currentWordData.yOff = y;\n                currentWordData.x1 = widthOfWord >> 1;\n                currentWordData.y1 = heightOfWord >> 1;\n                currentWordData.x0 = -currentWordData.x1;\n                currentWordData.y0 = -currentWordData.y1;\n\n                x += widthOfWord;\n            }\n\n            pixels = context.getImageData(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height).data;\n\n            sprite = [];\n\n            for (let i = quantityOfWords - 1; i >= 0; i--) {\n                let currentWordData: WordCloudDataPoint = words[i],\n                    width: number = currentWordData.width,\n                    width32: number = width >> 5,\n                    height: number = currentWordData.y1 - currentWordData.y0,\n                    x: number = 0,\n                    y: number = 0,\n                    seen: number = 0,\n                    seenRow: number = 0;\n\n                if (currentWordData.xOff + width >= (this.canvasViewport.width << 5) ||\n                    currentWordData.yOff + height >= this.canvasViewport.height) {\n                    currentWordData.sprite = null;\n\n                    continue;\n                }\n\n                for (let j = 0; j < height * width32; j++) {\n                    sprite[j] = 0;\n                }\n\n                if (currentWordData.xOff !== null)\n                    x = currentWordData.xOff;\n                else\n                    return;\n\n                y = currentWordData.yOff;\n\n                seen = 0;\n                seenRow = -1;\n\n                for (let j = 0; j < height; j++) {\n                    for (let k = 0; k < width; k++) {\n                        let l: number = width32 * j + (k >> 5),\n                            index: number = ((y + j) * (this.canvasViewport.width << 5) + (x + k)) << 2,\n                            m: number = pixels[index]\n                                ? 1 << (31 - (k % 32))\n                                : 0;\n\n                        sprite[l] |= m;\n                        seen |= m;\n                    }\n\n                    if (seen)\n                        seenRow = j;\n                    else {\n                        currentWordData.y0++;\n                        height--;\n                        j--;\n                        y++;\n                    }\n                }\n\n                currentWordData.y1 = currentWordData.y0 + seenRow;\n                currentWordData.sprite = sprite.slice(0, (currentWordData.y1 - currentWordData.y0) * width32);\n            }\n        }\n\n        private findPosition(surface: number[], word: WordCloudDataPoint, borders: IPoint[]): boolean {\n            let startPoint: IPoint = { x: word.x, y: word.y },\n                delta = Math.sqrt(this.specialViewport.width * this.specialViewport.width + this.specialViewport.height * this.specialViewport.height),\n                point: IPoint,\n                dt: number = Math.random() < 0.5 ? 1 : -1,\n                shift: number = -dt,\n                dx: number,\n                dy: number;\n\n            while (true) {\n                shift += dt;\n\n                point = this.archimedeanSpiral(shift);\n\n                dx = Math.floor(point.x);\n                dy = Math.floor(point.y);\n\n                if (Math.min(Math.abs(dx), Math.abs(dy)) >= delta)\n                    break;\n\n                word.x = startPoint.x + dx;\n                word.y = startPoint.y + dy;\n\n                if (word.x + word.x0 < 0 ||\n                    word.y + word.y0 < 0 ||\n                    word.x + word.x1 > this.specialViewport.width ||\n                    word.y + word.y1 > this.specialViewport.height)\n                    continue;\n\n                if (!borders || !this.checkIntersect(word, surface)) {\n                    if (!borders || this.checkIntersectOfRectangles(word, borders[0], borders[1])) {\n                        let sprite: number[] = word.sprite,\n                            width: number = word.width >> 5,\n                            shiftWidth: number = this.specialViewport.width >> 5,\n                            lx: number = word.x - (width << 4),\n                            sx: number = lx & 127,\n                            msx: number = 32 - sx,\n                            height: number = word.y1 - word.y0,\n                            x: number = (word.y + word.y0) * shiftWidth + (lx >> 5);\n\n                        for (let i: number = 0; i < height; i++) {\n                            let lastSprite: number = 0;\n\n                            for (let j: number = 0; j <= width; j++) {\n                                let leftMask: number = lastSprite << msx,\n                                    rightMask: number;\n\n                                if (j < width)\n                                    lastSprite = sprite[i * width + j];\n\n                                rightMask = j < width\n                                    ? lastSprite >>> sx\n                                    : 0;\n\n                                surface[x + j] |= leftMask | rightMask;\n                            }\n\n                            x += shiftWidth;\n                        }\n\n                        word.sprite = null;\n\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private archimedeanSpiral(value: number): IPoint {\n            let ratio: number = this.specialViewport.width / this.specialViewport.height;\n\n            value = value * 0.1;\n\n            return {\n                x: ratio * value * Math.cos(value),\n                y: value * Math.sin(value)\n            };\n        }\n\n        private checkIntersect(word: WordCloudDataPoint, surface: number[]): boolean {\n            let shiftWidth: number = this.specialViewport.width >> 5,\n                sprite: number[] = word.sprite,\n                widthOfWord = word.width >> 5,\n                lx: number = word.x - (widthOfWord << 4),\n                sx: number = lx & 127,\n                msx: number = 32 - sx,\n                heightOfWord = word.y1 - word.y0,\n                x: number = (word.y + word.y0) * shiftWidth + (lx >> 5);\n\n            for (let i = 0; i < heightOfWord; i++) {\n                let lastSprite: number = 0;\n\n                for (let j = 0; j <= widthOfWord; j++) {\n                    let mask: number = 0,\n                        leftMask: number,\n                        intersectMask: number = 0;\n\n                    leftMask = lastSprite << msx;\n\n                    if (j < widthOfWord)\n                        lastSprite = sprite[i * widthOfWord + j];\n\n                    mask = j < widthOfWord\n                        ? lastSprite >>> sx\n                        : 0;\n\n                    intersectMask = (leftMask | mask) & surface[x + j];\n\n                    if (intersectMask)\n                        return true;\n                }\n\n                x += shiftWidth;\n            }\n\n            return false;\n        }\n\n        private checkIntersectOfRectangles(word: WordCloudDataPoint, leftBorder: IPoint, rightBorder: IPoint): boolean {\n            return (word.x + word.x1) > leftBorder.x &&\n                (word.x + word.x0) < rightBorder.x &&\n                (word.y + word.y1) > leftBorder.y &&\n                (word.y + word.y0) < rightBorder.y;\n        }\n\n        private getCanvasContext(): CanvasRenderingContext2D {\n            if (!this.canvasViewport)\n                return null;\n\n            this.canvas.width = 1;\n            this.canvas.height = 1;\n\n            let context: CanvasRenderingContext2D = this.canvas.getContext(\"2d\");\n\n            this.canvas.width = this.canvasViewport.width << 5;\n            this.canvas.height = this.canvasViewport.height;\n\n            context = this.canvas.getContext(\"2d\");\n            context.fillStyle = context.strokeStyle = \"red\";\n            context.textAlign = \"center\";\n\n            return context;\n        }\n\n        private getReducedText(texts: WordCloudText[]): WordCloudText[] {\n            let brokenStrings: WordCloudText[] = [];\n            brokenStrings = this.getBrokenWords(texts);\n\n            return brokenStrings.reduce((previousValue: WordCloudText[], currentValue: WordCloudText) => {\n                if (!previousValue.some((value: WordCloudText) => {\n                    if (value.index !== currentValue.index && value.text === currentValue.text) {\n                        value.count += currentValue.count;\n\n                        return true;\n                    }\n\n                    return false;\n                })) {\n                    previousValue.push(currentValue);\n                }\n\n                return previousValue;\n            }, []);\n        }\n\n        private getBrokenWords(words: WordCloudText[]): WordCloudText[] {\n            let brokenStrings: WordCloudText[] = [],\n                whiteSpaceRegExp: RegExp = /\\s/,\n                punctuatuinRegExp: RegExp;\n\n            if (!this.settings.isBrokenText)\n                return words;\n\n            punctuatuinRegExp = new RegExp(`[${WordCloud.Punctuation.join(\"\\\\\")}]`, \"gim\");\n\n            words.forEach((item: WordCloudText) => {\n                if (typeof item.text === \"string\") {\n                    let words: string[];\n\n                    words = item.text.replace(punctuatuinRegExp, \" \").split(whiteSpaceRegExp);\n\n                    if (this.settings.isRemoveStopWords) {\n                        let stopWords: string[] = this.settings.stopWordsArray;\n\n                        if (this.settings.isDefaultStopWords)\n                            stopWords = stopWords.concat(WordCloud.StopWords);\n\n                        words = words.filter((value: string) => {\n                            return value.length > 0 && !stopWords.some((removeWord: string) => {\n                                return value.toLocaleLowerCase() === removeWord.toLocaleLowerCase();\n                            });\n                        });\n                    }\n\n                    words.forEach((element: string) => {\n                        if (element.length > 0 && !whiteSpaceRegExp.test(element)) {\n                            brokenStrings.push({\n                                text: element,\n                                count: item.count,\n                                index: item.index,\n                                selectionId: item.selectionId,\n                                color: item.color\n                            });\n                        }\n                    });\n                } else\n                    brokenStrings.push(item);\n            });\n\n            return brokenStrings;\n        }\n\n        private getWords(values: WordCloudText[]): WordCloudDataPoint[] {\n            let sortedValues: WordCloudText[],\n                minValue: number = 0,\n                maxValue: number = 0,\n                valueFormatter: IValueFormatter = this.settings.valueFormatter;\n\n            if (!values || !(values.length >= 1))\n                return [];\n\n            sortedValues = values.sort((a: WordCloudText, b: WordCloudText) => {\n                return b.count - a.count;\n            });\n\n            minValue = sortedValues[sortedValues.length - 1].count;\n            maxValue = sortedValues[0].count;\n            let returnValues = values.map((value: WordCloudText) => {\n                return <WordCloudDataPoint>{\n                    text: valueFormatter.format(value.text),\n                    size: this.getFontSize(value.count, minValue, maxValue),\n                    x: 0,\n                    y: 0,\n                    rotate: this.getAngle(),\n                    padding: 1,\n                    width: 0,\n                    height: 0,\n                    xOff: 0,\n                    yOff: 0,\n                    x0: 0,\n                    y0: 0,\n                    x1: 0,\n                    y1: 0,\n                    color: value.color,\n                    selectionId: value.selectionId,\n                    wordIndex: value.index\n                };\n            });\n            this.dataBeforeRender = returnValues;\n            return returnValues;\n        }\n\n        private getFontSize(\n            value: number,\n            minValue: number,\n            maxValue: number,\n            scaleType: WordCloudScaleType = WordCloudScaleType.value) {\n            let weight: number,\n                fontSize: number,\n                maxFontSize: number,\n                minFontSize: number;\n\n            minFontSize = Math.abs(this.parseNumber(this.settings.minFontSize, WordCloud.DefaultSettings.minFontSize));\n            maxFontSize = Math.abs(this.parseNumber(this.settings.maxFontSize, WordCloud.DefaultSettings.maxFontSize));\n\n            if (minFontSize > maxFontSize) {\n                let buffer: number = minFontSize;\n\n                minFontSize = maxFontSize;\n                maxFontSize = buffer;\n            }\n\n            switch (scaleType) {\n                case WordCloudScaleType.logn: {\n                    weight = Math.log(value);\n                }\n                case WordCloudScaleType.sqrt: {\n                    weight = Math.sqrt(value);\n                }\n                case WordCloudScaleType.value: {\n                    weight = value;\n                }\n            }\n\n            fontSize = weight > minValue\n                ? (maxFontSize * (weight - minValue)) / (maxValue - minValue)\n                : 0;\n\n            fontSize = (fontSize * 100) / maxFontSize;\n\n            fontSize = (fontSize * (maxFontSize - minFontSize)) / 100 + minFontSize;\n\n            return fontSize;\n        }\n\n        private getAngle(): number {\n            if (!this.settings ||\n                !this.settings.isRotateText)\n                return 0;\n\n            let minAngle: number,\n                maxAngle: number,\n                maxNumberOfOrientations: number,\n                angle: number;\n\n            maxNumberOfOrientations = Math.abs(this.parseNumber(this.settings.maxNumberOfOrientations, 0));\n\n            minAngle = this.parseNumber(\n                this.settings.minAngle,\n                0,\n                WordCloud.MinAngle,\n                WordCloud.MaxAngle);\n\n            maxAngle = this.parseNumber(\n                this.settings.maxAngle,\n                0,\n                WordCloud.MinAngle,\n                WordCloud.MaxAngle);\n\n            if (minAngle > maxAngle) {\n                let buffer: number = minAngle;\n\n                minAngle = maxAngle;\n                maxAngle = buffer;\n            }\n\n            angle = Math.abs(((maxAngle - minAngle) / maxNumberOfOrientations) * Math.floor(Math.random() * maxNumberOfOrientations));\n\n            return maxNumberOfOrientations !== 0 ? minAngle + angle : 0;\n        }\n\n        public update(visualUpdateOptions: VisualUpdateOptions): void {\n            if (!visualUpdateOptions ||\n                !visualUpdateOptions.viewport ||\n                !visualUpdateOptions.dataViews ||\n                !visualUpdateOptions.dataViews[0] ||\n                !visualUpdateOptions.viewport ||\n                !(visualUpdateOptions.viewport.height >= 0) ||\n                !(visualUpdateOptions.viewport.width >= 0))\n                return;\n\n            this.visualUpdateOptions = visualUpdateOptions;\n\n            this.layout.viewport = this.visualUpdateOptions.viewport;\n            let dataView: DataView = visualUpdateOptions.dataViews[0];\n\n            if (this.layout.viewportInIsZero)\n                return;\n\n            this.durationAnimations = getAnimationDuration(\n                this.animator,\n                visualUpdateOptions.suppressAnimations);\n            this.UpdateSize();\n\n            this.data = this.converter(dataView);\n            if (!this.data)\n                return;\n\n            this.settings = this.data.settings;\n            this.wordCloudTexts = this.data.texts;\n\n            this.computePositions(\n                this.getWords(this.getReducedText(this.data.texts)),\n                (wordCloudDataView: WordCloudDataView) => this.render(wordCloudDataView));\n\n            if (visualUpdateOptions !== this.visualUpdateOptions)\n                this.update(this.visualUpdateOptions);\n        }\n\n        private UpdateSize(): void {\n            let fakeWidth: number,\n                fakeHeight: number,\n                ratio: number;\n\n            ratio = Math.sqrt((this.fakeViewport.width * this.fakeViewport.height)\n                / (this.layout.viewportIn.width * this.layout.viewportIn.height));\n\n            if (isNaN(ratio))\n                fakeHeight = fakeWidth = 1;\n            else {\n                fakeHeight = this.layout.viewportIn.height * ratio;\n                fakeWidth = this.layout.viewportIn.width * ratio;\n            }\n\n            this.specialViewport = {\n                height: fakeHeight,\n                width: fakeWidth\n            };\n\n            this.root.attr({\n                \"height\": this.layout.viewport.height,\n                \"width\": this.layout.viewport.width\n            });\n        }\n\n        private render(wordCloudDataView: WordCloudDataView): void {\n            if (!wordCloudDataView ||\n                !wordCloudDataView.data)\n                return;\n\n            this.wordCloudDataView = wordCloudDataView;\n\n            let animatedWordSelection: D3.Selection,\n                wordElements: D3.Selection = this.main\n                    .select(WordCloud.Words.selector)\n                    .selectAll(WordCloud.Word.selector);\n\n            this.wordsSelection = wordElements.data(wordCloudDataView.data);\n\n            (<D3.UpdateSelection>this.animation(this.wordsSelection, this.durationAnimations))\n                .attr(\"transform\", (item: WordCloudDataPoint) => `${SVGUtil.translate(item.x, item.y)}rotate(${item.rotate})`)\n                .style({\n                    \"font-size\": ((item: WordCloudDataPoint): string => `${item.size}${WordCloud.Size}`),\n                    \"fill\": ((item: WordCloudDataPoint): string => item.color),\n                });\n\n            animatedWordSelection = this.wordsSelection\n                .enter()\n                .append(\"svg:text\")\n                .attr(\"transform\", (item: WordCloudDataPoint) => `${SVGUtil.translate(item.x, item.y)}rotate(${item.rotate})`)\n                .style(\"font-size\", \"1px\");\n\n            this.wordsSelection.on(\"click\", (item: WordCloudDataPoint) => {\n                this.selectionManager\n                    .select(item.selectionId, d3.event.ctrlKey)\n                    .then(() => this.setSelection(this.wordsSelection));\n                d3.event.stopPropagation();\n            });\n\n            (<D3.UpdateSelection>this.animation(animatedWordSelection, this.durationAnimations))\n                .style({\n                    \"font-size\": ((item: WordCloudDataPoint): string => `${item.size}${WordCloud.Size}`),\n                    \"fill\": ((item: WordCloudDataPoint): string => item.color),\n                });\n\n            this.wordsSelection\n                .text((item: WordCloudDataPoint) => item.text)\n                .classed(WordCloud.Word[\"class\"], true);\n\n            this.wordsSelection.exit().remove();\n            this.setSelection(this.wordsSelection);\n\n            setTimeout(() => {\n                if (this.root)\n                    this.scaleMainView(wordCloudDataView, wordElements[0].length && this.durationAnimations);\n\n            }, this.durationAnimations + WordCloud.RenderDelay);\n        }\n\n        private setSelection(selection: D3.Selection): void {\n            let selectionIds: SelectionId[] = this.selectionManager.getSelectionIds();\n\n            if (selectionIds.some(x => !selection.data().some((d: WordCloudDataPoint) => d.selectionId.getKey() === x.getKey()))) {\n                this.selectionManager.clear();\n                selectionIds = [];\n            }\n\n            if (!selectionIds.length) {\n                this.setOpacity(selection, WordCloud.MaxOpacity, true);\n                return;\n            }\n\n            let selectedColumns: D3.UpdateSelection = selection.filter((x: WordCloudDataPoint) =>\n                selectionIds.some((y: SelectionId) => y.getKey() === x.selectionId.getKey()));\n\n            this.setOpacity(selection, WordCloud.MinOpacity);\n            this.setOpacity(selectedColumns, WordCloud.MaxOpacity);\n        }\n\n        private setOpacity(element: D3.Selection, opacityValue: number, disableAnimation: boolean = false): void {\n            let elementAnimation = disableAnimation ? element : this.animation(element);\n            elementAnimation.style(\"fill-opacity\", opacityValue);\n        }\n\n        private scaleMainView(wordCloudDataView: WordCloudDataView, durationAnimation: number = 0): void {\n            if (!wordCloudDataView ||\n                !wordCloudDataView.leftBorder ||\n                !wordCloudDataView.rightBorder)\n                return;\n\n            let scale: number = 1,\n                mainSVGRect: SVGRect = this.main.node()[\"getBBox\"](),\n                leftBorder: IPoint = wordCloudDataView.leftBorder,\n                rightBorder: IPoint = wordCloudDataView.rightBorder,\n                width2: number,\n                height2: number,\n                scaleByX: number,\n                scaleByY: number;\n\n            scaleByX = this.layout.viewportIn.width / Math.abs(leftBorder.x - rightBorder.x);\n            scaleByY = this.layout.viewportIn.height / Math.abs(leftBorder.y - rightBorder.y);\n\n            scale = Math.min(scaleByX, scaleByY);\n\n            width2 = this.layout.margin.left + (mainSVGRect.x * scale * -1)\n                + (this.layout.viewportIn.width - (mainSVGRect.width * scale)) / 2;\n            height2 = this.layout.margin.top + (mainSVGRect.y * scale * -1)\n                + (this.layout.viewportIn.height - (mainSVGRect.height * scale)) / 2;\n\n            (<D3.Selection>this.animation(this.main, durationAnimation))\n                .attr(\"transform\", `${SVGUtil.translate(width2, height2)}scale(${scale})`);\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\n            let instances: VisualObjectInstance[] = [];\n\n            if (!this.settings)\n                return instances;\n\n            switch (options.objectName) {\n                case \"general\": {\n                    let general: VisualObjectInstance = {\n                        objectName: \"general\",\n                        displayName: \"general\",\n                        selector: null,\n                        properties: {\n                            maxNumberOfWords: this.settings.maxNumberOfWords,\n                            minFontSize: this.settings.minFontSize,\n                            maxFontSize: this.settings.maxFontSize,\n                            isBrokenText: this.settings.isBrokenText\n                        }\n                    };\n\n                    instances.push(general);\n                    break;\n                }\n                case \"dataPoint\": {\n                    if (!this.wordCloudDataView ||\n                        !this.wordCloudDataView.data)\n                        return;\n\n                    let dataPoints: WordCloudDataPoint[] = this.dataBeforeRender;\n                    let wordCategoriesIndex: number[] = [];\n                    dataPoints.forEach((item: WordCloudDataPoint) => {\n                        if (wordCategoriesIndex.indexOf(item.wordIndex) === -1) {\n                            wordCategoriesIndex.push(item.wordIndex);\n                            instances.push({\n                                objectName: \"dataPoint\",\n                                displayName: this.data.texts[item.wordIndex].text,\n                                selector: ColorHelper.normalizeSelector(item.selectionId.getSelector(), false),\n                                properties: {\n                                    fill: { solid: { color: item.color } }\n                                }\n                            });\n                        }\n                    });\n\n                    break;\n                }\n                case \"rotateText\": {\n                    let rotateText: VisualObjectInstance = {\n                        objectName: \"rotateText\",\n                        displayName: \"Rotate Text\",\n                        selector: null,\n                        properties: {\n                            show: this.settings.isRotateText,\n                            minAngle: this.settings.minAngle,\n                            maxAngle: this.settings.maxAngle,\n                            maxNumberOfOrientations: this.settings.maxNumberOfOrientations\n                        }\n                    };\n\n                    instances.push(rotateText);\n                    break;\n                }\n                case \"stopWords\": {\n                    let stopWords: VisualObjectInstance = {\n                        objectName: \"stopWords\",\n                        displayName: \"Stop Words\",\n                        selector: null,\n                        properties: {\n                            show: this.settings.isRemoveStopWords,\n                            isDefaultStopWords: this.settings.isDefaultStopWords,\n                            words: this.settings.stopWords ||\n                            this.settings.stopWordsArray.join(WordCloud.StopWordsDelemiter)\n                        }\n                    };\n\n                    instances.push(stopWords);\n                    break;\n                }\n            }\n\n            return instances;\n        }\n\n        private animation(\n            element: D3.Selection,\n            duration: number = 0,\n            callback?: (data: any, index: number) => void): D3.Transition.Transition | D3.Selection {\n            return element\n                .transition()\n                .duration(duration)\n                .each(\"end\", callback);\n        }\n\n        public destroy(): void {\n            this.root = null;\n            this.canvas = null;\n        }\n    }\n\n    module explore.util {\n        export function hexToRgb(hex): string {\n            // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n            let shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n            hex = hex.replace(shorthandRegex, function (m, r, g, b) {\n                return r + r + g + g + b + b;\n            });\n\n            let result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n            return result ? `rgb(${parseInt(result[1], 16)},${parseInt(result[2], 16)},${parseInt(result[3], 16)})` : null;\n        }\n\n        export function getRandomColor(): string {\n            let red: number = Math.floor(Math.random() * 255),\n                green: number = Math.floor(Math.random() * 255),\n                blue: number = Math.floor(Math.random() * 255);\n\n            return `rgb(${red},${green},${blue})`;\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *   \n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *   \n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n    import createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n    import PixelConverter = jsCommon.PixelConverter;\n\n    export interface ITableView {\n        data(data: any[], dataIdFunction: (d) => {}, dataAppended: boolean): ITableView;\n        rowHeight(rowHeight: number): ITableView;\n        columnWidth(columnWidth: number): ITableView;\n        orientation(orientation: string): ITableView;\n        rows(rows: number): ITableView;\n        columns(columns: number): ITableView;\n        viewport(viewport: IViewport): ITableView;\n        render(): void;\n        empty(): void;\n    }\n\n    export module TableViewFactory {\n        export function createTableView(options): ITableView {\n            return new TableView(options);\n        }\n    }\n\n    export interface TableViewViewOptions {\n        enter: (selection: D3.Selection) => void;\n        exit: (selection: D3.Selection) => void;\n        update: (selection: D3.Selection) => void;\n        loadMoreData: () => void;\n        baseContainer: D3.Selection;\n        rowHeight: number;\n        columnWidth: number;\n        orientation: string;\n        rows: number;\n        columns: number;\n        viewport: IViewport;\n        scrollEnabled: boolean;\n    }\n\n    /**\n     * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.\n     * It can create lists containing either HTML or SVG elements.\n     */\n    class TableView implements ITableView {\n        private getDatumIndex: (d: any) => {};\n        private _data: any[];\n        private _totalRows: number;\n        private _totalColumns: number;\n\n        private options: TableViewViewOptions;\n        private visibleGroupContainer: D3.Selection;\n        private scrollContainer: D3.Selection;\n\n        private static defaultRowHeight = 0;\n        private static defaultColumns = 1;\n\n        public constructor(options: TableViewViewOptions) {\n            // make a copy of options so that it is not modified later by caller\n            this.options = $.extend(true, {}, options);\n\n            this.options.baseContainer\n                .style('overflow-y', 'auto')\n                .attr('drag-resize-disabled', true);\n\n            this.scrollContainer = options.baseContainer\n                .append('div')\n                .attr('class', 'scrollRegion');\n            this.visibleGroupContainer = this.scrollContainer\n                .append('div')\n                .attr('class', 'visibleGroup');\n\n            TableView.SetDefaultOptions(options);\n        }\n\n        private static SetDefaultOptions(options: TableViewViewOptions) {\n            options.rowHeight = options.rowHeight || TableView.defaultRowHeight;\n        }\n\n        public rowHeight(rowHeight: number): TableView {\n            this.options.rowHeight = Math.ceil(rowHeight);\n            return this;\n        }\n        public columnWidth(columnWidth: number): TableView {\n            this.options.columnWidth = Math.ceil(columnWidth);\n            return this;\n        }\n\n        public orientation(orientation: string): TableView {\n            this.options.orientation = orientation;\n            return this;\n        }\n\n        public rows(rows: number): TableView {\n            this.options.rows = Math.ceil(rows);\n            return this;\n        }\n\n        public columns(columns: number): TableView {\n            this.options.columns = Math.ceil(columns);\n            return this;\n        }\n\n        public data(data: any[], getDatumIndex: (d) => {}, dataReset: boolean = false): ITableView {\n            this._data = data;\n            this.getDatumIndex = getDatumIndex;\n            this.setTotalRows();\n            if (dataReset) {\n                $(this.options.baseContainer.node()).scrollTop(0);\n            }\n            return this;\n        }\n\n        public viewport(viewport: IViewport): ITableView {\n            this.options.viewport = viewport;\n            return this;\n        }\n\n        public empty(): void {\n            this._data = [];\n            this.render();\n        }\n\n        private setTotalRows(): void {\n            var count = this._data.length;\n            var rows = Math.min(this.options.rows, count);\n            var columns = Math.min(this.options.columns, count);\n\n            if ((columns > 0) && (rows > 0)) {\n                this._totalColumns = columns;\n                this._totalRows = rows;\n            } else if (rows > 0) {\n                this._totalRows = rows;\n                this._totalColumns = Math.ceil(count / rows);\n            } else if (columns > 0) {\n                this._totalColumns = columns;\n                this._totalRows = Math.ceil(count / columns);\n            } else {\n                this._totalColumns = TableView.defaultColumns;\n                this._totalRows = Math.ceil(count / TableView.defaultColumns);\n            }\n        }\n\n        public render(): void {\n            var options = this.options;\n            var visibleGroupContainer = this.visibleGroupContainer;\n            var rowHeight = options.rowHeight || TableView.defaultRowHeight;\n            var groupedData: any[] = [];\n            var totalRows = options.rows; \n            var totalColumns = options.columns;\n            var totalItems: number = this._data.length;\n            var totalRows = options.rows > totalItems ? totalItems : options.rows; \n            var totalColumns = options.columns > totalItems ? totalItems : options.columns; \n\n            if (totalColumns === 0 && totalRows === 0) {\n                if (options.orientation === Orientation.HORIZONTAL)\n                {\n                    totalColumns = totalItems;\n                    totalRows = 1;\n                }\n                else\n                {\n                    totalColumns = 1;\n                    totalRows = totalItems;\n                }\n            }\n            else if (totalColumns === 0 && totalRows > 0)\n                totalColumns = Math.ceil(totalItems / totalRows);\n            else if (totalColumns > 0 && totalRows === 0)\n                totalRows = Math.ceil(totalItems / totalColumns);\n\n            if (this.options.orientation === Orientation.VERTICAL)\n            {\n                var n = totalRows;\n                totalRows = totalColumns;\n                totalColumns = n;\n            }\n\n            else if (this.options.orientation === Orientation.HORIZONTAL)\n            {\n                if (totalRows === 0) totalRows = this._totalRows;\n                if (totalColumns === 0) totalColumns = this._totalColumns;\n            }\n\n            var m: number = 0;\n            var k: number = 0;\n            for (var i: number = 0; i < totalRows; i++) {\n                if (this.options.orientation === Orientation.VERTICAL && options.rows === 0 && totalItems % options.columns > 0 && options.columns <= totalItems)\n                {\n                    if (totalItems % options.columns > i)\n                    {\n                        m = i * Math.ceil(totalItems / options.columns);\n                        k = m + Math.ceil(totalItems / options.columns);\n                        groupedData.push(this._data.slice(m, k)); \n                    }\n                    else\n                    {\n                        groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.columns)));\n                        k = k + Math.floor(totalItems / options.columns);\n                    }\n                }\n                else if (this.options.orientation === Orientation.HORIZONTAL && options.columns === 0 && totalItems % options.rows > 0 && options.rows <= totalItems)\n                {\n                    if (totalItems % options.rows > i)\n                    {\n                        m = i * Math.ceil(totalItems / options.rows);\n                        k = m + Math.ceil(totalItems / options.rows);\n                        groupedData.push(this._data.slice(m, k));\n                    }\n                    else\n                    {\n                        groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.rows)));\n                        k = k + Math.floor(totalItems / options.rows);\n                    }\n                }\n                else\n                {\n                    var k: number = i * totalColumns;\n                    groupedData.push(this._data.slice(k, k + totalColumns));\n                }\n            }\n\n            visibleGroupContainer.selectAll(\".row\").remove();\n            var cellSelection = visibleGroupContainer.selectAll(\".row\")\n                .data(groupedData)\n                .enter()\n                .append(\"div\")\n                .classed('row', true)\n                .selectAll(\".cell\")\n                .data(d => d);\n\n            cellSelection\n                .enter()\n                .append('div')\n                .classed('cell', true)\n                .call(d => options.enter(d));\n            cellSelection.order();\n\n            var cellUpdateSelection = visibleGroupContainer.selectAll('.cell:not(.transitioning)');\n\n            cellUpdateSelection.call(d => options.update(d));\n            cellUpdateSelection.style({ 'height': (rowHeight > 0) ? rowHeight + 'px' : 'auto' });\n\n            if (this.options.orientation === Orientation.VERTICAL)\n            {\n                var realColumnNumber = 0;\n                for (var i: number = 0; i < groupedData.length; i++)\n                {\n                    if (groupedData[i].length !== 0)\n                        realColumnNumber = i+1;\n                }\n\n                cellUpdateSelection.style({ 'width': '100%' });\n                var rowUpdateSelection = visibleGroupContainer.selectAll('div.row');\n                rowUpdateSelection.style({ 'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / realColumnNumber) + '%' });\n            }\n            else\n                cellUpdateSelection.style({\n                    'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / totalColumns) + '%'\n                });\n\n            cellSelection\n                .exit()\n                .call(d => options.exit(d))\n                .remove();\n        }\n    }\n\n    // TODO: Generate these from above, defining twice just introduces potential for error\n    export var chicletSlicerProps = {\n        general: {\n            orientation: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'orientation' },\n            columns: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'columns' },\n            rows: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'rows' },\n            showDisabled: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'showDisabled' },\n            multiselect: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'multiselect' },\n            selection: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'selection' },\n        },\n        header: {\n            show: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'show' },\n            title: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'title' },\n            fontColor: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'fontColor' },\n            background: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'background' },\n            outline: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'outline' },\n            textSize: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'textSize' },\n            outlineColor: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'outlineColor' },\n            outlineWeight: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'outlineWeight' }\n        },\n        rows: {\n            fontColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'fontColor' },\n            textSize: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'textSize' },\n            height: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'height' },\n            width: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'width' },\n            background: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'background' },\n            transparency: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'transparency' },\n            selectedColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'selectedColor' },\n            unselectedColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'unselectedColor' },\n            disabledColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'disabledColor' },\n            outline: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'outline' },\n            outlineColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'outlineColor' },\n            outlineWeight: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'outlineWeight' },\n            borderStyle: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'borderStyle' },\n        },\n        images: {\n            imageSplit: <DataViewObjectPropertyIdentifier>{ objectName: 'images', propertyName: 'imageSplit' },\n            stretchImage: <DataViewObjectPropertyIdentifier>{ objectName: 'images', propertyName: 'stretchImage' },\n            bottomImage: <DataViewObjectPropertyIdentifier>{ objectName: 'images', propertyName: 'bottomImage' },\n        },\n        selectedPropertyIdentifier: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'selected' },\n        filterPropertyIdentifier: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'filter' },\n        formatString: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'formatString' },\n        hasSavedSelection: true,\n    };\n\n    module ChicletBorderStyle {\n        export var ROUNDED: string = 'Rounded';\n        export var CUT: string = 'Cut';\n        export var SQUARE: string = 'Square';\n\n        export var type: IEnumType = createEnumType([\n            { value: ROUNDED, displayName: ChicletBorderStyle.ROUNDED },\n            { value: CUT, displayName: ChicletBorderStyle.CUT },\n            { value: SQUARE, displayName: ChicletBorderStyle.SQUARE },\n        ]);\n    }\n\n    module ChicletSlicerShowDisabled {\n        export var INPLACE: string = 'Inplace';\n        export var BOTTOM: string = 'Bottom';\n        export var HIDE: string = 'Hide';\n\n        export var type: IEnumType = createEnumType([\n            { value: INPLACE, displayName: ChicletSlicerShowDisabled.INPLACE },\n            { value: BOTTOM, displayName: ChicletSlicerShowDisabled.BOTTOM },\n            { value: HIDE, displayName: ChicletSlicerShowDisabled.HIDE },\n        ]);\n    }\n\n    module Orientation {\n        export var HORIZONTAL: string = 'Horizontal';\n        export var VERTICAL: string = 'Vertical';\n\n        export var type: IEnumType = createEnumType([\n            { value: HORIZONTAL, displayName: HORIZONTAL },\n            { value: VERTICAL, displayName: VERTICAL }\n        ]);\n    }\n\n    export interface ChicletSlicerConstructorOptions {\n        behavior?: ChicletSlicerWebBehavior;\n    }\n\n    export interface ChicletSlicerData {\n        categorySourceName: string;\n        formatString: string;\n        slicerDataPoints: ChicletSlicerDataPoint[];\n        slicerSettings: ChicletSlicerSettings;\n        hasSelectionOverride?: boolean;\n    }\n\n    export interface ChicletSlicerDataPoint extends SelectableDataPoint {\n        category?: string;\n        value?: number;\n        mouseOver?: boolean;\n        mouseOut?: boolean;\n        isSelectAllDataPoint?: boolean;\n        imageURL?: string;\n        selectable?: boolean;\n    }\n\n    export interface ChicletSlicerSettings {\n        general: {\n            orientation: string;\n            columns: number;\n            rows: number;\n            multiselect: boolean;\n            showDisabled: string;\n            selection: string;\n            getSavedSelection?: () => string[];\n            setSavedSelection?: (selectionIds: string[]) => void;\n        };\n        margin: IMargin;\n        header: {\n            borderBottomWidth: number;\n            show: boolean;\n            outline: string;\n            fontColor: string;\n            background?: string;\n            textSize: number;\n            outlineColor: string;\n            outlineWeight: number;\n            title: string;\n        };\n        headerText: {\n            marginLeft: number;\n            marginTop: number;\n        };\n        slicerText: {\n            textSize: number;\n            height: number;\n            width: number;\n            fontColor: string;\n            hoverColor: string;\n            selectedColor: string;\n            unselectedColor: string;\n            disabledColor: string;\n            marginLeft: number;\n            outline: string;\n            background?: string;\n            transparency: number;\n            outlineColor: string;\n            outlineWeight: number;\n            borderStyle: string;\n        };\n        slicerItemContainer: {\n            marginTop: number;\n            marginLeft: number;\n        };\n        images: {\n            imageSplit: number;\n            stretchImage: boolean;\n            bottomImage: boolean;\n        };\n    }\n\n    export class ChicletSlicer implements IVisual {\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: 'Category',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Field'),\n                },\n                {\n                    name: 'Values',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Values'),\n                },\n                {\n                    name: 'Image',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'Image',\n                },\n            ],\n            objects: {\n                general: {\n                    displayName: data.createDisplayNameGetter('Visual_General'),\n                    properties: {\n                        selection: {\n                            displayName: \"Selection\",\n                            type: { text: true }\n                        },\n                        orientation: {\n                            displayName: 'Orientation',\n                            type: { enumeration: Orientation.type }\n                        },\n                        columns: {\n                            displayName: 'Columns',\n                            type: { numeric: true }\n                        },\n                        rows: {\n                            displayName: 'Rows',\n                            type: { numeric: true }\n                        },\n                        showDisabled: {\n                            displayName: 'Show Disabled',\n                            type: { enumeration: ChicletSlicerShowDisabled.type }\n                        },\n                        multiselect: {\n                            displayName: 'Multiple selection',\n                            type: { bool: true }\n                        },\n                        selected: {\n                            type: { bool: true }\n                        },\n                        filter: {\n                            type: { filter: {} },\n                            rule: {\n                                output: {\n                                    property: 'selected',\n                                    selector: ['Category'],\n                                }\n                            }\n                        },\n                        formatString: {\n                            type: { formatting: { formatString: true } },\n                        },\n                    },\n                },\n                header: {\n                    displayName: data.createDisplayNameGetter('Visual_Header'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        title: {\n                            displayName: 'Title',\n                            type: { text: true }\n                        },\n                        fontColor: {\n                            displayName: data.createDisplayNameGetter('Visual_FontColor'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        background: {\n                            displayName: data.createDisplayNameGetter('Visual_Background'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        outline: {\n                            displayName: data.createDisplayNameGetter('Visual_Outline'),\n                            type: { formatting: { outline: true } }\n                        },\n                        textSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { numeric: true }\n                        },\n                        outlineColor: {\n                            displayName: 'Outline Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        outlineWeight: {\n                            displayName: 'Outline Weight',\n                            type: { numeric: true }\n                        }\n                    }\n                },\n                rows: {\n                    displayName: 'Chiclets',\n                    properties: {\n                        fontColor: {\n                            displayName: 'Text color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        textSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { numeric: true }\n                        },\n                        height: {\n                            displayName: 'Height',\n                            type: { numeric: true }\n                        },\n                        width: {\n                            displayName: 'Width',\n                            type: { numeric: true }\n                        },\n                        selectedColor: {\n                            displayName: 'Selected Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        unselectedColor: {\n                            displayName: 'Unselected Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        disabledColor: {\n                            displayName: 'Disabled Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        background: {\n                            displayName: data.createDisplayNameGetter('Visual_Background'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        transparency: {\n                            displayName: \"Transparency\",\n                            description: \"Set transparency for background color\",\n                            type: { numeric: true }\n                        },\n                        outline: {\n                            displayName: data.createDisplayNameGetter('Visual_Outline'),\n                            type: { formatting: { outline: true } }\n                        },\n                        outlineColor: {\n                            displayName: 'Outline Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        outlineWeight: {\n                            displayName: 'Outline Weight',\n                            type: { numeric: true }\n                        },\n                        borderStyle: {\n                            displayName: 'Outline Style',\n                            type: { enumeration: ChicletBorderStyle.type }\n                        },\n                    }\n                },\n                images: {\n                    displayName: 'Images',\n                    properties: {\n                        imageSplit: {\n                            displayName: 'Image Split',\n                            type: { numeric: true }\n                        },\n                        stretchImage: {\n                            displayName: 'Stretch image',\n                            type: { bool: true }\n                        },\n                        bottomImage: {\n                            displayName: 'Bottom image',\n                            type: { bool: true }\n                        },\n                    }\n                },\n            },\n            dataViewMappings: [{\n                conditions: [\n                    { 'Category': { max: 1 }, 'Image': { min: 0, max: 1 }, 'Values': { min: 0, max: 1 } }],\n                categorical: {\n                    categories: {\n                        for: { in: 'Category' },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: {\n                        group: {\n                            by: 'Image',\n                            select: [{ bind: { to: 'Values' } },\n                            ],\n                            dataReductionAlgorithm: { top: {} }\n                        }\n                    },\n                    includeEmptyGroups: true\n                }\n            }],\n            supportsHighlight: true,\n            sorting: {\n                default: {},\n            },\n            suppressDefaultTitle: true,\n        };\n        private element: JQuery;\n        private currentViewport: IViewport;\n        private dataView: DataView;\n        private slicerHeader: D3.Selection;\n        private slicerBody: D3.Selection;\n        private tableView: ITableView;\n        private slicerData: ChicletSlicerData;\n        private settings: ChicletSlicerSettings;\n        private interactivityService: IInteractivityService;\n        private behavior: ChicletSlicerWebBehavior;\n        private hostServices: IVisualHostServices;\n        private waitingForData: boolean;\n        private isSelectionLoaded: boolean;\n        private isSelectionSaved: boolean;\n\n        public static DefaultFontFamily: string = 'Segoe UI, Tahoma, Verdana, Geneva, sans-serif';\n        public static DefaultFontSizeInPt: number = 11;       \n        private static cellTotalInnerPaddings = 8;\n        private static cellTotalInnerBorders = 2;\n        private static chicletTotalInnerRightLeftPaddings = 14;\n\n        private static ItemContainer: ClassAndSelector = createClassAndSelector('slicerItemContainer');\n        private static HeaderText: ClassAndSelector = createClassAndSelector('headerText');\n        private static Container: ClassAndSelector = createClassAndSelector('chicletSlicer');\n        private static LabelText: ClassAndSelector = createClassAndSelector('slicerText');\n        private static Header: ClassAndSelector = createClassAndSelector('slicerHeader');\n        private static Input: ClassAndSelector = createClassAndSelector('slicerCheckbox');\n        private static Clear: ClassAndSelector = createClassAndSelector('clear');\n        private static Body: ClassAndSelector = createClassAndSelector('slicerBody');\n      \n        public static DefaultStyleProperties(): ChicletSlicerSettings {\n            return {\n                general: {\n                    orientation: Orientation.VERTICAL,\n                    columns: 3,\n                    rows: 0,\n                    multiselect: true,\n                    showDisabled: ChicletSlicerShowDisabled.INPLACE,\n                    selection: null,\n                },\n                margin: {\n                    top: 50,\n                    bottom: 50,\n                    right: 50,\n                    left: 50\n                },\n                header: {\n                    borderBottomWidth: 1,\n                    show: true,\n                    outline: 'BottomOnly',\n                    fontColor: '#a6a6a6',\n                    background: null,\n                    textSize: 10,\n                    outlineColor: '#a6a6a6',\n                    outlineWeight: 1,\n                    title: '',\n                },\n                headerText: {\n                    marginLeft: 8,\n                    marginTop: 0\n                },\n                slicerText: {\n                    textSize: 10,\n                    height: 0,\n                    width: 0,\n                    fontColor: '#666666',\n                    hoverColor: '#212121',\n                    selectedColor: '#BDD7EE',\n                    unselectedColor: '#ffffff',\n                    disabledColor: 'grey',\n                    marginLeft: 8,\n                    outline: 'Frame',\n                    background: null,\n                    transparency: 0,\n                    outlineColor: '#000000',\n                    outlineWeight: 1,\n                    borderStyle: 'Cut',\n\n                },\n                slicerItemContainer: {\n                    // The margin is assigned in the less file. This is needed for the height calculations.\n                    marginTop: 5,\n                    marginLeft: 0,\n                },\n                images: {\n                    imageSplit: 50,\n                    stretchImage: false,\n                    bottomImage: false\n                }\n            };\n        }\n\n        constructor(options?: ChicletSlicerConstructorOptions) {\n            if (options) {\n                if (options.behavior) {\n                    this.behavior = options.behavior;\n                }\n            }\n            if (!this.behavior) {\n                this.behavior = new ChicletSlicerWebBehavior();\n            }\n        }\n\n        public static converter(dataView: DataView, localizedSelectAllText: string, interactivityService: IInteractivityService): ChicletSlicerData {\n            if (!dataView ||\n                !dataView.categorical ||\n                !dataView.categorical.categories ||\n                !dataView.categorical.categories[0] ||\n                !dataView.categorical.categories[0].values ||\n                !(dataView.categorical.categories[0].values.length > 0)) {\n                return;\n            }\n            var converter = new ChicletSlicerChartConversion.ChicletSlicerConverter(dataView, interactivityService);\n            converter.convert();\n            var slicerData: ChicletSlicerData;\n            var defaultSettings: ChicletSlicerSettings = this.DefaultStyleProperties();\n            var objects: DataViewObjects = dataView.metadata.objects;\n            if (objects) {\n                defaultSettings.general.orientation = DataViewObjects.getValue<string>(objects, chicletSlicerProps.general.orientation, defaultSettings.general.orientation);\n                defaultSettings.general.columns = DataViewObjects.getValue<number>(objects, chicletSlicerProps.general.columns, defaultSettings.general.columns);\n                defaultSettings.general.rows = DataViewObjects.getValue<number>(objects, chicletSlicerProps.general.rows, defaultSettings.general.rows);\n                defaultSettings.general.multiselect = DataViewObjects.getValue<boolean>(objects, chicletSlicerProps.general.multiselect, defaultSettings.general.multiselect);\n                defaultSettings.general.showDisabled = DataViewObjects.getValue<string>(objects, chicletSlicerProps.general.showDisabled, defaultSettings.general.showDisabled);\n                defaultSettings.general.selection = DataViewObjects.getValue(dataView.metadata.objects, chicletSlicerProps.general.selection, defaultSettings.general.selection);\n\n                defaultSettings.header.show = DataViewObjects.getValue<boolean>(objects, chicletSlicerProps.header.show, defaultSettings.header.show);\n                defaultSettings.header.title = DataViewObjects.getValue<string>(objects, chicletSlicerProps.header.title, defaultSettings.header.title);\n                defaultSettings.header.fontColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.header.fontColor, defaultSettings.header.fontColor);\n                defaultSettings.header.background = DataViewObjects.getFillColor(objects, chicletSlicerProps.header.background, defaultSettings.header.background);\n                defaultSettings.header.textSize = DataViewObjects.getValue<number>(objects, chicletSlicerProps.header.textSize, defaultSettings.header.textSize);\n                defaultSettings.header.outline = DataViewObjects.getValue<string>(objects, chicletSlicerProps.header.outline, defaultSettings.header.outline);\n                defaultSettings.header.outlineColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.header.outlineColor, defaultSettings.header.outlineColor);\n                defaultSettings.header.outlineWeight = DataViewObjects.getValue<number>(objects, chicletSlicerProps.header.outlineWeight, defaultSettings.header.outlineWeight);\n\n                defaultSettings.slicerText.textSize = DataViewObjects.getValue<number>(objects, chicletSlicerProps.rows.textSize, defaultSettings.slicerText.textSize);\n                defaultSettings.slicerText.height = DataViewObjects.getValue<number>(objects, chicletSlicerProps.rows.height, defaultSettings.slicerText.height);\n                defaultSettings.slicerText.width = DataViewObjects.getValue<number>(objects, chicletSlicerProps.rows.width, defaultSettings.slicerText.width);\n                defaultSettings.slicerText.selectedColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.selectedColor, defaultSettings.slicerText.selectedColor);\n                defaultSettings.slicerText.unselectedColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.unselectedColor, defaultSettings.slicerText.unselectedColor);\n                defaultSettings.slicerText.disabledColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.disabledColor, defaultSettings.slicerText.disabledColor);\n                defaultSettings.slicerText.background = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.background, defaultSettings.slicerText.background);\n                defaultSettings.slicerText.transparency = DataViewObjects.getValue<number>(objects, chicletSlicerProps.rows.transparency, defaultSettings.slicerText.transparency);\n                defaultSettings.slicerText.fontColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.fontColor, defaultSettings.slicerText.fontColor);\n                defaultSettings.slicerText.outline = DataViewObjects.getValue<string>(objects, chicletSlicerProps.rows.outline, defaultSettings.slicerText.outline);\n                defaultSettings.slicerText.outlineColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.outlineColor, defaultSettings.slicerText.outlineColor);\n                defaultSettings.slicerText.outlineWeight = DataViewObjects.getValue<number>(objects, chicletSlicerProps.rows.outlineWeight, defaultSettings.slicerText.outlineWeight);\n                defaultSettings.slicerText.borderStyle = DataViewObjects.getValue<string>(objects, chicletSlicerProps.rows.borderStyle, defaultSettings.slicerText.borderStyle);\n\n                defaultSettings.images.imageSplit = DataViewObjects.getValue<number>(objects, chicletSlicerProps.images.imageSplit, defaultSettings.images.imageSplit);\n                defaultSettings.images.stretchImage = DataViewObjects.getValue<boolean>(objects, chicletSlicerProps.images.stretchImage, defaultSettings.images.stretchImage);\n                defaultSettings.images.bottomImage = DataViewObjects.getValue<boolean>(objects, chicletSlicerProps.images.bottomImage, defaultSettings.images.bottomImage);\n            }\n\n            var categories: DataViewCategoricalColumn = dataView.categorical.categories[0];\n            slicerData = {\n                categorySourceName: categories.source.displayName,\n                formatString: valueFormatter.getFormatString(categories.source, chicletSlicerProps.formatString),\n                slicerSettings: defaultSettings,\n                slicerDataPoints: converter.dataPoints,\n            };\n\n            // Override hasSelection if a objects contained more scopeIds than selections we found in the data\n            slicerData.hasSelectionOverride = converter.hasSelectionOverride;\n\n            return slicerData;\n        }\n\n        public init(options: VisualInitOptions): void {\n            this.element = options.element;\n            this.currentViewport = options.viewport;\n            if (this.behavior) {\n                this.interactivityService = createInteractivityService(options.host);\n            }\n            this.hostServices = options.host;\n            this.settings = ChicletSlicer.DefaultStyleProperties();\n\n            this.initContainer();\n        }\n\n        public update(options: VisualUpdateOptions) {\n            if (!options ||\n                !options.dataViews ||\n                !options.dataViews[0] ||\n                !options.viewport) {\n                return;\n            }\n\n            var existingDataView = this.dataView;\n            this.dataView = options.dataViews[0];\n\n            var resetScrollbarPosition: boolean = true;\n            if (existingDataView) {\n                resetScrollbarPosition = !DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);\n            }\n\n            if (options.viewport.height === this.currentViewport.height\n                && options.viewport.width === this.currentViewport.width) {\n                this.waitingForData = false;\n            }\n            else {\n                this.currentViewport = options.viewport;\n            }\n\n            this.updateInternal(resetScrollbarPosition);\n        }\n\n        public onResizing(finalViewport: IViewport): void {\n            this.currentViewport = finalViewport;\n            this.updateInternal(false /* resetScrollbarPosition */);\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\n            var data: ChicletSlicerData = this.slicerData;\n            if (!data) {\n                return;\n            }\n\n            var objectName = options.objectName;\n            switch (objectName) {\n                case 'rows':\n                    return this.enumerateRows(data);\n                case 'header':\n                    return this.enumerateHeader(data);\n                case 'general':\n                    return this.enumerateGeneral(data);\n                case 'images':\n                    return this.enumerateImages(data);\n            }\n        }\n\n        private enumerateHeader(data: ChicletSlicerData): VisualObjectInstance[] {\n            var slicerSettings: ChicletSlicerSettings = this.settings;\n            return [{\n                selector: null,\n                objectName: 'header',\n                properties: {\n                    show: slicerSettings.header.show,\n                    title: slicerSettings.header.title,\n                    fontColor: slicerSettings.header.fontColor,\n                    background: slicerSettings.header.background,\n                    textSize: slicerSettings.header.textSize,\n                    outline: slicerSettings.header.outline,\n                    outlineColor: slicerSettings.header.outlineColor,\n                    outlineWeight: slicerSettings.header.outlineWeight\n                }\n            }];\n        }\n\n        private enumerateRows(data: ChicletSlicerData): VisualObjectInstance[] {\n            var slicerSettings: ChicletSlicerSettings = this.settings;\n            return [{\n                selector: null,\n                objectName: 'rows',\n                properties: {\n                    textSize: slicerSettings.slicerText.textSize,\n                    height: slicerSettings.slicerText.height,\n                    width: slicerSettings.slicerText.width,\n                    background: slicerSettings.slicerText.background,\n                    transparency: slicerSettings.slicerText.transparency,\n                    selectedColor: slicerSettings.slicerText.selectedColor,\n                    unselectedColor: slicerSettings.slicerText.unselectedColor,\n                    disabledColor: slicerSettings.slicerText.disabledColor,\n                    outline: slicerSettings.slicerText.outline,\n                    outlineColor: slicerSettings.slicerText.outlineColor,\n                    outlineWeight: slicerSettings.slicerText.outlineWeight,\n                    fontColor: slicerSettings.slicerText.fontColor,\n                    borderStyle: slicerSettings.slicerText.borderStyle,\n                }\n            }];\n        }\n\n        private enumerateGeneral(data: ChicletSlicerData): VisualObjectInstance[] {\n            var slicerSettings: ChicletSlicerSettings = this.settings;\n\n            return [{\n                selector: null,\n                objectName: 'general',\n                properties: {\n                    orientation: slicerSettings.general.orientation,\n                    columns: slicerSettings.general.columns,\n                    rows: slicerSettings.general.rows,\n                    showDisabled: slicerSettings.general.showDisabled,\n                    multiselect: slicerSettings.general.multiselect,\n                }\n            }];\n        }\n\n        private enumerateImages(data: ChicletSlicerData): VisualObjectInstance[] {\n            var slicerSettings: ChicletSlicerSettings = this.settings;\n            return [{\n                selector: null,\n                objectName: 'images',\n                properties: {\n                    imageSplit: slicerSettings.images.imageSplit,\n                    stretchImage: slicerSettings.images.stretchImage,\n                    bottomImage: slicerSettings.images.bottomImage,\n                }\n            }];\n        }\n        private updateInternal(resetScrollbarPosition: boolean) {\n            this.updateSlicerBodyDimensions();\n\n            var localizedSelectAllText: string = 'Select All';\n            var data = ChicletSlicer.converter(this.dataView, localizedSelectAllText, this.interactivityService);\n            if (!data) {\n                this.tableView.empty();\n                return;\n            }\n\n            if (this.interactivityService) {\n                this.interactivityService.applySelectionStateToData(data.slicerDataPoints);\n            }\n\n            data.slicerSettings.header.outlineWeight = data.slicerSettings.header.outlineWeight < 0 ? 0 : data.slicerSettings.header.outlineWeight;\n            data.slicerSettings.slicerText.outlineWeight = data.slicerSettings.slicerText.outlineWeight < 0 ? 0 : data.slicerSettings.slicerText.outlineWeight;\n\n            data.slicerSettings.general.getSavedSelection = () => {\n                    try \n                    {\n                        return JSON.parse(this.slicerData.slicerSettings.general.selection) || [];\n                    }\n                    catch(ex)\n                    {\n                        return [];\n                    }\n                };\n            data.slicerSettings.general.setSavedSelection = (selectionIds: string[]) => {\n                this.isSelectionSaved = true;\n                this.hostServices.persistProperties(<VisualObjectInstancesToPersist>{\n                        merge: [{\n                        objectName: \"general\",\n                        selector: null,\n                        properties: { selection: selectionIds && JSON.stringify(selectionIds) || \"\" }\n                    }]});\n                };\n\n            if(this.slicerData) {\n                if(this.isSelectionSaved) {\n                     this.isSelectionLoaded = true;\n                } else {\n                   this.isSelectionLoaded = this.slicerData.slicerSettings.general.selection === data.slicerSettings.general.selection;\n                }\n            } else {\n                this.isSelectionLoaded = false;\n            }\n\n            this.slicerData = data;\n            this.settings = this.slicerData.slicerSettings;\n            if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.BOTTOM) {\n                data.slicerDataPoints.sort(function (a, b) {\n                    if (a.selectable === b.selectable) {\n                        return 0;\n                    } else if (a.selectable && !b.selectable) {\n                        return -1;\n                    } else {\n                        return 1;\n                    }\n                });\n            } else if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.HIDE) {\n                data.slicerDataPoints = data.slicerDataPoints.filter(x => x.selectable);\n            }\n\n            var height: number = this.settings.slicerText.height;\n            if (height === 0) {\n                var extraSpaceForCell = ChicletSlicer.cellTotalInnerPaddings + ChicletSlicer.cellTotalInnerBorders;\n                var textProperties = ChicletSlicer.getChicletTextProperties(this.settings.slicerText.textSize);\n                height = TextMeasurementService.estimateSvgTextHeight(textProperties) + TextMeasurementService.estimateSvgTextBaselineDelta(textProperties) + extraSpaceForCell;\n                var hasImage = _.any(data.slicerDataPoints, x=> x.imageURL !== '' && typeof x.imageURL !== \"undefined\");\n                if (hasImage)\n                    height += 100;\n            }\n\n            this.tableView\n                .rowHeight(height)\n                .columnWidth(this.settings.slicerText.width)\n                .orientation(this.settings.general.orientation)\n                .rows(this.settings.general.rows)\n                .columns(this.settings.general.columns)\n                .data(data.slicerDataPoints,\n                (d: ChicletSlicerDataPoint) => $.inArray(d, data.slicerDataPoints),\n                resetScrollbarPosition)\n                .viewport(this.getSlicerBodyViewport(this.currentViewport))\n                .render();\n\n            // if(!selectedItems.length  &&  String(savedSelection).length && this.slicerData && this.slicerData.hasSelectionOverride){\n            //     var arrSelection = String(savedSelection).split('&');\n            //     var arrSelected = jQuery.map(data.slicerDataPoints, function (d, index) { \n            //         if (arrSelection.indexOf(d.category) > -1) return d; \n            //     });\n            //     data.slicerDataPoints.forEach(function (d, index) { \n            //         if (arrSelection.indexOf(d.category) > -1){\n            //             d.selected = true;\n            //             // console.error('>>>>@@@', d, index);\n            //         }\n            //     });\n            //     if(!arrSelection.length){\n            //         this.slicerData.hasSelectionOverride = false\n            //     }\n            //     // console.error('>>> 2', 'RESTORE',   savedSelection,     arrSelected,     data.slicerDataPoints )\n            // }\n        }\n\n        private initContainer() {\n            var settings: ChicletSlicerSettings = this.settings;\n            var slicerBodyViewport: IViewport = this.getSlicerBodyViewport(this.currentViewport);\n            var slicerContainer: D3.Selection = d3.select(this.element.get(0))\n                .append('div')\n                .classed(ChicletSlicer.Container.class, true);\n\n            this.slicerHeader = slicerContainer\n                .append('div')\n                .classed(ChicletSlicer.Header.class, true);\n\n            this.slicerHeader\n                .append('span')\n                .classed(ChicletSlicer.Clear.class, true)\n                .attr('title', 'Clear');\n\n            this.slicerHeader\n                .append('div')\n                .classed(ChicletSlicer.HeaderText.class, true)\n                .style({\n                    'margin-left': PixelConverter.toString(settings.headerText.marginLeft),\n                    'margin-top': PixelConverter.toString(settings.headerText.marginTop),\n                    'border-style': this.getBorderStyle(settings.header.outline),\n                    'border-color': settings.header.outlineColor,\n                    'border-width': this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),\n                    'font-size': PixelConverter.fromPoint(settings.header.textSize),\n                });\n\n            this.slicerBody = slicerContainer\n                .append('div').classed(ChicletSlicer.Body.class, true)\n                .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)\n                .classed('slicerBody-vertical', settings.general.orientation === Orientation.VERTICAL)\n                .style({\n                    'height': PixelConverter.toString(slicerBodyViewport.height),\n                    'width': '100%',\n                });\n\n            var rowEnter = (rowSelection: D3.Selection) => {\n                var settings: ChicletSlicerSettings = this.settings;\n                var listItemElement = rowSelection.append('li')\n                    .classed(ChicletSlicer.ItemContainer.class, true)\n                    .style({\n                        'margin-left': PixelConverter.toString(settings.slicerItemContainer.marginLeft),\n                    });\n\n                listItemElement.append('div')\n                    .classed('slicer-img-wrapper', true);\n\n                listItemElement.append('div')\n                    .classed('slicer-text-wrapper', true)\n                    .append('span')\n                    .classed(ChicletSlicer.LabelText.class, true)\n                    .style({\n                        'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),\n                    });\n            };\n\n            var rowUpdate = (rowSelection: D3.Selection) => {\n                var settings: ChicletSlicerSettings = this.settings;\n                var data = this.slicerData;\n                if (data && settings) {\n                    this.slicerHeader.classed('hidden', !settings.header.show);\n                    this.slicerHeader.select(ChicletSlicer.HeaderText.selector)\n                        .text(settings.header.title.trim() !== \"\" ? settings.header.title.trim() : this.slicerData.categorySourceName)\n                        .style({\n                            'border-style': this.getBorderStyle(settings.header.outline),\n                            'border-color': settings.header.outlineColor,\n                            'border-width': this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),\n                            'color': settings.header.fontColor,\n                            'background-color': settings.header.background,\n                            'font-size': PixelConverter.fromPoint(settings.header.textSize),\n                        });\n\n                    this.slicerBody\n                        .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)\n                        .classed('slicerBody-vertical', settings.general.orientation === Orientation.VERTICAL);\n\n                    var slicerText = rowSelection.selectAll(ChicletSlicer.LabelText.selector);\n                    var textProperties = ChicletSlicer.getChicletTextProperties(settings.slicerText.textSize);\n\n                    var formatString = data.formatString;\n                    slicerText.text((d: ChicletSlicerDataPoint) => {\n                        var text = valueFormatter.format(d.category, formatString);\n                        textProperties.text = text;\n                        if (this.settings.slicerText.width === 0)\n                            return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, (this.currentViewport.width / this.settings.general.columns) - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight); \n                        else\n                            return TextMeasurementService.getTailoredTextOrDefault(textProperties, this.settings.slicerText.width - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);\n                    });\n\n                    var slicerImg = rowSelection.selectAll('.slicer-img-wrapper');\n                    slicerImg\n                        .style('height', settings.images.imageSplit + '%')\n                        .classed('hidden', (d: ChicletSlicerDataPoint) => {\n                            if (!(d.imageURL)) {\n                                return true;\n                            }\n                            if (settings.images.imageSplit < 10) {\n                                return true;\n                            }\n                        })\n                        .style('display', (d: ChicletSlicerDataPoint) => (d.imageURL) ? 'flex' : 'none')\n                        .classed('stretchImage', settings.images.stretchImage)\n                        .classed('bottomImage', settings.images.bottomImage)\n                        .style('background-image', (d: ChicletSlicerDataPoint) => {\n                            return d.imageURL ? `url(${d.imageURL})` : '';\n                        });\n\n                    rowSelection.selectAll('.slicer-text-wrapper')\n                        .style('height', (d: ChicletSlicerDataPoint) => {\n                            return d.imageURL ? (100 - settings.images.imageSplit) + '%' : '100%';\n                        })\n                        .classed('hidden', (d: ChicletSlicerDataPoint) => {\n                            if (settings.images.imageSplit > 90) {\n                                return true;\n                            }\n                        });\n\n                    rowSelection.selectAll('.slicerItemContainer').style({\n                        'color': settings.slicerText.fontColor,\n                        'border-style': this.getBorderStyle(settings.slicerText.outline),\n                        'border-color': settings.slicerText.outlineColor,\n                        'border-width': this.getBorderWidth(settings.slicerText.outline, settings.slicerText.outlineWeight),\n                        'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),\n                        'border-radius': this.getBorderRadius(settings.slicerText.borderStyle),\n                    });\n\n                    if (settings.slicerText.background)\n                        this.slicerBody.style('background-color', explore.util.hexToRGBString(settings.slicerText.background, (100 - settings.slicerText.transparency) / 100));\n                    else\n                        this.slicerBody.style('background-color',null);\n\n                    if (this.interactivityService && this.slicerBody) {\n                        var slicerBody = this.slicerBody.attr('width', this.currentViewport.width);\n                        var slicerItemContainers = slicerBody.selectAll(ChicletSlicer.ItemContainer.selector);\n                        var slicerItemLabels = slicerBody.selectAll(ChicletSlicer.LabelText.selector);\n                        var slicerItemInputs = slicerBody.selectAll(ChicletSlicer.Input.selector);\n                        var slicerClear = this.slicerHeader.select(ChicletSlicer.Clear.selector);\n\n                        var behaviorOptions: ChicletSlicerBehaviorOptions = {\n                            dataPoints: data.slicerDataPoints,\n                            slicerItemContainers: slicerItemContainers,\n                            slicerItemLabels: slicerItemLabels,\n                            slicerItemInputs: slicerItemInputs,\n                            slicerClear: slicerClear,\n                            interactivityService: this.interactivityService,\n                            slicerSettings: data.slicerSettings,\n                            isSelectionLoaded: this.isSelectionLoaded\n                        };\n\n                        this.interactivityService.bind(data.slicerDataPoints, this.behavior, behaviorOptions, {\n                            overrideSelectionFromData: true,\n                            hasSelectionOverride: data.hasSelectionOverride,\n                        });\n                        this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector),\n                            this.interactivityService.hasSelection());\n                    }\n                    else {\n                        this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), false);\n                    }\n                }\n            };\n\n            var rowExit = (rowSelection: D3.Selection) => {\n                rowSelection.remove();\n            };\n\n            var tableViewOptions: TableViewViewOptions = {\n                rowHeight: this.getRowHeight(),\n                columnWidth: this.settings.slicerText.width,\n                orientation: this.settings.general.orientation,\n                rows: this.settings.general.rows,\n                columns: this.settings.general.columns,\n                enter: rowEnter,\n                exit: rowExit,\n                update: rowUpdate,\n                loadMoreData: () => this.onLoadMoreData(),\n                scrollEnabled: true,\n                viewport: this.getSlicerBodyViewport(this.currentViewport),\n                baseContainer: this.slicerBody,\n            };\n\n            this.tableView = TableViewFactory.createTableView(tableViewOptions);\n        }\n\n        private onLoadMoreData(): void {\n            if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {\n                this.hostServices.loadMoreData();\n                this.waitingForData = true;\n            }\n        }\n\n        private getSlicerBodyViewport(currentViewport: IViewport): IViewport {\n            var settings = this.settings;\n            var headerHeight = (settings.header.show) ? this.getHeaderHeight() : 0;\n            var slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);\n            return {\n                height: slicerBodyHeight,\n                width: currentViewport.width\n            };\n        }\n\n        private updateSlicerBodyDimensions(): void {\n            var slicerViewport: IViewport = this.getSlicerBodyViewport(this.currentViewport);\n            this.slicerBody\n                .style({\n                    'height': PixelConverter.toString(slicerViewport.height),\n                    'width': '100%',\n                });\n        }\n\n        public static getChicletTextProperties(textSize?: number): TextProperties {\n            return <TextProperties>{\n                fontFamily: ChicletSlicer.DefaultFontFamily,\n                fontSize: PixelConverter.fromPoint(textSize || ChicletSlicer.DefaultFontSizeInPt),\n            };\n        }\n\n        private getHeaderHeight(): number {\n            return TextMeasurementService.estimateSvgTextHeight(\n                ChicletSlicer.getChicletTextProperties(this.settings.header.textSize));\n        }\n\n        private getRowHeight(): number {\n            var textSettings = this.settings.slicerText;\n            return textSettings.height !== 0\n                ? textSettings.height\n                : TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(textSettings.textSize));\n        }\n\n        private getBorderStyle(outlineElement: string): string {\n            return outlineElement === '0px' ? 'none' : 'solid';\n        }\n\n        private getBorderWidth(outlineElement: string, outlineWeight: number): string {\n            switch (outlineElement) {\n                case 'None':\n                    return '0px';\n                case 'BottomOnly':\n                    return '0px 0px ' + outlineWeight + 'px 0px';\n                case 'TopOnly':\n                    return outlineWeight + 'px 0px 0px 0px';\n                case 'TopBottom':\n                    return outlineWeight + 'px 0px ' + outlineWeight + 'px 0px';\n                case 'LeftRight':\n                    return '0px ' + outlineWeight + 'px 0px ' + outlineWeight + 'px';\n                case 'Frame':\n                    return outlineWeight + 'px';\n                default:\n                    return outlineElement.replace(\"1\", outlineWeight.toString());\n            }\n        }\n\n        private getBorderRadius(borderType: string): string {\n            switch (borderType) {\n                case ChicletBorderStyle.ROUNDED:\n                    return \"10px\";\n                case ChicletBorderStyle.SQUARE:\n                    return \"0px\";\n                default:\n                    return \"5px\";\n            }\n        }\n    }\n\n    module ChicletSlicerChartConversion {\n        export class ChicletSlicerConverter {\n            private dataViewCategorical: DataViewCategorical;\n            private dataViewMetadata: DataViewMetadata;\n            private category: DataViewCategoryColumn;\n            private categoryIdentities: DataViewScopeIdentity[];\n            private categoryValues: any[];\n            private categoryColumnRef: data.SQExpr[];\n            private categoryFormatString: string;\n            private interactivityService: IInteractivityService;\n\n            public numberOfCategoriesSelectedInData: number;\n            public dataPoints: ChicletSlicerDataPoint[];\n            public hasSelectionOverride: boolean;\n\n            public constructor(dataView: DataView, interactivityService: IInteractivityService) {\n\n                var dataViewCategorical = dataView.categorical;\n                this.dataViewCategorical = dataViewCategorical;\n                this.dataViewMetadata = dataView.metadata;\n\n                if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {\n                    this.category = dataViewCategorical.categories[0];\n                    this.categoryIdentities = this.category.identity;\n                    this.categoryValues = this.category.values;\n                    this.categoryColumnRef = <data.SQExpr[]> this.category.identityFields;\n                    this.categoryFormatString = valueFormatter.getFormatString(this.category.source, chicletSlicerProps.formatString);\n                }\n\n                this.dataPoints = [];\n\n                this.interactivityService = interactivityService;\n                this.hasSelectionOverride = false;\n            }\n\n            public convert(): void {\n                this.dataPoints = [];\n                this.numberOfCategoriesSelectedInData = 0;\n                // If category exists, we render labels using category values. If not, we render labels\n                // using measure labels.\n                if (this.categoryValues) {\n                    var objects = this.dataViewMetadata ? <any>this.dataViewMetadata.objects : undefined;\n\n                    var isInvertedSelectionMode = undefined;\n                    var numberOfScopeIds: number;\n                    if (objects && objects.general && objects.general.filter) {\n                        if (!this.categoryColumnRef)\n                            return;\n                        var filter = <powerbi.data.SemanticFilter>objects.general.filter;\n                        var scopeIds = powerbi.data.SQExprConverter.asScopeIdsContainer(filter, this.categoryColumnRef);\n                        if (scopeIds) {\n                            isInvertedSelectionMode = scopeIds.isNot;\n                            numberOfScopeIds = scopeIds.scopeIds ? scopeIds.scopeIds.length : 0;\n                        }\n                        else {\n                            isInvertedSelectionMode = false;\n                        }\n                    }\n\n                    if (this.interactivityService) {\n                        if (isInvertedSelectionMode === undefined) {\n                            // The selection state is read from the Interactivity service in case of SelectAll or Clear when query doesn't update the visual\n                            isInvertedSelectionMode = this.interactivityService.isSelectionModeInverted();\n                        }\n                        else {\n                            this.interactivityService.setSelectionModeInverted(isInvertedSelectionMode);\n                        }\n                    }\n\n                    var hasSelection: boolean = undefined;\n\n                    for (var idx = 0; idx < this.categoryValues.length; idx++) {\n                        var selected = isCategoryColumnSelected(chicletSlicerProps.selectedPropertyIdentifier, this.category, idx);\n                        if (selected != null) {\n                            hasSelection = selected;\n                            break;\n                        }\n                    }\n\n                    var dataViewCategorical = this.dataViewCategorical;\n                    var formatStringProp = chicletSlicerProps.formatString;\n                    var value: number = -Infinity;\n                    var imageURL: string = '';\n\n                    for (var categoryIndex: number = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {\n                        var categoryIdentity = this.category.identity ? this.category.identity[categoryIndex] : null;\n                        var categoryIsSelected = isCategoryColumnSelected(chicletSlicerProps.selectedPropertyIdentifier, this.category, categoryIndex);\n                        var selectable: boolean = true;\n\n                        if (hasSelection != null) {\n                            if (isInvertedSelectionMode) {\n                                if (this.category.objects == null)\n                                    categoryIsSelected = undefined;\n\n                                if (categoryIsSelected != null) {\n                                    categoryIsSelected = hasSelection;\n                                }\n                                else if (categoryIsSelected == null)\n                                    categoryIsSelected = !hasSelection;\n                            }\n                            else {\n                                if (categoryIsSelected == null) {\n                                    categoryIsSelected = !hasSelection;\n                                }\n                            }\n                        }\n\n                        if (categoryIsSelected) {\n                            this.numberOfCategoriesSelectedInData++;\n                        }\n\n                        var categoryValue = this.categoryValues[categoryIndex];\n                        var categoryLabel = valueFormatter.format(categoryValue, this.categoryFormatString);\n\n                        if (this.dataViewCategorical.values) {\n                        \n                            // Series are either measures in the multi-measure case, or the single series otherwise\n                            for (var seriesIndex: number = 0; seriesIndex < this.dataViewCategorical.values.length; seriesIndex++) {\n                                var seriesData = dataViewCategorical.values[seriesIndex];\n                                if (seriesData.values[categoryIndex] != null) {\n                                    value = seriesData.values[categoryIndex];\n                                    if (seriesData.highlights) {\n                                        selectable = !(seriesData.highlights[categoryIndex] === null);\n                                    }\n                                    if (seriesData.source.groupName && seriesData.source.groupName !== '') {\n                                        imageURL = converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);\n                                        if (!/^(ftp|http|https):\\/\\/[^ \"]+$/.test(imageURL)) {\n                                            imageURL = undefined;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        this.dataPoints.push({\n                            identity: SelectionId.createWithId(categoryIdentity),\n                            category: categoryLabel,\n                            imageURL: imageURL,\n                            value: value,\n                            selected: categoryIsSelected,\n                            selectable: selectable\n                        });\n                    }\n                    if (numberOfScopeIds != null && numberOfScopeIds > this.numberOfCategoriesSelectedInData) {\n                        this.hasSelectionOverride = true;\n                    }\n                }\n            }\n        }\n    }\n\n    //TODO: This module should be removed once TextMeasruementService exports the \"estimateSvgTextBaselineDelta\" function.\n    export module ChicletSlicerTextMeasurementHelper {\n        interface CanvasContext {\n            font: string;\n            measureText(text: string): { width: number };\n        }\n\n        interface CanvasElement extends HTMLElement {\n            getContext(name: string);\n        }\n\n        var spanElement: JQuery;\n        var svgTextElement: D3.Selection;\n        var canvasCtx: CanvasContext;\n\n        export function estimateSvgTextBaselineDelta(textProperties: TextProperties): number {\n            var rect = estimateSvgTextRect(textProperties);\n            return rect.y + rect.height;\n        }\n\n        function ensureDOM(): void {\n            if (spanElement)\n                return;\n\n            spanElement = $('<span/>');\n            $('body').append(spanElement);\n            //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.\n            svgTextElement = d3.select($('body').get(0))\n                .append('svg')\n                .style({\n                    'height': '0px',\n                    'width': '0px',\n                    'position': 'absolute'\n                })\n                .append('text');\n            canvasCtx = (<CanvasElement>$('<canvas/>').get(0)).getContext(\"2d\");\n        }\n\n        function measureSvgTextRect(textProperties: TextProperties): SVGRect {\n            debug.assertValue(textProperties, 'textProperties');\n\n            ensureDOM();\n\n            svgTextElement.style(null);\n            svgTextElement\n                .text(textProperties.text)\n                .attr({\n                    'visibility': 'hidden',\n                    'font-family': textProperties.fontFamily,\n                    'font-size': textProperties.fontSize,\n                    'font-weight': textProperties.fontWeight,\n                    'font-style': textProperties.fontStyle,\n                    'white-space': textProperties.whiteSpace || 'nowrap'\n                });\n\n            // We're expecting the browser to give a synchronous measurement here\n            // We're using SVGTextElement because it works across all browsers \n            return svgTextElement.node<SVGTextElement>().getBBox();\n        }\n\n        function estimateSvgTextRect(textProperties: TextProperties): SVGRect {\n            debug.assertValue(textProperties, 'textProperties');\n\n            var estimatedTextProperties: TextProperties = {\n                fontFamily: textProperties.fontFamily,\n                fontSize: textProperties.fontSize,\n                text: \"M\",\n            };\n\n            var rect = measureSvgTextRect(estimatedTextProperties);\n\n            return rect;\n        }\n    }\n\n    export interface ChicletSlicerBehaviorOptions {\n        slicerItemContainers: D3.Selection;\n        slicerItemLabels: D3.Selection;\n        slicerItemInputs: D3.Selection;\n        slicerClear: D3.Selection;\n        dataPoints: ChicletSlicerDataPoint[];\n        interactivityService: IInteractivityService;\n        slicerSettings: ChicletSlicerSettings;\n        isSelectionLoaded: boolean;\n    }\n\n    export class ChicletSlicerWebBehavior implements IInteractiveBehavior {\n        private slicers: D3.Selection;\n        private slicerItemLabels: D3.Selection;\n        private slicerItemInputs: D3.Selection;\n        private dataPoints: ChicletSlicerDataPoint[];\n        private interactivityService: IInteractivityService;\n        private slicerSettings: ChicletSlicerSettings;\n        private options: ChicletSlicerBehaviorOptions;\n\n        public bindEvents(options: ChicletSlicerBehaviorOptions, selectionHandler: ISelectionHandler): void {\n            var filterPropertyId = chicletSlicerProps.filterPropertyIdentifier;\n            var slicers = this.slicers = options.slicerItemContainers;\n            this.slicerItemLabels = options.slicerItemLabels;\n            this.slicerItemInputs = options.slicerItemInputs;\n            var slicerClear = options.slicerClear;\n            this.dataPoints = options.dataPoints;\n            this.interactivityService = options.interactivityService;\n            this.slicerSettings = options.slicerSettings;\n            this.options = options;\n\n            if(!this.options.isSelectionLoaded) {\n                this.loadSelection(selectionHandler);\n            }\n\n            slicers.on(\"mouseover\", (d: ChicletSlicerDataPoint) => {\n                if (d.selectable) {\n                    d.mouseOver = true;\n                    d.mouseOut = false;\n                    this.renderMouseover();\n                }\n            });\n\n            slicers.on(\"mouseout\", (d: ChicletSlicerDataPoint) => {\n                if (d.selectable) {\n                    d.mouseOver = false;\n                    d.mouseOut = true;\n                    this.renderMouseover();\n                }\n            });\n\n            slicers.on(\"click\", (d: ChicletSlicerDataPoint, index) => {\n                if (!d.selectable) {\n                    return;\n                }\n                var settings: ChicletSlicerSettings = this.slicerSettings;\n                d3.event.preventDefault();\n                if (d3.event.altKey && settings.general.multiselect) {\n                    var selectedIndexes = jQuery.map(this.dataPoints, function (d, index) { if (d.selected) return index; });\n                    var selIndex = selectedIndexes.length > 0 ? (selectedIndexes[selectedIndexes.length - 1]) : 0;\n                    if (selIndex > index) {\n                        var temp = index;\n                        index = selIndex;\n                        selIndex = temp;\n                    }\n                    selectionHandler.handleClearSelection();\n                    for (var i = selIndex; i <= index; i++) {\n                        selectionHandler.handleSelection(this.dataPoints[i], true /* isMultiSelect */);\n                    }\n                }\n                else if (d3.event.ctrlKey && settings.general.multiselect) {\n                    selectionHandler.handleSelection(d, true /* isMultiSelect */);\n                }\n                else {\n                    selectionHandler.handleSelection(d, false /* isMultiSelect */);\n                }\n                selectionHandler.persistSelectionFilter(filterPropertyId);\n                this.saveSelection(selectionHandler);\n            });\n\n            slicerClear.on(\"click\", (d: SelectableDataPoint) => {\n                selectionHandler.handleClearSelection();\n                selectionHandler.persistSelectionFilter(filterPropertyId);\n                this.saveSelection(selectionHandler);\n            });\n        }\n\n        public loadSelection(selectionHandler: ISelectionHandler): void {\n            selectionHandler.handleClearSelection();\n            var savedSelectionIds =  this.slicerSettings.general.getSavedSelection();\n            if(savedSelectionIds.length) {\n                var selectedDataPoints = this.dataPoints.filter(d => savedSelectionIds.some(x => d.identity.getKey() === x));\n                selectedDataPoints.forEach(x => selectionHandler.handleSelection(x, true));\n                selectionHandler.persistSelectionFilter(chicletSlicerProps.filterPropertyIdentifier);\n            }\n        }\n\n        public saveSelection(selectionHandler: ISelectionHandler): void {\n            var selectionIdKeys = (<SelectionId[]>(<any>selectionHandler).selectedIds).map(x=>x.getKey());\n            this.slicerSettings.general.setSavedSelection(selectionIdKeys);\n        }\n\n        public renderSelection(hasSelection: boolean): void {\n            if (!hasSelection && !this.interactivityService.isSelectionModeInverted()) {\n                this.slicers.style('background', this.slicerSettings.slicerText.unselectedColor);\n            }\n            else {\n                this.styleSlicerInputs(this.slicers, hasSelection);\n            }\n        }\n\n        private renderMouseover(): void {\n            this.slicerItemLabels.style({\n                'color': (d: ChicletSlicerDataPoint) => {\n                    if (d.mouseOver)\n                        return this.slicerSettings.slicerText.hoverColor;\n\n                    if (d.mouseOut) {\n                        if (d.selected)\n                            return this.slicerSettings.slicerText.fontColor;\n                        else\n                            return this.slicerSettings.slicerText.fontColor;\n                    }\n                }\n            });\n        }\n\n        public styleSlicerInputs(slicers: D3.Selection, hasSelection: boolean) {\n            var settings = this.slicerSettings;\n            var selectedItems = [];\n            slicers.each(function (d: ChicletSlicerDataPoint) {\n                // get selected items\n                if (d.selectable && d.selected) {\n                    selectedItems.push(d);\n                }\n                \n                d3.select(this).style({\n                    'background': d.selectable ? (d.selected ? settings.slicerText.selectedColor : settings.slicerText.unselectedColor)\n                        : settings.slicerText.disabledColor\n                });\n                d3.select(this).classed('slicerItem-disabled', !d.selectable);\n            });\n        }\n    }\n\n    module explore.util {\n        export function hexToRGBString(hex: string, transparency?: number): string {\n        \n            // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n            var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n            hex = hex.replace(shorthandRegex, function (m, r, g, b) {\n                return r + r + g + g + b + b;\n            });\n\n            // Hex format which return the format r-g-b\n            var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n            var rgb = result ? {\n                r: parseInt(result[1], 16),\n                g: parseInt(result[2], 16),\n                b: parseInt(result[3], 16)\n            } : null;\n\n            // Wrong input\n            if (rgb === null) {\n                return '';\n            }\n\n            if (!transparency && transparency !== 0) {\n                return \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \")\";\n            }\n            else {\n                return \"rgba(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \",\" + transparency + \")\";\n            }\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *   \n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *   \n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n\n    export interface ChordChartData {\n        dataMatrix: number[][];\n        labelDataPoints: ChordArcDescriptor[];\n        legendData?: LegendData;\n        labelFontSize: number;\n        tooltipData: ChordTooltipData[][];\n        sliceTooltipData: ChordTooltipData[];\n        tickUnit: number;\n        differentFromTo: boolean;\n        defaultDataPointColor?: string;\n        prevAxisVisible: boolean;\n        showAllDataPoints?: boolean;\n        showLabels: boolean;\n        showAxis: boolean;\n    }\n\n    export interface ChordArcDescriptor extends D3.Layout.ArcDescriptor {\n        data: ChordArcLabelData;\n    }\n\n    export interface ChordArcLabelData extends LabelEnabledDataPoint, SelectableDataPoint {\n        label: string;\n        labelColor: string;\n        barColor: string;\n        isCategory: boolean;\n    }\n\n    export interface ChordTooltipData {\n        tooltipInfo: TooltipDataItem[];\n    }\n\n    export class ChordChart implements IVisual {\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: 'Category',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'From',\n                }, {\n                    name: 'Series',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'To',\n                }, {\n                    name: 'Y',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Values'),\n                }\n            ],\n            dataViewMappings: [{\n                conditions: [\n                    { 'Category': { max: 1 }, 'Series': { max: 0 } },\n                    { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },\n                    { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 } },\n                ],\n                categorical: {\n                    categories: {\n                        for: { in: 'Category' },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: {\n                        group: {\n                            by: 'Series',\n                            select: [{ bind: { to: 'Y' } }],\n                            dataReductionAlgorithm: { top: {} }\n                        },\n                    },\n                    rowCount: { preferred: { min: 2 }, supported: { min: 1 } }\n                },\n            }],\n            objects: {\n                dataPoint: {\n                    displayName: data.createDisplayNameGetter('Visual_DataPoint'),\n                    properties: {\n                        defaultColor: {\n                            displayName: data.createDisplayNameGetter('Visual_DefaultColor'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        showAllDataPoints: {\n                            displayName: data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\n                            type: { bool: true }\n                        },\n                        fill: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                    },\n                },\n                axis: {\n                    displayName: 'Axis',\n                    properties: {\n                        show: {\n                            type: { bool: true }\n                        },\n                    },\n                },\n                labels: {\n                    displayName: 'Labels',\n                    properties: {\n                        show: {\n                            type: { bool: true }\n                        },\n                        color: {\n                            displayName: data.createDisplayNameGetter(\"Visual_Reference_Line_Data_Label_Color\"),\n                            description: data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { formatting: { fontSize: true } },\n                        },\n                    },\n                }\n            }\n        };\n\n        public static chordChartProps = {\n            general: {\n                formatString: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'formatString' },\n            },\n            dataPoint: {\n                defaultColor: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'defaultColor' },\n                fill: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'fill' },\n                showAllDataPoints: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'showAllDataPoints' },\n            },\n            axis: {\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'axis', propertyName: 'show' },\n            },\n            labels: {\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'show' },\n                color: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'color' },\n                fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'fontSize' },\n            },\n        };\n\n        public static PolylineOpacity = 0.5;\n\n        private static OuterArcRadiusRatio = 0.9;\n        private static InnerArcRadiusRatio = 0.8;\n        private static DefaultLabelColor = \"#777777\";\n        private static DefaultLabelsFontSize = 12;\n\n        private static VisualClassName = 'chordChart';\n\n        private static sliceClass: ClassAndSelector = {\n            class: 'slice',\n            selector: '.slice',\n        };\n\n        private static chordClass: ClassAndSelector = {\n            class: 'chord',\n            selector: '.chord',\n        };\n\n        private static sliceTicksClass: ClassAndSelector = {\n            class: 'slice-ticks',\n            selector: '.slice-ticks'\n        };\n\n        private static tickPairClass: ClassAndSelector = {\n            class: 'tick-pair',\n            selector: '.tick-pair'\n        };\n\n        private static tickLineClass: ClassAndSelector = {\n            class: 'tick-line',\n            selector: '.tick-line'\n        };\n\n        private static tickTextClass: ClassAndSelector = {\n            class: 'tick-text',\n            selector: '.tick-text'\n        };\n\n        private static labelGraphicsContextClass: ClassAndSelector = {\n            class: 'labels',\n            selector: '.labels',\n        };\n\n        private static labelsClass: ClassAndSelector = {\n            class: 'data-labels',\n            selector: '.data-labels',\n        };\n\n        private static linesGraphicsContextClass: ClassAndSelector = {\n            class: 'lines',\n            selector: '.lines',\n        };\n\n        private static lineClass: ClassAndSelector = {\n            class: 'line-label',\n            selector: '.line-label',\n        };\n\n        private chordLayout: D3.Layout.ChordLayout;\n        private element: JQuery;\n\n        private svg: D3.Selection;\n        private mainGraphicsContext: D3.Selection;\n\n        private data: ChordChartData;\n        private colors: IDataColorPalette;\n        private selectionManager: utility.SelectionManager;\n        private dataView: DataView;\n        \n        /* Convert a DataView into a view model */\n        public static converter(dataView: DataView, colors: IDataColorPalette, prevAxisVisible: boolean): ChordChartData {\n            let catDv: DataViewCategorical = dataView.categorical;\n\n            let defaultDataPointColor: string = ChordChart.getDefaultDataPointColor(dataView).solid.color;\n            let labelColor = ChordChart.getLabelsColor(dataView);\n            let labelFontSize = ChordChart.getLabelsFontSize(dataView);\n\n            if (catDv && catDv.categories && catDv.categories.length > 0 && catDv.values && catDv.categories[0].values && catDv.categories[0].values[0]) {\n\n                let cat: DataViewCategoryColumn = catDv.categories[0];\n                let catValues = cat.values;\n                let values = catDv.values;\n                let dataMatrix: number[][] = [];\n\n                let legendData: LegendData = {\n                    dataPoints: [],\n                    title: values[0] && values[0].source ? values[0].source.displayName : \"\",\n                };\n\n                let toolTipData: ChordTooltipData[][] = [];\n                let sliceTooltipData: ChordTooltipData[] = [];\n\n                let max: number = 1000;\n\n                let seriesName: string[] = [];  /* series name array */\n                let seriesIndex: number[] = []; /* series index array */\n\n                let catIndex: number[] = [];    /* index array for category names */\n\n                let isDiffFromTo: boolean = false;  /* boolean variable indicates that From and To are different */\n\n                let labelData: ChordArcLabelData[] = [];    /* label data: !important */\n\n                let colorHelper = new ColorHelper(colors,\n                    ChordChart.chordChartProps.dataPoint.fill,\n                    defaultDataPointColor);\n\n                for (let i: number = 0, iLen = catValues.length; i < iLen; i++) {\n                    catIndex[catValues[i]] = i;\n                }\n\n                for (let i: number = 0, iLen = values.length; i < iLen; i++) {\n                    let seriesNameStr: string = converterHelper.getSeriesName(values[i].source);\n\n                    seriesName.push(seriesNameStr);\n                    seriesIndex[seriesNameStr] = i;\n                }\n\n                let totalFields: any[] = this.union_arrays(catValues, seriesName);\n\n                if (ChordChart.getValidArrayLength(totalFields) ===\n                    ChordChart.getValidArrayLength(catValues) + ChordChart.getValidArrayLength(seriesName)) {\n                    isDiffFromTo = true;\n                }\n\n                let formatStringProp = ChordChart.chordChartProps.general.formatString;\n                let categorySourceFormatString = valueFormatter.getFormatString(cat.source, formatStringProp);\n\n                for (let i: number = 0, iLen = totalFields.length; i < iLen; i++) {\n                    let id: SelectionId = null;\n                    let color: string = '';\n                    let isCategory: boolean = false;\n\n                    if (catIndex[totalFields[i]] !== undefined) {\n                        let index = catIndex[totalFields[i]];\n                        id = SelectionIdBuilder\n                            .builder()\n                            .withCategory(cat, catIndex[totalFields[i]])\n                            .createSelectionId();\n                        isCategory = true;\n                        let thisCategoryObjects = cat.objects ? cat.objects[index] : undefined;\n\n                        color = colorHelper.getColorForSeriesValue(thisCategoryObjects, /* cat.identityFields */ undefined, catValues[index]);\n\n                    } else if (seriesIndex[totalFields[i]] !== undefined) {\n                        let index = seriesIndex[totalFields[i]];\n\n                        let seriesData = values[index];\n                        let seriesObjects = seriesData && seriesData.objects && seriesData.objects[0];\n                        let seriesNameStr = converterHelper.getSeriesName(seriesData.source);\n\n                        id = SelectionId.createWithId(seriesData.identity);\n                        isCategory = false;\n\n                        color = colorHelper.getColorForSeriesValue(seriesObjects, /* values.identityFields */ undefined, seriesNameStr);\n                    }\n\n                    labelData.push({\n                        label: totalFields[i],\n                        labelColor: labelColor,\n                        barColor: color,\n                        isCategory: isCategory,\n                        identity: id,\n                        selected: false\n                    });\n\n                    dataMatrix.push([]);\n                    toolTipData.push([]);\n\n                    let formattedCategoryValue = valueFormatter.format(catValues[i], categorySourceFormatString);\n\n                    for (let j = 0, jLen = totalFields.length; j < jLen; j++) {\n                        let elementValue: number = 0;\n                        let tooltipInfo: TooltipDataItem[] = [];\n\n                        if (catIndex[totalFields[i]] !== undefined &&\n                            seriesIndex[totalFields[j]] !== undefined) {\n                            let row: number = catIndex[totalFields[i]];\n                            let col: number = seriesIndex[totalFields[j]];\n                            if (values[col].values[row] !== null) {\n                                elementValue = values[col].values[row];\n\n                                if (elementValue > max)\n                                    max = elementValue;\n\n                                tooltipInfo = TooltipBuilder.createTooltipInfo(\n                                    formatStringProp,\n                                    catDv,\n                                    formattedCategoryValue,\n                                    elementValue,\n                                    null,\n                                    null,\n                                    col,\n                                    row);\n                            }\n                        } else if (isDiffFromTo && catIndex[totalFields[j]] !== undefined &&\n                            seriesIndex[totalFields[i]] !== undefined) {\n                            let row: number = catIndex[totalFields[j]];\n                            let col: number = seriesIndex[totalFields[i]];\n                            if (values[col].values[row] !== null) {\n                                elementValue = values[col].values[row];\n                            }\n                        }\n\n                        dataMatrix[i].push(elementValue);\n                        toolTipData[i].push({\n                            tooltipInfo: tooltipInfo\n                        });\n                    }\n\n                    let totalSum = d3.sum(dataMatrix[i]);\n\n                    sliceTooltipData.push({\n                        tooltipInfo: [{\n                            displayName: totalFields[i],\n                            value: (ChordChart.isInt(totalSum)) ? totalSum.toFixed(0) : totalSum.toFixed(2)\n                        }]\n                    });\n                }\n\n                let chordLayout = d3.layout.chord()\n                    .padding(0.1)\n                    .matrix(dataMatrix);\n\n                let unitLength: number = Math.round(max / 5).toString().length - 1;\n\n                return {\n                    dataMatrix: dataMatrix,\n                    labelDataPoints: ChordChart.convertToChordArcDescriptor(chordLayout.groups(), labelData),\n                    legendData: legendData,\n                    tooltipData: toolTipData,\n                    sliceTooltipData: sliceTooltipData,\n                    tickUnit: Math.pow(10, unitLength),\n                    differentFromTo: isDiffFromTo,\n                    defaultDataPointColor: defaultDataPointColor,\n                    prevAxisVisible: prevAxisVisible,\n                    showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),\n                    showLabels: ChordChart.getLabelsShow(dataView),\n                    showAxis: ChordChart.getAxisShow(dataView),\n                    labelFontSize: labelFontSize,\n                };\n            } else {\n                return {\n                    dataMatrix: [],\n                    labelDataPoints: [],\n                    legendData: null,\n                    tooltipData: [],\n                    sliceTooltipData: [],\n                    tickUnit: 1000,\n                    differentFromTo: false,\n                    defaultDataPointColor: defaultDataPointColor,\n                    prevAxisVisible: prevAxisVisible,\n                    showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),\n                    showLabels: ChordChart.getLabelsShow(dataView),\n                    showAxis: ChordChart.getAxisShow(dataView),\n                    labelFontSize: labelFontSize,\n                };\n            }\n        }\n\n        /* Check every element of the array and returns the count of elements which are valid(not undefined) */\n        public static getValidArrayLength(array: any[]): number {\n            let len = 0;\n            for (let i: number = 0, iLen = array.length; i < iLen; i++) {\n                if (array[i] !== undefined) {\n                    len++;\n                }\n            }\n            return len;\n        }\n\n        /* Convert ChordLayout to ChordArcDescriptor */\n        public static convertToChordArcDescriptor(groups: D3.Layout.ArcDescriptor[], datum: ChordArcLabelData[]): ChordArcDescriptor[] {\n            let labelDataPoints: ChordArcDescriptor[] = [];\n            for (let i: number = 0, iLen = groups.length; i < iLen; i++) {\n                let labelDataPoint: ChordArcDescriptor = groups[i];\n                labelDataPoint.data = datum[i];\n                labelDataPoints.push(labelDataPoint);\n            }\n\n            return labelDataPoints;\n        }\n\n        /* Calculate radius */\n        private calculateRadius(viewport: IViewport): number {\n            if (this.data && this.data.showLabels) {\n                // if we have category or data labels, use a sigmoid to blend the desired denominator from 2 to 3.\n                // if we are taller than we are wide, we need to use a larger denominator to leave horizontal room for the labels.\n                let hw = viewport.height / viewport.width;\n                let denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));\n                return Math.min(viewport.height, viewport.width) / denom;\n            }\n\n            // no labels\n            return Math.min(viewport.height, viewport.width) / 2;\n        }\n        \n        /* Draw category labels */\n        public static drawDefaultCategoryLabels(graphicsContext: D3.Selection, chordData: ChordChartData, radius: number, viewport: IViewport): void {\n            /** Multiplier to place the end point of the reference line at 0.05 * radius away from the outer edge of the chord/pie. */\n\n            let arc: D3.Svg.Arc = d3.svg.arc()\n                .innerRadius(0)\n                .outerRadius(radius * ChordChart.InnerArcRadiusRatio);\n\n            let outerArc: D3.Svg.Arc = d3.svg.arc()\n                .innerRadius(radius * ChordChart.OuterArcRadiusRatio)\n                .outerRadius(radius * ChordChart.OuterArcRadiusRatio);\n\n            if (chordData.showLabels) {\n                let labelLayout = ChordChart.getChordChartLabelLayout(radius, outerArc, viewport, chordData.labelFontSize);\n                ChordChart.drawDefaultLabelsForChordChart(chordData.labelDataPoints,\n                    graphicsContext,\n                    labelLayout, viewport,\n                    radius, arc, outerArc);\n            }\n            else\n                dataLabelUtils.cleanDataLabels(graphicsContext, true);\n        }\n\n        /* One time setup*/\n        public init(options: VisualInitOptions): void {\n            let element = this.element = options.element;\n            this.selectionManager = new utility.SelectionManager({ hostServices: options.host });\n\n            this.svg = d3.select(element.get(0))\n                .append('svg')\n                .style('position', 'absolute')\n                .classed(ChordChart.VisualClassName, true);\n\n            this.mainGraphicsContext = this.svg\n                .append('g');\n\n            this.mainGraphicsContext\n                .append('g')\n                .classed('slices', true);\n\n            this.mainGraphicsContext\n                .append('g')\n                .classed('ticks', true);\n\n            this.mainGraphicsContext\n                .append('g')\n                .classed('chords', true);\n\n            this.colors = options.style.colorPalette.dataColors;\n        }\n    \n        /* Called for data, size, formatting changes*/\n        public update(options: VisualUpdateOptions) {\n            // assert dataView           \n            if (!options.dataViews || !options.dataViews[0]) return;\n            \n            // get animation duration\n            let duration = options.suppressAnimations ? 0 : AnimatorCommon.MinervaAnimationDuration;\n\n            let dataView = this.dataView = options.dataViews[0];\n            let prevAxisShow: boolean = (this.data) ? this.data.showAxis : !ChordChart.getAxisShow(dataView);\n\n            let data = this.data = ChordChart.converter(dataView, this.colors, prevAxisShow);\n\n            let viewport = options.viewport;\n\n            let chordLayout = this.chordLayout = d3.layout.chord()\n                .padding(0.1)\n                //.sortGroups(d3.descending)\n                .matrix(data.dataMatrix);\n\n            let width = viewport.width;\n            let height = viewport.height;\n\n            let radius = this.calculateRadius(viewport);\n            let sm = this.selectionManager;\n\n            let innerRadius: number = radius;\n            let outerRadius: number = radius * ChordChart.InnerArcRadiusRatio;\n\n            let arc: D3.Svg.Arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius);\n\n            this.svg\n                .attr({\n                    'width': width,\n                    'height': height\n                });\n\n            let mainGraphicsContext = this.mainGraphicsContext\n                .attr('transform', SVGUtil.translate(width / 2, height / 2));\n\n            let sliceShapes = this.svg.select('.slices')\n                .selectAll('path' + ChordChart.sliceClass.selector)\n                .data(chordLayout.groups);\n\n            sliceShapes.enter()\n                .insert(\"path\")\n                .classed(ChordChart.sliceClass.class, true);\n\n            sliceShapes.style('fill', (d, i) => data.labelDataPoints[i].data.barColor)\n                .style(\"stroke\", (d, i) => data.labelDataPoints[i].data.barColor)\n                .on('click', function(d, i) {\n                    sm.select(data.labelDataPoints[i].data.identity).then(ids=> {\n                        if (ids.length > 0) {\n                            mainGraphicsContext.selectAll(\".chords path.chord\")\n                                .style(\"opacity\", 1);\n\n                            mainGraphicsContext.selectAll(\".slices path.slice\")\n                                .style('opacity', 0.3);\n\n                            mainGraphicsContext.selectAll(\".chords path.chord\")\n                                .filter(function(d) { return d.source.index !== i && d.target.index !== i; })\n                                .style(\"opacity\", 0.3);\n\n                            d3.select(this).style('opacity', 1);\n                        } else {\n                            sliceShapes.style('opacity', 1);\n                            mainGraphicsContext.selectAll(\".chords path.chord\")\n                                .filter(function(d) { return d.source.index !== i && d.target.index !== i; })\n                                .style(\"opacity\", 1);\n                        }\n                    });\n\n                    d3.event.stopPropagation();\n                })\n                .transition()\n                .duration(duration)\n                .attr(\"d\", arc);\n\n            sliceShapes.exit()\n                .remove();\n\n            TooltipManager.addTooltip(sliceShapes, (tooltipEvent: TooltipEvent) => {\n                return data.sliceTooltipData[tooltipEvent.data.index].tooltipInfo;\n            });\n\n            let chordShapes = this.svg.select('.chords')\n                .selectAll('path' + ChordChart.chordClass.selector)\n                .data(chordLayout.chords);\n\n            chordShapes\n                .enter().insert(\"path\")\n                .classed(ChordChart.chordClass.class, true);\n\n            chordShapes.style(\"fill\", (d, i) => data.labelDataPoints[d.target.index].data.barColor)\n                .style(\"opacity\", 1)\n                .transition()\n                .duration(duration)\n                .attr(\"d\", d3.svg.chord().radius(innerRadius));\n\n            chordShapes.exit()\n                .remove();\n\n            this.svg\n                .on('click', () => this.selectionManager.clear().then(() => {\n                    sliceShapes.style('opacity', 1);\n                    chordShapes.style('opacity', 1);\n                }));\n\n            ChordChart.drawTicks(this.mainGraphicsContext, data, chordLayout, outerRadius, duration, viewport);\n            ChordChart.drawDefaultCategoryLabels(this.mainGraphicsContext, data, radius, viewport);\n\n            TooltipManager.addTooltip(chordShapes, (tooltipEvent: TooltipEvent) => {\n                let tooltipInfo: TooltipDataItem[] = [];\n                if (data.differentFromTo) {\n                    tooltipInfo = data.tooltipData[tooltipEvent.data.source.index]\n                    [tooltipEvent.data.source.subindex]\n                        .tooltipInfo;\n                } else {\n                    tooltipInfo.push({\n                        displayName: data.labelDataPoints[tooltipEvent.data.source.index].data.label\n                        + '->' + data.labelDataPoints[tooltipEvent.data.source.subindex].data.label,\n                        value: data.dataMatrix[tooltipEvent.data.source.index]\n                        [tooltipEvent.data.source.subindex].toString()\n                    });\n                    tooltipInfo.push({\n                        displayName: data.labelDataPoints[tooltipEvent.data.target.index].data.label\n                        + '->' + data.labelDataPoints[tooltipEvent.data.target.subindex].data.label,\n                        value: data.dataMatrix[tooltipEvent.data.target.index]\n                        [tooltipEvent.data.target.subindex].toString()\n                    });\n                }\n                return tooltipInfo;\n            });\n        }\n\n        /*About to remove your visual, do clean up here */\n        public destroy() {\n\n        }\n\n        /* Clean ticks */\n        public static cleanTicks(context: D3.Selection) {\n            let empty = [];\n            let tickLines = context.selectAll(ChordChart.tickLineClass.selector).data(empty);\n            tickLines.exit().remove();\n\n            let tickTexts = context.selectAll(ChordChart.tickTextClass.selector).data(empty);\n            tickTexts.exit().remove();\n\n            context.selectAll(ChordChart.tickPairClass.selector).remove();\n            context.selectAll(ChordChart.sliceTicksClass.selector).remove();\n        }\n        \n        /* Draw axis(ticks) around the arc */\n        public static drawTicks(graphicsContext: D3.Selection, chordData: ChordChartData, chordLayout: D3.Layout.ChordLayout, outerRadius: number, duration: number, viewport: IViewport): void {\n\n            if (chordData.showAxis) {\n                let tickShapes = graphicsContext.select('.ticks')\n                    .selectAll('g' + ChordChart.sliceTicksClass.selector)\n                    .data(chordLayout.groups);\n                let animDuration = (chordData.prevAxisVisible === chordData.showAxis) ? duration : 0;\n\n                tickShapes.enter().insert('g')\n                    .classed(ChordChart.sliceTicksClass.class, true);\n\n                let tickPairs = tickShapes.selectAll('g' + ChordChart.tickPairClass.selector)\n                    .data(function(d) {\n                        let k = (d.endAngle - d.startAngle) / d.value;\n                        let range = d3.range(0, d.value, d.value - 1 < 0.15 ? 0.15 : d.value - 1);\n                        let retval =\n                            range.map(function(v, i) {\n                                let divider: number = 1000;\n                                let unitStr: string = 'k';\n\n                                if (chordData.tickUnit >= 1000 * 1000) {\n                                    divider = 1000 * 1000;\n                                    unitStr = 'm';\n                                }\n                                else if (chordData.tickUnit >= 1000) {\n                                    divider = 1000;\n                                    unitStr = 'k';\n                                } else {\n                                    divider = 1;\n                                    unitStr = '';\n                                }\n                                let retv =\n                                    {\n                                        angle: v * k + d.startAngle,\n                                        label: Math.floor(v / divider) + unitStr\n                                    };\n                                return retv;\n\n                            });\n                        return retval;\n                    });\n\n                tickPairs.enter().insert('g')\n                    .classed(ChordChart.tickPairClass.class, true);\n\n                tickPairs.transition()\n                    .duration(animDuration)\n                    .attr('transform', function(d) {\n                        return 'rotate(' + (d.angle * 180 / Math.PI - 90) + ')'\n                            + 'translate(' + outerRadius + ',0)';\n                    });\n\n                tickPairs.selectAll('line' + ChordChart.tickLineClass.selector)\n                    .data((d) => [d])\n                    .enter().insert('line')\n                    .classed(ChordChart.tickLineClass.class, true)\n                    .style(\"stroke\", \"#000\")\n                    .attr(\"x1\", 1)\n                    .attr(\"y1\", 0)\n                    .attr(\"x2\", 5)\n                    .attr(\"y2\", 0);\n\n                tickPairs.selectAll('text' + ChordChart.tickTextClass.selector)\n                    .data((d) => [d])\n                    .enter().insert('text')\n                    .classed(ChordChart.tickTextClass.class, true)\n                    .style(\"text-anchor\", function(d) { return d.angle > Math.PI ? \"end\" : null; })\n                    .text(function(d) { return d.label; })\n                    .attr(\"transform\", function(d) { return d.angle > Math.PI ? \"rotate(180)translate(-16)\" : null; })\n                    .attr(\"x\", 8)\n                    .attr(\"dy\", \".35em\");\n\n                tickPairs.exit()\n                    .remove();\n\n                tickShapes.exit()\n                    .remove();\n\n            } else {\n                ChordChart.cleanTicks(graphicsContext);\n            }\n\n        }\n\n        /* Get format parameter axis whether it determines show ticks or not. Default value is true */\n        private static getAxisShow(dataView: DataView): boolean {\n            if (dataView && dataView.metadata) {\n                let objects = dataView.metadata.objects;\n                if (objects) {\n                    let axis = objects['axis'];\n                    if (axis && axis.hasOwnProperty('show')) {\n                        return <boolean>axis['show'];\n                    }\n                }\n            }\n            return true;\n        }\n        \n        /* Get format parameter labels whether it determines show labels or not. Default value is true */\n        private static getLabelsShow(dataView: DataView): boolean {\n            if (dataView && dataView.metadata) {\n                let objects = dataView.metadata.objects;\n                if (objects) {\n                    let labels = objects['labels'];\n                    if (labels && labels.hasOwnProperty('show')) {\n                        return <boolean>labels['show'];\n                    }\n                }\n            }\n            return true;\n        }\n\n        /* Get format parameter labels whether it determines show labels or not. Default value is true */\n        private static getLabelsColor(dataView: DataView): string {\n            if (dataView && dataView.metadata) {\n                let objects = dataView.metadata.objects;\n                if (objects) {\n                    let labels = objects['labels'];\n                    if (labels && labels.hasOwnProperty('color'))\n                        return labels['color'].solid.color;\n                }\n            }\n            return ChordChart.DefaultLabelColor;\n        }\n\n        private static getLabelsFontSize(dataView: DataView): number {\n            if (dataView && dataView.metadata) {\n                let objects = dataView.metadata.objects;\n                if (objects) {\n                    let labels = objects['labels'];\n                    if (labels && labels.hasOwnProperty('fontSize'))\n                        return labels['fontSize'];\n                }\n            }\n            return ChordChart.DefaultLabelsFontSize;\n        }\n       \n        /* Select labels */\n        public static selectLabels(filteredData: LabelEnabledDataPoint[], context: D3.Selection, isDonut: boolean = false, forAnimation: boolean = false): D3.UpdateSelection {\n\n            // Check for a case where resizing leaves no labels - then we need to remove the labels 'g'\n            if (filteredData.length === 0) {\n                dataLabelUtils.cleanDataLabels(context, true);\n                return null;\n            }\n\n            if (context.select(ChordChart.labelGraphicsContextClass.selector).empty())\n                context.append('g').classed(ChordChart.labelGraphicsContextClass.class, true);\n\n            // line chart ViewModel has a special 'key' property for point identification since the 'identity' field is set to the series identity\n            let hasKey: boolean = (<any>filteredData)[0].key !== null;\n            let hasDataPointIdentity: boolean = (<any>filteredData)[0].identity !== null;\n            let getIdentifier = hasKey ?\n                (d: any) => d.key\n                : hasDataPointIdentity ?\n                    (d: SelectableDataPoint) => d.identity.getKey()\n                    : undefined;\n\n            let labels = isDonut ?\n                context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, (d: DonutArcDescriptor) => d.data.identity.getKey())\n                : getIdentifier !== null ?\n                    context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, getIdentifier)\n                    : context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData);\n\n            let newLabels = labels.enter()\n                .append('text')\n                .classed(ChordChart.labelsClass.class, true);\n            if (forAnimation)\n                newLabels.style('opacity', 0);\n\n            return labels;\n        }\n        \n        /* Draw labels */\n        public static drawDefaultLabelsForChordChart(data: any[], context: D3.Selection, layout: ILabelLayout, viewport: IViewport, radius: number, arc: D3.Svg.Arc, outerArc: D3.Svg.Arc) {\n            // Hide and reposition labels that overlap\n            let dataLabelManager = new DataLabelManager();\n            let filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout,/* addTransform */ true);\n\n            let labels: D3.UpdateSelection = ChordChart.selectLabels(filteredData, context, true);\n\n            if (!labels) {\n                return;\n            }\n\n            labels\n                .attr({ x: (d: LabelEnabledDataPoint) => d.labelX, y: (d: LabelEnabledDataPoint) => d.labelY, dy: '.35em' })\n                .text((d: LabelEnabledDataPoint) => d.labeltext)\n                .style(layout.style);\n\n            labels\n                .exit()\n                .remove();\n\n            if (context.select(ChordChart.linesGraphicsContextClass.selector).empty()) {\n                context\n                    .append('g')\n                    .classed(ChordChart.linesGraphicsContextClass.class, true);\n            }\n\n            let lines = context.select(ChordChart.linesGraphicsContextClass.selector).selectAll('polyline')\n                .data(filteredData, (d: ChordArcDescriptor) => d.data.identity.getKey());\n            let innerLinePointMultiplier = 2.05;\n\n            let midAngle = function(d: ChordArcDescriptor) {\n                return d.startAngle + (d.endAngle - d.startAngle) / 2;\n            };\n\n            lines.enter()\n                .append('polyline')\n                .classed(ChordChart.lineClass.class, true);\n\n            lines\n                .attr('points', function(d) {\n                    let textPoint = outerArc.centroid(d);\n                    textPoint[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);\n                    let midPoint = outerArc.centroid(d);\n                    let chartPoint = arc.centroid(d);\n                    chartPoint[0] *= innerLinePointMultiplier;\n                    chartPoint[1] *= innerLinePointMultiplier;\n                    return [chartPoint, midPoint, textPoint];\n                }).\n                style({\n                    'opacity': (d: ChordArcDescriptor) => ChordChart.PolylineOpacity,\n                    'stroke': (d: ChordArcDescriptor) => d.data.labelColor,\n                });\n\n            lines\n                .exit()\n                .remove();\n        }\n        \n        /* Get label layout */\n        public static getChordChartLabelLayout(radius: number, outerArc: D3.Svg.Arc, viewport: IViewport, labelFontSize: number): ILabelLayout {\n            let midAngle = function(d: ChordArcDescriptor) {\n                return d.startAngle + (d.endAngle - d.startAngle) / 2;\n            };\n\n            let spaceAvaliableForLabels: number = viewport.width / 2 - radius;\n            let minAvailableSpace: number = Math.min(spaceAvaliableForLabels, dataLabelUtils.maxLabelWidth);\n            var PixelConverter = jsCommon.PixelConverter;\n\n            return {\n                labelText: (d: DonutArcDescriptor) => {\n                    // show only category label\n                    return dataLabelUtils.getLabelFormattedText({\n                        label: d.data.label,\n                        maxWidth: minAvailableSpace,\n                        fontSize: labelFontSize,\n                    });\n                },\n                labelLayout: {\n                    x: (d: ChordArcDescriptor) => {\n                        return radius * (midAngle(d) < Math.PI ? 1 : -1);\n                    },\n                    y: (d: ChordArcDescriptor) => {\n                        let pos = outerArc.centroid(d);\n                        return pos[1];\n                    },\n                },\n                filter: (d: ChordArcDescriptor) => (d !== null && d.data !== null && d.data.label !== null),\n                style: {\n                    'fill': (d: ChordArcDescriptor) => d.data.labelColor,\n                    'text-anchor': (d: ChordArcDescriptor) => midAngle(d) < Math.PI ? 'start' : 'end',\n                    'font-size': (d: ChordArcDescriptor) => PixelConverter.fromPointToPixel(labelFontSize),\n                },\n            };\n        }\n        \n        /* Get Default Datapoint color */\n        private static getDefaultDataPointColor(dataView: DataView, defaultValue?: string): Fill {\n            if (dataView && dataView.metadata) {\n                let objects = dataView.metadata.objects;\n                if (objects) {\n                    let dataPoint = objects['dataPoint'];\n                    if (dataPoint && dataPoint.hasOwnProperty('defaultColor')) {\n                        let defaultColor = <Fill>dataPoint['defaultColor'];\n                        if (defaultColor) {\n                            return defaultColor;\n                        }\n                    }\n                }\n            }\n\n            return { solid: { color: defaultValue } };\n        }\n\n        /* Get format paramter value (showAllDataPoints)  */\n        private static getShowAllDataPoints(dataView: DataView): boolean {\n            if (!dataView || !dataView.metadata || !dataView.metadata.objects)\n                return false;\n\n            let objects: DataViewObjects = dataView.metadata.objects;\n            let dataPoint = objects['dataPoint'];\n            if (dataPoint && dataPoint.hasOwnProperty('showAllDataPoints')) {\n                return <boolean>dataPoint['showAllDataPoints'];\n            }\n            return false;\n        }\n\n        /* Enumerate format values */\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\n            let instances: VisualObjectInstance[] = [];\n            let axis: VisualObjectInstance;\n\n            switch (options.objectName) {\n                case 'axis':\n                    axis = {\n                        objectName: 'axis',\n                        displayName: 'Axis',\n                        selector: null,\n                        properties: {\n                            show: ChordChart.getAxisShow(this.dataView)\n                        }\n                    };\n\n                    instances.push(axis);\n                    break;\n                case 'labels':\n                    axis = {\n                        objectName: 'labels',\n                        displayName: 'Labels',\n                        selector: null,\n                        properties: {\n                            show: ChordChart.getLabelsShow(this.dataView),\n                            color: ChordChart.getLabelsColor(this.dataView),\n                            fontSize: ChordChart.getLabelsFontSize(this.dataView),\n                        }\n                    };\n                    instances.push(axis);\n                    break;\n                case 'dataPoint':\n                    let defaultColor: VisualObjectInstance = {\n                        objectName: 'dataPoint',\n                        selector: null,\n                        properties: {\n                            defaultColor: {\n                                solid: { color: (this.data && this.data.defaultDataPointColor) ? this.data.defaultDataPointColor : this.colors.getColorByIndex(0).value }\n                            }\n                        }\n                    };\n\n                    instances.push(defaultColor);\n\n                    let showAllDataPoints: VisualObjectInstance = {\n                        objectName: 'dataPoint',\n                        selector: null,\n                        properties: {\n                            showAllDataPoints: this.data ? !!this.data.showAllDataPoints : false,\n                        }\n                    };\n\n                    instances.push(showAllDataPoints);\n\n                    if (this.data && this.data.labelDataPoints) {\n                        for (let i: number = 0, iLen = this.data.labelDataPoints.length; i < iLen; i++) {\n                            let labelDataPoint: ChordArcLabelData = this.data.labelDataPoints[i].data;\n\n                            if (labelDataPoint.isCategory) {\n                                let colorInstance: VisualObjectInstance = {\n                                    objectName: 'dataPoint',\n                                    displayName: labelDataPoint.label,\n                                    selector: ColorHelper.normalizeSelector(labelDataPoint.identity.getSelector()),\n                                    properties: {\n                                        fill: { solid: { color: labelDataPoint.barColor } }\n                                    }\n                                };\n\n                                instances.push(colorInstance);\n                            }\n                        }\n                    }\n                    break;\n            }\n            return instances;\n        }\n\n        /* Utility function for checking if it is integer or float */\n        public static isInt(n: number): boolean {\n            return n % 1 === 0;\n        }\n        \n        /* Utility function for union two arrays without duplicates */\n        public static union_arrays(x: any[], y: any[]): any[] {\n            let obj: Object = {};\n\n            for (let i: number = 0; i < x.length; i++) {\n                obj[x[i]] = x[i];\n            }\n\n            for (let i: number = 0; i < y.length; i++) {\n                obj[y[i]] = y[i];\n            }\n\n            let res: string[] = [];\n\n            for (let k in obj) {\n                if (obj.hasOwnProperty(k)) {  // <-- optional\n                    res.push(obj[k]);\n                }\n            }\n            return res;\n        }\n    }\n}\n","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *   \n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *   \n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n    import DataRoleHelper = powerbi.data.DataRoleHelper;\n\n    interface ScatterChartMeasureMetadata {\n        idx: {\n            x?: number;\n            y?: number;\n            size?: number;\n            colorFill?: number;\n            shape?: number;\n            image?: number;\n            rotation?: number;\n            backdrop?: number;\n            xStart?: number;\n            xEnd?: number;\n            yStart?: number;\n            yEnd?: number;\n        };\n        cols: {\n            x?: DataViewMetadataColumn;\n            y?: DataViewMetadataColumn;\n            size?: DataViewMetadataColumn;\n            colorFill?: DataViewMetadataColumn;\n            shape?: DataViewMetadataColumn;\n            image?: DataViewMetadataColumn;\n            rotation?: DataViewMetadataColumn;\n            backdrop?: DataViewMetadataColumn;\n            xStart?: DataViewMetadataColumn;\n            xEnd?: DataViewMetadataColumn;\n            yStart?: DataViewMetadataColumn;\n            yEnd?: DataViewMetadataColumn;\n        };\n        axesLabels: ChartAxesLabels;\n    }\n\n    export interface EnhancedScatterChartDataPoint extends SelectableDataPoint, TooltipEnabledDataPoint, LabelEnabledDataPoint {\n        x: any;\n        y: any;\n        size: any;\n        radius: RadiusData;\n        fill: string;\n        formattedCategory: jsCommon.Lazy<string>;\n        colorFill?: string;\n        svgurl?: string;\n        shapeSymbolType?: (number) => string;\n        rotation: number;\n        backdrop?: string;\n        xStart?: number;\n        xEnd?: number;\n        yStart?: number;\n        yEnd?: number;\n    }\n\n    export interface EnhancedScatterChartData extends ScatterBehaviorChartData {\n        useShape: boolean;\n        useCustomColor: boolean;\n        backdrop?: {\n            show: boolean;\n            url: string;\n        };\n        outline?: boolean;\n        crosshair?: boolean;\n        xCol: DataViewMetadataColumn;\n        yCol: DataViewMetadataColumn;\n        dataPoints: EnhancedScatterChartDataPoint[];\n        legendData: LegendData;\n        axesLabels: ChartAxesLabels;\n        size?: DataViewMetadataColumn;\n        sizeRange: NumberRange;\n        dataLabelsSettings: PointDataLabelsSettings;\n        defaultDataPointColor?: string;\n        showAllDataPoints?: boolean;\n        hasDynamicSeries?: boolean;\n        fillPoint?: boolean;\n        colorBorder?: boolean;\n        colorByCategory?: boolean;\n        selectedIds: SelectionId[];\n    }\n\n    export class EnhancedScatterChart implements IVisual {\n        private AxisGraphicsContextClassName = 'axisGraphicsContext';\n        public static DefaultBubbleOpacity = 0.85;\n        public static DimmedBubbleOpacity = 0.4;\n        private static DataLabelsOffset = 5;\n        private static ClassName = 'enhancedScatterChart';\n        private static MainGraphicsContextClassName = 'mainGraphicsContext';\n        private static LegendLabelFontSizeDefault: number = 9;\n        private static LabelDisplayUnitsDefault: number = 0;\n        private static AxisFontSize = 11;\n\n        private static DotClasses: ClassAndSelector = {\n            class: 'dot',\n            selector: '.dot'\n        };\n        private static ImageClasses: ClassAndSelector = {\n            class: 'img',\n            selector: '.img'\n        };\n\n        private legend: ILegend;\n        private svgScrollable: D3.Selection;\n        private axisGraphicsContext: D3.Selection;\n        private axisGraphicsContextScrollable: D3.Selection;\n        private xAxisGraphicsContext: D3.Selection;\n        private backgroundGraphicsContext: D3.Selection;\n        private y1AxisGraphicsContext: D3.Selection;\n        private svg: D3.Selection;\n        private element: JQuery;\n        private mainGraphicsContext: D3.Selection;\n        private clearCatcher: D3.Selection;\n        private mainGraphicsG: D3.Selection;\n\n        private style: IVisualStyle;\n        private data: EnhancedScatterChartData;\n        private dataView: DataView;\n\n        private xAxisProperties: IAxisProperties;\n        private yAxisProperties: IAxisProperties;\n        private colors: IDataColorPalette;\n        private options: VisualInitOptions;\n        private interactivity: InteractivityOptions;\n        private interactivityService: IInteractivityService;\n        private categoryAxisProperties: DataViewObject;\n        private valueAxisProperties: DataViewObject;\n        private yAxisOrientation: string;\n        private scrollY: boolean;\n        private scrollX: boolean;\n\n        private dataViews: DataView[];\n        private legendObjectProperties: DataViewObject;\n        private hostServices: IVisualHostServices;\n        private layerLegendData: LegendData;\n        private legendLabelFontSize: number;\n        private cartesianSmallViewPortProperties: CartesianSmallViewPortProperties;\n        private hasCategoryAxis: boolean;\n        private yAxisIsCategorical: boolean;\n        private bottomMarginLimit: number;\n        private leftRightMarginLimit: number;\n        private isXScrollBarVisible: boolean;\n        private isYScrollBarVisible: boolean;\n        private ScrollBarWidth = 10;\n        private categoryAxisHasUnitType: boolean;\n        private valueAxisHasUnitType: boolean;\n        private svgDefaultImage: string;\n        private oldBackdrop: string;\n        private textProperties: TextProperties = {\n            fontFamily: 'wf_segoe-ui_normal',\n            fontSize: jsCommon.PixelConverter.toString(EnhancedScatterChart.AxisFontSize),\n        };\n        private behavior: IInteractiveBehavior;\n        private animator: IGenericAnimator;\n        private keyArray: string[];\n\n        private _margin: IMargin;\n        private get margin(): IMargin {\n            return this._margin || { left: 0, right: 0, top: 0, bottom: 0 };\n        }\n\n        private set margin(value: IMargin) {\n            this._margin = $.extend({}, value);\n            this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);\n        }\n\n        private _viewport: IViewport;\n        private get viewport(): IViewport {\n            return this._viewport || { width: 0, height: 0 };\n        }\n\n        private set viewport(value: IViewport) {\n            this._viewport = $.extend({}, value);\n            this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);\n        }\n\n        private _viewportIn: IViewport;\n        private get viewportIn(): IViewport {\n            return this._viewportIn || this.viewport;\n        }\n\n        private get legendViewport(): IViewport {\n            return this.legend.getMargins();\n        }\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: 'Category',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Details'),\n                }, {\n                    name: 'Series',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Legend'),\n                }, {\n                    name: 'X',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_X'),\n                }, {\n                    name: 'Y',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Y'),\n                }, {\n                    name: 'Size',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Size'),\n                }, {\n                    name: 'Gradient',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Gradient'),\n                }, {\n                    name: 'ColorFill',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Customized Color',\n                }, {\n                    name: 'Shape',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Shape',\n                }, {\n                    name: 'Image',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Image',\n                }, {\n                    name: 'Rotation',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Rotation',\n                }, {\n                    name: 'Backdrop',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Backdrop',\n                }, {\n                    name: 'X Start',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'X Start',\n                }, {\n                    name: 'X End',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'X End',\n                }, {\n                    name: 'Y Start',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Y Start',\n                }, {\n                    name: 'Y End',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Y End',\n                }\n            ],\n\n            dataViewMappings: [{\n                conditions: [{\n                    'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 },\n                    'Size': { max: 1 }, 'Gradient': { max: 0 }, 'ColorFill': { max: 1 }, 'Shape': { max: 1 },\n                    'Image': { max: 0 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\n                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\n                }, {\n                        'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 },\n                        'Size': { max: 1 }, 'Gradient': { max: 1 }, 'ColorFill': { max: 1 }, 'Shape': { max: 1 },\n                        'Image': { max: 0 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\n                        'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\n                    }, {\n                        'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 },\n                        'Size': { max: 1 }, 'Gradient': { max: 0 }, 'ColorFill': { max: 0 }, 'Shape': { max: 0 },\n                        'Image': { max: 1 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\n                        'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\n                    }, {\n                        'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 },\n                        'Size': { max: 1 }, 'Gradient': { max: 1 }, 'ColorFill': { max: 0 }, 'Shape': { max: 0 },\n                        'Image': { max: 1 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\n                        'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\n                    }],\n                categorical: {\n                    categories: {\n                        for: { in: 'Category' },\n                        dataReductionAlgorithm: { sample: {} }\n                    },\n                    values: {\n                        group: {\n                            by: 'Series',\n                            select: [\n                                { bind: { to: 'X' } },\n                                { bind: { to: 'Y' } },\n                                { bind: { to: 'Size' } },\n                                { bind: { to: 'Gradient' } },\n                                { bind: { to: 'ColorFill' } },\n                                { bind: { to: 'Shape' } },\n                                { bind: { to: 'Image' } },\n                                { bind: { to: 'Rotation' } },\n                                { bind: { to: 'Backdrop' } },\n                                { bind: { to: 'X Start' } },\n                                { bind: { to: 'X End' } },\n                                { bind: { to: 'Y Start' } },\n                                { bind: { to: 'Y End' } },\n                            ],\n                            dataReductionAlgorithm: { top: {} }\n                        }\n                    },\n                    rowCount: { preferred: { min: 2 } }\n                },\n            }],\n\n            objects: {\n                dataPoint: {\n                    displayName: data.createDisplayNameGetter('Visual_DataPoint'),\n                    properties: {\n                        defaultColor: {\n                            displayName: data.createDisplayNameGetter('Visual_DefaultColor'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        showAllDataPoints: {\n                            displayName: data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\n                            type: { bool: true }\n                        },\n                        useShape: {\n                            displayName: data.createDisplayNameGetter('Visual_UseImage'),\n                            type: { bool: true }\n                        },\n                        fill: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fillRule: {\n                            displayName: data.createDisplayNameGetter('Visual_Gradient'),\n                            type: { fillRule: {} },\n                            rule: {\n                                inputRole: 'Gradient',\n                                output: {\n                                    property: 'fill',\n                                    selector: ['Category'],\n                                },\n                            }\n                        }\n                    }\n                },\n                general: {\n                    displayName: data.createDisplayNameGetter('Visual_General'),\n                    properties: {\n                        formatString: {\n                            type: { formatting: { formatString: true } },\n                        },\n                    },\n                },\n                categoryAxis: {\n                    displayName: data.createDisplayNameGetter('Visual_XAxis'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        axisScale: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Scale'),\n                            type: { formatting: { axisScale: true } }\n                        },\n                        start: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Start'),\n                            type: { numeric: true }\n                        },\n                        end: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_End'),\n                            type: { numeric: true }\n                        },\n                        showAxisTitle: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Title'),\n                            type: { bool: true }\n                        },\n                        axisStyle: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Style'),\n                            type: { formatting: { axisStyle: true } }\n                        },\n                        axisColor: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        labelDisplayUnits: {\n                            displayName: 'Display Units',\n                            type: { formatting: { labelDisplayUnits: true } },\n                        },\n                    }\n                },\n                valueAxis: {\n                    displayName: data.createDisplayNameGetter('Visual_YAxis'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: data.createDisplayNameGetter('Visual_YAxis_Position'),\n                            type: { formatting: { yAxisPosition: true } }\n                        },\n                        axisScale: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Scale'),\n                            type: { formatting: { axisScale: true } }\n                        },\n                        start: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Start'),\n                            type: { numeric: true }\n                        },\n                        end: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_End'),\n                            type: { numeric: true }\n                        },\n                        showAxisTitle: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Title'),\n                            type: { bool: true }\n                        },\n                        axisStyle: {\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Style'),\n                            type: { formatting: { axisStyle: true } }\n                        },\n                        axisColor: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        labelDisplayUnits: {\n                            displayName: 'Display Units',\n                            type: { formatting: { labelDisplayUnits: true } },\n                        }\n                    }\n                },\n                legend: {\n                    displayName: data.createDisplayNameGetter('Visual_Legend'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendPosition'),\n                            description: data.createDisplayNameGetter('Visual_LegendPositionDescription'),\n                            type: { enumeration: legendPosition.type },\n                        },\n                        showTitle: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendShowTitle'),\n                            description: data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),\n                            type: { bool: true }\n                        },\n                        titleText: {\n                            displayName: 'Legend Name',\n                            description: data.createDisplayNameGetter('Visual_LegendNameDescription'),\n                            type: { text: true }\n                        },\n                        labelColor: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: 'Text Size',\n                            type: { formatting: { fontSize: true } }\n                        }\n                    }\n                },\n                categoryLabels: {\n                    displayName: data.createDisplayNameGetter('Visual_CategoryLabels'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        color: {\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: 'Text Size',\n                            type: { formatting: { fontSize: true } }\n                        },\n                    },\n                },\n                fillPoint: {\n                    displayName: data.createDisplayNameGetter('Visual_FillPoint'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { bool: true }\n                        },\n                    },\n                },\n                backdrop: {\n                    displayName: 'Backdrop',\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        url: {\n                            displayName: 'Image URL',\n                            type: { text: true }\n                        },\n                    },\n                },\n                crosshair: {\n                    displayName: 'Crosshair',\n                    properties: {\n                        show: {\n                            displayName: 'Crosshair',\n                            type: { bool: true }\n                        },\n                    },\n                },\n                outline: {\n                    displayName: 'Outline',\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Outline'),\n                            type: { bool: true }\n                        }\n                    }\n                }\n            }\n        };\n\n        private static substractMargin(viewport: IViewport, margin: IMargin): IViewport {\n            return {\n                width: Math.max(viewport.width - (margin.left + margin.right), 0),\n                height: Math.max(viewport.height - (margin.top + margin.bottom), 0)\n            };\n        }\n\n        private static getCustomSymbolType(shape: any): (number) => string {\n            let customSymbolTypes = d3.map({\n                \"circle\": (size) => {\n                    let r = Math.sqrt(size / Math.PI);\n                    return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + (-r) + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\n                },\n\n                \"cross\": function (size) {\n                    let r = Math.sqrt(size / 5) / 2;\n                    return \"M\" + -3 * r + \",\" + -r\n                        + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\n                },\n\n                \"diamond\": (size) => {\n                    let ry = Math.sqrt(size / (2 * Math.tan(Math.PI / 6))),\n                        rx = ry * Math.tan(Math.PI / 6);\n                    return \"M0,\" + -ry\n                        + \"L\" + rx + \",0\"\n                        + \" 0,\" + ry\n                        + \" \" + -rx + \",0\"\n                        + \"Z\";\n                },\n\n                \"square\": (size) => {\n                    let r = Math.sqrt(size) / 2;\n                    return \"M\" + -r + \",\" + -r\n                        + \"L\" + r + \",\" + -r\n                        + \" \" + r + \",\" + r\n                        + \" \" + -r + \",\" + r\n                        + \"Z\";\n                },\n\n                \"triangle-up\": (size) => {\n                    let rx = Math.sqrt(size / Math.sqrt(3)),\n                        ry = rx * Math.sqrt(3) / 2;\n                    return \"M0,\" + -ry\n                        + \"L\" + rx + \",\" + ry\n                        + \" \" + -rx + \",\" + ry\n                        + \"Z\";\n                },\n\n                \"triangle-down\": (size) => {\n                    let rx = Math.sqrt(size / Math.sqrt(3)),\n                        ry = rx * Math.sqrt(3) / 2;\n                    return \"M0,\" + ry\n                        + \"L\" + rx + \",\" + -ry\n                        + \" \" + -rx + \",\" + -ry\n                        + \"Z\";\n                },\n\n                'star': (size) => {\n                    let outerRadius = Math.sqrt(size / 2);\n                    let innerRadius = Math.sqrt(size / 10);\n                    let results = \"\";\n                    let angle = Math.PI / 5;\n                    for (let i = 0; i < 10; i++) {\n                        // Use outer or inner radius depending on what iteration we are in.\n                        let r = (i & 1) === 0 ? outerRadius : innerRadius;\n                        let currX = Math.cos(i * angle) * r;\n                        let currY = Math.sin(i * angle) * r;\n                        // Our first time we simply append the coordinates, subsequet times\n                        // we append a \", \" to distinguish each coordinate pair.\n                        if (i === 0) {\n                            results = \"M\" + currX + \",\" + currY + \"L\";\n                        } else {\n                            results += \" \" + currX + \",\" + currY;\n                        }\n                    }\n                    return results + \"Z\";\n                },\n\n                'hexagon': (size) => {\n                    let r = Math.sqrt(size / (6 * Math.sqrt(3)));\n                    let r2 = Math.sqrt(size / (2 * Math.sqrt(3)));\n\n                    return \"M0,\" + (2 * r) + \"L\" + (-r2) + \",\" + r + \" \" + (-r2) + \",\" + (-r) + \" 0,\" + (-2 * r) + \" \" + r2 + \",\" + (-r) + \" \" + r2 + \",\" + r + \"Z\";\n                },\n\n                'x': (size) => {\n                    let r = Math.sqrt(size / 10);\n                    return \"M0,\" + r + \"L\" + (-r) + \",\" + 2 * r + \" \" + (-2 * r) + \",\" + r + \" \" + (-r) + \",0 \" + (-2 * r) + \",\" + (-r) + \" \" + (-r) + \",\" + (-2 * r) + \" 0,\" + (-r) + \" \" + r + \",\" + (-2 * r) + \" \" + (2 * r) + \",\" + (-r) + \" \" + r + \",0 \" + (2 * r) + \",\" + r + \" \" + r + \",\" + (2 * r) + \"Z\";\n                },\n\n                'uparrow': (size) => {\n                    let r = Math.sqrt(size / 12);\n                    return \"M\" + r + \",\" + (3 * r) + \"L\" + (-r) + \",\" + (3 * r) + \" \" + (-r) + \",\" + (-r) + \" \" + (-2 * r) + \",\" + (-r) + \" 0,\" + (-3 * r) + \" \" + (2 * r) + \",\" + (-r) + \" \" + r + \",\" + (-r) + \"Z\";\n                },\n\n                'downarrow': (size) => {\n                    let r = Math.sqrt(size / 12);\n                    return \"M0,\" + (3 * r) + \"L\" + (-2 * r) + \",\" + r + \" \" + (-r) + \",\" + r + \" \" + (-r) + \",\" + (-3 * r) + \" \" + r + \",\" + (-3 * r) + \" \" + r + \",\" + r + \" \" + (2 * r) + \",\" + r + \"Z\";\n                }\n            });\n\n            let defaultValue = customSymbolTypes.entries()[0].value;\n            if (!shape) {\n                return defaultValue;\n            } else if (isNaN(shape)) {\n                return customSymbolTypes[shape && shape.toString().toLowerCase()] || defaultValue;\n            } else {\n                let result = customSymbolTypes.entries()[Math.floor(shape)];\n                return result ? result.value : defaultValue;\n            }\n        }\n\n        public init(options: VisualInitOptions): void {\n            this.options = options;\n            this.animator = new BaseAnimator();\n            this.behavior = new CartesianChartBehavior([new ScatterChartWebBehavior()]);\n            let element = this.element = options.element;\n            this.viewport = _.clone(options.viewport);\n            this.style = options.style;\n            this.hostServices = options.host;\n            this.colors = this.style.colorPalette.dataColors;\n            this.interactivity = options.interactivity;\n            this.margin = {\n                top: 1,\n                right: 1,\n                bottom: 1,\n                left: 1\n            };\n\n            this.yAxisOrientation = yAxisPosition.left;\n            this.adjustMargins();\n\n            let showLinesOnX = this.scrollY = true;\n\n            let showLinesOnY = this.scrollX = true;\n\n            let svg = this.svg = d3.select(element.get(0))\n                .append('svg')\n                .style('position', 'absolute')\n                .classed(EnhancedScatterChart.ClassName, true);\n\n            let axisGraphicsContext = this.axisGraphicsContext = svg.append('g')\n                .classed(this.AxisGraphicsContextClassName, true);\n\n            this.svgScrollable = svg.append('svg')\n                .classed('svgScrollable', true)\n                .style('overflow', 'hidden');\n\n            let axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')\n                .classed(this.AxisGraphicsContextClassName, true);\n\n            this.clearCatcher = appendClearCatcher(this.axisGraphicsContextScrollable);\n            let axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;\n\n            this.backgroundGraphicsContext = axisGraphicsContext.append('svg:image');\n            this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');\n            this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');\n\n            this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);\n            this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);\n\n            this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);\n            this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);\n            this.interactivityService = createInteractivityService(this.hostServices);\n\n            this.legend = createLegend(element, this.interactivity && this.interactivity.isInteractiveLegend, this.interactivityService, true);\n\n            this.mainGraphicsG = this.axisGraphicsContextScrollable.append('g')\n                .classed(EnhancedScatterChart.MainGraphicsContextClassName, true);\n\n            this.mainGraphicsContext = this.mainGraphicsG.append('svg');\n            this.svgDefaultImage = \"http://svg-edit.googlecode.com/svn-history/r1771/trunk/clipart/sun.svg\";\n            this.keyArray = [];\n        }\n\n        private adjustMargins(): void {\n            // Adjust margins if ticks are not going to be shown on either axis\n            let xAxis = this.element.find('.x.axis');\n\n            if (AxisHelper.getRecommendedNumberOfTicksForXAxis(this.viewportIn.width) === 0\n                && AxisHelper.getRecommendedNumberOfTicksForYAxis(this.viewportIn.height) === 0) {\n                this.margin = {\n                    top: 0,\n                    right: 0,\n                    bottom: 0,\n                    left: 0\n                };\n                xAxis.hide();\n            } else {\n                xAxis.show();\n            }\n        }\n\n        private getValueAxisProperties(dataViewMetadata: DataViewMetadata, axisTitleOnByDefault?: boolean): DataViewObject {\n            let toReturn: DataViewObject = {};\n            if (!dataViewMetadata)\n                return toReturn;\n\n            let objects = dataViewMetadata.objects;\n\n            if (objects) {\n                let valueAxisObject = objects['valueAxis'];\n                if (valueAxisObject) {\n                    toReturn = {\n                        show: valueAxisObject['show'],\n                        position: valueAxisObject['position'],\n                        axisScale: valueAxisObject['axisScale'],\n                        start: valueAxisObject['start'],\n                        end: valueAxisObject['end'],\n                        showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],\n                        axisStyle: valueAxisObject['axisStyle'],\n                        axisColor: valueAxisObject['axisColor'],\n                        secShow: valueAxisObject['secShow'],\n                        secPosition: valueAxisObject['secPosition'],\n                        secAxisScale: valueAxisObject['secAxisScale'],\n                        secStart: valueAxisObject['secStart'],\n                        secEnd: valueAxisObject['secEnd'],\n                        secShowAxisTitle: valueAxisObject['secShowAxisTitle'],\n                        secAxisStyle: valueAxisObject['secAxisStyle'],\n                        labelDisplayUnits: valueAxisObject['labelDisplayUnits'],\n                    };\n                }\n            }\n            return toReturn;\n        }\n\n        private getCategoryAxisProperties(dataViewMetadata: DataViewMetadata, axisTitleOnByDefault?: boolean): DataViewObject {\n            let toReturn: DataViewObject = {};\n            if (!dataViewMetadata)\n                return toReturn;\n\n            let objects = dataViewMetadata.objects;\n\n            if (objects) {\n                let categoryAxisObject = objects['categoryAxis'];\n\n                if (categoryAxisObject) {\n                    toReturn = {\n                        show: categoryAxisObject['show'],\n                        axisType: categoryAxisObject['axisType'],\n                        axisScale: categoryAxisObject['axisScale'],\n                        axisColor: categoryAxisObject['axisColor'],\n                        start: categoryAxisObject['start'],\n                        end: categoryAxisObject['end'],\n                        showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],\n                        axisStyle: categoryAxisObject['axisStyle'],\n                        labelDisplayUnits: categoryAxisObject['labelDisplayUnits']\n                    };\n                }\n            }\n            return toReturn;\n        }\n\n        public static converter(dataView: DataView, currentViewport: IViewport, colorPalette: IDataColorPalette, interactivityService?: IInteractivityService, categoryAxisProperties?: DataViewObject, valueAxisProperties?: DataViewObject): EnhancedScatterChartData {\n            let categoryValues: any[],\n                categoryFormatter: IValueFormatter,\n                categoryObjects: DataViewObjects[],\n                categoryIdentities: DataViewScopeIdentity[],\n                categoryQueryName: string;\n\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\n            let dataViewMetadata: DataViewMetadata = dataView.metadata;\n\n            if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {\n                categoryValues = dataViewCategorical.categories[0].values;\n                categoryFormatter = valueFormatter.create({ format: valueFormatter.getFormatString(dataViewCategorical.categories[0].source, scatterChartProps.general.formatString), value: categoryValues[0], value2: categoryValues[categoryValues.length - 1] });\n                categoryIdentities = dataViewCategorical.categories[0].identity;\n                categoryObjects = dataViewCategorical.categories[0].objects;\n                categoryQueryName = dataViewCategorical.categories[0].source.queryName;\n            }\n            else {\n                categoryValues = [null];\n                // creating default formatter for null value (to get the right string of empty value from the locale)\n                categoryFormatter = valueFormatter.createDefaultFormatter(null);\n            }\n            let categories = dataViewCategorical.categories;\n            let dataValues = dataViewCategorical.values;\n            let hasDynamicSeries = !!dataValues.source;\n            let grouped = dataValues.grouped();\n            let useShape = (!!(DataRoleHelper.getMeasureIndexOfRole(grouped, 'Image') >= 0)) ? false : true;\n            let useCustomColor = (!!(DataRoleHelper.getMeasureIndexOfRole(grouped, 'ColorFill') >= 0)) ? true : false;\n            let dvSource = dataValues.source;\n            let scatterMetadata = EnhancedScatterChart.getMetadata(grouped, dvSource);\n            let dataLabelsSettings = dataLabelUtils.getDefaultPointLabelSettings();\n            let fillPoint = false;\n            let backdrop = { show: false, url: \"\" };\n            let crosshair = false;\n            let outline = false;\n            let defaultDataPointColor = \"\";\n            let showAllDataPoints = true;\n\n            if (dataViewMetadata && dataViewMetadata.objects) {\n                let objects = dataViewMetadata.objects;\n\n                defaultDataPointColor = DataViewObjects.getFillColor(objects, columnChartProps.dataPoint.defaultColor);\n                showAllDataPoints = DataViewObjects.getValue<boolean>(objects, columnChartProps.dataPoint.showAllDataPoints);\n                /*if(objects['dataPoint']){\n                    let shapeObj = objects['dataPoint'];\n                    if(shapeObj['useShape']){\n                        shape = <boolean>shapeObj['useShape'];\n                    }\n                }*/\n\n                let labelsObj = objects['categoryLabels'];\n                if (labelsObj) {\n                    dataLabelsSettings.show = (labelsObj['show'] !== undefined) ? <boolean>labelsObj['show'] : dataLabelsSettings.show;\n                    dataLabelsSettings.fontSize = (labelsObj['fontSize'] !== undefined) ? <number>labelsObj['fontSize'] : dataLabelsSettings.fontSize;\n                    if (labelsObj['color'] !== undefined) {\n                        dataLabelsSettings.labelColor = (<Fill>labelsObj['color']).solid.color;\n                    }\n                }\n\n                fillPoint = DataViewObjects.getValue<boolean>(objects, scatterChartProps.fillPoint.show, fillPoint);\n\n                let backdropObject = objects['backdrop'];\n                if (backdropObject !== undefined) {\n                    backdrop.show = <boolean>backdropObject['show'];\n                    if (backdrop.show) {\n                        backdrop.url = <string>backdropObject['url'];\n                    }\n                }\n                let crosshairObject = objects['crosshair'];\n                if (crosshairObject !== undefined) {\n                    crosshair = <boolean>crosshairObject['show'];\n                }\n                let outlineObject = objects['outline'];\n                if (outlineObject !== undefined) {\n                    outline = <boolean>outlineObject['show'];\n                }\n            }\n\n            let dataPoints = EnhancedScatterChart.createDataPoints(\n                dataValues,\n                scatterMetadata,\n                categories,\n                categoryValues,\n                categoryFormatter,\n                categoryIdentities,\n                categoryObjects,\n                colorPalette,\n                hasDynamicSeries,\n                dataLabelsSettings,\n                defaultDataPointColor,\n                categoryQueryName);\n\n            if (interactivityService) {\n                interactivityService.applySelectionStateToData(dataPoints);\n            }\n\n            let legendItems = hasDynamicSeries\n                ? EnhancedScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, valueFormatter.getFormatString(dvSource, scatterChartProps.general.formatString), defaultDataPointColor)\n                : [];\n\n            let legendTitle = dataValues && dvSource ? dvSource.displayName : \"\";\n            if (!legendTitle) {\n                legendTitle = categories && categories[0].source.displayName ? categories[0].source.displayName : \"\";\n            }\n\n            let legendData = { title: legendTitle, dataPoints: legendItems };\n\n            let sizeRange = EnhancedScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);\n\n            if (categoryAxisProperties && categoryAxisProperties[\"showAxisTitle\"] !== null && categoryAxisProperties[\"showAxisTitle\"] === false) {\n                scatterMetadata.axesLabels.x = null;\n            }\n            if (valueAxisProperties && valueAxisProperties[\"showAxisTitle\"] !== null && valueAxisProperties[\"showAxisTitle\"] === false) {\n                scatterMetadata.axesLabels.y = null;\n            }\n\n            if (dataPoints && dataPoints[0]) {\n                let point = dataPoints[0];\n                if (point.backdrop != null) {\n                    backdrop.show = true;\n                    backdrop.url = point.backdrop;\n                }\n                if (point.xStart != null) {\n                    categoryAxisProperties['start'] = point.xStart;\n                }\n                if (point.xEnd != null) {\n                    categoryAxisProperties['end'] = point.xEnd;\n                }\n                if (point.yStart != null) {\n                    valueAxisProperties['start'] = point.yStart;\n                }\n                if (point.yEnd != null) {\n                    valueAxisProperties['end'] = point.yEnd;\n                }\n            }\n\n            return {\n                xCol: scatterMetadata.cols.x,\n                yCol: scatterMetadata.cols.y,\n                dataPoints: dataPoints,\n                legendData: legendData,\n                axesLabels: scatterMetadata.axesLabels,\n                selectedIds: [],\n                size: scatterMetadata.cols.size,\n                sizeRange: sizeRange,\n                dataLabelsSettings: dataLabelsSettings,\n                defaultDataPointColor: defaultDataPointColor,\n                hasDynamicSeries: hasDynamicSeries,\n                showAllDataPoints: showAllDataPoints,\n                fillPoint: fillPoint,\n                useShape: useShape,\n                useCustomColor: useCustomColor,\n                backdrop: backdrop,\n                crosshair: crosshair,\n                outline: outline\n            };\n        }\n\n        private static createSeriesLegend(\n            dataValues: DataViewValueColumns,\n            colorPalette: IDataColorPalette,\n            categorical: DataViewValueColumns,\n            formatString: string,\n            defaultDataPointColor: string): LegendDataPoint[] {\n\n            let grouped = dataValues.grouped();\n            let colorHelper = new ColorHelper(colorPalette, scatterChartProps.dataPoint.fill, defaultDataPointColor);\n\n            let legendItems: LegendDataPoint[] = [];\n            for (let i = 0, len = grouped.length; i < len; i++) {\n                let grouping = grouped[i];\n                let color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);\n\n                legendItems.push({\n                    color: color,\n                    icon: LegendIcon.Circle,\n                    label: valueFormatter.format(grouping.name, formatString),\n                    identity: grouping.identity ? SelectionId.createWithId(grouping.identity) : SelectionId.createNull(),\n                    selected: false,\n                });\n            }\n\n            return legendItems;\n        }\n\n        private static getSizeRangeForGroups(\n            dataViewValueGroups: DataViewValueColumnGroup[],\n            sizeColumnIndex: number): NumberRange {\n\n            let result: NumberRange = {};\n            if (dataViewValueGroups) {\n                dataViewValueGroups.forEach((group) => {\n                    let sizeColumn = ScatterChart.getMeasureValue(sizeColumnIndex, group.values);\n                    let currentRange: NumberRange = AxisHelper.getRangeForColumn(sizeColumn);\n                    if (result.min == null || result.min > currentRange.min) {\n                        result.min = currentRange.min;\n                    }\n                    if (result.max == null || result.max < currentRange.max) {\n                        result.max = currentRange.max;\n                    }\n                });\n            }\n            return result;\n        }\n\n        private static getMetadata(grouped: DataViewValueColumnGroup[], source: DataViewMetadataColumn): ScatterChartMeasureMetadata {\n            let xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X');\n            let yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y');\n            let sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Size');\n\n            let gradientIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Gradient');\n            let colorFillIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'ColorFill');\n            let shapeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Shape');\n            let imageIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Image');\n            let rotationIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Rotation');\n            let backdropIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Backdrop');\n            let xStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X Start');\n            let xEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X End');\n            let yStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y Start');\n            let yEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y End');\n            let xCol: DataViewMetadataColumn;\n            let yCol: DataViewMetadataColumn;\n            let sizeCol: DataViewMetadataColumn;\n            let colorFillCol: DataViewMetadataColumn;\n            let shapeCol: DataViewMetadataColumn;\n            let imageCol: DataViewMetadataColumn;\n            let rotationCol: DataViewMetadataColumn;\n            let backdropCol: DataViewMetadataColumn;\n            let xStartCol: DataViewMetadataColumn;\n            let xEndCol: DataViewMetadataColumn;\n            let yStartCol: DataViewMetadataColumn;\n            let yEndCol: DataViewMetadataColumn;\n            let xAxisLabel = \"\";\n            let yAxisLabel = \"\";\n\n            if (grouped && grouped.length) {\n                let firstGroup = grouped[0],\n                    measureCount = firstGroup.values.length;\n\n                if (!(xIndex >= 0))\n                    xIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                if (!(yIndex >= 0))\n                    yIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                if (!(sizeIndex >= 0))\n                    sizeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                if (!(colorFillIndex >= 0))\n                    colorFillIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                if (!(shapeIndex >= 0))\n                    shapeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                if (!(imageIndex >= 0)) {\n                    imageIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                }\n                if (!(rotationIndex >= 0))\n                    rotationIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                if (!(backdropIndex >= 0))\n                    backdropIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\n                if (!(xStartIndex >= 0))\n                    xStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xEndIndex, yStartIndex, yEndIndex]);\n                if (!(xEndIndex >= 0))\n                    xEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, yStartIndex, yEndIndex]);\n                if (!(yStartIndex >= 0))\n                    yStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yEndIndex]);\n                if (!(yEndIndex >= 0))\n                    yEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex]);\n\n                if (xIndex >= 0) {\n                    xCol = firstGroup.values[xIndex].source;\n                    xAxisLabel = firstGroup.values[xIndex].source.displayName;\n                }\n                if (yIndex >= 0) {\n                    yCol = firstGroup.values[yIndex].source;\n                    yAxisLabel = firstGroup.values[yIndex].source.displayName;\n                }\n                if (sizeIndex >= 0) {\n                    sizeCol = firstGroup.values[sizeIndex].source;\n                }\n                if (colorFillIndex >= 0) {\n                    colorFillCol = firstGroup.values[colorFillIndex].source;\n                }\n                if (shapeIndex >= 0) {\n                    shapeCol = firstGroup.values[shapeIndex].source;\n                }\n                if (imageIndex >= 0) {\n                    imageCol = firstGroup.values[imageIndex].source;\n                }\n                if (rotationIndex >= 0) {\n                    rotationCol = firstGroup.values[rotationIndex].source;\n                }\n\n                if (backdropIndex >= 0) {\n                    backdropCol = firstGroup.values[backdropIndex].source;\n                }\n                if (xStartIndex >= 0) {\n                    xStartCol = firstGroup.values[xStartIndex].source;\n                }\n                if (xEndIndex >= 0) {\n                    xEndCol = firstGroup.values[xEndIndex].source;\n                }\n                if (yStartIndex >= 0) {\n                    yStartCol = firstGroup.values[yStartIndex].source;\n                }\n                if (yEndIndex >= 0) {\n                    yEndCol = firstGroup.values[yEndIndex].source;\n                }\n            }\n\n            return {\n                idx: {\n                    x: xIndex,\n                    y: yIndex,\n                    size: sizeIndex,\n                    colorFill: colorFillIndex,\n                    shape: shapeIndex,\n                    image: imageIndex,\n                    rotation: rotationIndex,\n                    backdrop: backdropIndex,\n                    xStart: xStartIndex,\n                    xEnd: xEndIndex,\n                    yStart: yStartIndex,\n                    yEnd: yEndIndex,\n                },\n                cols: {\n                    x: xCol,\n                    y: yCol,\n                    size: sizeCol,\n                    colorFill: colorFillCol,\n                    shape: shapeCol,\n                    image: imageCol,\n                    rotation: rotationCol,\n                    backdrop: backdropCol,\n                    xStart: xStartCol,\n                    xEnd: xEndCol,\n                    yStart: yStartCol,\n                    yEnd: yEndCol,\n                },\n                axesLabels: {\n                    x: xAxisLabel,\n                    y: yAxisLabel\n                }\n            };\n        }\n\n        private static getDefaultMeasureIndex(count: number, usedIndexes: number[]): number {\n            for (let i = 0; i < count; i++) {\n                let found = true;\n                for (let j = 0; j < usedIndexes.length; j++) {\n                    if (i === usedIndexes[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n                if (found === true) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n        public static createLazyFormattedCategory(formatter: IValueFormatter, value: string): jsCommon.Lazy<string> {\n            return new jsCommon.Lazy(() => formatter.format(value));\n        }\n\n        private static createDataPoints(\n            dataValues: DataViewValueColumns,\n            metadata: ScatterChartMeasureMetadata,\n            categories: DataViewCategoryColumn[],\n            categoryValues: any[],\n            categoryFormatter: IValueFormatter,\n            categoryIdentities: DataViewScopeIdentity[],\n            categoryObjects: DataViewObjects[],\n            colorPalette: IDataColorPalette,\n            hasDynamicSeries: boolean,\n            labelSettings: PointDataLabelsSettings,\n            defaultDataPointColor?: string,\n            categoryQueryName?: string): EnhancedScatterChartDataPoint[] {\n\n            let dataPoints: EnhancedScatterChartDataPoint[] = [],\n                indicies = metadata.idx,\n                formatStringProp = scatterChartProps.general.formatString,\n                dataValueSource = dataValues.source,\n                grouped = dataValues.grouped();\n\n            let colorHelper = new ColorHelper(colorPalette, scatterChartProps.dataPoint.fill, defaultDataPointColor);\n\n            for (let categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) {\n                let categoryValue = categoryValues[categoryIdx];\n\n                for (let seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {\n                    let grouping = grouped[seriesIdx];\n                    let seriesValues = grouping.values;\n                    let measureX = ScatterChart.getMeasureValue(indicies.x, seriesValues);\n                    let measureY = ScatterChart.getMeasureValue(indicies.y, seriesValues);\n                    let measureSize = ScatterChart.getMeasureValue(indicies.size, seriesValues);\n                    let measureColorFill = ScatterChart.getMeasureValue(indicies.colorFill, seriesValues);\n                    let measureShape = ScatterChart.getMeasureValue(indicies.shape, seriesValues);\n                    let measureImage = ScatterChart.getMeasureValue(indicies.image, seriesValues);\n                    let measureRotation = ScatterChart.getMeasureValue(indicies.rotation, seriesValues);\n                    let measureBackdrop = ScatterChart.getMeasureValue(indicies.backdrop, seriesValues);\n                    let measureXStart = ScatterChart.getMeasureValue(indicies.xStart, seriesValues);\n                    let measureXEnd = ScatterChart.getMeasureValue(indicies.xEnd, seriesValues);\n                    let measureYStart = ScatterChart.getMeasureValue(indicies.yStart, seriesValues);\n                    let measureYEnd = ScatterChart.getMeasureValue(indicies.yEnd, seriesValues);\n\n                    let xVal = measureX && measureX.values && !isNaN(measureX.values[categoryIdx]) ? measureX.values[categoryIdx] : null;\n                    let yVal = measureY && measureY.values && !isNaN(measureY.values[categoryIdx]) ? measureY.values[categoryIdx] : 0;\n                    let size = measureSize && measureSize.values ? measureSize.values[categoryIdx] : null;\n                    let colorFill = measureColorFill && measureColorFill.values ? measureColorFill.values[categoryIdx] : null;\n                    let shapeSymbolType = EnhancedScatterChart.getCustomSymbolType(measureShape && measureShape.values && measureShape.values[categoryIdx]);\n                    let image = measureImage && measureImage.values ? measureImage.values[categoryIdx] : null;\n                    let rotation = measureRotation && measureRotation.values ? measureRotation.values[categoryIdx] : 0;\n                    let backdrop = measureBackdrop && measureBackdrop.values ? measureBackdrop.values[categoryIdx] : null;\n                    let xStart = measureXStart && measureXStart.values ? measureXStart.values[categoryIdx] : null;\n                    let xEnd = measureXEnd && measureXEnd.values ? measureXEnd.values[categoryIdx] : null;\n                    let yStart = measureYStart && measureYStart.values ? measureYStart.values[categoryIdx] : null;\n                    let yEnd = measureYEnd && measureYEnd.values ? measureYEnd.values[categoryIdx] : null;\n\n                    let hasNullValue = (xVal == null) || (yVal == null);\n\n                    if (hasNullValue)\n                        continue;\n\n                    let color: string;\n                    if (hasDynamicSeries) {\n                        color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);\n                    } else {\n                        // If we have no Size measure then use a blank query name\n                        let measureSource = (measureSize != null)\n                            ? measureSize.source.queryName\n                            : '';\n                        color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);\n                    }\n\n                    let category = categories && categories.length > 0 ? categories[0] : null;\n                    let identity = SelectionIdBuilder.builder()\n                        .withCategory(category, categoryIdx)\n                        .withSeries(dataValues, grouping)\n                        .createSelectionId();\n\n                    let seriesData: TooltipSeriesDataItem[] = [];\n                    if (dataValueSource) {\n                        // Dynamic series\n                        seriesData.push({ value: grouping.name, metadata: { source: dataValueSource, values: [] } });\n                    }\n                    if (measureX) {\n                        seriesData.push({ value: xVal, metadata: measureX });\n                    }\n                    if (measureY) {\n                        seriesData.push({ value: yVal, metadata: measureY });\n                    }\n                    if (measureSize && measureSize.values && measureSize.values.length > 0) {\n                        seriesData.push({ value: measureSize.values[categoryIdx], metadata: measureSize });\n                    }\n                    if (measureColorFill && measureColorFill.values && measureColorFill.values.length > 0) {\n                        seriesData.push({ value: measureColorFill.values[categoryIdx], metadata: measureColorFill });\n                    }\n                    if (measureShape && measureShape.values && measureShape.values.length > 0) {\n                        seriesData.push({ value: measureShape.values[categoryIdx], metadata: measureShape });\n                    }\n                    if (measureImage && measureImage.values && measureImage.values.length > 0) {\n                        seriesData.push({ value: measureImage.values[categoryIdx], metadata: measureImage });\n                    }\n                    if (measureRotation && measureRotation.values && measureRotation.values.length > 0) {\n                        seriesData.push({ value: measureRotation.values[categoryIdx], metadata: measureRotation });\n                    }\n\n                    if (measureBackdrop && measureBackdrop.values && measureBackdrop.values.length > 0) {\n                        seriesData.push({ value: measureBackdrop.values[categoryIdx], metadata: measureBackdrop });\n                    }\n                    if (measureXStart && measureXStart.values && measureXStart.values.length > 0) {\n                        seriesData.push({ value: measureXStart.values[categoryIdx], metadata: measureXStart });\n                    }\n                    if (measureXEnd && measureXEnd.values && measureXEnd.values.length > 0) {\n                        seriesData.push({ value: measureXEnd.values[categoryIdx], metadata: measureXEnd });\n                    }\n                    if (measureYStart && measureYStart.values && measureYStart.values.length > 0) {\n                        seriesData.push({ value: measureYStart.values[categoryIdx], metadata: measureYStart });\n                    }\n                    if (measureYEnd && measureYEnd.values && measureYEnd.values.length > 0) {\n                        seriesData.push({ value: measureYEnd.values[categoryIdx], metadata: measureYEnd });\n                    }\n\n                    let tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, null, categoryValue, null, categories, seriesData);\n\n                    let dataPoint: EnhancedScatterChartDataPoint = {\n                        x: xVal,\n                        y: yVal,\n                        size: size,\n                        radius: { sizeMeasure: measureSize, index: categoryIdx },\n                        fill: color,\n                        formattedCategory: this.createLazyFormattedCategory(categoryFormatter, categoryValue),\n                        selected: false,\n                        identity: identity,\n                        tooltipInfo: tooltipInfo,\n                        labelFill: labelSettings.labelColor,\n                        labelFontSize: labelSettings.fontSize,\n                        colorFill: colorFill,\n                        shapeSymbolType: shapeSymbolType,\n                        svgurl: image,\n                        rotation: rotation,\n                        backdrop: backdrop,\n                        xStart: xStart,\n                        xEnd: xEnd,\n                        yStart: yStart,\n                        yEnd: yEnd\n                    };\n\n                    dataPoints.push(dataPoint);\n                }\n            }\n            return dataPoints;\n        }\n\n        public setData(dataViews: DataView[]) {\n            this.data = {\n                xCol: undefined,\n                yCol: undefined,\n                dataPoints: [],\n                legendData: { dataPoints: [] },\n                axesLabels: { x: '', y: '' },\n                selectedIds: [],\n                sizeRange: [],\n                dataLabelsSettings: dataLabelUtils.getDefaultPointLabelSettings(),\n                defaultDataPointColor: null,\n                hasDynamicSeries: false,\n                useShape: true,\n                useCustomColor: false,\n            };\n\n            if (dataViews.length > 0) {\n                let dataView = dataViews[0];\n\n                if (dataView) {\n                    this.categoryAxisProperties = this.getCategoryAxisProperties(dataView.metadata, true);\n                    this.valueAxisProperties = this.getValueAxisProperties(dataView.metadata, true);\n                    this.dataView = dataView;\n\n                    if (dataView.categorical && dataView.categorical.values) {\n                        this.data = EnhancedScatterChart.converter(dataView, this.viewport, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties);\n                    }\n\n                }\n            }\n        }\n\n        public update(options: VisualUpdateOptions) {\n\n            debug.assertValue(options, 'options');\n\n            let dataViews = this.dataViews = options.dataViews;\n            this.viewport = _.clone(options.viewport);\n\n            if (!dataViews) return;\n\n            if (dataViews && dataViews.length > 0) {\n                let warnings = getInvalidValueWarnings(\n                    dataViews,\n                    false /*supportsNaN*/,\n                    false /*supportsNegativeInfinity*/,\n                    false /*supportsPositiveInfinity*/);\n\n                if (warnings && warnings.length > 0)\n                    this.hostServices.setWarnings(warnings);\n\n                this.populateObjectProperties(dataViews);\n            }\n\n            this.setData(dataViews);\n            \n            // Note: interactive legend shouldn't be rendered explicitly here\n            // The interactive legend is being rendered in the render method of ICartesianVisual\n            if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend)) {\n                this.renderLegend();\n            }\n\n            this.render(options.suppressAnimations);\n\n        }\n\n        private populateObjectProperties(dataViews: DataView[]) {\n            if (dataViews && dataViews.length > 0) {\n                let dataViewMetadata = dataViews[0].metadata;\n\n                if (dataViewMetadata) {\n                    this.legendObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});\n                }\n                else {\n                    this.legendObjectProperties = {};\n                }\n                this.categoryAxisProperties = this.getCategoryAxisProperties(dataViewMetadata);\n                this.valueAxisProperties = this.getValueAxisProperties(dataViewMetadata);\n                let axisPosition = this.valueAxisProperties['position'];\n                this.yAxisOrientation = axisPosition ? axisPosition.toString() : yAxisPosition.left;\n            }\n        }\n\n        private renderLegend(): void {\n            let legendData: LegendData = { title: \"\", dataPoints: [] };\n            let legend: ILegend = this.legend;\n\n            this.layerLegendData = this.data.legendData;\n            if (this.layerLegendData) {\n                legendData.title = this.layerLegendData.title || \"\";\n                legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);\n                legendData.fontSize = this.legendLabelFontSize ? this.legendLabelFontSize : EnhancedScatterChart.LegendLabelFontSizeDefault;\n                if (this.layerLegendData.grouped) {\n                    legendData.grouped = true;\n                }\n            }\n\n            let legendProperties = this.legendObjectProperties;\n\n            if (legendProperties) {\n                LegendData.update(legendData, legendProperties);\n                let position = <string>legendProperties[legendProps.position];\n\n                if (position)\n                    legend.changeOrientation(LegendPosition[position]);\n            }\n            else {\n                legend.changeOrientation(LegendPosition.Top);\n            }\n\n            if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {\n                legendData.dataPoints = [];\n            }\n\n            let viewport = this.viewport;\n            legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });\n            Legend.positionChartArea(this.svg, legend);\n        }\n        private hideLegends(): boolean {\n            if (this.cartesianSmallViewPortProperties) {\n                if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.viewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private shouldRenderAxis(axisProperties: IAxisProperties, propertyName: string = \"show\"): boolean {\n            if (!axisProperties) {\n                return false;\n            }\n            else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {\n                return axisProperties.values && axisProperties.values.length > 0;\n            }\n            else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {\n                return axisProperties.values && axisProperties.values.length > 0;\n            }\n\n            return false;\n        }\n\n        private getMaxMarginFactor(): number {\n            return this.options.style.maxMarginFactor || 0.25;\n        }\n\n        private adjustViewportbyBackdrop(): void {\n            let img = new Image();\n            let that = this;\n            img.src = this.data.backdrop.url;\n            img.onload = function () {\n                if (that.oldBackdrop !== this.src) {\n                    that.render(true);\n                    that.oldBackdrop = this.src;\n                }\n            };\n\n            if (img.width > 0 && img.height > 0) {\n                if (img.width * this.viewportIn.height < this.viewportIn.width * img.height) {\n                    let deltaWidth = this.viewportIn.width - this.viewportIn.height * img.width / img.height;\n                    this.viewport = { width: this.viewport.width - deltaWidth, height: this.viewport.height };\n                } else {\n                    let deltaHeight = this.viewportIn.height - this.viewportIn.width * img.height / img.width;\n                    this.viewport = { width: this.viewport.width, height: this.viewport.height - deltaHeight };\n                }\n            }\n        }\n\n        public render(suppressAnimations: boolean): void {\n            this.viewport.height -= this.legendViewport.height;\n            this.viewport.width -= this.legendViewport.width;\n\n            if (this.viewportIn.width === 0 || this.viewportIn.height === 0) {\n                return;\n            }\n\n            let maxMarginFactor = this.getMaxMarginFactor();\n            this.leftRightMarginLimit = this.viewport.width * maxMarginFactor;\n            let bottomMarginLimit = this.bottomMarginLimit = Math.max(25, Math.ceil(this.viewport.height * maxMarginFactor));\n\n            // reset defaults\n            this.margin.top = 8;\n            this.margin.bottom = bottomMarginLimit;\n            this.margin.right = 0;\n\n            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\n\n            this.yAxisIsCategorical = this.yAxisProperties.isCategoryAxis;\n            this.hasCategoryAxis = this.yAxisIsCategorical ? this.yAxisProperties && this.yAxisProperties.values.length > 0 : this.xAxisProperties && this.xAxisProperties.values.length > 0;\n\n            let renderXAxis = this.shouldRenderAxis(this.xAxisProperties);\n            let renderY1Axis = this.shouldRenderAxis(this.yAxisProperties);\n\n            let mainAxisScale;\n            this.isXScrollBarVisible = false;\n            this.isYScrollBarVisible = false;\n            let tickLabelMargins;\n            let axisLabels: ChartAxesLabels;\n            let chartHasAxisLabels: boolean;\n\n            let yAxisOrientation = this.yAxisOrientation;\n            let showY1OnRight = yAxisOrientation === yAxisPosition.right;\n\n            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\n\n            let doneWithMargins = false,\n                maxIterations = 2,\n                numIterations = 0;\n\n            while (!doneWithMargins && numIterations < maxIterations) {\n                numIterations++;\n                tickLabelMargins = AxisHelper.getTickLabelMargins(\n                    { width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit,\n                    TextMeasurementService.measureSvgTextWidth, TextMeasurementService.measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties },\n                    this.bottomMarginLimit, this.textProperties,\n                    this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight,\n                    renderXAxis, renderY1Axis, false);\n\n                // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side\n                let maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft,\n                    maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight,\n                    xMax = tickLabelMargins.xMax;\n\n                maxMainYaxisSide += 10;\n                maxSecondYaxisSide += 10;\n                xMax += 12;\n                if (showY1OnRight && renderY1Axis) {\n                    maxSecondYaxisSide += 20;\n                }\n\n                if (!showY1OnRight && renderY1Axis) {\n                    maxMainYaxisSide += 20;\n                }\n\n                if (this.hideAxisLabels()) {\n                    this.xAxisProperties.axisLabel = null;\n                    this.yAxisProperties.axisLabel = null;\n                }\n\n                this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);\n\n                axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };\n                chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);\n\n                if (axisLabels.x != null)\n                    xMax += 18;\n\n                if (axisLabels.y != null)\n                    maxMainYaxisSide += 20;\n\n                if (axisLabels.y2 != null)\n                    maxSecondYaxisSide += 20;\n\n                this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;\n                this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;\n                this.margin.bottom = xMax;\n\n                // re-calculate the axes with the new margins\n                let previousTickCountY1 = this.yAxisProperties.values.length;\n\n                this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\n\n                // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again\n                // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.\n                if (this.yAxisProperties.values.length === previousTickCountY1)\n                    doneWithMargins = true;\n            }\n            // we have to do the above process again since changes are made to viewport.\n            \n            if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {\n                this.adjustViewportbyBackdrop();\n\n                doneWithMargins = false;\n                maxIterations = 2;\n                numIterations = 0;\n\n                while (!doneWithMargins && numIterations < maxIterations) {\n                    numIterations++;\n                    tickLabelMargins = AxisHelper.getTickLabelMargins(\n                        { width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit,\n                        TextMeasurementService.measureSvgTextWidth, TextMeasurementService.measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties },\n                        this.bottomMarginLimit, this.textProperties,\n                        this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight,\n                        renderXAxis, renderY1Axis, false);\n\n                    // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side\n                    let maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft,\n                        maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight,\n                        xMax = tickLabelMargins.xMax;\n\n                    maxMainYaxisSide += 10;\n                    if (showY1OnRight && renderY1Axis)\n                        maxSecondYaxisSide += 15;\n                    xMax += 12;\n\n                    if (this.hideAxisLabels()) {\n                        this.xAxisProperties.axisLabel = null;\n                        this.yAxisProperties.axisLabel = null;\n                    }\n\n                    this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);\n\n                    axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };\n                    chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);\n\n                    if (axisLabels.x != null)\n                        xMax += 18;\n\n                    if (axisLabels.y != null)\n                        maxMainYaxisSide += 20;\n\n                    if (axisLabels.y2 != null)\n                        maxSecondYaxisSide += 20;\n\n                    this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;\n                    this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;\n                    this.margin.bottom = xMax;\n\n                    // re-calculate the axes with the new margins\n                    let previousTickCountY1 = this.yAxisProperties.values.length;\n\n                    this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\n\n                    // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again\n                    // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.\n                    if (this.yAxisProperties.values.length === previousTickCountY1)\n                        doneWithMargins = true;\n                }\n            }\n\n            this.renderChart(mainAxisScale, this.xAxisProperties, this.yAxisProperties, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations);\n\n            this.updateAxis();\n\n            if (!this.data)\n                return;\n\n            let data = this.data;\n            let dataPoints = this.data.dataPoints;\n\n            let hasSelection = this.interactivityService && this.interactivityService.hasSelection();\n\n            this.mainGraphicsContext.attr('width', this.viewportIn.width)\n                .attr('height', this.viewportIn.height);\n\n            let sortedData = dataPoints.sort(function (a, b) {\n                return b.radius.sizeMeasure ? (b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index]) : 0;\n            });\n\n            let duration = AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);\n            let scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration);\n\n            let dataLabelsSettings = this.data.dataLabelsSettings;\n            if (dataLabelsSettings.show) {\n                let layout = this.getEnhanchedScatterChartLabelLayout(dataLabelsSettings, this.viewportIn, data.sizeRange);\n                let clonedDataPoints: Array<EnhancedScatterChartDataPoint> = this.cloneDataPoints(dataPoints);\n                //fix bug 3863: drawDefaultLabelsForDataPointChart add to datapoints[xxx].size = object , which causes when\n                //category labels is on and Fill Points option off to fill the points when mouse click occures because of default size\n                //is set to datapoints.\n                dataLabelUtils.drawDefaultLabelsForDataPointChart(clonedDataPoints, this.mainGraphicsG, layout, this.viewportIn);\n                let offset = dataLabelsSettings.fontSize * EnhancedScatterChart.DataLabelsOffset;\n                this.mainGraphicsG.select('.labels').attr('transform', SVGUtil.translate(offset, 0));\n            }\n            else {\n                dataLabelUtils.cleanDataLabels(this.mainGraphicsG);\n            }\n            let behaviorOptions: ScatterBehaviorOptions = undefined;\n            if (this.interactivityService) {\n                behaviorOptions = {\n                    dataPointsSelection: scatterMarkers,\n                    data: this.data,\n                    plotContext: this.mainGraphicsContext,\n                };\n            }\n\n            TooltipManager.addTooltip(scatterMarkers, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo);\n\n            SVGUtil.flushAllD3TransitionsIfNeeded(this.options);\n\n            if (this.behavior) {\n                let layerBehaviorOptions: any[] = [];\n                layerBehaviorOptions.push(behaviorOptions);\n\n                if (this.interactivityService) {\n                    let cbehaviorOptions: CartesianBehaviorOptions = {\n                        layerOptions: layerBehaviorOptions,\n                        clearCatcher: this.clearCatcher,\n                    };\n                    this.interactivityService.bind(dataPoints, this.behavior, cbehaviorOptions);\n                }\n            }\n        }\n\n        private cloneDataPoints(dataPoints: Array<EnhancedScatterChartDataPoint>): Array<EnhancedScatterChartDataPoint> {\n            let clonedDataPoints: Array<EnhancedScatterChartDataPoint> = new Array<EnhancedScatterChartDataPoint>();\n\n            for (let dataPoint of dataPoints) {\n                let clonedDataPoint: EnhancedScatterChartDataPoint = _.clone(dataPoint);\n                clonedDataPoints.push(clonedDataPoint);\n            }\n\n            return clonedDataPoints;\n        }\n\n        private darkenZeroLine(g: D3.Selection): void {\n            let zeroTick = g.selectAll('g.tick').filter((data) => data === 0).node();\n            if (zeroTick) {\n                d3.select(zeroTick).select('line').classed('zero-line', true);\n            }\n        }\n\n        private getCategoryAxisFill(): Fill {\n            if (this.dataView && this.dataView.metadata.objects) {\n                let label = this.dataView.metadata.objects['categoryAxis'];\n                if (label) {\n                    return <Fill>label['axisColor'];\n                }\n            }\n            return { solid: { color: '#333' } };\n        }\n\n        private getEnhanchedScatterChartLabelLayout(labelSettings: PointDataLabelsSettings,\n            viewport: IViewport,\n            sizeRange: NumberRange): ILabelLayout {\n\n            let xScale = this.xAxisProperties.scale;\n            let yScale = this.yAxisProperties.scale;\n            let fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize);\n            let offset = labelSettings.fontSize * EnhancedScatterChart.DataLabelsOffset;\n\n            return {\n                labelText: function (d: EnhancedScatterChartDataPoint) {\n                    return dataLabelUtils.getLabelFormattedText({\n                        label: d.formattedCategory.getValue(),\n                        fontSize: labelSettings.fontSize,\n                        maxWidth: viewport.width,\n                    });\n                },\n                labelLayout: {\n                    x: function (d: EnhancedScatterChartDataPoint) { return xScale(d.x) - offset; },\n                    y: function (d: EnhancedScatterChartDataPoint) {\n                        let margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;\n                        return labelSettings.position === 0 /* Above */ ? yScale(d.y) - margin : yScale(d.y) + margin;\n                    },\n                },\n                filter: function (d: EnhancedScatterChartDataPoint) {\n                    return (d != null && d.formattedCategory.getValue() != null);\n                },\n                style: {\n                    'fill': function (d: EnhancedScatterChartDataPoint) { return d.labelFill; },\n                    'font-size': fontSizeInPx,\n                },\n            };\n        }\n\n        private getValueAxisFill(): Fill {\n            if (this.dataView && this.dataView.metadata.objects) {\n                let label = this.dataView.metadata.objects['valueAxis'];\n                if (label)\n                    return <Fill>label['axisColor'];\n            }\n\n            return { solid: { color: '#333' } };\n        }\n\n        private renderCrossHair() {\n            let xScale = <D3.Scale.LinearScale>this.xAxisProperties.scale;\n            let yScale = <D3.Scale.LinearScale>this.yAxisProperties.scale;\n            let mainGraphicsContext = this.mainGraphicsContext;\n            mainGraphicsContext.selectAll(\".crosshairCanvas\").remove();\n            if (this.data.crosshair) {\n                let canvas = mainGraphicsContext.append(\"g\").attr(\"class\", \"crosshairCanvas\").attr(\"id\", \"crosshairCanvas\");\n                let crossHair = canvas.append(\"g\").attr(\"class\", \"crosshair\");\n                let hLine = crossHair.append(\"line\").attr(\"id\", \"h_crosshair\") // horizontal cross hair\n                    .attr(\"x1\", 0)\n                    .attr(\"y1\", 0)\n                    .attr(\"x2\", 0)\n                    .attr(\"y2\", 0)\n                    .style(\"stroke\", \"gray\")\n                    .style(\"stroke-width\", \"1px\")\n                    .style(\"stroke-dasharray\", \"5,5\")\n                    .style(\"display\", \"none\");\n\n                let vLine = crossHair.append(\"line\").attr(\"id\", \"v_crosshair\") // vertical cross hair\n                    .attr(\"x1\", 0)\n                    .attr(\"y1\", 0)\n                    .attr(\"x2\", 0)\n                    .attr(\"y2\", 0)\n                    .style(\"stroke\", \"gray\")\n                    .style(\"stroke-width\", \"1px\")\n                    .style(\"stroke-dasharray\", \"5,5\")\n                    .style(\"display\", \"none\");\n\n                let text = crossHair.append(\"text\").attr(\"id\", \"crosshair_text\") // text label for cross hair\n                    .style(\"font-size\", \"10px\")\n                    .style(\"stroke\", \"gray\")\n                    .style(\"stroke-width\", \"0.5px\");\n\n                let addCrossHair = (xCoord, yCoord) => {\n                    \n                    // Update horizontal cross hair\n                    hLine.attr(\"x1\", 0)\n                        .attr(\"y1\", yCoord)\n                        .attr(\"x2\", this.viewportIn.width)\n                        .attr(\"y2\", yCoord)\n                        .style(\"display\", \"block\");\n                    \n                    // Update vertical cross hair\n                    vLine.attr(\"x1\", xCoord)\n                        .attr(\"y1\", 0)\n                        .attr(\"x2\", xCoord)\n                        .attr(\"y2\", this.viewportIn.height)\n                        .style(\"display\", \"block\");\n\n                    // Update text label\n                    text.attr(\"transform\", \"translate(\" + (xCoord + 5) + \",\" + (yCoord - 5) + \")\")\n                        .text(\"(\" + Math.round(xScale.invert(xCoord) * 100) / 100 + \" , \" + Math.round(yScale.invert(yCoord) * 100) / 100 + \")\");\n                };\n\n                this.axisGraphicsContextScrollable.on(\"mousemove\", function () {\n                    let coordinates = d3.mouse(this);\n                    let svgNode = this.viewportElement;\n                    let scaledRect = svgNode.getBoundingClientRect();\n                    let domRect = svgNode.getBBox();\n                    let ratioX = scaledRect.width / domRect.width;\n                    let ratioY = scaledRect.height / domRect.height;\n                    if (domRect.width > 0 && !Double.equalWithPrecision(ratioX, 1.0, 0.00001)) {\n                        coordinates[0] = coordinates[0] / ratioX;\n                    }\n                    if (domRect.height > 0 && !Double.equalWithPrecision(ratioY, 1.0, 0.00001)) {\n                        coordinates[1] = coordinates[1] / ratioY;\n                    }\n                    addCrossHair(coordinates[0], coordinates[1]);\n                })\n                    .on(\"mouseover\", function () {\n                        d3.selectAll(\".crosshair\").style(\"display\", \"block\");\n                    })\n                    .on(\"mouseout\", function () {\n                        d3.selectAll(\".crosshair\").style(\"display\", \"none\");\n                    });\n            }\n        }\n\n        private renderBackground() {\n            if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {\n                this.backgroundGraphicsContext\n                    .attr(\"xlink:href\", this.data.backdrop.url)\n                    .attr('x', 0)\n                    .attr('y', 0)\n                    .attr('width', this.viewportIn.width)\n                    .attr('height', this.viewportIn.height);\n            } else {\n                this.backgroundGraphicsContext\n                    .attr('width', 0)\n                    .attr('height', 0);\n            }\n        }\n\n        private renderChart(\n            mainAxisScale: any,\n            xAxis: IAxisProperties,\n            yAxis: IAxisProperties,\n            tickLabelMargins: any,\n            chartHasAxisLabels: boolean,\n            axisLabels: ChartAxesLabels,\n            suppressAnimations: boolean,\n            scrollScale?: any,\n            extent?: number[]) {\n\n            let bottomMarginLimit = this.bottomMarginLimit;\n            let leftRightMarginLimit = this.leftRightMarginLimit;\n            let duration = AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);\n\n            this.renderBackground();\n            \n            //hide show x-axis here\n            if (this.shouldRenderAxis(xAxis)) {\n                xAxis.axis.orient(\"bottom\");\n                if (!xAxis.willLabelsFit)\n                    xAxis.axis.tickPadding(5);\n\n                let xAxisGraphicsElement = this.xAxisGraphicsContext;\n                if (duration) {\n                    xAxisGraphicsElement\n                        .transition()\n                        .duration(duration)\n                        .call(xAxis.axis)\n                        .call(this.darkenZeroLine);\n                }\n                else {\n                    xAxisGraphicsElement\n                        .call(xAxis.axis)\n                        .call(this.darkenZeroLine);\n                }\n                let xZeroTick = xAxisGraphicsElement.selectAll('g.tick').filter((data) => data === 0);\n                if (xZeroTick) {\n                    let xZeroColor = this.getValueAxisFill();\n                    if (xZeroColor)\n                        xZeroTick.selectAll('line').style({ 'stroke': xZeroColor.solid.color });\n                }\n\n                let xAxisTextNodes = xAxisGraphicsElement.selectAll('text');\n                if (xAxis.willLabelsWordBreak) {\n                    xAxisTextNodes\n                        .call(AxisHelper.LabelLayoutStrategy.wordBreak, xAxis, bottomMarginLimit);\n                } else {\n                    xAxisTextNodes\n                        .call(AxisHelper.LabelLayoutStrategy.rotate,\n                        bottomMarginLimit,\n                        TextMeasurementService.getTailoredTextOrDefault,\n                        CartesianChart.AxisTextProperties,\n                        !xAxis.willLabelsFit,\n                        bottomMarginLimit === tickLabelMargins.xMax,\n                        xAxis,\n                        this.margin,\n                        this.isXScrollBarVisible || this.isYScrollBarVisible);\n                }\n            }\n            else {\n                this.xAxisGraphicsContext.selectAll('*').remove();\n            }\n\n            if (this.shouldRenderAxis(yAxis)) {\n                let yAxisOrientation = this.yAxisOrientation;\n\n                yAxis.axis\n                    .tickSize(-this.viewportIn.width)\n                    .tickPadding(10)\n                    .orient(yAxisOrientation.toLowerCase());\n\n                let y1AxisGraphicsElement = this.y1AxisGraphicsContext;\n                if (duration) {\n                    y1AxisGraphicsElement\n                        .transition()\n                        .duration(duration)\n                        .call(yAxis.axis)\n                        .call(this.darkenZeroLine);\n                }\n                else {\n                    y1AxisGraphicsElement\n                        .call(yAxis.axis)\n                        .call(this.darkenZeroLine);\n                }\n\n                let yZeroTick = y1AxisGraphicsElement.selectAll('g.tick').filter((data) => data === 0);\n                if (yZeroTick) {\n                    let yZeroColor = this.getCategoryAxisFill();\n                    if (yZeroColor) {\n                        yZeroTick.selectAll('line').style({ 'stroke': yZeroColor.solid.color });\n                    }\n                }\n\n                if (tickLabelMargins.yLeft >= leftRightMarginLimit) {\n                    y1AxisGraphicsElement.selectAll('text')\n                        .call(AxisHelper.LabelLayoutStrategy.clip,\n                        // Can't use padding space to render text, so subtract that from available space for ellipses calculations\n                        leftRightMarginLimit - 10,\n                        TextMeasurementService.svgEllipsis);\n                }\n\n                // TODO: clip (svgEllipsis) the Y2 labels\n            }\n            else {\n                this.y1AxisGraphicsContext.selectAll('*').remove();\n            }\n            // Axis labels\n            //TODO: Add label for second Y axis for combo chart\n            if (chartHasAxisLabels) {\n                let hideXAxisTitle = !this.shouldRenderAxis(xAxis, \"showAxisTitle\");\n                let hideYAxisTitle = !this.shouldRenderAxis(yAxis, \"showAxisTitle\");\n                let hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties[\"secShowAxisTitle\"] != null && this.valueAxisProperties[\"secShowAxisTitle\"] === false;\n\n                this.renderAxesLabels(axisLabels, this.legendViewport.height, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);\n            }\n            else {\n                this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\n                this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\n            }\n            this.renderCrossHair();\n        }\n\n        private renderAxesLabels(axisLabels: ChartAxesLabels, legendMargin: number, hideXAxisTitle: boolean, hideYAxisTitle: boolean, hideY2AxisTitle: boolean): void {\n            this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\n            this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\n\n            let margin = this.margin;\n            let width = this.viewportIn.width;\n            let height = this.viewport.height;\n            let fontSize = EnhancedScatterChart.AxisFontSize;\n            let yAxisOrientation = this.yAxisOrientation;\n            let showY1OnRight = yAxisOrientation === yAxisPosition.right;\n\n            if (!hideXAxisTitle) {\n                let xAxisLabel = this.axisGraphicsContext.append(\"text\")\n                    .style(\"text-anchor\", \"middle\")\n                    .text(axisLabels.x)\n                    .call((text: D3.Selection) => {\n                        text.each(function () {\n                            let text = d3.select(this);\n                            text.attr({\n                                \"class\": \"xAxisLabel\",\n                                \"transform\": SVGUtil.translate(width / 2, height - fontSize - 2)\n                            });\n                        });\n                    });\n\n                xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\n                    width,\n                    TextMeasurementService.svgEllipsis);\n            }\n\n            if (!hideYAxisTitle) {\n                let yAxisLabel = this.axisGraphicsContext.append(\"text\")\n                    .style(\"text-anchor\", \"middle\")\n                    .text(axisLabels.y)\n                    .call((text: D3.Selection) => {\n                        text.each(function () {\n                            let text = d3.select(this);\n                            text.attr({\n                                \"class\": \"yAxisLabel\",\n                                \"transform\": \"rotate(-90)\",\n                                \"y\": showY1OnRight ? width + margin.right - fontSize : -margin.left,\n                                \"x\": -((height - margin.top - legendMargin) / 2),\n                                \"dy\": \"1em\"\n                            });\n                        });\n                    });\n\n                yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\n                    height - (margin.bottom + margin.top),\n                    TextMeasurementService.svgEllipsis);\n            }\n\n            if (!hideY2AxisTitle && axisLabels.y2) {\n                let y2AxisLabel = this.axisGraphicsContext.append(\"text\")\n                    .style(\"text-anchor\", \"middle\")\n                    .text(axisLabels.y2)\n                    .call((text: D3.Selection) => {\n                        text.each(function () {\n                            let text = d3.select(this);\n                            text.attr({\n                                \"class\": \"yAxisLabel\",\n                                \"transform\": \"rotate(-90)\",\n                                \"y\": showY1OnRight ? -margin.left : width + margin.right - fontSize,\n                                \"x\": -((height - margin.top - legendMargin) / 2),\n                                \"dy\": \"1em\"\n                            });\n                        });\n                    });\n\n                y2AxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\n                    height - (margin.bottom + margin.top),\n                    TextMeasurementService.svgEllipsis);\n            }\n        }\n\n        private updateAxis(): void {\n            this.adjustMargins();\n\n            let yAxisOrientation = this.yAxisOrientation;\n            let showY1OnRight = yAxisOrientation === yAxisPosition.right;\n\n            this.xAxisGraphicsContext\n                .attr('transform', SVGUtil.translate(0, this.viewportIn.height));\n\n            this.y1AxisGraphicsContext\n                .attr('transform', SVGUtil.translate(showY1OnRight ? this.viewportIn.width : 0, 0));\n\n            this.svg.attr({\n                'width': this.viewport.width,\n                'height': this.viewport.height\n            });\n\n            this.svgScrollable.attr({\n                'width': this.viewport.width,\n                'height': this.viewport.height\n            });\n\n            this.svgScrollable.attr({\n                'x': 0\n            });\n\n            let left: number = this.margin.left;\n            let top: number = this.margin.top;\n\n            this.axisGraphicsContext.attr('transform', SVGUtil.translate(left, top));\n            this.axisGraphicsContextScrollable.attr('transform', SVGUtil.translate(left, top));\n            this.clearCatcher.attr('transform', SVGUtil.translate(-left, -top));\n\n            if (this.isXScrollBarVisible) {\n                this.svgScrollable.attr({\n                    'x': left\n                });\n                this.axisGraphicsContextScrollable.attr('transform', SVGUtil.translate(0, top));\n                this.svgScrollable.attr('width', this.viewportIn.width);\n                this.svg.attr('width', this.viewport.width)\n                    .attr('height', this.viewport.height + this.ScrollBarWidth);\n            }\n            else if (this.isYScrollBarVisible) {\n                this.svgScrollable.attr('height', this.viewportIn.height + top);\n                this.svg.attr('width', this.viewport.width + this.ScrollBarWidth)\n                    .attr('height', this.viewport.height);\n            }\n        }\n\n        private getUnitType(xAxis: IAxisProperties) {\n            if (xAxis.formatter &&\n                xAxis.formatter.displayUnit &&\n                xAxis.formatter.displayUnit.value > 1)\n                return xAxis.formatter.displayUnit.title;\n            return null;\n        }\n\n        private addUnitTypeToAxisLabel(xAxis: IAxisProperties, yAxis: IAxisProperties): void {\n            let unitType = this.getUnitType(xAxis);\n            if (xAxis.isCategoryAxis) {\n                this.categoryAxisHasUnitType = unitType !== null;\n            }\n            else {\n                this.valueAxisHasUnitType = unitType !== null;\n            }\n\n            if (xAxis.axisLabel && unitType) {\n                if (xAxis.isCategoryAxis) {\n                    xAxis.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, xAxis.axisLabel, unitType);\n                }\n                else {\n                    xAxis.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, xAxis.axisLabel, unitType);\n                }\n            }\n\n            unitType = this.getUnitType(yAxis);\n\n            if (!yAxis.isCategoryAxis) {\n                this.valueAxisHasUnitType = unitType !== null;\n            }\n            else {\n                this.categoryAxisHasUnitType = unitType !== null;\n            }\n\n            if (yAxis.axisLabel && unitType) {\n                if (!yAxis.isCategoryAxis) {\n                    yAxis.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, yAxis.axisLabel, unitType);\n                }\n                else {\n                    yAxis.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, yAxis.axisLabel, unitType);\n                }\n            }\n        }\n\n        private hideAxisLabels(): boolean {\n            if (this.cartesianSmallViewPortProperties) {\n                if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort\n                    && ((this.viewport.height + this.legendViewport.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible)\n                    && !this.options.interactivity.isInteractiveLegend) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private drawScatterMarkers(scatterData: EnhancedScatterChartDataPoint[], hasSelection: boolean, sizeRange: NumberRange, duration: number) {\n            let xScale = this.xAxisProperties.scale;\n            let yScale = this.yAxisProperties.scale;\n            let shouldEnableFill = (!sizeRange || !sizeRange.min) && this.data.fillPoint;\n\n            let markers;\n            let useCustomColor = this.data.useCustomColor;\n            if (this.data.useShape) {\n                this.mainGraphicsContext.selectAll(EnhancedScatterChart.ImageClasses.selector).remove();\n                markers = this.mainGraphicsContext.classed('ScatterMarkers', true).selectAll(EnhancedScatterChart.DotClasses.selector).data(scatterData, (d: EnhancedScatterChartDataPoint) => d.identity.getKey());\n                markers.enter()\n                    .append('path')\n                    .classed(EnhancedScatterChart.DotClasses.class, true).attr('id', 'markershape');\n                markers\n                    .style({\n                        'stroke-opacity': (d: EnhancedScatterChartDataPoint) => ScatterChart.getBubbleOpacity(d, hasSelection),\n                        'stroke-width': '1px',\n                        'stroke': (d: EnhancedScatterChartDataPoint) => {\n                            let color = useCustomColor ? d.colorFill : d.fill;\n                            if (this.data.outline) {\n                                return d3.rgb(color).darker();\n                            } else {\n                                return d3.rgb(color);\n                            }\n                        },\n                        'fill': (d: EnhancedScatterChartDataPoint) => d3.rgb(useCustomColor ? d.colorFill : d.fill),\n                        'fill-opacity': (d: EnhancedScatterChartDataPoint) => (d.size != null || shouldEnableFill) ? ScatterChart.getBubbleOpacity(d, hasSelection) : 0,\n                    })\n                    .attr(\"d\", (d: EnhancedScatterChartDataPoint) => {\n                        let r = ScatterChart.getBubbleRadius(d.radius, sizeRange, this.viewport);\n                        let area = 4 * r * r;\n                        return d.shapeSymbolType(area);\n                    })\n                    .transition()\n                    .duration((d) => {\n                        if (this.keyArray.indexOf(d.identity.getKey()) >= 0) {\n                            return duration;\n                        } else {\n                            return 0;\n                        }\n                    })\n                    .attr(\"transform\", function (d) { return \"translate(\" + xScale(d.x) + \",\" + yScale(d.y) + \") rotate(\" + d.rotation + \")\"; });\n            } else {\n                this.mainGraphicsContext.selectAll(EnhancedScatterChart.DotClasses.selector).remove();\n                markers = this.mainGraphicsContext.classed('ScatterMarkers', true).selectAll(EnhancedScatterChart.ImageClasses.selector).data(scatterData, (d: EnhancedScatterChartDataPoint) => d.identity.getKey());\n                markers.enter().append(\"svg:image\")\n                    .classed(EnhancedScatterChart.ImageClasses.class, true).attr('id', 'markerimage');\n                markers\n                    .attr(\"xlink:href\", (d) => {\n                        if (d.svgurl !== undefined && d.svgurl != null && d.svgurl !== \"\") {\n                            return d.svgurl;\n                        } else {\n                            return this.svgDefaultImage;\n                        }\n                    })\n                    .attr(\"width\", (d) => {\n                        return ScatterChart.getBubbleRadius(d.radius, sizeRange, this.viewport) * 2;\n                    })\n                    .attr(\"height\", (d) => {\n                        return ScatterChart.getBubbleRadius(d.radius, sizeRange, this.viewport) * 2;\n                    })\n                    .transition()\n                    .duration((d) => {\n                        if (this.keyArray.indexOf(d.identity.getKey()) >= 0) {\n                            return duration;\n                        } else {\n                            return 0;\n                        }\n                    })\n                    .attr(\"transform\", (d) => {\n                        let radius = ScatterChart.getBubbleRadius(d.radius, sizeRange, this.viewport);\n                        return \"translate(\" + (xScale(d.x) - radius) + \",\" + (yScale(d.y) - radius) + \") rotate(\" + d.rotation + \",\" + radius + \",\" + radius + \")\";\n                    });\n            }\n\n            markers.exit().remove();\n            this.keyArray = [];\n            for (let i = 0; i < scatterData.length; i++) {\n                this.keyArray.push(scatterData[i].identity.getKey());\n            }\n\n            return markers;\n        }\n\n        public calculateAxes(\n            categoryAxisProperties: DataViewObject,\n            valueAxisProperties: DataViewObject,\n            textProperties: TextProperties,\n            scrollbarVisible: boolean): IAxisProperties[] {\n\n            let visualOptions: CalculateScaleAndDomainOptions = {\n                viewport: this.viewport,\n                margin: this.margin,\n                forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],\n                forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,\n                showCategoryAxisLabel: false,\n                showValueAxisLabel: false,\n                categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? <string>categoryAxisProperties['axisScale'] : null,\n                valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? <string>valueAxisProperties['axisScale'] : null,\n                valueAxisDisplayUnits: valueAxisProperties && valueAxisProperties['labelDisplayUnits'] != null ? <number>valueAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault,\n                categoryAxisDisplayUnits: categoryAxisProperties && categoryAxisProperties['labelDisplayUnits'] != null ? <number>categoryAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault,\n                trimOrdinalDataOnOverflow: false\n            };\n\n            if (valueAxisProperties) {\n                visualOptions.forcedYDomain = AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);\n            }\n\n            visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']);\n\n            visualOptions.showValueAxisLabel = true;\n\n            let width = this.viewport.width - (this.margin.left + this.margin.right);\n\n            let axes = this.calculateAxesProperties(visualOptions);\n            axes[0].willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(\n                axes[0],\n                width,\n                TextMeasurementService.measureSvgTextWidth,\n                textProperties);\n\n            // If labels do not fit and we are not scrolling, try word breaking\n            axes[0].willLabelsWordBreak = (!axes[0].willLabelsFit && !scrollbarVisible) && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(\n                axes[0], this.margin, width, TextMeasurementService.measureSvgTextWidth,\n                TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault,\n                textProperties);\n            return axes;\n        }\n\n        public calculateAxesProperties(options: CalculateScaleAndDomainOptions): IAxisProperties[] {\n            let data = this.data;\n            let dataPoints = data.dataPoints;\n            this.margin = options.margin;\n            this.viewport = options.viewport;\n\n            let minY = 0,\n                maxY = 10,\n                minX = 0,\n                maxX = 10;\n            if (dataPoints.length > 0) {\n                minY = d3.min<EnhancedScatterChartDataPoint, number>(dataPoints, d => d.y);\n                maxY = d3.max<EnhancedScatterChartDataPoint, number>(dataPoints, d => d.y);\n                minX = d3.min<EnhancedScatterChartDataPoint, number>(dataPoints, d => d.x);\n                maxX = d3.max<EnhancedScatterChartDataPoint, number>(dataPoints, d => d.x);\n            }\n\n            let xDomain = [minX, maxX];\n            let combinedXDomain = AxisHelper.combineDomain(options.forcedXDomain, xDomain);\n\n            this.xAxisProperties = AxisHelper.createAxis({\n                pixelSpan: this.viewportIn.width,\n                dataDomain: combinedXDomain,\n                metaDataColumn: data.xCol,\n                formatString: valueFormatter.getFormatString(data.xCol, scatterChartProps.general.formatString),\n                outerPadding: 0,\n                isScalar: true,\n                isVertical: false,\n                forcedTickCount: options.forcedTickCount,\n                useTickIntervalForDisplayUnits: true,\n                isCategoryAxis: true, //scatter doesn't have a categorical axis, but this is needed for the pane to react correctly to the x-axis toggle one/off\n                scaleType: options.categoryAxisScaleType,\n                axisDisplayUnits: options.categoryAxisDisplayUnits\n            });\n            this.xAxisProperties.axis.tickSize(-this.viewportIn.height, 0);\n            this.xAxisProperties.axisLabel = this.data.axesLabels.x;\n\n            let combinedDomain = AxisHelper.combineDomain(options.forcedYDomain, [minY, maxY]);\n\n            this.yAxisProperties = AxisHelper.createAxis({\n                pixelSpan: this.viewportIn.height,\n                dataDomain: combinedDomain,\n                metaDataColumn: data.yCol,\n                formatString: valueFormatter.getFormatString(data.yCol, scatterChartProps.general.formatString),\n                outerPadding: 0,\n                isScalar: true,\n                isVertical: true,\n                forcedTickCount: options.forcedTickCount,\n                useTickIntervalForDisplayUnits: true,\n                isCategoryAxis: false,\n                scaleType: options.valueAxisScaleType,\n                axisDisplayUnits: options.valueAxisDisplayUnits\n            });\n            this.yAxisProperties.axisLabel = this.data.axesLabels.y;\n\n            return [this.xAxisProperties, this.yAxisProperties];\n        }\n\n        private enumerateDataPoints(enumeration: ObjectEnumerationBuilder): void {\n            let data = this.data;\n            if (!data)\n                return;\n\n            let seriesCount = data.dataPoints.length;\n\n            if (!data.hasDynamicSeries) {\n                // Add default color and show all slices\n                enumeration.pushInstance({\n                    objectName: 'dataPoint',\n                    selector: null,\n                    properties: {\n                        defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }\n                    }\n                }).pushInstance({\n                    objectName: 'dataPoint',\n                    selector: null,\n                    properties: {\n                        showAllDataPoints: !!data.showAllDataPoints\n                    }\n                });\n\n                for (let i = 0; i < seriesCount; i++) {\n                    let seriesDataPoints = data.dataPoints[i];\n                    enumeration.pushInstance({\n                        objectName: 'dataPoint',\n                        displayName: seriesDataPoints.formattedCategory.getValue(),\n                        selector: ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),\n                        properties: {\n                            fill: { solid: { color: seriesDataPoints.fill } }\n                        },\n                    });\n                }\n            }\n            else {\n                let legendDataPointLength = data.legendData.dataPoints.length;\n                for (let i = 0; i < legendDataPointLength; i++) {\n                    let series = data.legendData.dataPoints[i];\n                    enumeration.pushInstance({\n                        objectName: 'dataPoint',\n                        displayName: series.label,\n                        selector: ColorHelper.normalizeSelector(series.identity.getSelector()),\n                        properties: {\n                            fill: { solid: { color: series.color } }\n                        },\n                    });\n                }\n            }\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\n            let enumeration = new ObjectEnumerationBuilder();\n\n            switch (options.objectName) {\n                case 'dataPoint':\n                    let categoricalDataView: DataViewCategorical = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;\n                    if (!GradientUtils.hasGradientRole(categoricalDataView))\n                        this.enumerateDataPoints(enumeration);\n                    break;\n                case 'categoryAxis':\n                    this.getCategoryAxisValues(enumeration);\n                    break;\n                case 'valueAxis':\n                    this.getValueAxisValues(enumeration);\n                    break;\n                case 'categoryLabels':\n                    if (this.data)\n                        dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, true);\n                    else\n                        dataLabelUtils.enumerateCategoryLabels(enumeration, null, true);\n                    break;\n                case 'fillPoint':\n                    let sizeRange = this.data.sizeRange;\n                    // Check if the card should be shown or not\n                    if (sizeRange && sizeRange.min)\n                        break;\n\n                    enumeration.pushInstance({\n                        objectName: 'fillPoint',\n                        selector: null,\n                        properties: {\n                            show: this.data.fillPoint,\n                        },\n                    });\n                    break;\n                case 'backdrop':\n                    enumeration.pushInstance({\n                        objectName: 'backdrop',\n                        displayName: 'Backdrop',\n                        selector: null,\n                        properties: {\n                            show: this.data.backdrop ? this.data.backdrop.show : false,\n                            url: this.data.backdrop ? this.data.backdrop.url : null\n                        },\n                    });\n                    break;\n                case 'crosshair':\n                    enumeration.pushInstance({\n                        objectName: 'crosshair',\n                        selector: null,\n                        properties: {\n                            show: this.data.crosshair\n                        },\n                    });\n                    break;\n                case 'outline':\n                    enumeration.pushInstance({\n                        objectName: 'outline',\n                        selector: null,\n                        properties: {\n                            show: this.data.outline\n                        },\n                    });\n                    break;\n                case 'legend':\n                    this.getLegendValue(enumeration);\n                    break;\n            }\n            return enumeration.complete();\n        }\n\n        public hasLegend(): boolean {\n            return this.data && this.data.hasDynamicSeries;\n        }\n\n        private getLegendValue(enumeration: ObjectEnumerationBuilder): void {\n            if (!this.hasLegend())\n                return;\n            let show = DataViewObject.getValue<boolean>(this.legendObjectProperties, legendProps.show, this.legend.isVisible());\n            let showTitle = DataViewObject.getValue<boolean>(this.legendObjectProperties, legendProps.showTitle, true);\n            let titleText = DataViewObject.getValue<string>(this.legendObjectProperties, legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : '');\n            let legendLabelColor = DataViewObject.getValue<string>(this.legendObjectProperties, legendProps.labelColor, LegendData.DefaultLegendLabelFillColor);\n            this.legendLabelFontSize = DataViewObject.getValue<number>(this.legendObjectProperties, legendProps.fontSize, EnhancedScatterChart.LegendLabelFontSizeDefault);\n\n            enumeration.pushInstance({\n                selector: null,\n                properties: {\n                    show: show,\n                    position: LegendPosition[this.legend.getOrientation()],\n                    showTitle: showTitle,\n                    titleText: titleText,\n                    labelColor: legendLabelColor,\n                    fontSize: this.legendLabelFontSize,\n                },\n                objectName: 'legend'\n            });\n        }\n\n        private getCategoryAxisValues(enumeration: ObjectEnumerationBuilder): void {\n            let supportedType = axisType.both;\n            let isScalar = true;\n            let logPossible = false;\n            let scaleOptions = [axisScale.log, axisScale.linear];//until options can be update in propPane, show all options\n\n            if (!isScalar) {\n                if (this.categoryAxisProperties) {\n                    this.categoryAxisProperties['start'] = null;\n                    this.categoryAxisProperties['end'] = null;\n                }\n            }\n\n            let instance: VisualObjectInstance = {\n                selector: null,\n                properties: {},\n                objectName: 'categoryAxis',\n                validValues: {\n                    axisScale: scaleOptions\n                }\n            };\n\n            instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;\n            if (this.yAxisIsCategorical)//in case of e.g. barChart\n                instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : yAxisPosition.left;\n            if (supportedType === axisType.both) {\n                instance.properties['axisType'] = isScalar ? axisType.scalar : axisType.categorical;\n            }\n            if (isScalar) {\n                instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : axisScale.linear;\n                instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;\n                instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;\n                instance.properties['labelDisplayUnits'] = this.categoryAxisProperties && this.categoryAxisProperties['labelDisplayUnits'] != null ? this.categoryAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault;\n            }\n            instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : true;\n\n            enumeration\n                .pushInstance(instance)\n                .pushInstance({\n                    selector: null,\n                    properties: {\n                        axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : axisStyle.showTitleOnly,\n                        labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null\n                    },\n                    objectName: 'categoryAxis',\n                    validValues: {\n                        axisStyle: this.categoryAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly]\n                    }\n                });\n        }\n\n        //todo: wrap all these object getters and other related stuff into an interface\n        private getValueAxisValues(enumeration: ObjectEnumerationBuilder): void {\n            let scaleOptions = [axisScale.log, axisScale.linear];  //until options can be update in propPane, show all options\n            let logPossible = false;\n\n            let instance: VisualObjectInstance = {\n                selector: null,\n                properties: {},\n                objectName: 'valueAxis',\n                validValues: {\n                    axisScale: scaleOptions,\n                    secAxisScale: scaleOptions\n                }\n            };\n\n            instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;\n\n            if (!this.yAxisIsCategorical) {\n                instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : yAxisPosition.left;\n            }\n            instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : axisScale.linear;\n            instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;\n            instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;\n            instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : true;\n            instance.properties['labelDisplayUnits'] = this.valueAxisProperties && this.valueAxisProperties['labelDisplayUnits'] != null ? this.valueAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault;\n\n            enumeration\n                .pushInstance(instance)\n                .pushInstance({\n                    selector: null,\n                    properties: {\n                        axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : axisStyle.showTitleOnly,\n                        labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null\n                    },\n                    objectName: 'valueAxis',\n                    validValues: {\n                        axisStyle: this.valueAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly]\n                    },\n                });\n        }\n\n        public onClearSelection(): void {\n            if (this.interactivityService)\n                this.interactivityService.clearSelection();\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *   \n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *   \n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import SelectionManager = utility.SelectionManager;\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n    import CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n    import PixelConverter = jsCommon.PixelConverter;\n\n    export interface RadarChartConstructorOptions {\n        animator?: IGenericAnimator;\n        svg?: D3.Selection;\n        margin?: IMargin;\n    }\n\n    export interface RadarChartDatapoint extends SelectableDataPoint {\n        x: number;\n        y: number;\n        y0?: number;\n        color?: string;\n        value?: number;\n        tooltipInfo?: TooltipDataItem[];\n        labelFormatString?: string;\n        labelFontSize?: string;\n    }\n\n    export interface RadarChartData {\n        legendData: LegendData;\n        series: RadarChartSeries[];\n        settings: RadarChartSettings;\n        dataLabelsSettings: PointDataLabelsSettings;\n    }\n\n    export interface RadarChartSeries {\n        fill: string;\n        name: string;\n        data: RadarChartDatapoint[];\n        identity: SelectionId;\n    }\n\n    export interface RadarChartSettings {\n        showLegend?: boolean;\n    }\n\n    export interface RadarChartBehaviorOptions {\n        selection: D3.Selection;\n        clearCatcher: D3.Selection;\n    }\n    \n    /**\n     * RadarChartBehavior\n     */\n    export class RadarChartWebBehavior implements IInteractiveBehavior {\n        private selection: D3.Selection;\n\n        public bindEvents(options: RadarChartBehaviorOptions, selectionHandler: ISelectionHandler): void {\n            let selection = this.selection = options.selection;\n            let clearCatcher = options.clearCatcher;\n\n            selection.on('click', function (d: SelectableDataPoint) {\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\n                d3.event.stopPropagation();\n            });\n\n            clearCatcher.on('click', function () {\n                selectionHandler.handleClearSelection();\n            });\n        }\n\n        public renderSelection(hasSelection: boolean): void {\n            this.selection.style(\"opacity\", (d: SelectableDataPoint) => (hasSelection && !d.selected) ? RadarChart.DimmedAreaFillOpacity : RadarChart.AreaFillOpacity);\n        }\n    }\n\n    export class RadarChart implements IVisual {\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    displayName: 'Category',\n                    name: 'Category',\n                    kind: powerbi.VisualDataRoleKind.Grouping,\n                },\n                {\n                    displayName: 'Y Axis',\n                    name: 'Y',\n                    kind: powerbi.VisualDataRoleKind.Measure,\n                },\n            ],\n            dataViewMappings: [{\n                conditions: [{ 'Category': { min: 1, max: 1 } }],\n                categorical: {\n                    categories: {\n                        for: { in: 'Category' },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: {\n                        select: [{ bind: { to: 'Y' } }]\n                    }\n                }\n            }],\n            objects: {\n                general: {\n                    displayName: data.createDisplayNameGetter('Visual_General'),\n                    properties: {\n                        formatString: {\n                            type: { formatting: { formatString: true } },\n                        },\n                    },\n                },\n                legend: {\n                    displayName: data.createDisplayNameGetter('Visual_Legend'),\n                    description: data.createDisplayNameGetter('Visual_LegendDescription'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendPosition'),\n                            description: data.createDisplayNameGetter('Visual_LegendPositionDescription'),\n                            type: { enumeration: legendPosition.type }\n                        },\n                        showTitle: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendShowTitle'),\n                            description: data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),\n                            type: { bool: true }\n                        },\n                        titleText: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendName'),\n                            description: data.createDisplayNameGetter('Visual_LegendNameDescription'),\n                            type: { text: true },\n                            suppressFormatPainterCopy: true\n                        },\n                        labelColor: {\n                            displayName: data.createDisplayNameGetter('Visual_LegendTitleColor'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { formatting: { fontSize: true } }\n                        }\n                    }\n                },\n                dataPoint: {\n                    displayName: data.createDisplayNameGetter('Visual_DataPoint'),\n                    description: data.createDisplayNameGetter('Visual_DataPointDescription'),\n                    properties: {\n                        fill: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                },\n                labels: {\n                    displayName: data.createDisplayNameGetter('Visual_DataPointsLabels'),\n                    description: data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),\n                    properties: {\n                        show: {\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\n                            type: { bool: true }\n                        },\n                        color: {\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\n                            description: data.createDisplayNameGetter('Visual_LabelsFillDescription'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        labelDisplayUnits: {\n                            displayName: data.createDisplayNameGetter('Visual_DisplayUnits'),\n                            description: data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),\n                            type: { formatting: { labelDisplayUnits: true } },\n                            suppressFormatPainterCopy: true,\n                        },\n                        labelPrecision: {\n                            displayName: data.createDisplayNameGetter('Visual_Precision'),\n                            description: data.createDisplayNameGetter('Visual_PrecisionDescription'),\n                            placeHolderText: data.createDisplayNameGetter('Visual_Precision_Auto'),\n                            type: { numeric: true },\n                            suppressFormatPainterCopy: true,\n                        },\n                        fontSize: {\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\n                            type: { formatting: { fontSize: true } }\n                        },\n                    }\n                }\n            }\n        };\n\n        /** Note: Public for testability */\n        public static formatStringProp: DataViewObjectPropertyIdentifier = {\n            objectName: 'general',\n            propertyName: 'formatString',\n        };\n\n        private static Properties: any = {\n            legend: {\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'show' }\n            },\n            dataPoint: {\n                fill: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'fill' }\n            },\n            labels: {\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'show' },\n                color: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'color' },\n                displayUnits: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'labelDisplayUnits' },\n                precision: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'labelPrecision' },\n                fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'fontSize' },\n            }\n        };\n\n        private static VisualClassName = 'radarChart';\n        private static Segments: ClassAndSelector = CreateClassAndSelector('segments');\n        private static SegmentNode: ClassAndSelector = CreateClassAndSelector('segmentNode');\n        private static Axis: ClassAndSelector = CreateClassAndSelector('axis');\n        private static AxisNode: ClassAndSelector = CreateClassAndSelector('axisNode');\n        private static AxisLabel: ClassAndSelector = CreateClassAndSelector('axisLabel');\n        private static Chart: ClassAndSelector = CreateClassAndSelector('chart');\n        private static ChartNode: ClassAndSelector = CreateClassAndSelector('chartNode');\n        private static ChartPolygon: ClassAndSelector = CreateClassAndSelector('chartPolygon');\n        private static ChartDot: ClassAndSelector = CreateClassAndSelector('chartDot');\n\n        private svg: D3.Selection;\n        private segments: D3.Selection;\n        private axis: D3.Selection;\n        private chart: D3.Selection;\n\n        private mainGroupElement: D3.Selection;\n        private colors: IDataColorPalette;\n        private selectionManager: SelectionManager;\n        private viewport: IViewport;\n        private interactivityService: IInteractivityService;\n\n        private animator: IGenericAnimator;\n        private margin: IMargin;\n        private legend: ILegend;\n        private legendObjectProperties: DataViewObject;\n        private radarChartData: RadarChartData;\n        private isInteractiveChart: boolean;\n\n        private static DefaultMargin: IMargin = {\n            top: 50,\n            bottom: 50,\n            right: 100,\n            left: 100\n        };\n\n        private static SegmentLevels: number = 6;\n        private static SegmentFactor: number = 1;\n        private static Radians: number = 2 * Math.PI;\n        private static Scale: number = 1;\n        public static AreaFillOpacity = 1;\n        public static DimmedAreaFillOpacity = 0.4;\n        private angle: number;\n        private radius: number;\n\n        public static converter(dataView: DataView, colors: IDataColorPalette): RadarChartData {\n            if (!dataView ||\n                !dataView.categorical ||\n                !dataView.categorical.categories ||\n                !(dataView.categorical.categories.length > 0) ||\n                !dataView.categorical.categories[0] ||\n                !dataView.categorical.values ||\n                !(dataView.categorical.values.length > 0)) {\n                return {\n                    legendData: {\n                        dataPoints: []\n                    },\n                    settings: {\n                        showLegend: true\n                    },\n                    series: [],\n                    dataLabelsSettings: dataLabelUtils.getDefaultPointLabelSettings(),\n                };\n            }\n\n            let catDv: DataViewCategorical = dataView.categorical;\n            let values = catDv.values;\n            let series: RadarChartSeries[] = [];\n            let colorHelper = new ColorHelper(colors, RadarChart.Properties.dataPoint.fill);\n            let legendData: LegendData = {\n                fontSize: 8.25,\n                dataPoints: [],\n                title: \"\"\n            };\n\n            //Parse legend settings          \n            let legendSettings: RadarChartSettings = RadarChart.parseSettings(dataView);\n            let dataLabelsSettings: PointDataLabelsSettings = RadarChart.parseLabelSettings(dataView);\n\n            for (let i = 0, iLen = values.length; i < iLen; i++) {\n                let color = colors.getColorByIndex(i).value,\n                    serieIdentity: SelectionId,\n                    queryName: string,\n                    displayName: string,\n                    dataPoints: RadarChartDatapoint[] = [];\n\n                if (values[i].source) {\n                    let source = values[i].source;\n\n                    if (source.queryName) {\n                        queryName = source.queryName;\n                        serieIdentity = SelectionId.createWithMeasure(queryName);\n                    }\n\n                    if (source.displayName)\n                        displayName = source.displayName;\n\n                    if (source.objects) {\n                        let objects: any = source.objects;\n                        color = colorHelper.getColorForMeasure(objects, queryName);\n                    }\n                }\n\n                legendData.dataPoints.push({\n                    label: displayName,\n                    color: color,\n                    icon: LegendIcon.Box,\n                    selected: false,\n                    identity: serieIdentity\n                });\n\n                for (let k = 0, kLen = values[i].values.length; k < kLen; k++) {\n\n                    let dataPointIdentity = SelectionIdBuilder\n                        .builder()\n                        .withMeasure(queryName)\n                        .withCategory(catDv.categories[0], k)\n                        .withSeries(dataView.categorical.values, dataView.categorical.values[i])\n                        .createSelectionId();\n\n                    let tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(RadarChart.formatStringProp,\n                        catDv,\n                        catDv.categories[0].values[k],\n                        values[i].values[k],\n                        null,\n                        null,\n                        i);\n\n                    let labelFormatString = valueFormatter.getFormatString(catDv.values[i].source, RadarChart.formatStringProp);\n                    let fontSizeInPx = jsCommon.PixelConverter.fromPoint(dataLabelsSettings.fontSize);\n\n                    dataPoints.push({\n                        x: k,\n                        y: values[i].values[k],\n                        color: color,\n                        identity: dataPointIdentity,\n                        selected: false,\n                        tooltipInfo: tooltipInfo,\n                        value: values[i].values[k],\n                        labelFormatString: labelFormatString,\n                        labelFontSize: fontSizeInPx,\n                    });\n                }\n\n                if (dataPoints.length > 0)\n                    series.push({\n                        fill: color,\n                        name: displayName,\n                        data: dataPoints,\n                        identity: serieIdentity,\n                    });\n            }\n\n            return {\n                legendData: legendData,\n                settings: legendSettings,\n                series: series,\n                dataLabelsSettings: dataLabelsSettings,\n            };\n        }\n\n        public constructor(options?: RadarChartConstructorOptions) {\n\n            if (options) {\n                if (options.svg)\n                    this.svg = options.svg;\n\n                if (options.animator)\n                    this.animator = options.animator;\n\n                if (options.margin)\n                    this.margin = options.margin;\n            }\n        }\n\n        public init(options: VisualInitOptions): void {\n            let element = options.element;\n            this.selectionManager = new SelectionManager({ hostServices: options.host });\n\n            if (!this.svg) {\n                this.svg = d3.select(element.get(0)).append('svg');\n                this.svg.style('position', 'absolute');\n            }\n\n            if (!this.margin)\n                this.margin = RadarChart.DefaultMargin;\n\n            this.svg.classed(RadarChart.VisualClassName, true);\n            this.interactivityService = visuals.createInteractivityService(options.host);\n            this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;\n            this.legend = createLegend(element,\n                this.isInteractiveChart,\n                this.interactivityService,\n                true,\n                LegendPosition.Top);\n            this.colors = options.style.colorPalette.dataColors;\n            this.mainGroupElement = this.svg.append('g');\n\n            this.segments = this.mainGroupElement\n                .append('g')\n                .classed(RadarChart.Segments.class, true);\n\n            this.axis = this.mainGroupElement\n                .append('g')\n                .classed(RadarChart.Axis.class, true);\n\n            this.chart = this.mainGroupElement\n                .append('g')\n                .classed(RadarChart.Chart.class, true);\n        }\n\n        public update(options: VisualUpdateOptions): void {\n            if (!options.dataViews || !options.dataViews[0])\n                return;\n\n            let dataView = options.dataViews[0];\n            this.radarChartData = RadarChart.converter(dataView, this.colors);\n            let categories: any[] = [],\n                series = this.radarChartData.series,\n                dataViewMetadataColumn: DataViewMetadataColumn,\n                duration = AnimatorCommon.GetAnimationDuration(this.animator, options.suppressAnimations);\n\n            if (dataView.categorical &&\n                dataView.categorical.categories &&\n                dataView.categorical.categories[0] &&\n                dataView.categorical.categories[0].values)\n                categories = dataView.categorical.categories[0].values;\n\n            if (dataView.metadata && dataView.metadata.columns && dataView.metadata.columns.length > 0)\n                dataViewMetadataColumn = dataView.metadata.columns[0];\n\n            this.viewport = {\n                height: options.viewport.height > 0 ? options.viewport.height : 0,\n                width: options.viewport.width > 0 ? options.viewport.width : 0\n            };\n\n            this.parseLegendProperties(dataView);\n            this.renderLegend(this.radarChartData);\n            this.updateViewport();\n\n            this.svg\n                .attr({\n                    'height': this.viewport.height,\n                    'width': this.viewport.width\n                });\n\n            let mainGroup = this.mainGroupElement;\n            mainGroup.attr('transform', SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));\n           \n            let width: number = this.viewport.width - this.margin.left - this.margin.right;\n            let height: number = this.viewport.height - this.margin.top - this.margin.bottom;\n\n            this.angle = RadarChart.Radians / categories.length;\n            this.radius = RadarChart.SegmentFactor * RadarChart.Scale * Math.min(width, height) / 2;\n\n            this.drawCircularSegments(categories);\n            this.drawAxes(categories);\n            this.drawAxesLabels(categories, dataViewMetadataColumn);\n            this.drawChart(series, duration);\n            this.drawDataLabels(series);\n        }\n\n        private getRadarChartLabelLayout(labelSettings: PointDataLabelsSettings, allDataPoints: RadarChartDatapoint[]): ILabelLayout {\n\n            let formattersCache = dataLabelUtils.createColumnFormatterCacheManager();\n            let angle: number = this.angle;\n            let radius: number = this.radius;\n            let dataPoints: RadarChartDatapoint[][] = this.getDataPoints(this.radarChartData.series);\n            let stack = d3.layout.stack();\n            let layers = stack(dataPoints);\n            let viewport = this.viewport;\n            let halfHeight = this.viewport.height / 2;\n            let halfWidth = this.viewport.width / 2;\n            let y = d3.scale.linear()\n                .domain([0, d3.max(layers, (layer) => {\n                    return d3.max(layer, (d) => {\n                        return d.y0 + d.y;\n                    });\n                })]).range([0, radius]);\n\n            return {\n                labelText: (d: RadarChartDatapoint) => {\n\n                    let formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings);\n\n                    if (labelSettings.displayUnits === 0) {\n                        let maxDataPoint: RadarChartDatapoint = _.max(allDataPoints, d => d.value);\n                        let maxValue = maxDataPoint.value > 0 ? maxDataPoint.value : 0;\n\n                        formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings, maxValue);\n                    }\n                    return dataLabelUtils.getLabelFormattedText({ label: formmater.format(d.value), maxWidth: viewport.width, fontSize: labelSettings.fontSize });\n                },\n                labelLayout: {\n                    x: (d: RadarChartDatapoint) => -1 * y(d.y) * Math.sin(d.x * angle) + halfWidth,\n                    y: (d: RadarChartDatapoint) => -1 * y(d.y) * Math.cos(d.x * angle) + halfHeight - 10,\n                },\n                filter: (d: RadarChartDatapoint) => {\n                    return (d != null && d.value != null);\n                },\n                style: {\n                    'fill': labelSettings.labelColor,\n                    'font-size': (d: RadarChartDatapoint) => PixelConverter.fromPoint(labelSettings.fontSize),\n                },\n            };\n        }\n\n        private drawCircularSegments(values: string[]): void {\n            let data = [];\n            let angle: number = this.angle,\n                factor: number = RadarChart.SegmentFactor,\n                levels: number = RadarChart.SegmentLevels,\n                radius: number = this.radius;\n\n            for (let level = 0; level < levels - 1; level++) {\n                let levelFactor: number = radius * ((level + 1) / levels);\n                let transform: number = -1 * levelFactor;\n\n                for (let i = 0; i < values.length; i++)\n                    data.push({\n                        x1: levelFactor * (1 - factor * Math.sin(i * angle)),\n                        y1: levelFactor * (1 - factor * Math.cos(i * angle)),\n                        x2: levelFactor * (1 - factor * Math.sin((i + 1) * angle)),\n                        y2: levelFactor * (1 - factor * Math.cos((i + 1) * angle)),\n                        translate: SVGUtil.translate(transform, transform)\n                    });\n            }\n\n            let selection = this.mainGroupElement\n                .select(RadarChart.Segments.selector)\n                .selectAll(RadarChart.SegmentNode.selector)\n                .data(data);\n\n            selection\n                .enter()\n                .append('svg:line')\n                .classed(RadarChart.SegmentNode.class, true);\n            selection\n                .attr({\n                    'x1': item => item.x1,\n                    'y1': item => item.y1,\n                    'x2': item => item.x2,\n                    'y2': item => item.y2,\n                    'transform': item => item.translate\n                });\n\n            selection.exit().remove();\n        }\n\n        private drawDataLabels(series: RadarChartSeries[]): void {\n\n            let allDataPoints: RadarChartDatapoint[] = this.getAllDataPointsList(series);\n\n            if (this.radarChartData.dataLabelsSettings.show) {\n                let layout = this.getRadarChartLabelLayout(this.radarChartData.dataLabelsSettings, allDataPoints);\n                let viewport = this.viewport;\n                let labels = dataLabelUtils.drawDefaultLabelsForDataPointChart(allDataPoints, this.mainGroupElement, layout, viewport);\n\n                if (labels)\n                    labels.attr('transform', SVGUtil.translate(-(viewport.width / 2), -(viewport.height / 2)));\n            }\n            else\n                dataLabelUtils.cleanDataLabels(this.mainGroupElement);\n        }\n\n        private drawAxes(values: string[]): void {\n\n            let angle: number = this.angle,\n                radius: number = -1 * this.radius;\n\n            let selection: D3.Selection = this.mainGroupElement\n                .select(RadarChart.Axis.selector)\n                .selectAll(RadarChart.AxisNode.selector);\n\n            let axis = selection.data(values);\n\n            axis\n                .enter()\n                .append('svg:line');\n            axis\n                .attr({\n                    'x1': 0,\n                    'y1': 0,\n                    'x2': (name, i) => radius * Math.sin(i * angle),\n                    'y2': (name, i) => radius * Math.cos(i * angle)\n                })\n                .classed(RadarChart.AxisNode.class, true);\n\n            axis.exit().remove();\n        }\n\n        private drawAxesLabels(values: string[], dataViewMetadataColumn?: DataViewMetadataColumn): void {\n            let angle: number = this.angle,\n                radius: number = -1 * this.radius,\n                length: number = values.length;\n\n            let formatter = valueFormatter.create({\n                format: valueFormatter.getFormatString(dataViewMetadataColumn, RadarChart.formatStringProp, true),\n                value: values[0],\n                value2: values[length - 1],\n            });\n\n            let selection: D3.Selection = this.mainGroupElement\n                .select(RadarChart.Axis.selector)\n                .selectAll(RadarChart.AxisLabel.selector);\n\n            let labels = selection.data(values);\n\n            labels\n                .enter()\n                .append('svg:text');\n\n            labels\n                .attr({\n                    'text-anchor': 'middle',\n                    'dy': '1.5em',\n                    'transform': SVGUtil.translate(0, -10),\n                    'x': (name, i) => { return (radius - 20) * Math.sin(i * angle); },\n                    'y': (name, i) => { return (radius - 10) * Math.cos(i * angle); }\n                })\n                .text(item => formatter.format(item))\n                .classed(RadarChart.AxisLabel.class, true);\n\n            labels.exit().remove();\n        }\n\n        private drawChart(series: RadarChartSeries[], duration: number): void {\n            let angle: number = this.angle,\n                radius: number = this.radius,\n                dotRadius: number = 5,\n                dataPoints: RadarChartDatapoint[][] = this.getDataPoints(series);\n\n            let stack = d3.layout.stack();\n            let layers = stack(dataPoints);\n\n            let y = d3.scale.linear()\n                .domain([0, d3.max(layers, (layer) => {\n                    return d3.max(layer, (d) => {\n                        return d.y0 + d.y;\n                    });\n                })]).range([0, radius]);\n\n            let calculatePoints = (points) => {\n                return points.map((value) => {\n                    let x1 = -1 * y(value.y) * Math.sin(value.x * angle);\n                    let y1 = -1 * y(value.y) * Math.cos(value.x * angle);\n                    return `${x1},${y1}`;\n                }).join(' ');\n            };\n\n            let selection = this.chart.selectAll(RadarChart.ChartNode.selector).data(layers);\n\n            selection\n                .enter()\n                .append('g')\n                .classed(RadarChart.ChartNode.class, true);\n\n            let polygon = selection.selectAll(RadarChart.ChartPolygon.selector).data(d => {\n                if (d && d.length > 0) {\n                    return [d];\n                }\n\n                return [];\n            });\n            polygon\n                .enter()\n                .append('polygon')\n                .classed(RadarChart.ChartPolygon.class, true);\n            polygon\n                .style('fill', d => d[0].color)\n                .style('opacity', RadarChart.DimmedAreaFillOpacity)\n                .on('mouseover', function (d) {\n                    d3.select(this).transition()\n                        .duration(duration)\n                        .style('opacity', RadarChart.AreaFillOpacity);\n                })\n                .on('mouseout', function (d) {\n                    d3.select(this).transition()\n                        .duration(duration)\n                        .style('opacity', RadarChart.DimmedAreaFillOpacity);\n                })\n                .attr('points', calculatePoints);\n            polygon.exit().remove();\n\n            let dots = selection.selectAll(RadarChart.ChartDot.selector)\n                .data((d: RadarChartDatapoint[]) => { return d.filter(d => d.y != null); });\n\n            dots.enter()\n                .append('svg:circle')\n                .classed(RadarChart.ChartDot.class, true);\n            dots.attr('r', dotRadius)\n                .attr({\n                    'cx': (value) => -1 * y(value.y) * Math.sin(value.x * angle),\n                    'cy': (value) => -1 * y(value.y) * Math.cos(value.x * angle)\n                })\n                .style('fill', d => d.color);\n\n            dots.exit().remove();\n\n            TooltipManager.addTooltip(dots, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo, true);\n\n            selection.exit().remove();\n\n            let behaviorOptions: RadarChartBehaviorOptions = undefined;\n\n            if (this.interactivityService) {\n                \t\t\t\t\t                      \n                // Register interactivity\n                let dataPointsToBind = this.getAllDataPointsList(series);\n\n                behaviorOptions = { selection: dots, clearCatcher: this.svg };\n                this.interactivityService.bind(dataPointsToBind, new RadarChartWebBehavior(), behaviorOptions);\n            }\n        }\n\n        private renderLegend(radarChartData: RadarChartData): void {\n            if (!radarChartData.legendData)\n                return;\n\n            let legendData: LegendData = radarChartData.legendData;\n\n            if (this.legendObjectProperties) {\n                LegendData.update(legendData, this.legendObjectProperties);\n                let position = <string>this.legendObjectProperties[legendProps.position];\n\n                if (position)\n                    this.legend.changeOrientation(LegendPosition[position]);\n            }\n            else\n                this.legend.changeOrientation(LegendPosition.Top);\n\n            let viewport = this.viewport;\n            this.legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });\n            Legend.positionChartArea(this.svg, this.legend);\n        }\n\n        private getDataPoints(series: RadarChartSeries[]): RadarChartDatapoint[][] {\n            let dataPoints: RadarChartDatapoint[][] = [];\n\n            for (let serie of series) {\n                dataPoints.push(serie.data);\n            }\n\n            return dataPoints;\n        }\n\n        private getAllDataPointsList(series: RadarChartSeries[]): RadarChartDatapoint[] {\n            let dataPoints: RadarChartDatapoint[] = [];\n\n            for (let serie of series) {\n                dataPoints = dataPoints.concat(serie.data);\n            }\n\n            return dataPoints;\n        }\n\n        private parseLegendProperties(dataView: DataView): void {\n            if (!dataView || !dataView.metadata) {\n                this.legendObjectProperties = {};\n                return;\n            }\n\n            this.legendObjectProperties = DataViewObjects.getObject(dataView.metadata.objects, \"legend\", {});\n        }\n\n        private static parseSettings(dataView: DataView): RadarChartSettings {\n            let objects: DataViewObjects;\n\n            if (!dataView || !dataView.metadata || !dataView.metadata.columns || !dataView.metadata.objects)\n                objects = null;\n            else\n                objects = dataView.metadata.objects;\n\n            return {\n                showLegend: DataViewObjects.getValue(objects, RadarChart.Properties.legend.show, true)\n            };\n        }\n\n        private static parseLabelSettings(dataView: DataView): PointDataLabelsSettings {\n            let objects: DataViewObjects;\n\n            if (!dataView || !dataView.metadata || !dataView.metadata.objects)\n                objects = null;\n            else\n                objects = dataView.metadata.objects;\n\n            let dataLabelsSettings: PointDataLabelsSettings = dataLabelUtils.getDefaultPointLabelSettings();\n\n            let labelsObj: PointDataLabelsSettings = {\n                show: DataViewObjects.getValue(objects, RadarChart.Properties.labels.show, dataLabelsSettings.show),\n                labelColor: DataViewObjects.getFillColor(objects, RadarChart.Properties.labels.color, dataLabelsSettings.labelColor),\n                displayUnits: DataViewObjects.getValue(objects, RadarChart.Properties.labels.displayUnits, dataLabelsSettings.displayUnits),\n                precision: DataViewObjects.getValue(objects, RadarChart.Properties.labels.precision, dataLabelsSettings.precision),\n                fontSize: DataViewObjects.getValue(objects, RadarChart.Properties.labels.fontSize, dataLabelsSettings.fontSize),\n                position: dataLabelsSettings.position\n            };\n\n            return labelsObj;\n        }\n\n        // This function returns the values to be displayed in the property pane for each object.\n        // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do\n        // validation and return other values/defaults\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\n            let enumeration = new ObjectEnumerationBuilder();\n            let settings: RadarChartSettings;\n\n            if (!this.radarChartData || !this.radarChartData.settings)\n                return [];\n\n            settings = this.radarChartData.settings;\n\n            switch (options.objectName) {\n                case \"legend\":\n                    enumeration.pushInstance(this.enumerateLegend(settings));\n                    break;\n                case \"dataPoint\":\n                    this.enumerateDataPoint(enumeration);\n                    break;\n                case 'labels':\n                    this.enumerateDataLabels(enumeration);\n                    break;\n            }\n\n            return enumeration.complete();\n        }\n\n        private getLabelSettingsOptions(enumeration: ObjectEnumerationBuilder, labelSettings: PointDataLabelsSettings): VisualDataLabelsSettingsOptions {\n            return {\n                enumeration: enumeration,\n                dataLabelsSettings: labelSettings,\n                show: true,\n                displayUnits: true,\n                precision: true,\n                fontSize: true,\n            };\n        }\n\n        private enumerateDataLabels(enumeration: ObjectEnumerationBuilder): void {\n            let labelSettings = this.radarChartData.dataLabelsSettings;\n           \n            //Draw default settings\n            dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings));\n        }\n\n        private enumerateLegend(settings: RadarChartSettings): VisualObjectInstance {\n            let showTitle: boolean = true,\n                titleText: string = \"\",\n                legend: VisualObjectInstance,\n                labelColor: DataColorPalette,\n                fontSize: number = 8;\n\n            showTitle = DataViewObject.getValue(this.legendObjectProperties, legendProps.showTitle, showTitle);\n            titleText = DataViewObject.getValue(this.legendObjectProperties, legendProps.titleText, titleText);\n            labelColor = DataViewObject.getValue(this.legendObjectProperties, legendProps.labelColor, labelColor);\n            fontSize = DataViewObject.getValue(this.legendObjectProperties, legendProps.fontSize, fontSize);\n            legend = {\n                objectName: \"legend\",\n                displayName: \"legend\",\n                selector: null,\n                properties: {\n                    show: settings.showLegend,\n                    position: LegendPosition[this.legend.getOrientation()],\n                    showTitle: showTitle,\n                    titleText: titleText,\n                    labelColor: labelColor,\n                    fontSize: fontSize,\n                }\n            };\n\n            return legend;\n        }\n\n        private enumerateDataPoint(enumeration: ObjectEnumerationBuilder): void {\n            if (!this.radarChartData || !this.radarChartData.series)\n                return;\n\n            let series: RadarChartSeries[] = this.radarChartData.series;\n\n            for (let serie of series) {\n                enumeration.pushInstance({\n                    objectName: \"dataPoint\",\n                    displayName: serie.name,\n                    selector: ColorHelper.normalizeSelector(serie.identity.getSelector(), false),\n                    properties: {\n                        fill: { solid: { color: serie.fill } }\n                    }\n                });\n            }\n        }\n\n        private updateViewport(): void {\n            let legendMargins: IViewport = this.legend.getMargins(),\n                legendPosition: LegendPosition;\n\n            legendPosition = LegendPosition[<string>this.legendObjectProperties[legendProps.position]];\n\n            switch (legendPosition) {\n                case LegendPosition.Top:\n                case LegendPosition.TopCenter:\n                case LegendPosition.Bottom:\n                case LegendPosition.BottomCenter:\n                    this.viewport.height -= legendMargins.height;\n                    break;\n\n                case LegendPosition.Left:\n                case LegendPosition.LeftCenter:\n                case LegendPosition.Right:\n                case LegendPosition.RightCenter:\n                    this.viewport.width -= legendMargins.width;\n                    break;\n            }\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import SelectionManager = utility.SelectionManager;\n    import ValueFormatter = powerbi.visuals.valueFormatter;\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n    import getAnimationDuration = AnimatorCommon.GetAnimationDuration;\n\n    type D3Element =\n        D3.UpdateSelection |\n        D3.Selection |\n        D3.Selectors |\n        D3.Transition.Transition;\n\n    export interface HistogramConstructorOptions {\n        svg?: D3.Selection;\n        animator?: IGenericAnimator;\n        margin?: IMargin;\n    }\n\n    export interface HistogramSettings {\n        displayName?: string;\n        fillColor?: string;\n        frequency: boolean;\n        bins?: number;\n        precision: number;\n    }\n\n    export interface HistogramData extends D3.Layout.Bin, TooltipEnabledDataPoint {\n        range: number[];\n        selectionIds: SelectionId[];\n    }\n\n    export interface HistogramDataView {\n        data: HistogramData[];\n        xScale?: D3.Scale.LinearScale;\n        yScale?: D3.Scale.LinearScale;\n        settings: HistogramSettings;\n        formatter: IValueFormatter;\n    }\n\n    interface HistogramValue {\n        value: number;\n        selectionId: SelectionId;\n        frequency: number;\n    }\n\n    interface Legend {\n        text: string;\n        transform?: string;\n        dx?: string;\n        dy?: string;\n    }\n\n    interface Brackets {\n        left: string;\n        right: string;\n    }\n\n    interface HistogramProperty {\n        [propertyName: string]: DataViewObjectPropertyIdentifier;\n    }\n\n    interface HistogramProperties {\n        [objectName: string]: HistogramProperty;\n    }\n\n    export class HistogramChartWarning {\n        public static ErrorInvalidDataValues: string = \"Some data values are invalid or too big\";\n\n        private message: string;\n        constructor(message: string) {\n            this.message = message;\n        }\n\n        public get code(): string {\n            return \"BulletChartWarning\";\n        }\n\n        public getMessages(resourceProvider: jsCommon.IStringResourceProvider): IVisualErrorMessage {\n            return {\n                message: this.message,\n                title: resourceProvider.get(\"\"),\n                detail: resourceProvider.get(\"\")\n            };\n        }\n    }\n\n    export class Histogram implements IVisual {\n        private static ClassName: string = \"histogram\";\n        private static FrequencyText: string = \"Frequency\";\n        private static DensityText: string = \"Density\";\n\n        private static Properties: HistogramProperties = {\n            general: {\n                bins: {\n                    objectName: \"general\",\n                    propertyName: \"bins\"\n                },\n                frequency: {\n                    objectName: \"general\",\n                    propertyName: \"frequency\"\n                },\n                formatString: {\n                    objectName: \"general\",\n                    propertyName: \"formatString\"\n                }\n            },\n            dataPoint: {\n                fill: {\n                    objectName: \"dataPoint\",\n                    propertyName: \"fill\"\n                }\n            },\n            labels: {\n                labelPrecision: {\n                    objectName: \"labels\",\n                    propertyName: \"labelPrecision\"\n                }\n            }\n        };\n\n        private static DefaultHistogramSettings: HistogramSettings = {\n            frequency: true,\n            displayName: \"Histogram\",\n            bins: null,\n            fillColor: \"cadetblue\",\n            precision: 2\n        };\n\n        private static Axes: ClassAndSelector = {\n            \"class\": \"axes\",\n            selector: \".axes\"\n        };\n\n        private static Axis: ClassAndSelector = {\n            \"class\": \"axis\",\n            selector: \".axis\"\n        };\n\n        private static Columns: ClassAndSelector = {\n            \"class\": \"columns\",\n            selector: \".columns\"\n        };\n\n        private static Column: ClassAndSelector = {\n            \"class\": \"column\",\n            selector: \".column\"\n        };\n\n        private static Legends: ClassAndSelector = {\n            \"class\": \"legends\",\n            selector: \".legends\"\n        };\n\n        private static Legend: ClassAndSelector = {\n            \"class\": \"legend\",\n            selector: \".legend\"\n        };\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [{\n                name: \"Values\",\n                kind: VisualDataRoleKind.Grouping,\n                displayName: data.createDisplayNameGetter(\"Role_DisplayName_Values\")\n            }, {\n                name: \"Frequency\",\n                kind: VisualDataRoleKind.Measure,\n                displayName: \"Frequency\"\n            }],\n            dataViewMappings: [{\n                conditions: [{ \"Values\": { min: 1, max: 1 }, \"Frequency\": { min: 0, max: 1 } }],\n                categorical: {\n                    categories: {\n                        bind: { to: \"Values\" },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: { for: { in: \"Frequency\" } }\n                }\n            }],\n            sorting: {\n                implicit: {\n                    clauses: [{ role: \"Values\", direction: 1 /*SortDirection.Ascending*/ }] //Constant SortDirection.Ascending currently is not supported on the msit\n                }\n            },\n            objects: {\n                general: {\n                    displayName: data.createDisplayNameGetter(\"Visual_General\"),\n                    properties: {\n                        formatString: { type: { formatting: { formatString: true } } },\n                        bins: {\n                            displayName: \"Bins\",\n                            type: { numeric: true }\n                        },\n                        frequency: {\n                            displayName: \"Frequency\",\n                            type: { bool: true }\n                        }\n                    },\n                },\n                dataPoint: {\n                    displayName: data.createDisplayNameGetter(\"Visual_DataPoint\"),\n                    properties: {\n                        fill: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                },\n                labels: {\n                    displayName: data.createDisplayNameGetter('Visual_DataPointsLabels'),\n                    properties: {\n                        labelPrecision: {\n                            displayName: data.createDisplayNameGetter('Visual_Precision'),\n                            type: { numeric: true }\n                        }\n                    }\n                }\n            }\n        };\n\n        private ColumnPadding: number = 1;\n        private MinColumnHeight: number = 1;\n        private MinOpacity: number = 0.3;\n        private MaxOpacity: number = 1;\n        private NumberOfLabelsOnAxisY: number = 5;\n        private MinNumberOfBins: number = 0;\n        private MaxNumberOfBins: number = 100;\n        private MinPrecision: number = 0;\n        private MaxPrecision: number = 17; // max number of decimals in float\n        private TooltipDisplayName: string = \"Range\";\n        private SeparatorNumbers: string = \", \";\n        private LegendSize: number = 50;\n        private AxisSize: number = 30;\n\n        private ExcludeBrackets: Brackets = {\n            left: \"(\",\n            right: \")\"\n        };\n\n        private IncludeBrackets: Brackets = {\n            left: \"[\",\n            right: \"]\"\n        };\n\n        private margin: IMargin = {\n            top: 10,\n            right: 10,\n            bottom: 10,\n            left: 10\n        };\n\n        private durationAnimations: number = 200;\n\n        private viewport: IViewport;\n        private hostService: IVisualHostServices;\n        private selectionManager: SelectionManager;\n        private colors: IDataColorPalette;\n\n        private root: D3.Selection;\n        private svg: D3.Selection;\n        private main: D3.Selection;\n        private axes: D3.Selection;\n        private axisX: D3.Selection;\n        private axisY: D3.Selection;\n        private legend: D3.Selection;\n        private columns: D3.Selection;\n\n        private histogramDataView: HistogramDataView;\n\n        private animator: IGenericAnimator;\n\n        private get columnsSelection(): D3.Selection {\n            return this.main.select(Histogram.Columns.selector)\n                .selectAll(Histogram.Column.selector);\n        }\n\n        constructor(histogramConstructorOptions?: HistogramConstructorOptions) {\n            if (histogramConstructorOptions) {\n                if (histogramConstructorOptions.svg) {\n                    this.svg = histogramConstructorOptions.svg;\n                }\n\n                if (histogramConstructorOptions.animator) {\n                    this.animator = histogramConstructorOptions.animator;\n                }\n\n                this.margin = histogramConstructorOptions.margin || this.margin;\n            }\n        }\n\n        public init(visualsOptions: VisualInitOptions): void {\n            this.hostService = visualsOptions.host;\n\n            if (this.svg) {\n                this.root = this.svg;\n            } else {\n                this.root = d3.select(visualsOptions.element.get(0))\n                    .append(\"svg\");\n            }\n\n            var style: IVisualStyle = visualsOptions.style;\n\n            this.colors = style && style.colorPalette\n                ? style.colorPalette.dataColors\n                : new DataColorPalette();\n\n            this.root.classed(Histogram.ClassName, true);\n\n            this.main = this.root.append(\"g\");\n\n            this.axes = this.main\n                .append(\"g\")\n                .classed(Histogram.Axes[\"class\"], true);\n\n            this.axisX = this.axes\n                .append(\"g\")\n                .classed(Histogram.Axis[\"class\"], true);\n\n            this.axisY = this.axes\n                .append(\"g\")\n                .classed(Histogram.Axis[\"class\"], true);\n\n            this.legend = this.main\n                .append(\"g\")\n                .classed(Histogram.Legends[\"class\"], true);\n\n            this.columns = this.main\n                .append(\"g\")\n                .classed(Histogram.Columns[\"class\"], true);\n\n            this.selectionManager = new SelectionManager({ hostServices: visualsOptions.host });\n        }\n\n        public converter(dataView: DataView): HistogramDataView {\n            if (!dataView ||\n                !dataView.categorical ||\n                !dataView.categorical.categories ||\n                !dataView.categorical.categories[0] ||\n                !dataView.categorical.categories[0].values ||\n                !(dataView.categorical.categories[0].values.length > 0)) {\n                return null;\n            }\n\n            var settings: HistogramSettings,\n                histogramLayout: D3.Layout.HistogramLayout,\n                values: HistogramValue[],\n                numericalValues: number[] = [],\n                data: D3.Layout.Bin[],\n                xScale: D3.Scale.LinearScale,\n                yScale: D3.Scale.LinearScale,\n                valueFormatter: IValueFormatter,\n                frequencies: number[] = [],\n                identities: DataViewScopeIdentity[] = [],\n                shiftByValues: number = 0,\n                sumFrequency: number = 0;\n\n            if (dataView.categorical.values &&\n                dataView.categorical.values[0] &&\n                dataView.categorical.values[0].values) {\n                frequencies = dataView.categorical.values[0].values;\n            }\n\n            if (dataView.categorical.categories[0].identity\n                && dataView.categorical.categories[0].identity.length > 0) {\n                identities = dataView.categorical.categories[0].identity;\n            }\n\n            settings = this.parseSettings(dataView);\n\n            if (!settings) {\n                return null;\n            }\n\n            values = this.getValuesByFrequencies(\n                dataView.categorical.categories[0].values,\n                frequencies,\n                identities);\n\n            values.forEach((value: HistogramValue) => {\n                numericalValues.push(value.value);\n\n                sumFrequency += value.frequency;\n            });\n\n            histogramLayout = d3.layout.histogram();\n\n            if (settings.bins && settings.bins > this.MinNumberOfBins) {\n                histogramLayout = histogramLayout.bins(settings.bins);\n            }\n\n            data = histogramLayout.frequency(settings.frequency)(numericalValues);\n\n            data.forEach((bin: D3.Layout.Bin, index: number) => {\n                var filteredValues: HistogramValue[],\n                    frequency: number;\n\n                filteredValues = values.filter((value: HistogramValue) => {\n                    return this.isValueContainedInRange(value, bin, index);\n                });\n\n                frequency = filteredValues.reduce((previousValue: number, currentValue: HistogramValue): number => {\n                    return previousValue + currentValue.frequency;\n                }, 0);\n\n                bin.y = settings.frequency\n                    ? frequency\n                    : frequency / sumFrequency;\n\n                shiftByValues += bin.length;\n            });\n\n            xScale = d3.scale.linear()\n                .domain([\n                    d3.min(data, (item: D3.Layout.Bin) => d3.min(item)),\n                    d3.max(data, (item: D3.Layout.Bin) => d3.max(item))\n                ])\n                .range([0, this.viewport.width - this.LegendSize - this.AxisSize]);\n\n            yScale = d3.scale.linear()\n                .domain([\n                    0,\n                    d3.max(data, (item: D3.Layout.Bin) => item.y)\n                ])\n                .range([this.viewport.height - this.LegendSize, 0]);\n\n            valueFormatter = ValueFormatter.create({\n                format: ValueFormatter.getFormatString(\n                    dataView.categorical.categories[0].source, Histogram.Properties[\"general\"][\"formatString\"]),\n                value: values[0].value,\n                value2: values[values.length - 1].value,\n                precision: settings.precision\n            });\n\n            return {\n                xScale: xScale,\n                yScale: yScale,\n                settings: settings,\n                data: this.getData(values, numericalValues, data, settings, valueFormatter),\n                formatter: valueFormatter\n            };\n        }\n\n        private getValuesByFrequencies(sourceValues: number[], frequencies: number[], identities: DataViewScopeIdentity[]): HistogramValue[] {\n            var values: HistogramValue[] = [];\n\n            sourceValues.forEach((item: number, index: number) => {\n                var frequency: number = 1,\n                    value: number = Number(item);\n\n                value = isNaN(value) ? 0 : value;\n\n                if (frequencies\n                    && frequencies[index]\n                    && !isNaN(frequencies[index])\n                    && frequencies[index] > 1) {\n                    frequency = frequencies[index];\n                }\n\n                values.push({\n                    value: value,\n                    frequency: frequency,\n                    selectionId: SelectionId.createWithId(identities[index])\n                });\n            });\n\n            return values;\n        }\n\n        private getData(\n            values: HistogramValue[],\n            numericalValues: number[],\n            data: D3.Layout.Bin[],\n            settings: HistogramSettings,\n            valueFormatter: IValueFormatter): HistogramData[] {\n            var minValue: number = d3.min(numericalValues),\n                maxValue: number = d3.max(numericalValues);\n\n            return data.map((bin: HistogramData, index: number): HistogramData => {\n                bin.range = this.getRange(minValue, maxValue, bin.dx, index);\n                bin.tooltipInfo = this.getTooltipData(bin.y, bin.range, settings, index === 0, valueFormatter);\n                bin.selectionIds = this.getSelectionIds(values, bin, index);\n\n                return bin;\n            });\n        }\n\n        private getRange(minValue: number, maxValue: number, step: number, index: number): number[] {\n            var leftBorder: number = minValue + index * step,\n                rightBorder: number = leftBorder + step;\n\n            return [leftBorder, rightBorder];\n        }\n\n        private getTooltipData(\n            value: number,\n            range: number[],\n            settings: HistogramSettings,\n            includeLeftBorder: boolean,\n            valueFormatter: IValueFormatter): TooltipDataItem[] {\n\n            return [{\n                displayName: this.getLegendText(settings),\n                value: valueFormatter.format(value)\n            }, {\n                displayName: this.TooltipDisplayName,\n                value: this.rangeToString(range, includeLeftBorder, valueFormatter)\n            }];\n        }\n\n        private getSelectionIds(values: HistogramValue[], bin: HistogramData, index: number): SelectionId[] {\n            var selectionIds: SelectionId[] = [];\n\n            values.forEach((value: HistogramValue) => {\n                if (this.isValueContainedInRange(value, bin, index)) {\n                    selectionIds.push(value.selectionId);\n                }\n            });\n\n            return selectionIds;\n        }\n\n        private isValueContainedInRange(value: HistogramValue, bin: D3.Layout.Bin, index: number): boolean {\n            return ((index === 0 && value.value >= bin.x) || (value.value > bin.x)) && value.value <= bin.x + bin.dx;\n        }\n\n        private parseSettings(dataView: DataView): HistogramSettings {\n            if (!dataView ||\n                !dataView.metadata ||\n                !dataView.metadata.columns ||\n                !dataView.metadata.columns[0]) {\n                return null;\n            }\n\n            var histogramSettings: HistogramSettings = <HistogramSettings>{},\n                objects: DataViewObjects,\n                colorHelper: ColorHelper;\n\n            colorHelper = new ColorHelper(\n                this.colors,\n                Histogram.Properties[\"dataPoint\"][\"fill\"],\n                Histogram.DefaultHistogramSettings.fillColor);\n\n            histogramSettings.displayName = Histogram.DefaultHistogramSettings.displayName;\n            histogramSettings.fillColor = Histogram.DefaultHistogramSettings.fillColor;\n            histogramSettings.bins = Histogram.DefaultHistogramSettings.bins;\n            histogramSettings.frequency = Histogram.DefaultHistogramSettings.frequency;\n            histogramSettings.displayName =\n                dataView.metadata.columns[0].displayName || Histogram.DefaultHistogramSettings.displayName;\n\n            objects = this.getObjectsFromDataView(dataView);\n\n            if (objects) {\n                histogramSettings.fillColor = colorHelper.getColorForMeasure(objects, \"\");\n                histogramSettings.bins = this.getBins(objects);\n                histogramSettings.frequency = this.getFrequency(objects);\n                histogramSettings.precision = this.getPrecision(objects);\n            }\n\n            return histogramSettings;\n        }\n\n        private getBins(objects: DataViewObjects): number {\n            var binsNumber: number;\n\n            binsNumber = Number(DataViewObjects.getValue<number>(\n                objects,\n                Histogram.Properties[\"general\"][\"bins\"],\n                Histogram.DefaultHistogramSettings.bins));\n\n            if (!binsNumber || isNaN(binsNumber) || binsNumber <= this.MinNumberOfBins) {\n                return Histogram.DefaultHistogramSettings.bins;\n            }\n\n            if (binsNumber > this.MaxNumberOfBins) {\n                return this.MaxNumberOfBins;\n            }\n\n            return binsNumber;\n        }\n\n        private getFrequency(objects: DataViewObjects): boolean {\n            return DataViewObjects.getValue<boolean>(\n                objects,\n                Histogram.Properties[\"general\"][\"frequency\"],\n                Histogram.DefaultHistogramSettings.frequency);\n        }\n\n        private getPrecision(objects: DataViewObjects): number {\n            var precision: number = DataViewObjects.getValue(\n                objects,\n                Histogram.Properties[\"labels\"][\"labelPrecision\"],\n                Histogram.DefaultHistogramSettings.precision);\n\n            if (precision <= this.MinPrecision) {\n                return this.MinPrecision;\n            }\n\n            if (precision >= this.MaxPrecision) {\n                return this.MaxPrecision;\n            }\n\n            return precision;\n        }\n\n        public validateData(data: HistogramDataView): boolean {\n            if (data && data.data.some(x=> x.range.some(x => isNaN(x) || x === Infinity || x === -Infinity))) {\n                this.hostService.setWarnings([new HistogramChartWarning(HistogramChartWarning.ErrorInvalidDataValues)]);\n                return false;\n            }\n\n            return true;\n        }\n\n        public update(visualUpdateOptions: VisualUpdateOptions): void {\n            if (!visualUpdateOptions ||\n                !visualUpdateOptions.dataViews ||\n                !visualUpdateOptions.dataViews[0]) {\n                return;\n            }\n\n            var dataView: DataView = visualUpdateOptions.dataViews[0];\n\n            this.durationAnimations = getAnimationDuration(\n                this.animator,\n                visualUpdateOptions.suppressAnimations);\n\n            this.setSize(visualUpdateOptions.viewport);\n\n            this.histogramDataView = this.converter(dataView);\n            if (!this.validateData(this.histogramDataView)) {\n                this.histogramDataView.data = [];\n            }\n\n            this.render();\n        }\n\n        private setSize(viewport: IViewport): void {\n            var height: number,\n                width: number;\n\n            height = viewport.height -\n                this.margin.top -\n                this.margin.bottom;\n\n            width = viewport.width -\n                this.margin.left -\n                this.margin.right;\n\n            this.viewport = {\n                height: height,\n                width: width\n            };\n\n            this.updateElements(viewport.height, viewport.width);\n        }\n\n        private updateElements(height: number, width: number): void {\n            var shiftToRight: number = this.margin.left + this.LegendSize;\n\n            this.root.attr({\n                \"height\": height,\n                \"width\": width\n            });\n\n            this.main.attr(\"transform\", SVGUtil.translate(this.margin.left, this.margin.top));\n\n            this.legend.attr(\"transform\", SVGUtil.translate(this.margin.left, this.margin.top));\n\n            this.columns.attr(\"transform\", SVGUtil.translate(shiftToRight, 0));\n\n            this.axes.attr(\"transform\", SVGUtil.translate(shiftToRight, 0));\n\n            this.axisX.attr(\n                \"transform\",\n                SVGUtil.translate(0, this.viewport.height - this.LegendSize));\n        }\n\n        private render(): void {\n            if (!this.histogramDataView || !this.histogramDataView.settings) {\n                return;\n            }\n\n            this.renderAxes();\n            var columnsSelection: D3.UpdateSelection = this.renderColumns();\n            this.renderLegend();\n\n            this.bindSelectionHandler(columnsSelection);\n        }\n\n        private renderColumns(): D3.UpdateSelection {\n            var data: HistogramData[] = this.histogramDataView.data,\n                yScale: D3.Scale.LinearScale = this.histogramDataView.yScale,\n                countOfValues: number = data.length,\n                widthOfColumn: number,\n                updateColumnsSelection: D3.UpdateSelection;\n\n            widthOfColumn = countOfValues && ((this.viewport.width - this.AxisSize - this.LegendSize) / countOfValues - this.ColumnPadding);\n\n            if (widthOfColumn < 0) {\n                widthOfColumn = 0;\n            }\n\n            updateColumnsSelection = this.columnsSelection.data(data);\n\n            updateColumnsSelection\n                .enter()\n                .append(\"svg:rect\");\n\n            updateColumnsSelection\n                .attr(\"x\", this.ColumnPadding / 2)\n                .attr(\"width\", widthOfColumn)\n                .attr(\"height\", (item: HistogramData) => this.getColumnHeight(item, yScale))\n                .style(\"fill\", this.histogramDataView.settings.fillColor)\n                .attr(\"class\", Histogram.Column[\"class\"])\n                .attr(\"transform\", (item: HistogramData, index: number) => SVGUtil.translate(\n                    widthOfColumn * index + this.ColumnPadding * index,\n                    yScale(item.y) - this.ColumnPadding / 2.5));\n\n            if (countOfValues) {\n                //if data is empty, it throws for some reason\n                updateColumnsSelection.classed(Histogram.Column[\"class\"]);\n            }\n\n            updateColumnsSelection.exit().remove();\n\n            this.renderTooltip(updateColumnsSelection);\n\n            return updateColumnsSelection;\n        }\n\n        private renderTooltip(selection: D3.UpdateSelection): void {\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) => {\n                return (<HistogramData> tooltipEvent.data).tooltipInfo;\n            });\n        }\n\n        private getColumnHeight(column: D3.Layout.Bin, y: D3.Scale.LinearScale): number {\n            var height: number = this.viewport.height - this.LegendSize - y(column.y);\n\n            return height > 0 ? height : this.MinColumnHeight;\n        }\n\n        private renderAxes(): void {\n            var xScale: D3.Scale.LinearScale = this.histogramDataView.xScale,\n                yScale: D3.Scale.LinearScale = this.histogramDataView.yScale,\n                valueFormatter: IValueFormatter = this.histogramDataView.formatter,\n                xAxis: D3.Svg.Axis,\n                yAxis: D3.Svg.Axis;\n\n            xAxis = d3.svg.axis()\n                .scale(xScale)\n                .orient(\"bottom\")\n                .tickValues(this.rangesToArray(this.histogramDataView.data))\n                .tickFormat((item: number) => valueFormatter.format(item));\n\n            yAxis = d3.svg.axis()\n                .scale(yScale)\n                .orient(\"left\")\n                .ticks(this.NumberOfLabelsOnAxisY);\n\n            this.axisX.call(xAxis);\n\n            this.axisY.call(yAxis);\n        }\n\n        private rangesToArray(data: HistogramData[]): number[] {\n            return data.reduce((previousValue: number[], currentValue: HistogramData, index: number) => {\n                var range: number[];\n\n                range = index === 0\n                    ? currentValue.range\n                    : currentValue.range.slice(1);\n\n                return previousValue.concat(range);\n            }, []);\n        }\n\n        private rangeToString(range: number[], includeLeftBorder: boolean, valueFormatter: IValueFormatter): string {\n            var leftBracket: string,\n                rightBracket: string = this.IncludeBrackets.right,\n                leftBorder: string = valueFormatter.format(range[0]),\n                rightBorder: string = valueFormatter.format(range[1]);\n\n            leftBracket = includeLeftBorder\n                ? this.IncludeBrackets.left\n                : this.ExcludeBrackets.left;\n\n            return `${leftBracket}${leftBorder}${this.SeparatorNumbers}${rightBorder}${rightBracket}`;\n        }\n\n        private renderLegend(): void {\n            var legendElements: D3.Selection,\n                legendSelection: D3.UpdateSelection,\n                datalegends: Legend[] = this.getDataLegends(this.histogramDataView.settings);\n\n            legendElements = this.main\n                .select(Histogram.Legends.selector)\n                .selectAll(Histogram.Legend.selector);\n\n            legendSelection = legendElements.data(datalegends);\n\n            legendSelection\n                .enter()\n                .append(\"svg:text\");\n\n            legendSelection\n                .attr(\"x\", 0)\n                .attr(\"y\", 0)\n                .attr(\"dx\", (item: Legend) => item.dx)\n                .attr(\"dy\", (item: Legend) => item.dy)\n                .attr(\"transform\", (item: Legend) => item.transform)\n                .attr(\"class\", Histogram.Legend[\"class\"])\n                .text((item: Legend) => item.text)\n                .classed(Histogram.Legend[\"class\"], true);\n\n            legendSelection\n                .exit()\n                .remove();\n        }\n\n        private getDataLegends(settings: HistogramSettings): Legend[] {\n            var bottomLegendText: string = this.getLegendText(settings);\n\n            return [{\n                transform: SVGUtil.translate(\n                    this.viewport.width / 2,\n                    this.viewport.height),\n                text: settings.displayName,\n                dx: \"1em\",\n                dy: \"-1em\"\n            }, {\n                transform: SVGUtil.translateAndRotate(\n                    0,\n                    this.viewport.height / 2,\n                    0,\n                    0,\n                    270),\n                text: bottomLegendText,\n                dx: \"3em\"\n            }];\n        }\n\n        private getLegendText(settings: HistogramSettings): string {\n            return settings.frequency\n                ? Histogram.FrequencyText\n                : Histogram.DensityText;\n        }\n\n        private bindSelectionHandler(columnsSelection: D3.UpdateSelection): void {\n            this.setSelection(columnsSelection);\n\n            columnsSelection.on(\"click\", (data: HistogramData) => {\n                this.selectionManager.clear();\n\n                data.selectionIds.forEach((selectionId: SelectionId) => {\n                    this.selectionManager.select(selectionId, true).then((selectionIds: SelectionId[]) => {\n                        if (selectionIds.length > 0) {\n                            this.setSelection(columnsSelection, data);\n                        } else {\n                            this.setSelection(columnsSelection);\n                        }\n                    });\n                });\n\n                d3.event.stopPropagation();\n            });\n\n            this.root.on(\"click\", () => {\n                this.selectionManager.clear();\n                this.setSelection(columnsSelection);\n            });\n        }\n\n        private setSelection(columnsSelection: D3.UpdateSelection, data?: HistogramData): void {\n            columnsSelection.transition()\n                .duration(this.durationAnimations)\n                .style(\"fill-opacity\", this.MaxOpacity);\n\n            if (!data) {\n                return;\n            }\n\n            columnsSelection\n                .filter((columnSelection: HistogramData) => {\n                    return columnSelection !== data;\n                })\n                .transition()\n                .duration(this.durationAnimations)\n                .style(\"fill-opacity\", this.MinOpacity);\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\n            var instances: VisualObjectInstance[] = [],\n                settings: HistogramSettings;\n\n            if (!this.histogramDataView ||\n                !this.histogramDataView.settings) {\n                return instances;\n            }\n\n            settings = this.histogramDataView.settings;\n\n            switch (options.objectName) {\n                case \"general\": {\n                    var general: VisualObjectInstance = {\n                        objectName: \"general\",\n                        displayName: \"general\",\n                        selector: null,\n                        properties: {\n                            bins: settings.bins,\n                            frequency: settings.frequency\n                        }\n                    };\n\n                    instances.push(general);\n                    break;\n                }\n                case \"dataPoint\": {\n                    var dataPoint: VisualObjectInstance = {\n                        objectName: \"dataPoint\",\n                        displayName: \"dataPoint\",\n                        selector: null,\n                        properties: {\n                            fill: settings.fillColor\n                        }\n                    };\n\n                    instances.push(dataPoint);\n                    break;\n                }\n                case \"labels\": {\n                    var labels: VisualObjectInstance = {\n                        objectName: \"labels\",\n                        displayName: \"labels\",\n                        selector: null,\n                        properties: {\n                            labelPrecision: settings.precision\n                        }\n                    };\n\n                    instances.push(labels);\n                    break;\n                }\n            }\n\n            return instances;\n        }\n\n        private getObjectsFromDataView(dataView: DataView): DataViewObjects {\n            if (!dataView ||\n                !dataView.metadata ||\n                !dataView.metadata.columns ||\n                !dataView.metadata.objects) {\n                    return null;\n            }\n\n            return dataView.metadata.objects;\n        }\n\n        public destroy(): void {\n            this.root = null;\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import ValueFormatter = powerbi.visuals.valueFormatter;\n    \n    export interface ColorBarChartData {\n        category: string;\n        value: number;\n        color: string;\n    }\n    \n    export interface ColorBarChartDataView {\n        values: ColorBarChartData[];\n    }\n\n    export class ColorBarChart implements IVisual {\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [{\n                displayName: 'Values',\n                name: 'Values',\n                kind: VisualDataRoleKind.GroupingOrMeasure\n            }],\n            dataViewMappings: [{\n                table: {\n                    rows: {\n                        for: { in: 'Values' },\n                        dataReductionAlgorithm: { window: { count: 100 } }\n                    },\n                    rowCount: { preferred: { min: 1 } }\n                },\n            }],\n            objects: {\n                general: {\n                    displayName: data.createDisplayNameGetter('Visual_General'),\n                    properties: {\n                        fill: {\n                            type: { fill: { solid: { color: true } } },\n                            displayName: 'Fill'\n                        },\n                        size: {\n                            type: { numeric: true },\n                            displayName: 'Size'\n                        }\n                    },\n                }\n            },\n        };\n\n        private viewport: IViewport;\n        private root: D3.Selection;\n        private main: D3.Selection;\n        private dataView: DataView;\n        private NumberOfLabelsOnAxisY: number = 5;\n        private axes: D3.Selection;\n        private axisX: D3.Selection;\n        private axisY: D3.Selection;\n        private xAxis: D3.Svg.Axis;\n        private yAxis: D3.Svg.Axis;\n        private columns: D3.Selection;\n        private valueFormatter: IValueFormatter;\n        private xScale: D3.Scale.OrdinalScale;\n        private yScale: D3.Scale.LinearScale;\n        \n        private margin: IMargin = {\n            top: 10,\n            right: 10,\n            bottom: 20,\n            left: 40\n        };\n\n        public static converter(dataView: DataView): ColorBarChartDataView {\n            var viewModel: ColorBarChartDataView = {\n                values: []\n            };\n            var table = dataView.table;\n            if (!table) return viewModel;\n            \n            for (var row of table.rows) {\n                var chartData: ColorBarChartData = {\n                    category: row[0],\n                    value: row[1],\n                    color: row[2]\n                };\n                viewModel.values.push(chartData);\n            }\n\n            return viewModel;\n        }\n\n        public init(options: VisualInitOptions): void {\n            this.root = d3.select(options.element.get(0))\n                .append('svg')\n                .classed('colorBarChart', true);\n                \n            this.main = this.root.append('g');\n            \n            this.axes = this.main\n                .append(\"g\")\n                .classed(\"axes\", true);\n\n            this.axisX = this.axes\n                .append(\"g\")\n                .classed(\"axis\", true);\n\n            this.axisY = this.axes\n                .append(\"g\")\n                .classed(\"axis\", true);\n        }\n\n        public update(options: VisualUpdateOptions) {\n            if (!options.dataViews && !options.dataViews[0]) return;\n            var dataView = this.dataView = options.dataViews[0];\n            var viewModel: ColorBarChartDataView = ColorBarChart.converter(dataView);\n            \n            this.valueFormatter = ValueFormatter.create({\n                value: viewModel.values[0].value,\n                value2: viewModel.values[viewModel.values.length - 1].value\n            });\n\n            this.viewport = options.viewport;\n            \n            this.setSize(options.viewport);\n        \n            this.renderAxes(viewModel);\n            \n            this.renderColumns(viewModel);\n        }\n        \n        private renderAxes(viewModel: ColorBarChartDataView): void {\n            var valueFormatter: IValueFormatter = this.valueFormatter;\n\n            this.xScale = d3.scale.ordinal()\n                        .domain(viewModel.values.map((v: ColorBarChartData) => { return v.category; }))\n                        .rangeRoundBands([0, this.viewport.width], .1);\n\n            this.yScale = d3.scale.linear()\n                      .domain([0, d3.max(viewModel.values.map((v: ColorBarChartData) => { return v.value; }))])\n                      .range([this.viewport.height, 0]);\n\n            this.xAxis = d3.svg.axis()\n                .scale(this.xScale)\n                .orient(\"bottom\")\n                .tickValues(viewModel.values.map((v: ColorBarChartData) => { return v.category; }));\n\n            this.yAxis = d3.svg.axis()\n                .scale(this.yScale)\n                .orient(\"left\")\n                .tickFormat((item: number) => valueFormatter.format(item))\n                .ticks(this.NumberOfLabelsOnAxisY);\n\n            this.axisX.call(this.xAxis);\n\n            this.axisY.call(this.yAxis);\n        }\n        \n        private renderColumns(viewModel: ColorBarChartDataView): void {\n            var self = this;\n            this.columns = this.main.append('g').selectAll('.column')\n                            .data(viewModel.values)\n                            .enter().append('svg:rect')\n                            .attr('class', 'column')\n                            .attr('fill', (item: ColorBarChartData) => { return item.color; })\n                            .attr('x', (item: ColorBarChartData) => this.xScale(item.category))\n                            .attr('y', (item: ColorBarChartData) => this.yScale(item.value))\n                            .attr('width', this.xScale.rangeBand())\n                            .attr('height', (item: ColorBarChartData) => { return self.viewport.height - this.yScale(item.value); });\n        }\n        \n        private setSize(viewport: IViewport): void {\n            var height: number,\n                width: number;\n\n            height = viewport.height -\n                this.margin.top -\n                this.margin.bottom;\n\n            width = viewport.width -\n                this.margin.left -\n                this.margin.right;\n\n            this.viewport = {\n                height: height,\n                width: width\n            };\n\n            this.updateElements(viewport.height, viewport.width);\n        }\n\n        private updateElements(height: number, width: number): void {\n            var shiftToRight: number = 0;\n\n            this.root.attr({\n                \"height\": height,\n                \"width\": width\n            });\n\n            this.main.attr(\"transform\", SVGUtil.translate(this.margin.left, this.margin.top));\n\n            this.axes.attr(\"transform\", SVGUtil.translate(shiftToRight, 0));\n\n            this.axisX.attr(\n                \"transform\",\n                SVGUtil.translate(0, this.viewport.height));\n        }\n\n        private static getFill(dataView: DataView): Fill {\n            if (dataView) {\n                var objects = dataView.metadata.objects;\n                if (objects) {\n                    var general = objects['general'];\n                    if (general) {\n                        var fill = <Fill>general['fill'];\n                        if (fill)\n                            return fill;\n                    }\n                }\n            }\n            return { solid: { color: 'red' } };\n        }\n\n        private static getSize(dataView: DataView): number {\n            if (dataView) {\n                var objects = dataView.metadata.objects;\n                if (objects) {\n                    var general = objects['general'];\n                    if (general) {\n                        var size = <number>general['size'];\n                        if (size)\n                            return size;\n                    }\n                }\n            }\n            return 100;\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\n            var instances: VisualObjectInstance[] = [];\n            var dataView = this.dataView;\n            switch (options.objectName) {\n                case 'general':\n                    var general: VisualObjectInstance = {\n                        objectName: 'general',\n                        displayName: 'General',\n                        selector: null,\n                        properties: {\n                            fill: ColorBarChart.getFill(dataView),\n                            size: ColorBarChart.getSize(dataView)\n                        }\n                    };\n                    instances.push(general);\n                    break;\n            }\n\n            return instances;\n        }\n\n        public destroy(): void {\n            this.root = null;\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n    import getAnimationDuration = AnimatorCommon.GetAnimationDuration;\n    import CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n    import AxisScale = powerbi.visuals.axisScale;\n    import PixelConverter = jsCommon.PixelConverter;\n\n    const MaxXAxisHeight: number = 40;\n    const LabelMargin: number = 15;\n    const DefaultRadius: number = 5;\n    const DefaultStrokeWidth: number = 1;\n    const DefaultDataPointColor = \"#00B8AA\";\n    const MinPrecision: number = 0;\n    const MaxPrecision: number = 17;\n\n    export const DotPlotProperties: any = {\n        general: {\n            formatString: <DataViewObjectPropertyIdentifier>{\n                objectName: \"general\",\n                propertyName: \"formatString\"\n            }\n        },\n        labels: {\n            show: <DataViewObjectPropertyIdentifier>{\n                objectName: \"labels\",\n                propertyName: \"show\"\n            },\n            fontSize: <DataViewObjectPropertyIdentifier>{\n                objectName: \"labels\",\n                propertyName: \"fontSize\"\n            },\n            labelPrecision: <DataViewObjectPropertyIdentifier>{\n                objectName: \"labels\",\n                propertyName: \"labelPrecision\"\n            },\n            labelDisplayUnits: <DataViewObjectPropertyIdentifier>{\n                objectName: \"labels\",\n                propertyName: \"labelDisplayUnits\"\n            },\n            labelColor: <DataViewObjectPropertyIdentifier>{\n                objectName: \"labels\",\n                propertyName: \"labelColor\"\n            }\n        },\n        dataPoint: {\n            fill: <DataViewObjectPropertyIdentifier>{\n                objectName: \"dataPoint\",\n                propertyName: \"fill\"\n            }\n        },\n        categories: {\n            show: <DataViewObjectPropertyIdentifier>{\n                objectName: \"categories\",\n                propertyName: \"show\"\n            },\n            fontColor: <DataViewObjectPropertyIdentifier>{\n                objectName: \"categories\",\n                propertyName: \"fontColor\"\n            },\n            fontSize: <DataViewObjectPropertyIdentifier>{\n                objectName: \"categories\",\n                propertyName: \"fontSize\"\n            }\n        }\n    };\n\n    export interface DotPlotSelectors {\n        svgPlotSelector: ClassAndSelector;\n        plotSelector: ClassAndSelector;\n        plotGroupSelector: ClassAndSelector;\n        axisSelector: ClassAndSelector;\n        xAxisSelector: ClassAndSelector;\n        circleSeletor: ClassAndSelector;\n    }\n\n    export interface DotPlotChartCategory {\n        value: string;\n        selectionId: SelectionId;\n    }\n\n    export interface DotPlotConstructorOptions {\n        animator?: IGenericAnimator;\n        svg?: D3.Selection;\n        margin?: IMargin;\n        radius?: number;\n        strokeWidth?: number;\n    }\n\n    export interface DotPlotDataPoint {\n        x: number;\n        y: number;\n        tooltipInfo: TooltipDataItem[];\n    }\n\n    export interface DotPlotSettings {\n        labelSettings?: VisualDataLabelsSettings;\n        formatter?: IValueFormatter;\n        tooltipFormatter?: IValueFormatter;\n        categorySettings?: DotPlotCategorySettings;\n        defaultDataPointColor?: string;\n    }\n\n    export interface DotPlotCategorySettings {\n        show?: boolean;\n        fontColor?: string;\n        fontSize?: number;\n    }\n\n    export interface DotPlotDataGroup extends SelectableDataPoint {\n        label?: string;\n        value?: number;\n        color?: string;\n        tooltipInfo?: TooltipDataItem[];\n        dataPoints: DotPlotDataPoint[];\n        labelFontSize: string;\n        highlight?: boolean;\n    }\n\n    export interface DotPlotDataView {\n        displayName: string;\n        dataPoints: DotPlotDataGroup[];\n        values: any[];\n        settings: DotPlotSettings;\n        categories: DotPlotChartCategory[];\n    }\n\n    export class DotPlot implements IVisual {\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [{\n                name: 'Category',\n                kind: powerbi.VisualDataRoleKind.Grouping,\n                displayName: 'Category'\n            },\n                {\n                    name: \"Values\",\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Values'\n                }],\n            dataViewMappings: [{\n                conditions: [\n                    { 'Category': { max: 1 }, 'Values': { max: 1 } },\n                ],\n                categorical: {\n                    categories: {\n                        for: { in: 'Category' },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: {\n                        group: {\n                            by: \"Series\",\n                            select: [{ for: { in: \"Values\" } }],\n                            dataReductionAlgorithm: { top: {} }\n                        }\n                    }\n                },\n            }],\n            objects: {\n                general: {\n                    displayName: 'General',\n                    properties: {\n                        formatString: {\n                            type: { formatting: { formatString: true } },\n                        },\n                    },\n                },\n                dataPoint: {\n                    displayName: 'Data colors',\n                    properties: {\n                        fill: {\n                            displayName: 'Fill',\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                },\n                labels: {\n                    displayName: \"Data labels\",\n                    description: 'Display data label options',\n                    properties: {\n                        show: {\n                            displayName: 'Show',\n                            type: { bool: true }\n                        },\n                        showSeries: {\n                            displayName: 'Show',\n                            type: { bool: true }\n                        },\n                        color: {\n                            displayName: 'Color',\n                            description: 'Select color for data labels',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        labelDisplayUnits: {\n                            displayName: 'Display units',\n                            description: 'Select the units (millions, billions, etc.)',\n                            type: { formatting: { labelDisplayUnits: true } },\n                            suppressFormatPainterCopy: true\n                        },\n                        labelPrecision: {\n                            displayName: 'Decimal places',\n                            description: 'Select the number of decimal places to display',\n                            placeHolderText: 'Auto',\n                            type: { numeric: true },\n                            suppressFormatPainterCopy: true\n                        },\n                        showAll: {\n                            displayName: 'Customize series',\n                            type: { bool: true }\n                        },\n                        fontSize: {\n                            displayName: 'Text Size',\n                            type: { formatting: { fontSize: true } }\n                        },\n                    }\n                }\n            }\n        };\n\n        private DefaultMargin: IMargin = {\n            top: 10,\n            bottom: 10,\n            right: 20,\n            left: 20\n        };\n\n        private svg: D3.Selection;\n        private xAxis: D3.Selection;\n        private dotPlot: D3.Selection;\n        private clearCatcher: D3.Selection;\n        private behavior: IInteractiveBehavior;\n\n        private colors: IDataColorPalette;\n        private dataView: DataView;\n        private animator: IGenericAnimator;\n        private durationAnimations: number = 200;\n        private dotPlotDataView: DotPlotDataView;\n\n        private radius: number;\n        private strokeWidth: number;\n        private interactivityService: IInteractivityService;\n        private scaleType: string = AxisScale.linear;\n        private textProperties: TextProperties = {\n            fontFamily: 'wf_segoe-ui_normal',\n            fontSize: jsCommon.PixelConverter.toString(9),\n        };\n\n        private dotPlotSelectors: DotPlotSelectors =\n        {\n            svgPlotSelector: CreateClassAndSelector('dotplot'),\n            plotSelector: CreateClassAndSelector('dotplotSelector'),\n            plotGroupSelector: CreateClassAndSelector('dotplotGroup'),\n            axisSelector: CreateClassAndSelector('axisGraphicsContext'),\n            xAxisSelector: CreateClassAndSelector('x axis'),\n            circleSeletor: CreateClassAndSelector('circleSelector'),\n        };\n\n        private DefaultDotPlotSettings: DotPlotSettings = {\n            labelSettings: {\n                show: true,\n                precision: 2,\n                fontSize: dataLabelUtils.DefaultFontSizeInPt,\n                displayUnits: 0,\n                labelColor: dataLabelUtils.defaultLabelColor,\n            },\n            categorySettings: {\n                show: true,\n                fontColor: LegendData.DefaultLegendLabelFillColor\n            },\n            defaultDataPointColor: DefaultDataPointColor\n        };\n\n        private static getTooltipData(value: number): TooltipDataItem[] {\n            return [{\n                displayName: \"Value\",\n                value: value.toString()\n            }];\n        }\n\n        public static converter(dataView: DataView, scale: D3.Scale.OrdinalScale, defaultMargin: IMargin, defaultSetting: DotPlotSettings, colors: IDataColorPalette, viewport: IViewport, radius: number): DotPlotDataView {\n            let values: DataViewValueColumns = dataView.categorical.values,\n                dataPointsGroup: DotPlotDataGroup[] = [],\n                displayName: string = dataView.categorical.categories[0].source.displayName,\n                objects: DataViewObjects = this.getObjectsFromDataView(dataView),\n                settings: DotPlotSettings,\n                defaultColor = DataViewObjects.getFillColor(objects, DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value);\n\n            let categories: DotPlotChartCategory[] = dataView.categorical.categories[0].values.map((x, i) => <DotPlotChartCategory>{\n                value: x,\n                selectionId: SelectionId.createWithId(dataView.categorical.categories[0].identity[i])\n            });\n\n            settings = {\n                categorySettings: this.getCategorySettings(objects, defaultSetting),\n                defaultDataPointColor: defaultColor,\n                labelSettings: this.parseSettings(objects, defaultSetting)\n            };\n\n            let categoryColumn = dataView.categorical.categories[0];\n            let diameter: number = 2 * radius + 1;\n            let dotsTotalHeight: number = viewport.height - radius - MaxXAxisHeight;\n            let maxDots: number = Math.floor((dotsTotalHeight - defaultMargin.top) / diameter) - 1;\n            let fontSizeInPx: string = PixelConverter.fromPoint(settings.labelSettings.fontSize);\n\n            let yScale: D3.Scale.LinearScale = d3.scale.linear()\n                .domain([0, maxDots])\n                .range([dotsTotalHeight - defaultMargin.bottom, defaultMargin.top + defaultMargin.bottom]);\n\n            for (let value of values) {\n                let min = _.min(value.values);\n                let max = _.max(value.values);\n\n                let color = DataViewObjects.getFillColor(objects, DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value);\n                let length = value.values.length;\n                let minDots = min / (max / maxDots);\n                let dotsScale = d3.scale.log().domain([min, max]).range([minDots === 0 ? 1 : minDots, maxDots]).clamp(true);\n\n                for (let k = 0; k < length; k++) {\n                    let y = dotsScale(value.values[k]);\n                    let dataPoints: DotPlotDataPoint[] = [];\n\n                    for (let level = 0; level < y; level++) {\n                        dataPoints.push({\n                            x: scale(categories[k].value) + scale.rangeBand() / 2,\n                            y: yScale(level),\n                            tooltipInfo: DotPlot.getTooltipData(value.values[k])\n                        });\n                    }\n\n                    let categorySelectionId = SelectionIdBuilder.builder().withCategory(categoryColumn, k).createSelectionId();\n                    let tooltipInfo = DotPlot.getTooltipData(value.values[k]);\n\n                    dataPointsGroup.push({\n                        selected: false,\n                        value: value.values[k],\n                        label: value.values[k],\n                        color: color,\n                        identity: categorySelectionId,\n                        tooltipInfo: tooltipInfo,\n                        dataPoints: dataPoints,\n                        labelFontSize: fontSizeInPx,\n                    });\n                }\n            }\n\n            return {\n                dataPoints: dataPointsGroup,\n                values: dataView.categorical.categories[0].values,\n                displayName: displayName,\n                categories: categories,\n                settings: settings\n            };\n        }\n\n        public constructor(options?: DotPlotConstructorOptions) {\n            if (options) {\n                if (options.svg) {\n                    this.svg = options.svg;\n                }\n                if (options.animator) {\n                    this.animator = options.animator;\n                }\n\n                this.radius = options.radius || DefaultRadius;\n                this.strokeWidth = options.strokeWidth || DefaultStrokeWidth;\n            }\n        }\n\n        public init(options: VisualInitOptions): void {\n            let element = options.element;\n            this.behavior = new DotplotBehavior();\n\n            this.interactivityService = createInteractivityService(options.host);\n            this.radius = DefaultRadius;\n            this.strokeWidth = DefaultStrokeWidth;\n            this.colors = options.style.colorPalette.dataColors;\n\n            this.svg = d3.select(element.get(0)).append('svg').classed(this.dotPlotSelectors.svgPlotSelector.class, true).style('position', 'absolute');\n            this.clearCatcher = appendClearCatcher(this.svg);\n\n            let axisGraphicsContext = this.svg.append('g').classed(this.dotPlotSelectors.axisSelector.class, true);\n            this.dotPlot = this.svg.append('g').classed(this.dotPlotSelectors.plotSelector.class, true);\n            this.xAxis = axisGraphicsContext.append(\"g\").classed(this.dotPlotSelectors.xAxisSelector.class, true);\n        }\n\n        public update(options: VisualUpdateOptions): void {\n            if (!options.dataViews || !options.dataViews[0]) return;\n\n            this.durationAnimations = getAnimationDuration(this.animator, options.suppressAnimations);\n            let dataView = this.dataView = options.dataViews[0];\n            let viewport = options.viewport;\n\n            if (!dataView ||\n                !dataView.categorical ||\n                !dataView.categorical.values ||\n                dataView.categorical.values.length < 1 ||\n                !dataView.categorical ||\n                !dataView.categorical.categories ||\n                !dataView.categorical.categories[0]) {\n                this.clearData();\n                return;\n            }\n\n            let viewportIn: IViewport =\n                {\n                    height: (viewport.height - this.DefaultMargin.top),\n                    width: (viewport.width - this.DefaultMargin.left)\n                };\n\n            this.svg.style({\n                height: PixelConverter.toString(viewport.height),\n                width: PixelConverter.toString(viewport.width)\n            });\n\n            let xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, false);\n            let data = DotPlot.converter(dataView, <D3.Scale.OrdinalScale>xAxisProperties.scale, this.DefaultMargin, this.DefaultDotPlotSettings, this.colors, viewport, this.radius);\n\n            this.dotPlotDataView = data;\n            let dataPoints = data.dataPoints;\n\n            if (this.interactivityService)\n                this.interactivityService.applySelectionStateToData(dataPoints);\n\n            this.renderAxis(viewportIn.height - MaxXAxisHeight, xAxisProperties, data, this.durationAnimations);\n            this.drawDotPlot(dataPoints, data.settings);\n\n            let dataLabelsSettings = data.settings.labelSettings;\n            if (dataLabelsSettings.show) {\n                let layout = this.getEnhanchedDotplotLayout(dataLabelsSettings, viewportIn);\n                dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.svg, layout, viewportIn, !options.suppressAnimations, this.durationAnimations);\n            }\n            else {\n                dataLabelUtils.cleanDataLabels(this.svg);\n            }\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\n            let enumeration = new ObjectEnumerationBuilder();\n\n            switch (options.objectName) {\n                case 'dataPoint':\n                    this.enumerateDataPoints(enumeration, this.dataView);\n                    break;\n                case 'labels':\n                    this.enumerateDataLabels(enumeration, this.dataView);\n                    break;\n                case 'categories':\n                    this.enumerateCategories(enumeration, this.dataView);\n                    break;\n            }\n\n            return enumeration.complete();\n        }\n\n        private static getObjectsFromDataView(dataView: DataView): DataViewObjects {\n            if (!dataView ||\n                !dataView.metadata ||\n                !dataView.metadata.columns ||\n                !dataView.metadata.objects) {\n                return null;\n            }\n\n            return dataView.metadata.objects;\n        }\n\n        private static parseSettings(objects: DataViewObjects, defaultDotPlotSettings: DotPlotSettings): VisualDataLabelsSettings {\n            let precision = this.getPrecision(objects, defaultDotPlotSettings);\n\n            return {\n                show: DataViewObjects.getValue(objects, DotPlotProperties.labels.show, defaultDotPlotSettings.labelSettings.show),\n                precision: precision,\n                fontSize: DataViewObjects.getValue(objects, DotPlotProperties.labels.fontSize, defaultDotPlotSettings.labelSettings.fontSize),\n                displayUnits: DataViewObjects.getValue<number>(objects, DotPlotProperties.labels.labelDisplayUnits, defaultDotPlotSettings.labelSettings.displayUnits),\n                labelColor: DataViewObjects.getFillColor(objects, DotPlotProperties.labels.labelColor, defaultDotPlotSettings.labelSettings.labelColor),\n            };\n        }\n\n        private static getCategorySettings(objects: DataViewObjects, defaultDotPlotSettings: DotPlotSettings): DotPlotCategorySettings {\n            return {\n                show: DataViewObject.getValue<boolean>(objects, DotPlotProperties.categories.show, defaultDotPlotSettings.categorySettings.show),\n                fontColor: DataViewObjects.getFillColor(objects, DotPlotProperties.categories.fontColor, defaultDotPlotSettings.categorySettings.fontColor)\n            };\n        }\n\n        private static getPrecision(objects: DataViewObjects, defaultDotPlotSettings: DotPlotSettings): number {\n            let precision: number = DataViewObjects.getValue<number>(objects, DotPlotProperties.labels.labelPrecision, defaultDotPlotSettings.labelSettings.precision);\n\n            if (precision <= MinPrecision)\n                return MinPrecision;\n\n            if (precision >= MaxPrecision)\n                return MaxPrecision;\n\n            return precision;\n        }\n\n        private drawDotPlot(data: DotPlotDataGroup[], setting: DotPlotSettings): void {\n            let selection: D3.UpdateSelection = this.dotPlot.selectAll(this.dotPlotSelectors.plotGroupSelector.selector).data(data);\n            let hasSelection = this.interactivityService && this.interactivityService.hasSelection();\n\n            selection\n                .enter()\n                .append('g')\n                .attr(\n                {\n                    stroke: \"black\",\n                    \"stroke-width\": this.strokeWidth\n                }).\n                style(\"fill-opacity\", (item: DotPlotDataGroup) => ColumnUtil.getFillOpacity(item.selected, item.highlight, hasSelection, false)).\n                classed(this.dotPlotSelectors.plotGroupSelector.class, true);\n\n            let circleSelection = selection.selectAll(this.dotPlotSelectors.circleSeletor.selector).data((d: DotPlotDataGroup) => { return d.dataPoints; });\n            circleSelection.enter().append('circle')\n                .classed(this.dotPlotSelectors.circleSeletor.class, true);\n\n            circleSelection.attr(\n                {\n                    cx: (point: DotPlotDataPoint) => { return point.x; },\n                    cy: (point: DotPlotDataPoint) => { return point.y; },\n                    r: this.radius,\n                    fill: setting.defaultDataPointColor\n                });\n\n            this.renderTooltip(selection);\n            circleSelection.exit().remove();\n            selection.exit().remove();\n\n            let interactivityService = this.interactivityService;\n            if (interactivityService) {\n                interactivityService.applySelectionStateToData(data);\n\n                let behaviorOptions: DotplotBehaviorOptions = {\n                    columns: selection,\n                    clearCatcher: this.clearCatcher,\n                    interactivityService: this.interactivityService,\n                };\n                interactivityService.bind(data, this.behavior, behaviorOptions);\n            }\n        }\n\n        private getEnhanchedDotplotLayout(labelSettings: VisualDataLabelsSettings, viewport: IViewport): ILabelLayout {\n            let fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize);\n\n            let formatter: IValueFormatter = valueFormatter.create({\n                format: valueFormatter.getFormatString(this.dataView.categorical.categories[0].source, DotPlotProperties.general.formatString),\n                precision: labelSettings.precision,\n                value: labelSettings.displayUnits\n            });\n\n            return {\n                labelText: function (d) {\n                    return dataLabelUtils.getLabelFormattedText({\n                        label: formatter.format(d.label),\n                        fontSize: labelSettings.fontSize,\n                        maxWidth: viewport.width,\n                    });\n                },\n                labelLayout: {\n                    x: (d: DotPlotDataGroup) => d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].x : 0,\n                    y: (d: DotPlotDataGroup) => d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].y - LabelMargin : 0\n                },\n                filter: function (d) {\n                    return (d != null && d.label != null);\n                },\n                style: {\n                    'fill': labelSettings.categoryLabelColor,\n                    'font-size': fontSizeInPx,\n                },\n            };\n        }\n\n        private enumerateDataLabels(enumeration: ObjectEnumerationBuilder, dataView: DataView): void {\n            let objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;\n            enumeration.pushInstance({\n                objectName: \"labels\",\n                displayName: \"Labels\",\n                selector: null,\n                properties: {\n                    show: DataViewObjects.getValue<boolean>(objects, DotPlotProperties.labels.show, this.DefaultDotPlotSettings.labelSettings.show),\n                    fontSize: DataViewObjects.getValue<number>(objects, DotPlotProperties.labels.fontSize, this.DefaultDotPlotSettings.labelSettings.fontSize),\n                    labelPrecision: DataViewObjects.getValue<number>(objects, DotPlotProperties.labels.labelPrecision, this.DefaultDotPlotSettings.labelSettings.precision),\n                    labelDisplayUnits: DataViewObjects.getValue<number>(objects, DotPlotProperties.labels.labelDisplayUnits, this.DefaultDotPlotSettings.labelSettings.displayUnits),\n                    labelColor: DataViewObjects.getFillColor(objects, DotPlotProperties.labels.labelColor, this.DefaultDotPlotSettings.labelSettings.labelColor)\n                }\n            });\n        }\n\n        private enumerateDataPoints(enumeration: ObjectEnumerationBuilder, dataView: DataView): void {\n            let objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;\n            let dataPointColor = DataViewObjects.getFillColor(objects, DotPlotProperties.dataPoint.fill, this.DefaultDotPlotSettings.defaultDataPointColor);\n            enumeration.pushInstance({\n                objectName: \"dataPoint\",\n                displayName: \"Data Points\",\n                selector: null,\n                properties: {\n                    fill: { solid: { color: dataPointColor } }\n                }\n            });\n        }\n\n        private enumerateCategories(enumeration: ObjectEnumerationBuilder, dataView: DataView): void {\n            let objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;\n            let categoriesSettings = DotPlot.getCategorySettings(objects, this.DefaultDotPlotSettings);\n            enumeration.pushInstance({\n                objectName: \"categories\",\n                displayName: \"Categories\",\n                selector: null,\n                properties: {\n                    show: categoriesSettings.show,\n                    fontSize: categoriesSettings.fontSize,\n                    fontColor: categoriesSettings.fontColor\n                }\n            });\n        }\n\n        private clearData(): void {\n            this.dotPlot.selectAll(\"*\").remove();\n            this.xAxis.selectAll(\"*\").remove();\n            dataLabelUtils.cleanDataLabels(this.svg);\n        }\n\n        private renderTooltip(selection: D3.UpdateSelection): void {\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) =>\n                (<DotPlotDataGroup>tooltipEvent.data).tooltipInfo);\n        }\n\n        private calculateAxes(\n            viewportIn: IViewport,\n            textProperties: TextProperties,\n            scrollbarVisible: boolean): IAxisProperties {\n\n            let category = this.dataView.categorical.categories && this.dataView.categorical.categories.length > 0\n                ? this.dataView.categorical.categories[0]\n                : {\n                    source: undefined,\n                    values: [valueFormatter.format(null)],\n                    identity: undefined,\n                };\n\n            let visualOptions: CalculateScaleAndDomainOptions = {\n                viewport: viewportIn,\n                margin: this.DefaultMargin,\n                forcedXDomain: this.dataView.categorical.categories[0].values,\n                forceMerge: false,\n                showCategoryAxisLabel: false,\n                showValueAxisLabel: false,\n                categoryAxisScaleType: this.scaleType,\n                valueAxisScaleType: null,\n                valueAxisDisplayUnits: 0,\n                categoryAxisDisplayUnits: 0,\n                trimOrdinalDataOnOverflow: false,\n            };\n\n            let width = viewportIn.width;\n            let axes = this.calculateAxesProperties(viewportIn, visualOptions, category.source);\n            axes.willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(\n                axes,\n                width,\n                TextMeasurementService.measureSvgTextWidth,\n                textProperties);\n\n            // If labels do not fit and we are not scrolling, try word breaking\n            axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(\n                axes, this.DefaultMargin, width, TextMeasurementService.measureSvgTextWidth,\n                TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault,\n                textProperties);\n\n            return axes;\n        }\n\n        private calculateAxesProperties(viewportIn: IViewport, options: CalculateScaleAndDomainOptions, metaDataColumn: DataViewMetadataColumn): IAxisProperties {\n            let xAxisProperties = AxisHelper.createAxis({\n                pixelSpan: viewportIn.width,\n                dataDomain: options.forcedXDomain,\n                metaDataColumn: metaDataColumn,\n                formatString: valueFormatter.getFormatString(metaDataColumn, DotPlotProperties.general.formatString),\n                outerPadding: 0,\n                isScalar: false,\n                isVertical: false,\n                forcedTickCount: options.forcedTickCount,\n                useTickIntervalForDisplayUnits: true,\n                isCategoryAxis: true,\n                getValueFn: (index, type) => index,\n                scaleType: options.categoryAxisScaleType,\n                axisDisplayUnits: options.categoryAxisDisplayUnits\n            });\n\n            xAxisProperties.axisLabel = \"New Label\";\n            return xAxisProperties;\n        }\n\n        private renderAxis(height: number, xAxisProperties: IAxisProperties, data: DotPlotDataView, duration: number): void {\n            this.xAxis.attr(\n                {\n                    transform: SVGUtil.translate(0, height)\n                });\n\n            let xAxis = xAxisProperties.axis;\n            xAxis.orient('bottom');\n\n            this.xAxis\n                .transition()\n                .duration(duration)\n                .call(xAxis);\n        }\n    }\n\n    export interface DotplotBehaviorOptions {\n        columns: D3.Selection;\n        clearCatcher: D3.Selection;\n        interactivityService: IInteractivityService;\n    }\n\n    export class DotplotBehavior implements IInteractiveBehavior {\n        private columns: D3.Selection;\n        private clearCatcher: D3.Selection;\n        private interactivityService: IInteractivityService;\n\n        public bindEvents(options: DotplotBehaviorOptions, selectionHandler: ISelectionHandler): void {\n            this.columns = options.columns;\n            this.clearCatcher = options.clearCatcher;\n            this.interactivityService = options.interactivityService;\n\n            this.columns.on('click', (d: SelectableDataPoint, i: number) => {\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\n            });\n\n            options.clearCatcher.on('click', () => {\n                selectionHandler.handleClearSelection();\n            });\n        }\n\n        public renderSelection(hasSelection: boolean) {\n            let hasHighlights = this.interactivityService.hasSelection();\n            this.columns.style(\"fill-opacity\", (d: DotPlotDataGroup) => ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights));\n        }\n    }\n}\n","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *   \n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *   \n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\n/*\n *  This file is based on or incorporates material from the projects listed below (Third Party IP). \n *  The original copyright notice and the license under which Microsoft received such Third Party IP, \n *  are set forth below. Such licenses and notices are provided for informational purposes only. \n *  Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product. \n *  Microsoft reserves all other rights not expressly granted under this agreement, whether by \n *  implication, estoppel or otherwise.\n *  \n *  d3 Force Layout\n *  Copyright (c) 2010-2015, Michael Bostock\n *  All rights reserved.\n *  \n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *  \n *  * Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *  \n *  * Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *  \n *  * The name Michael Bostock may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *  \n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nmodule powerbi.visuals.samples {\n    import PixelConverter = jsCommon.PixelConverter;\n\n    module linkColorType {\n        export var byWeight: string = 'ByWeight';\n        export var byLinkType: string = 'ByLinkType';\n        export var interactive: string = 'Interactive';\n\n        export var type: IEnumType = createEnumType([\n            { value: byWeight, displayName: 'ByWeight' },\n            { value: byLinkType, displayName: 'ByLinkType' },\n            { value: interactive, displayName: 'Interactive' },\n        ]);\n    }\n\n    export interface ForceGraphOptions {\n        showDataLabels: boolean;\n        labelColor: string;\n        fontSize: number;\n        showArrow: boolean;\n        showLabel: boolean;\n        colorLink: string;\n        thickenLink: boolean;\n        displayImage: boolean;\n        defaultImage: string;\n        imageUrl: string;\n        imageExt: string;\n        nameMaxLength: number;\n        highlightReachableLinks: boolean;\n        charge: number;\n        defaultLinkColor: string;\n        defaultLinkHighlightColor: string;\n        defaultLinkThickness: string;\n    }\n\n    export var forceProps = {\n        general: {\n            formatString: <DataViewObjectPropertyIdentifier>{\n                objectName: \"general\",\n                propertyName: \"formatString\"\n            }\n        },\n        labels: {\n            show: <DataViewObjectPropertyIdentifier>{\n                objectName: \"labels\",\n                propertyName: \"show\"\n            },\n            color: <DataViewObjectPropertyIdentifier>{\n                objectName: \"labels\",\n                propertyName: \"color\"\n            },\n            fontSize: <DataViewObjectPropertyIdentifier>{\n                objectName: \"labels\",\n                propertyName: \"fontSize\"\n            }\n        },\n        links: {\n            showArrow: <DataViewObjectPropertyIdentifier>{ objectName: 'links', propertyName: 'showArrow' },\n            showLabel: <DataViewObjectPropertyIdentifier>{ objectName: 'links', propertyName: 'showLabel' },\n            colorLink: <DataViewObjectPropertyIdentifier>{ objectName: 'links', propertyName: 'colorLink' },\n            thickenLink: <DataViewObjectPropertyIdentifier>{ objectName: 'links', propertyName: 'thickenLink' },\n        },\n        nodes: {\n            displayImage: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'displayImage' },\n            defaultImage: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'defaultImage' },\n            imageUrl: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'imageUrl' },\n            imageExt: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'imageExt' },\n            nameMaxLength: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'nameMaxLength' },\n            highlightReachableLinks: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'highlightReachableLinks' },\n        },\n        size: {\n            charge: <DataViewObjectPropertyIdentifier>{ objectName: 'size', propertyName: 'charge' },\n        }\n    };\n\n    export interface ForceGraphData {\n        nodes: {};\n        links: any[];\n        minFiles: number;\n        maxFiles: number;\n        linkedByName: {};\n        linkTypes: {};\n    }\n\n    export class ForceGraph implements IVisual {\n        public static VisualClassName = 'forceGraph';\n        private root: D3.Selection;\n        private paths: D3.Selection;\n        private nodes: D3.Selection;\n        private forceLayout: D3.Layout.ForceLayout;\n        private dataView: DataView;\n        private colors: IDataColorPalette;\n        private options: ForceGraphOptions;\n        private data: ForceGraphData;\n\n        private marginValue: IMargin;\n        private get margin(): IMargin {\n            return this.marginValue || { left: 0, right: 0, top: 0, bottom: 0 };\n        }\n        private set margin(value: IMargin) {\n            this.marginValue = $.extend({}, value);\n            this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);\n        }\n\n        private viewportValue: IViewport;\n        private get viewport(): IViewport {\n            return this.viewportValue || { width: 0, height: 0 };\n        }\n        private set viewport(value: IViewport) {\n            this.viewportValue = $.extend({}, value);\n            this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);\n        }\n\n        private viewportInValue: IViewport;\n        private get viewportIn(): IViewport {\n            return this.viewportInValue || this.viewport;\n        }\n\n        private static substractMargin(viewport: IViewport, margin: IMargin): IViewport {\n            return {\n                width: Math.max(viewport.width - (margin.left + margin.right), 0),\n                height: Math.max(viewport.height - (margin.top + margin.bottom), 0)\n            };\n        }\n\n        private scale1to10(d) {\n            let scale = d3.scale.linear().domain([this.data.minFiles, this.data.maxFiles]).rangeRound([1, 10]).clamp(true);\n            return scale(d);\n        }\n\n        private getLinkColor(d): string {\n            switch (this.options.colorLink) {\n                case linkColorType.byWeight:\n                    return this.colors.getColorByIndex(this.scale1to10(d.filecount)).value;\n                case linkColorType.byLinkType:\n                    return d.type && this.data.linkTypes[d.type] ? this.data.linkTypes[d.type].color : this.options.defaultLinkColor;\n            };\n            return this.options.defaultLinkColor;\n        }\n\n        private getDefaultOptions(): ForceGraphOptions {\n            return {\n                showDataLabels: true,\n                labelColor: dataLabelUtils.defaultLabelColor,\n                fontSize: dataLabelUtils.DefaultFontSizeInPt,\n                showArrow: false,\n                showLabel: false,\n                colorLink: linkColorType.interactive,\n                thickenLink: true,\n                displayImage: false,\n                defaultImage: \"Home\",\n                imageUrl: \"\",\n                imageExt: \".png\",\n                nameMaxLength: 10,\n                highlightReachableLinks: false,\n                charge: -15,\n                defaultLinkColor: \"#bbb\",\n                defaultLinkHighlightColor: \"#f00\",\n                defaultLinkThickness: \"1.5px\",\n            };\n        }\n\n        private updateOptions(objects: DataViewObjects) {\n            this.options.showDataLabels = DataViewObjects.getValue(objects, forceProps.labels.show, this.options.showDataLabels);\n            this.options.labelColor = DataViewObjects.getFillColor(objects, forceProps.labels.color, this.options.labelColor);\n            this.options.fontSize = DataViewObjects.getValue(objects, forceProps.labels.fontSize, this.options.fontSize);\n            this.options.showArrow = DataViewObjects.getValue(objects, forceProps.links.showArrow, this.options.showArrow);\n            this.options.showLabel = DataViewObjects.getValue(objects, forceProps.links.showLabel, this.options.showLabel);\n            this.options.colorLink = DataViewObjects.getValue(objects, forceProps.links.colorLink, this.options.colorLink);\n            this.options.thickenLink = DataViewObjects.getValue(objects, forceProps.links.thickenLink, this.options.thickenLink);\n            this.options.displayImage = DataViewObjects.getValue(objects, forceProps.nodes.displayImage, this.options.displayImage);\n            this.options.defaultImage = DataViewObjects.getValue(objects, forceProps.nodes.defaultImage, this.options.defaultImage);\n            this.options.imageUrl = DataViewObjects.getValue(objects, forceProps.nodes.imageUrl, this.options.imageUrl);\n            this.options.imageExt = DataViewObjects.getValue(objects, forceProps.nodes.imageExt, this.options.imageExt);\n            this.options.nameMaxLength = DataViewObjects.getValue(objects, forceProps.nodes.nameMaxLength, this.options.nameMaxLength);\n            this.options.highlightReachableLinks = DataViewObjects.getValue(objects, forceProps.nodes.highlightReachableLinks, this.options.highlightReachableLinks);\n            this.options.charge = DataViewObjects.getValue(objects, forceProps.size.charge, this.options.charge);\n            if (this.options.charge >= 0 || this.options.charge < -100) this.options.charge = this.getDefaultOptions().charge;\n        }\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: 'Source',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'Source',\n                },\n                {\n                    name: 'Target',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'Target',\n                },\n                {\n                    name: 'Weight',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Weight',\n                },\n                {\n                    name: 'LinkType',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'LinkType',\n                    description: 'Links can be colored by link types',\n                },\n                {\n                    name: 'SourceType',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'SourceType',\n                    description: 'Source type represents the image name for source entities',\n                },\n                {\n                    name: 'TargetType',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'TargetType',\n                    description: 'Target type represents the image name for target entities',\n                },\n            ],\n            objects: {\n                general: {\n                    properties: {\n                        formatString: {\n                            type: { formatting: { formatString: true } },\n                        }\n                    }\n                },\n                labels: {\n                    displayName: 'Data labels',\n                    properties: {\n                        show: {\n                            displayName: 'Show',\n                            type: { bool: true }\n                        },\n                        color: {\n                            displayName: 'Fill',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: 'Text Size',\n                            type: { formatting: { fontSize: true } }\n                        }\n                    }\n                },\n                links: {\n                    displayName: 'Links',\n                    properties: {\n                        showArrow: {\n                            type: { bool: true },\n                            displayName: 'Arrow'\n                        },\n                        showLabel: {\n                            type: { bool: true },\n                            displayName: 'Label',\n                            description: 'Displays weight on links',\n                        },\n                        colorLink: {\n                            type: { enumeration: linkColorType.type },\n                            displayName: 'Color',\n                        },\n                        thickenLink: {\n                            type: { bool: true },\n                            displayName: 'Thickness',\n                            description: 'Thickenss of links represents weight',\n                        },\n                    }\n                },\n                nodes: {\n                    displayName: 'Nodes',\n                    properties: {\n                        displayImage: {\n                            type: { bool: true },\n                            displayName: 'Image',\n                            description: 'Images are loaded from image url + source or target type + image extension',\n                        },\n                        defaultImage: {\n                            type: { text: true },\n                            displayName: 'Default image'\n                        },\n                        imageUrl: {\n                            type: { text: true },\n                            displayName: 'Image url'\n                        },\n                        imageExt: {\n                            type: { text: true },\n                            displayName: 'Image extension'\n                        },\n                        nameMaxLength: {\n                            type: { numeric: true },\n                            displayName: 'Max name length',\n                            description: 'Max length of the name of entities displayed',\n                        },\n                        highlightReachableLinks: {\n                            type: { bool: true },\n                            displayName: 'Highlight all reachable links',\n                            description: \"In interactive mode, whether a node's all reachable links will be highlighted\",\n                        },\n                    }\n                },\n                size: {\n                    displayName: 'Size',\n                    properties: {\n                        charge: {\n                            type: { numeric: true },\n                            displayName: 'Charge',\n                            description: 'The larger the negative charge the more apart the entities, must be negative but greater than -100',\n                        },\n                    }\n                },\n            },\n            dataViewMappings: [{\n                conditions: [\n                    { 'Source': { max: 1 }, 'Target': { max: 1 }, 'Weight': { max: 1 }, 'LinkType': { max: 1 }, 'SourceType': { max: 1 }, 'TargetType': { max: 1 } },\n                ],\n                categorical: {\n                    categories: {\n                        for: { in: 'Source' },\n                        dataReductionAlgorithm: { top: {} }\n                    },\n                    values: {\n                        select: [\n                            { bind: { to: 'Target' } },\n                            { bind: { to: 'Weight' } },\n                            { bind: { to: 'LinkType' } },\n                            { bind: { to: 'SourceType' } },\n                            { bind: { to: 'TargetType' } },\n                        ],\n                    },\n                    rowCount: { preferred: { min: 1 } }\n                },\n            }],\n            suppressDefaultTitle: true,\n        };\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\n            let enumeration = new ObjectEnumerationBuilder();\n\n            switch (options.objectName) {\n                case 'labels':\n                    this.enumerateLabels(enumeration);\n                    break;\n                case 'links':\n                    this.enumerateLinks(enumeration);\n                    break;\n                case 'nodes':\n                    this.enumerateNodes(enumeration);\n                    break;\n                case 'size':\n                    this.enumerateSize(enumeration);\n                    break;\n                default:\n                    break;\n            }\n\n            return enumeration.complete();\n        }\n\n        private enumerateLabels(enumeration: ObjectEnumerationBuilder): void {\n            let labels: VisualObjectInstance,\n                options: ForceGraphOptions;\n\n            if (!this.options || !this.options)\n                return;\n\n            options = this.options;\n\n            labels = {\n                objectName: 'labels',\n                displayName: 'Labels',\n                selector: null,\n                properties: {\n                    show: options.showDataLabels,\n                    fontSize: options.fontSize,\n                    color: options.labelColor\n                }\n            };\n\n            enumeration.pushInstance(labels);\n        }\n\n        private enumerateLinks(enumeration: ObjectEnumerationBuilder): void {\n            let links: VisualObjectInstance,\n                options: ForceGraphOptions;\n\n            if (!this.options)\n                return;\n\n            options = this.options;\n\n            links = {\n                objectName: 'links',\n                displayName: 'Links',\n                selector: null,\n                properties: {\n                    showArrow: options.showArrow,\n                    colorLink: options.colorLink,\n                    showLabel: options.showLabel,\n                    thickenLink: options.thickenLink,\n                }\n            };\n\n            enumeration.pushInstance(links);\n        }\n\n        private enumerateNodes(enumeration: ObjectEnumerationBuilder): void {\n            let nodes: VisualObjectInstance,\n                options: ForceGraphOptions;\n\n            if (!this.options)\n                return;\n\n            options = this.options;\n\n            nodes = {\n                objectName: 'nodes',\n                displayName: 'Nodes',\n                selector: null,\n                properties: {\n                    displayImage: options.displayImage,\n                    defaultImage: options.defaultImage,\n                    imageUrl: options.imageUrl,\n                    imageExt: options.imageExt,\n                    nameMaxLength: options.nameMaxLength,\n                    highlightReachableLinks: options.highlightReachableLinks,\n                }\n            };\n\n            enumeration.pushInstance(nodes);\n        }\n\n        private enumerateSize(enumeration: ObjectEnumerationBuilder): void {\n            let size: VisualObjectInstance,\n                options: ForceGraphOptions;\n\n            if (!this.options)\n                return;\n\n            options = this.options;\n\n            size = {\n                objectName: 'size',\n                displayName: 'Size',\n                selector: null,\n                properties: {\n                    charge: options.charge,\n                }\n            };\n\n            enumeration.pushInstance(size);\n        }\n\n        public static converter(dataView: DataView, colors: IDataColorPalette): ForceGraphData {\n            let categorical: DataViewCategorical = dataView.categorical;\n            let nodes = {};\n            let minFiles = Number.MAX_VALUE;\n            let maxFiles = 0;\n            let linkedByName = {};\n            let links = [];\n            let linkDataPoints = {};\n            let linkTypeCount = 0;\n            let sourceCol = -1, targetCol = -1, weightCol = -1, linkTypeCol = -1, sourceTypeCol = -1, targetTypeCol = -1;\n            let rows;\n            let tooltipInfo: TooltipDataItem[] = [];\n            let formatStringProp = forceProps.general.formatString;\n\n            if (dataView && dataView.categorical && dataView.categorical.categories && dataView.metadata && dataView.metadata.columns) {\n                let metadataColumns = dataView.metadata.columns;\n                for (let i = 0; i < metadataColumns.length; i++) {\n                    let col = metadataColumns[i];\n                    if (col.roles) {\n                        if (col.roles['Source'])\n                            sourceCol = i;\n                        else if (col.roles['Target'])\n                            targetCol = i;\n                        else if (col.roles['Weight'])\n                            weightCol = i;\n                        else if (col.roles['LinkType'])\n                            linkTypeCol = i;\n                        else if (col.roles['SourceType'])\n                            sourceTypeCol = i;\n                        else if (col.roles['TargetType'])\n                            targetTypeCol = i;\n                    }\n                }\n            }\n            if (dataView && dataView.table) {\n                rows = dataView.table.rows;\n            }\n            if (sourceCol < 0 || targetCol < 0)\n                return <ForceGraphData>{\n                    nodes: {},\n                    links: [],\n                    minFiles: 0,\n                    maxFiles: 0,\n                    linkedByName: {},\n                    linkTypes: {},\n                };\n\n            let categorySourceFormatString = valueFormatter.getFormatString(categorical.categories[0].source, formatStringProp);\n            let categoryTargetFormatString = valueFormatter.getFormatString(categorical.categories[1].source, formatStringProp);\n            let weightFormatString = valueFormatter.getFormatString(categorical.values ? categorical.values[0].source : null, formatStringProp, true);\n\n            rows.forEach(function(item) {\n                linkedByName[item[sourceCol] + \",\" + item[targetCol]] = 1;\n                let source = nodes[item[sourceCol]] ||\n                    (nodes[item[sourceCol]] = { name: item[sourceCol], image: sourceTypeCol > 0 ? item[sourceTypeCol] : '', adj: {} });\n                let target = nodes[item[targetCol]] ||\n                    (nodes[item[targetCol]] = { name: item[targetCol], image: targetTypeCol > 0 ? item[targetTypeCol] : '', adj: {} });\n                source.adj[target.name] = 1;\n                target.adj[source.name] = 1;\n\n                tooltipInfo = [{\n                    displayName: dataView.metadata.columns[0].displayName,\n                    value: valueFormatter.format(source.name, categorySourceFormatString)\n                }, {\n                        displayName: dataView.metadata.columns[1].displayName,\n                        value: valueFormatter.format(target.name, categoryTargetFormatString)\n                    }];\n\n                if (weightCol > 0)\n                    tooltipInfo.push({\n                        displayName: dataView.metadata.columns[2].displayName,\n                        value: valueFormatter.format(item[weightCol], weightFormatString)\n                    });\n\n                let link = {\n                    source: source,\n                    target: target,\n                    filecount: weightCol > 0 ? item[weightCol] : 0,\n                    type: linkTypeCol > 0 ? item[linkTypeCol] : '',\n                    tooltipInfo: tooltipInfo,\n                };\n\n                if (linkTypeCol > 0) {\n                    if (!linkDataPoints[item[linkTypeCol]]) {\n                        linkDataPoints[item[linkTypeCol]] = {\n                            label: item[linkTypeCol],\n                            color: colors.getColorByIndex(linkTypeCount++).value,\n                        };\n                    };\n                };\n                if (link.filecount < minFiles) { minFiles = link.filecount; };\n                if (link.filecount > maxFiles) { maxFiles = link.filecount; };\n                links.push(link);\n            });\n\n            return {\n                nodes: nodes,\n                links: links,\n                minFiles: minFiles,\n                maxFiles: maxFiles,\n                linkedByName: linkedByName,\n                linkTypes: linkDataPoints,\n            };\n        }\n\n        public init(options: VisualInitOptions): void {\n            this.root = d3.select(options.element.get(0));\n            this.forceLayout = d3.layout.force();\n            this.colors = options.style.colorPalette.dataColors;\n            this.options = this.getDefaultOptions();\n        }\n\n        public update(options: VisualUpdateOptions) {\n            if (!options.dataViews || (options.dataViews.length < 1)) return;\n            this.data = ForceGraph.converter(this.dataView = options.dataViews[0], this.colors);\n            if (!this.data) return;\n            if (options.dataViews[0].metadata && options.dataViews[0].metadata.objects)\n                this.updateOptions(options.dataViews[0].metadata.objects);\n            this.viewport = options.viewport;\n            let k = Math.sqrt(Object.keys(this.data.nodes).length / (this.viewport.width * this.viewport.height));\n\n            this.root.selectAll(\"svg\").remove();\n\n            let svg = this.root\n                .append(\"svg\")\n                .attr(\"width\", this.viewport.width)\n                .attr(\"height\", this.viewport.height)\n                .classed(ForceGraph.VisualClassName, true);\n\n            this.forceLayout\n                .gravity(100 * k)\n                .links(this.data.links)\n                .size([this.viewport.width, this.viewport.height])\n                .linkDistance(100)\n                .charge(this.options.charge / k)\n                .on(\"tick\", this.tick());\n            this.updateNodes();\n            this.forceLayout.start();\n\n            // uncomment if we don't need the marker-end workaround\n            //if (this.options.showArrow) {\n            // build the arrow.\n            //function marker(d, i) {\n            //    let val = \"mid_\" + i;\n            //    svg.append(\"defs\").selectAll(\"marker\")\n            //        .data([val])      // Different link/path types can be defined here\n            //        .enter().append(\"marker\")    // This section adds in the arrows\n            //        .attr(\"id\", String)\n            //        .attr(\"viewBox\", \"0 -5 10 10\")\n            //        .attr(\"refX\", 10)\n            //        .attr(\"refY\", 0)\n            //        .attr(\"markerWidth\", 6)\n            //        .attr(\"markerHeight\", 6)\n            //        .attr(\"orient\", \"auto\")\n            //        .attr(\"markerUnits\", \"userSpaceOnUse\")\n            //        .append(\"path\")\n            //        .attr(\"d\", \"M0,-5L10,0L0,5\")\n            //    //below works if no marker-end workaround needed\n            //        .style(\"fill\", d => this.getLinkColor(d))\n            //    ;\n            //    return \"url(#\" + val + \")\";\n            //}\n            //}\n            this.paths = svg.selectAll(\".link\")\n                .data(this.forceLayout.links())\n                .enter().append(\"path\")\n                .attr(\"class\", \"link\")\n                .attr(\"id\", (d, i) => \"linkid_\" + i)\n                // uncomment if we don't need the marker-end workaround\n                //.attr(\"marker-end\", function (d, i) { return marker(d, i); })\n                .attr(\"stroke-width\", d => this.options.thickenLink ? this.scale1to10(d.filecount) : this.options.defaultLinkThickness)\n                .style(\"stroke\", d => this.getLinkColor(d))\n                // no need for \"fill\" if we don't need the marker-end workaround\n                .style(\"fill\", d => { if (this.options.showArrow) return this.getLinkColor(d); })\n                .on(\"mouseover\", this.fadePath(.3, this.options.defaultLinkHighlightColor))\n                .on(\"mouseout\", this.fadePath(1, this.options.defaultLinkColor));\n\n            TooltipManager.addTooltip(this.paths, (tooltipEvent: TooltipEvent) => {\n                return tooltipEvent.data.tooltipInfo;\n            });\n\n            if (this.options.showLabel) {\n                svg.selectAll(\".linklabelholder\")\n                    .data(this.forceLayout.links())\n                    .enter().append(\"g\")\n                    .attr(\"class\", \"linklabelholder\")\n                    .append(\"text\")\n                    .attr(\"class\", \"linklabel\")\n                    .attr(\"y\", \"-12\")\n                    .attr(\"text-anchor\", \"middle\")\n                    .style(\"fill\", \"#000\")\n                    .append(\"textPath\")\n                    .attr(\"xlink:href\", (d, i) => \"#linkid_\" + i)\n                    .attr(\"startOffset\", \"25%\") //use \"50%\" if we don't need the marker-end workaround\n                    .text(d => this.options.colorLink === linkColorType.byLinkType ? d.type : d.filecount);\n            }\n\n            // define the nodes\n            this.nodes = svg.selectAll(\".node\")\n                .data(this.forceLayout.nodes())\n                .enter().append(\"g\")\n                .attr(\"class\", \"node\")\n                .call(this.forceLayout.drag)\n                .on(\"mouseover\", this.fadeNode(.3, this.options.defaultLinkHighlightColor))\n                .on(\"mouseout\", this.fadeNode(1, this.options.defaultLinkColor))\n                .on(\"mousedown\", () => d3.event.stopPropagation())\n                .attr(\"drag-resize-disabled\", true);\n\n            // add the nodes\n            if (this.options.displayImage) {\n                this.nodes.append(\"image\")\n                    .attr(\"xlink:href\", d =>\n                        d.image && d.image !== '' ?\n                            this.options.imageUrl + d.image + this.options.imageExt :\n                            (\n                                this.options.defaultImage && this.options.defaultImage !== '' ?\n                                    this.options.imageUrl + this.options.defaultImage + this.options.imageExt :\n                                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAMAAAHNDTTxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuUExURQAAAMbGxvLy8sfHx/Hx8fLy8vHx8cnJycrKyvHx8fHx8cvLy/Ly8szMzM3NzfHx8dDQ0PHx8fLy8vHx8e/v79LS0tPT0/Ly8tTU1NXV1dbW1vHx8fHx8fDw8NjY2PT09PLy8vLy8vHx8fLy8vHx8fHx8enp6fDw8PLy8uPj4+Tk5OXl5fHx8b+/v/Pz8+bm5vHx8ejo6PLy8vHx8fLy8sTExPLy8vLy8sXFxfHx8YCtMbUAAAA6dFJOUwD/k/+b7/f///+r/////0z/w1RcEP//ZP///4fj/v8Yj3yXn/unDEhQ////YP9Y/8//aIMU/9+L/+fzC4s1AAAACXBIWXMAABcRAAAXEQHKJvM/AAABQElEQVQoU5WS61LCMBCFFymlwSPKVdACIgWkuNyL+P4v5ibZ0jKjP/xm0uw5ySa7mRItAhnMoIC5TwQZdCZiZjcoC8WU6EVsmZgzoqGdxafgvJAvjUXCb2M+0cXNsd/GDarZqSf7av3M2P1E3xhfLkPUvLD5joEYwVVJQXM6+9McWUwLf4nDTCQZAy96UoDjNI/jhl3xPLbQamu8xD7iaIsPKw7GJ7KZEnWLY3Gi8EFj5nqibXnwD5VEGjJXk5sbpLppfvvo1RazQVrhSopPK4TODrtnjS3dY4ic8KurruWQYF+UG60BacexTMyT2jlNg41dOmKvTpkUd/Jevy7ZxQ61ULRUpoododx8GeDPvIrktbFVdUsK6f8Na5VlVpjZJtowTXVy7kfXF5wCaV1tqXAFuIdWJu+JviaQzNzfQvQDGKRXXEmy83cAAAAASUVORK5CYII='\n                            )\n                    )\n                    .attr(\"x\", \"-12px\")\n                    .attr(\"y\", \"-12px\")\n                    .attr(\"width\", \"24px\")\n                    .attr(\"height\", \"24px\");\n            } else {\n                this.nodes.append(\"circle\")\n                    .attr(\"r\", d => d.weight < 5 ? 5 : d.weight);\n            }\n\n            // add the text\n            if (this.options.showDataLabels) {\n                this.nodes.append(\"text\")\n                    .attr({\n                        x: 12,\n                        dy: \".35em\"\n                    })\n                    .style({\n                        fill: this.options.labelColor,\n                        'font-size': PixelConverter.fromPoint(this.options.fontSize)\n                    })\n                    .text(d => d.name ? (d.name.length > this.options.nameMaxLength ? d.name.substr(0, this.options.nameMaxLength) : d.name) : '');\n            }\n        }\n\n        private updateNodes() {\n            let oldNodes = this.forceLayout.nodes();\n            this.forceLayout.nodes(d3.values(this.data.nodes));\n            this.forceLayout.nodes().forEach((node, i) => {\n                if (!oldNodes[i]) {\n                    return;\n                }\n                node.x = oldNodes[i].x;\n                node.y = oldNodes[i].y;\n                node.px = oldNodes[i].px;\n                node.py = oldNodes[i].py;\n                node.weight = oldNodes[i].weight;\n            });\n        }\n\n        private tick() {\n            let viewport = this.viewportIn;\n            // limitX and limitY is necessary when you minimize the graph and then resize it to normal.\n            //\"width/height * 20\" seems enough to move nodes freely by force layout.\n            let maxWidth = viewport.width * 20;\n            let maxHeight = viewport.height * 20;\n            let limitX = x => Math.max((viewport.width - maxWidth) / 2, Math.min((viewport.width + maxWidth) / 2, x));\n            let limitY = y => Math.max((viewport.height - maxHeight) / 2, Math.min((viewport.height + maxHeight) / 2, y));\n            //use this if we don't need the marker-end workaround\n            //path.attr(\"d\", function (d) {\n            //    let dx = d.target.x - d.source.x,\n            //        dy = d.target.y - d.source.y,\n            //        dr = Math.sqrt(dx * dx + dy * dy);\n            //    // x and y distances from center to outside edge of target node\n            //    let offsetX = (dx * d.target.radius) / dr;\n            //    let offsetY = (dy * d.target.radius) / dr;\n            //    return \"M\" +\n            //        d.source.x + \",\" +\n            //        d.source.y + \"A\" +\n            //        dr + \",\" + dr + \" 0 0,1 \" +\n            //        (d.target.x - offsetX) + \",\" +\n            //        (d.target.y - offsetY);\n            //});\n\n            let getPath = this.options.showArrow ?\n                //this is for marker-end workaround, build the marker with the path\n                d => {\n                    d.source.x = limitX(d.source.x);\n                    d.source.y = limitY(d.source.y);\n                    d.target.x = limitX(d.target.x);\n                    d.target.y = limitY(d.target.y);\n                    let dx = d.target.x - d.source.x,\n                        dy = d.target.y - d.source.y,\n                        dr = Math.sqrt(dx * dx + dy * dy),\n                        theta = Math.atan2(dy, dx) + Math.PI / 7.85,\n                        d90 = Math.PI / 2,\n                        dtxs = d.target.x - 6 * Math.cos(theta),\n                        dtys = d.target.y - 6 * Math.sin(theta);\n                    return \"M\" +\n                        d.source.x + \",\" +\n                        d.source.y + \"A\" +\n                        dr + \",\" + dr + \" 0 0 1,\" +\n                        d.target.x + \",\" +\n                        d.target.y +\n                        \"A\" + dr + \",\" + dr + \" 0 0 0,\" + d.source.x + \",\" + d.source.y + \"M\" + dtxs + \",\" + dtys + \"l\" + (3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + \",\" + (-3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + \"L\" + (dtxs - 3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + \",\" + (dtys + 3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + \"z\";\n                } :\n                d => {\n                    d.source.x = limitX(d.source.x);\n                    d.source.y = limitY(d.source.y);\n                    d.target.x = limitX(d.target.x);\n                    d.target.y = limitY(d.target.y);\n                    let dx = d.target.x - d.source.x,\n                        dy = d.target.y - d.source.y,\n                        dr = Math.sqrt(dx * dx + dy * dy);\n                    return \"M\" +\n                        d.source.x + \",\" +\n                        d.source.y + \"A\" +\n                        dr + \",\" + dr + \" 0 0,1 \" +\n                        d.target.x + \",\" +\n                        d.target.y;\n                };\n\n            return () => {\n                this.paths.each(function() { this.parentNode.insertBefore(this, this); });\n                this.paths.attr(\"d\", getPath);\n                this.nodes.attr(\"transform\", d => \"translate(\" + limitX(d.x) + \",\" + limitY(d.y) + \")\");\n            };\n        }\n\n        private fadePath(opacity: number, highlight: string) {\n            if (this.options.colorLink !== linkColorType.interactive) return;\n            return d => {\n                this.paths.style(\"stroke-opacity\", o => o.source === d.source && o.target === d.target ? 1 : opacity);\n                this.paths.style(\"stroke\", o => o.source === d.source && o.target === d.target ? highlight : this.options.defaultLinkColor);\n            };\n        }\n\n        private isReachable(a, b): boolean {\n            if (a.name === b.name) return true;\n            if (this.data.linkedByName[a.name + \",\" + b.name]) return true;\n            let visited = {};\n            for (let name in this.data.nodes) {\n                visited[name] = false;\n            };\n            visited[a.name] = true;\n\n            let stack = [];\n            stack.push(a.name);\n            while (stack.length > 0) {\n                let cur = stack.pop();\n                let node = this.data.nodes[cur];\n                for (let nb in node.adj) {\n                    if (nb === b.name) return true;\n\n                    if (!visited[nb]) {\n                        visited[nb] = true;\n                        stack.push(nb);\n                    }\n                }\n            };\n            return false;\n        }\n\n        private fadeNode(opacity: number, highlight: string) {\n            if (this.options.colorLink !== linkColorType.interactive) return;\n            let isConnected = (a, b) => this.data.linkedByName[a.name + \",\" + b.name] || this.data.linkedByName[b.name + \",\" + a.name] || a.name === b.name;\n\n            return d => {\n                let that = this;\n                this.nodes.style(\"stroke-opacity\", function(o) {\n                    let thisOpacity = (that.options.highlightReachableLinks ? that.isReachable(d, o) : isConnected(d, o)) ? 1 : opacity;\n                    this.setAttribute('fill-opacity', thisOpacity);\n                    return thisOpacity;\n                });\n\n                this.paths.style(\"stroke-opacity\", o =>\n                    (this.options.highlightReachableLinks ? this.isReachable(d, o.source) :\n                        (o.source === d || o.target === d)) ? 1 : opacity);\n                this.paths.style(\"stroke\", o =>\n                    (this.options.highlightReachableLinks ? this.isReachable(d, o.source) :\n                        (o.source === d || o.target === d)) ? highlight : this.options.defaultLinkColor);\n            };\n        }\n\n        public destroy(): void {\n            this.root = null;\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import SelectionManager = utility.SelectionManager;\n    import PixelConverter = jsCommon.PixelConverter;\n    import IStringResourceProvider = jsCommon.IStringResourceProvider;\n\n    const PercentFormat: string = \"0.00 %;-0.00 %;0.00 %\";\n    const MillisecondsInADay: number = 86400000;\n    const MillisecondsInWeek: number = 604800000;\n    const MillisecondsInAMonth: number = 2629746000;\n    const MillisecondsInAYear: number = 31556952000;\n    export const DefaultDateType: string = \"Week\";\n    const ChartLineHeight: number = 40;\n    const PaddingTasks: number = 5;\n\n    export module dateTypeSelector {\n        export const day: string = 'Day';\n        export const week: string = 'Week';\n        export const month: string = 'Month';\n        export const year: string = 'Year';\n\n        export const type: IEnumType = createEnumType([\n            { value: day, displayName: 'Day' },\n            { value: week, displayName: 'Week' },\n            { value: month, displayName: 'Month' },\n            { value: year, displayName: 'Year' }\n        ]);\n    }\n    export interface Task extends SelectableDataPoint {\n        id: number;\n        name: string;\n        start: Date;\n        duration: number;\n        completion: number;\n        resource: string;\n        end: Date;\n        taskType: string;\n        description: string;\n        color: string;\n        tooltipInfo: TooltipDataItem[];\n    }\n\n    export interface GanttChartFormatters {\n        startDateFormatter: IValueFormatter;\n        completionFormatter: IValueFormatter;\n        durationFormatter: IValueFormatter;\n    }\n\n    export interface GanttChartData {\n        legendData: LegendData;\n        series: GanttSeries[];\n        showLegend: boolean;\n    }\n\n    export interface GanttViewModel {\n        taskLabelsShow: boolean;\n        taskLabelsColor: string;\n        taskLabelsFontSize: number;\n        taskLabelsWidth: number;\n        taskProgressColor: string;\n        taskResourceShow: boolean;\n        taskResourceColor: string;\n        taskResourceFontSize: number;\n        legendData: LegendData;\n        taskTypes: TaskTypes;\n        dateType: string;\n    }\n\n    export interface GanttDataPoint extends SelectableDataPoint {\n        color: string;\n        value: any;\n    }\n\n    export interface GanttSeries extends SelectableDataPoint {\n        tasks: Task[];\n        fill: string;\n        name: string;\n    }\n\n    export interface TaskTypes { /*TODO: change to more proper name*/\n        types: string[];\n        typeName: string;\n    };\n\n    interface Line {\n        x1: number;\n        y1: number;\n        x2: number;\n        y2: number;\n        tooltipInfo: TooltipDataItem[];\n    }\n\n    export const GanttChartProps = {\n        legend: {\n            show: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'show' },\n            position: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'position' },\n            showTitle: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'showTitle' },\n            titleText: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'titleText' },\n            labelColor: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'labelColor' },\n            fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'fontSize' },\n        },\n        taskCompletion: {\n            fill: <DataViewObjectPropertyIdentifier>{ objectName: 'taskCompletion', propertyName: 'fill' },\n        },\n        dataPoint: {\n            fill: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'fill' },\n        },\n        taskLabels: {\n            show: <DataViewObjectPropertyIdentifier>{ objectName: 'taskLabels', propertyName: 'show' },\n            fill: <DataViewObjectPropertyIdentifier>{ objectName: 'taskLabels', propertyName: 'fill' },\n            fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'taskLabels', propertyName: 'fontSize' },\n            width: <DataViewObjectPropertyIdentifier>{ objectName: 'taskLabels', propertyName: 'width' },\n        },\n        taskResource: {\n            show: <DataViewObjectPropertyIdentifier>{ objectName: 'taskResource', propertyName: 'show' },\n            fill: <DataViewObjectPropertyIdentifier>{ objectName: 'taskResource', propertyName: 'fill' },\n            fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'taskResource', propertyName: 'fontSize' },\n        },\n        ganttDateType:\n        {\n            type: <DataViewObjectPropertyIdentifier>{ objectName: 'ganttDateType', propertyName: 'type' },\n        }\n    };\n\n    module Selectors {\n\n        import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n        import CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n\n        export const ClassName: ClassAndSelector = CreateClassAndSelector(\"gantt\");\n        export const Chart: ClassAndSelector = CreateClassAndSelector(\"chart\");\n        export const ChartLine: ClassAndSelector = CreateClassAndSelector(\"chart-line\");\n        export const Body: ClassAndSelector = CreateClassAndSelector(\"gantt-body\");\n        export const AxisGroup: ClassAndSelector = CreateClassAndSelector(\"axis\");\n        export const Domain: ClassAndSelector = CreateClassAndSelector(\"domain\");\n        export const AxisTick: ClassAndSelector = CreateClassAndSelector(\"tick\");\n\n        export const Tasks: ClassAndSelector = CreateClassAndSelector(\"tasks\");\n        export const SingleTask: ClassAndSelector = CreateClassAndSelector(\"task\");\n        export const TaskRect: ClassAndSelector = CreateClassAndSelector(\"task-rect\");\n        export const TaskProgress: ClassAndSelector = CreateClassAndSelector(\"task-progress\");\n        export const TaskResource: ClassAndSelector = CreateClassAndSelector(\"task-resource\");\n        export const SingleMilestone: ClassAndSelector = CreateClassAndSelector(\"milestone\");\n\n        export const TaskLabels: ClassAndSelector = CreateClassAndSelector(\"task-labels\");\n        export const TaskLines: ClassAndSelector = CreateClassAndSelector(\"task-lines\");\n        export const SingleTaskLine: ClassAndSelector = CreateClassAndSelector(\"task-line\");\n        export const Label: ClassAndSelector = CreateClassAndSelector(\"label\");\n        export const LegendItems: ClassAndSelector = CreateClassAndSelector(\"legendItem\");\n        export const LegendTitle: ClassAndSelector = CreateClassAndSelector(\"legendTitle\");\n    }\n\n    export class Gantt implements IVisual {\n\n        private data: GanttChartData;\n        private dataView: DataView;\n        private viewport: IViewport;\n        private colors: IDataColorPalette;\n        private legend: ILegend;\n        private legendObjectProperties: DataViewObject;\n\n        private textProperties: TextProperties = {\n            fontFamily: 'wf_segoe-ui_normal',\n            fontSize: jsCommon.PixelConverter.toString(9),\n        };\n\n        private static DefaultValues = {\n            AxisTickSize: 6,\n            LabelFontSize: 9,\n            LegendFontSize: 8,\n            LegendLabelColor: \"#000000\",\n            MaxTaskOpacity: 1,\n            MinTaskOpacity: 0.4,\n            ProgressBarHeight: 4,\n            ProgressColor: \"#000000\",\n            ResourceFontSize: 9,\n            ResourceWidth: 100,\n            TaskColor: \"#00B099\",\n            TaskLabelColor: \"#000000\",\n            TaskLabelWidth: 110,\n            TaskLineWidth: 15,\n            TaskResourceColor: \"#000000\",\n            ganttFormatString: \"MMM dd\"\n        };\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: \"Legend\",\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: \"Legend\",\n                }, {\n                    name: \"Task\",\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: \"Task\"\n                }, {\n                    name: \"StartDate\",\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: \"Start Date\",\n                }, {\n                    name: \"Duration\",\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: \"Duration\",\n                    requiredTypes: [{ numeric: true }, { integer: true }]\n                }, {\n                    name: \"Completion\",\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: \"% Completion\",\n                    requiredTypes: [{ numeric: true }, { integer: true }]\n                }, {\n                    name: \"Resource\",\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: \"Resource\"\n                }\n            ],\n            dataViewMappings: [{\n                conditions: [\n                    {\n                        \"Legend\": { min: 0, max: 1 },\n                        \"Task\": { min: 1, max: 1 },\n                        \"StartDate\": { min: 0, max: 0 },\n                        \"Duration\": { min: 0, max: 0 },\n                        \"Completion\": { min: 0, max: 0 },\n                        \"Resource\": { min: 0, max: 0 }\n                    }, {\n                        \"Legend\": { min: 0, max: 1 },\n                        \"Task\": { min: 1, max: 1 },\n                        \"StartDate\": { min: 0, max: 1 },\n                        \"Duration\": { min: 0, max: 0 },\n                        \"Completion\": { min: 0, max: 0 },\n                        \"Resource\": { min: 0, max: 0 }\n                    }, {\n                        \"Legend\": { min: 0, max: 1 },\n                        \"Task\": { min: 0, max: 1 },\n                        \"StartDate\": { min: 0, max: 1 },\n                        \"Duration\": { min: 0, max: 1 },\n                        \"Completion\": { min: 0, max: 1 },\n                        \"Resource\": { min: 0, max: 1 },\n                    }\n                ],\n                table: {\n                    rows: {\n                        select:\n                        [\n                            { for: { in: \"Legend\" } },\n                            { for: { in: \"Task\" } },\n                            { for: { in: \"StartDate\" } },\n                            { for: { in: \"Duration\" } },\n                            { for: { in: \"Completion\" } },\n                            { for: { in: \"Resource\" } },\n                        ]\n                    },\n                },\n            }],\n            sorting: {\n                default: {},\n            },\n            objects: {\n                legend: {\n                    displayName: \"Legend\",\n                    description: \"Display legend options\",\n                    properties: {\n                        show: {\n                            displayName: \"Show\",\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: \"Position\",\n                            description: \"Select the location for the legend\",\n                            type: { enumeration: legendPosition.type }\n                        },\n                        showTitle: {\n                            displayName: \"Title\",\n                            description: \"Display a title for legend symbols\",\n                            type: { bool: true }\n                        },\n                        titleText: {\n                            displayName: \"Legend Name\",\n                            description: \"Title text\",\n                            type: { text: true },\n                            suppressFormatPainterCopy: true\n                        },\n                        labelColor: {\n                            displayName: \"Color\",\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: \"Text Size\",\n                            type: { formatting: { fontSize: true } }\n                        }\n                    }\n                },\n                //dataPoint: {\n                //    displayName: \"Data colors\",\n                //    properties: {\n                //        fill: {\n                //            displayName: \"Fill\",\n                //            type: { fill: { solid: { color: true } } }\n                //        }\n                //    }\n                //},\n                taskLabels: {\n                    displayName: 'Category Labels',\n                    properties: {\n                        show: {\n                            displayName: \"Show\",\n                            type: { bool: true }\n                        },\n                        fill: {\n                            displayName: 'Fill',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: 'Font Size',\n                            type: { formatting: { fontSize: true } }\n                        },\n                        width: {\n                            displayName: 'Width',\n                            type: { numeric: true }\n                        }\n                    }\n                },\n                taskCompletion: {\n                    displayName: 'Task Completion',\n                    properties: {\n                        show: {\n                            type: { bool: true }\n                        },\n                        fill: {\n                            displayName: 'Completion Color',\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                },\n                taskResource: {\n                    displayName: 'Data Labels',\n                    properties: {\n                        show: {\n                            displayName: \"Show\",\n                            type: { bool: true }\n                        },\n                        fill: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: 'Font Size',\n                            type: { formatting: { fontSize: true } }\n                        }\n                    }\n                },\n                ganttDateType: {\n                    displayName: 'Gantt Date Type',\n                    properties: {\n                        type: {\n                            displayName: \"Type\",\n                            type: { enumeration: dateTypeSelector.type }\n                        },\n                    }\n                },\n            }\n        };\n\n        private margin: IMargin = {\n            top: 50,\n            right: 40,\n            bottom: 40,\n            left: 10\n        };\n\n        private style: IVisualStyle;\n        private body: D3.Selection;\n        private ganttSvg: D3.Selection;\n        private viewModel: GanttViewModel;\n        private timeScale: D3.Scale.TimeScale;\n        private axisGroup: D3.Selection;\n\n        private chartGroup: D3.Selection;\n        private taskGroup: D3.Selection;\n        private lineGroup: D3.Selection;\n\n        private clearCatcher: D3.Selection;\n        private ganttDiv: D3.Selection;\n        private selectionManager: SelectionManager;\n        private behavior: GanttChartBehavior;\n        private interactivityService: IInteractivityService;\n        private hostServices: IVisualHostServices;\n        private isInteractiveChart: boolean;\n\n        public static getMaxTaskOpacity(): number {\n            return Gantt.DefaultValues.MaxTaskOpacity;\n        }\n\n        public static getMinTaskOpacity(): number {\n            return Gantt.DefaultValues.MinTaskOpacity;\n        }\n\n        public init(options: VisualInitOptions): void {\n            let element: JQuery = options.element;\n\n            this.style = options.style;\n            this.body = d3.select(element.get(0));\n\n            this.hostServices = options.host;\n            this.selectionManager = new SelectionManager({ hostServices: options.host });\n\n            this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;\n            this.interactivityService = createInteractivityService(this.hostServices);\n            this.createViewport(element);\n            this.updateChartSize(options.viewport);\n            this.behavior = new GanttChartBehavior();\n            this.colors = options.style.colorPalette.dataColors;\n\n            this.data = {\n                legendData: null,\n                series: null,\n                showLegend: null\n            };\n        }\n\n        /**\n         * Create the vieport area of the gantt chart\n         */\n        private createViewport(element: JQuery): void {\n            //create div container to the whole viewport area\n            this.ganttDiv = this.body.append(\"div\")\n                .classed(Selectors.Body.class, true);\n\n            //create container to the svg area\n            this.ganttSvg = this.ganttDiv\n                .append(\"svg\")\n                .classed(Selectors.ClassName.class, true);\n         \n            //create clear catcher\n            this.clearCatcher = appendClearCatcher(this.ganttSvg);\n\n            //create axis container\n            this.axisGroup = this.ganttSvg\n                .append(\"g\")\n                .classed(Selectors.AxisGroup.class, true);\n            \n            //create task lines container\n            this.lineGroup = this.ganttSvg\n                .append(\"g\")\n                .classed(Selectors.TaskLines.class, true);\n            \n            //create chart container\n            this.chartGroup = this.ganttSvg\n                .append(\"g\")\n                .classed(Selectors.Chart.class, true);\n            \n            //create tasks container\n            this.taskGroup = this.chartGroup\n                .append(\"g\")\n                .classed(Selectors.Tasks.class, true);\n\n            //create legend container\n            this.legend = createLegend(element.children(Selectors.Body.selector),\n                this.isInteractiveChart,\n                this.interactivityService,\n                true,\n                LegendPosition.Top);\n        }\n\n        /**\n         * Clear the viewport area\n         */\n        private clearViewport(): void {\n            this.body.selectAll(Selectors.LegendItems.selector).remove();\n            this.body.selectAll(Selectors.LegendTitle.selector).remove();\n            this.axisGroup.selectAll(Selectors.AxisTick.selector).remove();\n            this.axisGroup.selectAll(Selectors.Domain.selector).remove();\n            this.lineGroup.selectAll(\"*\").remove();\n            this.chartGroup.selectAll(Selectors.ChartLine.selector).remove();\n            this.chartGroup.selectAll(Selectors.SingleTask.selector).remove();\n        }\n\n        /**\n         * Update div container size to the whole viewport area\n         * @param viewport The vieport to change it size \n         */\n        private updateChartSize(viewport: IViewport): void {\n            this.ganttDiv.style({\n                height: PixelConverter.toString(viewport.height),\n                width: PixelConverter.toString(viewport.width)\n            });\n        }\n\n        /**\n       * Create the gantt tasks series based on all task types\n       * @param taskTypes All unique types from the tasks array.\n       */\n        private createSeries(objects: DataViewObjects, tasks: Task[]): GanttSeries[] {\n            let colorHelper = new ColorHelper(this.colors, GanttChartProps.dataPoint.fill);\n            let taskGroup: _.Dictionary<Task[]> = _.groupBy(tasks, t=> t.taskType);\n            let taskTypes = Gantt.getAllTasksTypes(this.dataView);\n\n            let series: GanttSeries[] = _.map(taskTypes.types, type => {\n                return {\n                    tasks: taskGroup[type],\n                    fill: colorHelper.getColorForMeasure(objects, type),\n                    name: type,\n                    identity: SelectionId.createWithMeasure(type),\n                    selected: false\n                };\n            });\n\n            return series;\n        }\n\n        /**\n        * Convert the dataView to view model\n        * @param dataView The data Model\n        */\n        public static converter(dataView: DataView, colorPalette: IDataColorPalette): GanttViewModel {\n            let taskLabelsShow: boolean = DataViewObjects.getValue<boolean>(dataView.metadata.objects, GanttChartProps.taskLabels.show, true);\n            let taskLabelsColor: string = DataViewObjects.getFillColor(dataView.metadata.objects, GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor);\n            let taskLabelsFontSize: number = DataViewObjects.getValue<number>(dataView.metadata.objects, GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize);\n            let taskLabelsWidth: number = DataViewObjects.getValue<number>(dataView.metadata.objects, GanttChartProps.taskLabels.width, taskLabelsShow ? Gantt.DefaultValues.TaskLabelWidth : 0);\n            let taskProgressColor: string = DataViewObjects.getFillColor(dataView.metadata.objects, GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor);\n            let taskResourceColor: string = DataViewObjects.getFillColor(dataView.metadata.objects, GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor);\n            let taskResourceFontSize: number = DataViewObjects.getValue<number>(dataView.metadata.objects, GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize);\n            let taskResourceShow: boolean = DataViewObjects.getValue<boolean>(dataView.metadata.objects, GanttChartProps.taskResource.show, true);\n            let dateType: string = DataViewObjects.getValue<string>(dataView.metadata.objects, GanttChartProps.ganttDateType.type, DefaultDateType);\n\n            let taskTypes = Gantt.getAllTasksTypes(dataView);\n            let colorHelper = new ColorHelper(colorPalette, GanttChartProps.dataPoint.fill);\n            let legendData: LegendData = {\n                fontSize: Gantt.DefaultValues.LegendFontSize,\n                dataPoints: [],\n                title: taskTypes.typeName\n            };\n\n            legendData.dataPoints = _.map(taskTypes.types, type => {\n                return {\n                    label: type,\n                    color: colorHelper.getColorForMeasure(dataView.metadata.objects, type),\n                    icon: LegendIcon.Circle,\n                    selected: false,\n                    identity: SelectionId.createWithMeasure(type)\n                };\n            });\n\n            let settings: GanttViewModel = {\n                taskLabelsShow: taskLabelsShow,\n                taskLabelsColor: taskLabelsColor,\n                taskLabelsFontSize: taskLabelsFontSize,\n                taskLabelsWidth: taskLabelsWidth,\n                taskProgressColor: taskProgressColor,\n                taskResourceShow: taskResourceShow,\n                taskResourceColor: taskResourceColor,\n                taskResourceFontSize: taskResourceFontSize,\n                legendData: legendData,\n                taskTypes: taskTypes,\n                dateType: dateType\n            };\n\n            return settings;\n        }\n\n        /**\n         * Returns the chart formatters\n         * @param dataView The data Model\n         */\n        private parseSettings(dataView: DataView): GanttChartFormatters {\n            if (!dataView ||\n                !dataView.metadata ||\n                !dataView.metadata.columns)\n                return null;\n\n            let dateFormat = \"d\";\n            let numberFormat = \"#\";\n\n            for (let dvColumn of dataView.metadata.columns) {\n                if (!!dataView.categorical.categories) {\n                    for (let dvCategory of dataView.categorical.categories) {\n                        if (this.hasRole(dvCategory.source, \"StartDate\"))\n                            dateFormat = dvColumn.format;\n                    }\n                }\n            }\n\n            return <GanttChartFormatters>{\n                startDateFormatter: valueFormatter.create({ format: dateFormat }),\n                durationFormatter: valueFormatter.create({ format: numberFormat }),\n                completionFormatter: valueFormatter.create({ format: PercentFormat, value: 1, allowFormatBeautification: true })\n            };\n        }\n\n        private isValidDate(date: Date) {\n            if (Object.prototype.toString.call(date) !== \"[object Date]\")\n                return false;\n            return !isNaN(date.getTime());\n        }\n\n        private convertToDecimal(number) {\n            if (!(number >= 0 && number <= 1))\n                return (number / 100);\n            return number;\n        }\n\n        /**\n        * Create task objects dataView\n        * @param dataView The data Model.\n        * @param formatters task attributes represented format.\n        * @param series An array that holds the color data of different task groups.\n        */\n        private createTasks(dataView: DataView, formatters: GanttChartFormatters): Task[] {\n            let columnSource = dataView.table.columns;\n            let data = dataView.table.rows;\n            let categories = dataView.categorical.categories[0];\n            let colorHelper = new ColorHelper(this.colors, GanttChartProps.dataPoint.fill);\n\n            return data.map((child: DataViewTableRow, index: number) => {\n                let dateString = this.getTaskProperty<Date>(columnSource, child, \"StartDate\");\n                //let startDate = new Date(dateString);\n                dateString = this.isValidDate(dateString) ? dateString : new Date(Date.now());\n\n                let duration = this.getTaskProperty<number>(columnSource, child, \"Duration\");\n\n                let completionValue = this.getTaskProperty<number>(columnSource, child, \"Completion\");\n                let completion = this.convertToDecimal(completionValue);\n                completion = completion <= 1 ? completion : 1;\n\n                let taskType = this.getTaskProperty<string>(columnSource, child, \"Legend\");\n                let tasksTypeColor: string = colorHelper.getColorForMeasure(dataView.metadata.objects, taskType);\n\n                let task: Task = {\n                    id: index,\n                    name: this.getTaskProperty<string>(columnSource, child, \"Task\"),\n                    start: dateString ? dateString : new Date(Date.now()),\n                    duration: duration > 0 ? duration : 1,\n                    end: null,\n                    completion: completion > 0 ? completion : 0,\n                    resource: this.getTaskProperty<string>(columnSource, child, \"Resource\"),\n                    taskType: taskType,\n                    color: tasksTypeColor ? tasksTypeColor : Gantt.DefaultValues.TaskColor, /* get color by task type  */\n                    tooltipInfo: null,\n                    description: \"\",\n                    identity: SelectionId.createWithIdAndMeasure(categories.identity[index], taskType),\n                    selected: false\n                };\n\n                task.end = d3.time.day.offset(task.start, task.duration);\n                task.tooltipInfo = this.getTooltipInfo(task, formatters);\n                return task;\n            });\n        }\n\n        /**\n        * Gets all unique types from the tasks array\n        * @param dataView The data model.\n        */\n        private static getAllTasksTypes(dataView: DataView): TaskTypes {\n            let types: string[] = [];\n            let groupName: string = \"\";\n            let taskTypes: TaskTypes;\n            let data = dataView.table.rows;\n            let index = _.findIndex(dataView.table.columns, col => col.roles.hasOwnProperty(\"Legend\"));\n\n            if (index !== -1) {\n                groupName = dataView.table.columns[index].displayName;\n                types = _.unique(data, (d) => d[index]).map((d) => d[index]);\n            }\n\n            taskTypes = {\n                typeName: groupName,\n                types: types\n            };\n\n            return taskTypes;\n        }\n\n        /**\n        * Get the tooltip info (data display names & formated values)\n        * @param task All task attributes.\n        * @param formatters Formatting options for gantt attributes.\n        */\n        private getTooltipInfo(task: Task, formatters: GanttChartFormatters, timeInterval: string = \"Days\") {\n            let tooltipDataArray: TooltipDataItem[] = [];\n\n            if (task.taskType)\n                tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[0].name, value: task.taskType });\n\n            tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[1].name, value: task.name });\n            if (!isNaN(task.start.getDate()))\n                tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[2].name, value: formatters.startDateFormatter.format(task.start.toLocaleDateString()) });\n\n            tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[3].name, value: formatters.durationFormatter.format(task.duration) + \" \" + timeInterval });\n            tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[4].name, value: formatters.completionFormatter.format(task.completion) });\n\n            if (task.resource)\n                tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[5].name, value: task.resource });\n\n            return tooltipDataArray;\n        }\n\n        /**\n         * Get task property from the data view\n         * @param columnSource\n         * @param child\n         * @param propertyName The property to get\n         */\n        private getTaskProperty<T>(columnSource: DataViewMetadataColumn[], child: DataViewTableRow, propertyName: string): T {\n            if (!child ||\n                !columnSource ||\n                !(columnSource.length > 0) ||\n                !columnSource[0].roles)\n                return null;\n\n            let index = columnSource.indexOf(columnSource.filter(x=> x.roles[propertyName])[0]);\n            return index !== -1 ? <T>child[index] : null;\n        }\n\n        /**\n         * Check if dataView has a given role\n         * @param column The dataView headers\n         * @param name The role to find\n         */\n        private hasRole(column: DataViewMetadataColumn, name: string) {\n            var roles = column.roles;\n            return roles && roles[name];\n        }\n\n        /**\n         * Check if task has data for task\n         * @param dataView\n         */\n        private isChartHasTask(dataView: DataView): boolean {\n            if (dataView.table &&\n                dataView.table.columns) {\n                for (let column of dataView.table.columns) {\n                    if (this.hasRole(column, \"Task\")) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Get legend data, calculate position and draw it\n         * @param ganttChartData Data for series and legend\n         */\n        private renderLegend(legendData: LegendData): void {\n            if (!legendData)\n                return;\n\n            if (this.legendObjectProperties) {\n                LegendData.update(legendData, this.legendObjectProperties);\n                var position: string;\n                position = <string>this.legendObjectProperties[legendProps.position];\n\n                if (position)\n                    this.legend.changeOrientation(LegendPosition[position]);\n            }\n\n            let viewport = this.viewport;\n            this.legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });\n            Legend.positionChartArea(this.ganttSvg, this.legend);\n        }\n\n        private parseLegendProperties(dataView: DataView): void {\n            if (!dataView || !dataView.metadata) {\n                this.legendObjectProperties = {};\n                return;\n            }\n\n            this.legendObjectProperties = DataViewObjects.getObject(dataView.metadata.objects, 'legend', {});\n        }\n\n        /**\n        * Called on data change or resizing\n        * @param options The visual option that contains the dataview and the viewport\n        */\n        public update(options: VisualUpdateOptions) {\n            if (!options.dataViews || !options.dataViews[0])\n                return;\n            let dataView = options.dataViews[0];\n\n            if (!this.isChartHasTask(dataView) || options.dataViews[0].table.rows.length === 0) {\n                this.clearViewport();\n                return;\n            }\n\n            this.dataView = dataView;\n            let viewport = options.viewport;\n            this.viewport = viewport;\n            this.updateChartSize(viewport);\n\n            let viewModel: GanttViewModel = Gantt.converter(dataView, this.colors),\n                formatters: GanttChartFormatters = this.parseSettings(dataView),\n                tasks: Task[] = this.createTasks(dataView, formatters);\n\n            this.parseLegendProperties(dataView);\n            this.renderLegend(viewModel.legendData);\n            this.data.series = this.createSeries(dataView.metadata.objects, tasks);\n            this.viewModel = viewModel;\n\n            if (this.interactivityService) {\n                this.interactivityService.applySelectionStateToData(tasks);\n                this.interactivityService.applySelectionStateToData(this.data.series);\n            }\n\n            if (tasks.length > 0) {\n                let tasksSortedByStartDate: Task[] = _.sortBy(tasks, (t) => t.start);\n                let tasksSortedByEndDate: Task[] = _.sortBy(tasks, (t) => t.end);\n                let dateTypeMilliseconds = this.getDateType();\n\n                let startDate: Date = tasksSortedByStartDate[0].start,\n                    endDate: Date = tasksSortedByEndDate[tasks.length - 1].end,\n                    ticks = Math.ceil(Math.round(endDate.valueOf() - startDate.valueOf()) / dateTypeMilliseconds);\n\n                ticks = ticks === 0 || ticks === 1 ? 2 : ticks;\n                let axisLength = ticks * 50;\n                this.ganttSvg\n                    .attr({\n                        height: PixelConverter.toString(tasks.length * ChartLineHeight + this.margin.top),\n                        width: PixelConverter.toString(this.margin.left + this.viewModel.taskLabelsWidth + axisLength + Gantt.DefaultValues.ResourceWidth)\n                    });\n\n                let viewportIn: IViewport = {\n                    height: viewport.height,\n                    width: axisLength\n                };\n\n                let xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, startDate, endDate, axisLength, ticks, false);\n                this.timeScale = <D3.Scale.TimeScale>xAxisProperties.scale;\n\n                this.renderAxis(xAxisProperties, 200);\n                this.renderTasks(tasks);\n\n                this.createMilestoneLine(tasks);\n                this.updateTaskLabels(tasks, viewModel.taskLabelsWidth);\n                this.updateElementsPositions(viewport, this.margin);\n\n                if (this.interactivityService) {\n                    let behaviorOptions: GanttBehaviorOptions = {\n                        clearCatcher: this.clearCatcher,\n                        taskSelection: this.taskGroup.selectAll(Selectors.SingleTask.selector),\n                        legendSelection: this.body.selectAll(Selectors.LegendItems.selector),\n                        interactivityService: this.interactivityService\n                    };\n                    this.interactivityService.bind(tasks, this.behavior, behaviorOptions);\n                }\n            }\n        }\n        \n        private getDateType(): number {\n            let milliSeconds: number = MillisecondsInWeek;\n\n            switch (this.viewModel.dateType) {\n                case \"Day\":\n                    milliSeconds = MillisecondsInADay;\n                    break;\n\n                case \"Week\":\n                    milliSeconds = MillisecondsInWeek;\n                    break;\n\n                case \"Month\":\n                    milliSeconds = MillisecondsInAMonth;\n                    break;\n\n                case \"Year\":\n                    milliSeconds = MillisecondsInAYear;\n                    break;\n            }\n\n            return milliSeconds;\n        }\n\n        private calculateAxes(\n            viewportIn: IViewport,\n            textProperties: TextProperties,\n            startDate: Date,\n            endDate: Date,\n            axisLength: number,\n            ticksCount: number,\n            scrollbarVisible: boolean): IAxisProperties {\n\n            let dataTypeDatetime = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Date);\n            let category: DataViewMetadataColumn = { displayName: \"StartDate\", queryName: \"StartDate\", type: dataTypeDatetime, index: 0 };\n            let visualOptions: CalculateScaleAndDomainOptions = {\n                viewport: viewportIn,\n                margin: this.margin,\n                forcedXDomain: [startDate, endDate],\n                forceMerge: false,\n                showCategoryAxisLabel: false,\n                showValueAxisLabel: false,\n                categoryAxisScaleType: powerbi.visuals.axisScale.linear,\n                valueAxisScaleType: null,\n                valueAxisDisplayUnits: 0,\n                categoryAxisDisplayUnits: 0,\n                trimOrdinalDataOnOverflow: false,\n                forcedTickCount: ticksCount\n            };\n\n            let width = viewportIn.width;\n            let axes = this.calculateAxesProperties(viewportIn, visualOptions, axisLength, category);\n            axes.willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(\n                axes,\n                width,\n                TextMeasurementService.measureSvgTextWidth,\n                textProperties);\n\n            // If labels do not fit and we are not scrolling, try word breaking\n            axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(\n                axes, this.margin, width, TextMeasurementService.measureSvgTextWidth,\n                TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault,\n                textProperties);\n\n            return axes;\n        }\n\n        private calculateAxesProperties(viewportIn: IViewport, options: CalculateScaleAndDomainOptions, axisLength: number, metaDataColumn: DataViewMetadataColumn): IAxisProperties {\n            let xAxisProperties = AxisHelper.createAxis({\n                pixelSpan: viewportIn.width,\n                dataDomain: options.forcedXDomain,\n                metaDataColumn: metaDataColumn,\n                formatString: Gantt.DefaultValues.ganttFormatString,\n                outerPadding: 0,\n                isScalar: true,\n                isVertical: false,\n                forcedTickCount: options.forcedTickCount,\n                useTickIntervalForDisplayUnits: true,\n                isCategoryAxis: true,\n                getValueFn: (index, type) => {\n                    return valueFormatter.format(new Date(index), Gantt.DefaultValues.ganttFormatString);\n                },\n                scaleType: options.categoryAxisScaleType,\n                axisDisplayUnits: options.categoryAxisDisplayUnits,\n            });\n\n            xAxisProperties.axisLabel = metaDataColumn.displayName;\n            return xAxisProperties;\n        }\n\n        private renderAxis(xAxisProperties: IAxisProperties, duration: number): void {\n            let xAxis = xAxisProperties.axis;\n            xAxis.orient('bottom');\n\n            this.axisGroup.transition().duration(duration).call(xAxis);\n        }\n        /**\n        * Update task labels and add its tooltips \n        * @param tasks All tasks array\n        * @param width The task label width\n        */\n        private updateTaskLabels(tasks: Task[], width: number): void {\n            let axisLabel: D3.UpdateSelection;\n            let taskLineCoordinateX: number = 15;\n            let taskLabelsShow = this.viewModel ? this.viewModel.taskLabelsShow : true;\n            let taskLabelsColor = this.viewModel ? this.viewModel.taskLabelsColor : Gantt.DefaultValues.TaskLabelColor;\n            let taskLabelsFontSize = this.viewModel ? this.viewModel.taskLabelsFontSize : Gantt.DefaultValues.LabelFontSize;\n\n            if (taskLabelsShow) {\n                axisLabel = this.lineGroup.selectAll(Selectors.Label.selector).data(tasks);\n                axisLabel.enter().append(\"text\").classed(Selectors.Label.class, true);\n                axisLabel.attr({\n                    x: taskLineCoordinateX,\n                    y: (task: Task, i: number) => this.getTaskLabelCoordinateY(task.id),\n                    fill: taskLabelsColor,\n                    \"stroke-width\": 1\n                })\n                    .style(\"font-size\", PixelConverter.fromPoint(taskLabelsFontSize))\n                    .text((task) => { return task.name; });\n\n                axisLabel.call(AxisHelper.LabelLayoutStrategy.clip, width - 20, TextMeasurementService.svgEllipsis);\n                axisLabel.append(\"title\").text((task) => { return task.name; });\n                axisLabel.exit().remove();\n            }\n            else {\n                this.lineGroup.selectAll(Selectors.Label.selector).remove();\n            }\n        }\n\n        private renderTasks(tasks: Task[]) {\n            let taskSelection: D3.UpdateSelection = this.taskGroup.selectAll(Selectors.SingleTask.selector).data(tasks);\n            let taskProgressColor = this.viewModel ? this.viewModel.taskProgressColor : Gantt.DefaultValues.ProgressColor;\n            let taskResourceShow = this.viewModel ? this.viewModel.taskResourceShow : true;\n            let padding: number = 4;\n            let taskResourceColor = this.viewModel ? this.viewModel.taskResourceColor : Gantt.DefaultValues.TaskResourceColor;\n            let taskResourceFontSize: number = this.viewModel ? this.viewModel.taskResourceFontSize : Gantt.DefaultValues.ResourceFontSize;\n\n            //render task group container \n            taskSelection.enter().append(\"g\").classed(Selectors.SingleTask.class, true);\n            //render task main rect\n            let taskRect = taskSelection.selectAll(Selectors.TaskRect.selector).data((d: Task) => [d]);\n            taskRect.enter().append(\"rect\").classed(Selectors.TaskRect.class, true);\n            taskRect.classed(Selectors.TaskRect.class, true).attr({\n                x: (task: Task) => this.timeScale(task.start),\n                y: (task: Task) => this.getBarYCoordinate(task.id),\n                width: (task: Task) => this.taskDurationToWidth(task),\n                height: () => this.getBarHeight()\n            }).style(\"fill\", (task: Task) => task.color);\n            taskRect.exit().remove();\n\n            //render task progress rect \n            let taskProgress = taskSelection.selectAll(Selectors.TaskProgress.selector).data((d: Task) => [d]);\n            taskProgress.enter().append(\"rect\").classed(Selectors.TaskProgress.class, true);\n            taskProgress.attr({\n                x: (task: Task) => this.timeScale(task.start),\n                y: (task: Task) => this.getBarYCoordinate(task.id) + this.getBarHeight() / 2 - Gantt.DefaultValues.ProgressBarHeight / 2,\n                width: (task: Task) => this.setTaskProgress(task),\n                height: Gantt.DefaultValues.ProgressBarHeight\n            }).style(\"fill\", taskProgressColor);\n            taskProgress.exit().remove();\n\n            if (taskResourceShow) {\n                //render task resource labels\n                let taskResource = taskSelection.selectAll(Selectors.TaskResource.selector).data((d: Task) => [d]);\n                taskResource.enter().append(\"text\").classed(Selectors.TaskResource.class, true);\n                taskResource.attr({\n                    x: (task: Task) => this.timeScale(task.end) + padding,\n                    y: (task: Task) => (this.getBarYCoordinate(task.id) + (this.getBarHeight() / 2) + padding)\n                })\n                    .text((task: Task) => task.resource)\n                    .style({\n                        fill: taskResourceColor,\n                        \"font-size\": PixelConverter.fromPoint(taskResourceFontSize)\n                    }).call(AxisHelper.LabelLayoutStrategy.clip,\n                    Gantt.DefaultValues.ResourceWidth - 10,\n                    TextMeasurementService.svgEllipsis);\n\n                taskResource.exit().remove();\n            }\n            else {\n                taskSelection.selectAll(Selectors.TaskResource.selector).remove();\n            }\n\n            TooltipManager.addTooltip(taskSelection, (tooltipEvent: TooltipEvent) => (<Task>tooltipEvent.data).tooltipInfo);\n            taskSelection.exit().remove();\n        }\n\n        public onClearSelection() {\n            this.selectionManager.clear();\n        }\n\n        /**\n         * Returns the matching Y coordinate for a given task index \n         * @param taskIndex Task Number\n         */\n        private getTaskLabelCoordinateY(taskIndex: number): number {\n            let fontSize: number = +this.getTaskLabelFontSize();\n            return (ChartLineHeight * taskIndex) + (this.getBarHeight() + 5 - (40 - fontSize) / 4);\n        }\n\n        /**\n         * Set the task progress bar in the gantt\n         * @param task All task attributes\n         */\n        private setTaskProgress(task: Task): number {\n            let fraction = task.completion / 1.0,\n                y = this.timeScale,\n                progress = (y(task.end) - y(task.start)) * fraction;\n\n            return progress;\n        }\n\n        /**\n         * Set the task progress bar in the gantt\n         * @param lineNumber Line number that represents the task number\n         */\n        private getBarYCoordinate(lineNumber: number): number {\n            return (ChartLineHeight * lineNumber) + (PaddingTasks);\n        }\n\n        private getBarHeight(): number {\n            return ChartLineHeight / 1.5;\n        }\n\n        /**\n        * convert task duration to width in the time scale\n        * @param task The task to convert\n        */\n        private taskDurationToWidth(task: Task): number {\n            return this.timeScale(task.end) - this.timeScale(task.start);\n        }\n\n        private getTooltipForMilstoneLine(timestamp: number, milestoneTitle: string): TooltipDataItem[] {\n            let stringDate = new Date(timestamp).toDateString();\n            let tooltip: TooltipDataItem[] = [{ displayName: milestoneTitle, value: stringDate }];\n            return tooltip;\n        }\n\n        /**\n        * Create vertical dotted line that represent milestone in the time axis (by default it shows not time)\n        * @param tasks All tasks array\n        * @param timestamp the milestone to be shown in the time axis (default Date.now())\n        */\n        private createMilestoneLine(tasks: Task[], milestoneTitle: string = \"Today\", timestamp: number = Date.now()): void {\n            let line: Line[] = [{\n                x1: this.timeScale(timestamp),\n                y1: 0,\n                x2: this.timeScale(timestamp),\n                y2: this.getMilestoneLineLength(tasks.length),\n                tooltipInfo: this.getTooltipForMilstoneLine(timestamp, milestoneTitle)\n            }];\n\n            let chartLineSelection: D3.UpdateSelection = this.chartGroup.selectAll(Selectors.ChartLine.selector).data(line);\n            chartLineSelection.enter().append(\"line\").classed(Selectors.ChartLine.class, true);\n            chartLineSelection.attr({\n                x1: (line: Line) => line.x1,\n                y1: (line: Line) => line.y1,\n                x2: (line: Line) => line.x2,\n                y2: (line: Line) => line.y2,\n                tooltipInfo: (line: Line) => line.tooltipInfo\n            });\n\n            TooltipManager.addTooltip(chartLineSelection, (tooltipEvent: TooltipEvent) => (<Line>tooltipEvent.data).tooltipInfo);\n            chartLineSelection.exit().remove();\n        }\n\n        private updateElementsPositions(viewport: IViewport, margin: IMargin): void {\n            let viewModel = this.viewModel;\n            this.axisGroup.attr(\"transform\", SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, 15));\n            this.chartGroup.attr(\"transform\", SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, margin.top));\n            this.lineGroup.attr(\"transform\", SVGUtil.translate(0, margin.top));\n        }\n       \n        /**\n         * Returns the width of the now line based on num of tasks\n         * @param numOfTasks Number of tasks\n         */\n        private getMilestoneLineLength(numOfTasks: number): number {\n            return numOfTasks * ChartLineHeight;\n        }\n\n        private getTaskLabelFontSize(): number {\n            return DataViewObjects.getValue<number>(this.dataView.metadata.objects, GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize);\n        }\n            \n        /** \n         * handle \"Legend\" card\n         * @param enumeration The instance to be pushed into \"Legend\" card\n         * @param objects Dataview objects\n         */\n        private enumerateLegendOptions(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\n            enumeration.pushInstance({\n                displayName: GanttChartProps.legend.show.objectName,\n                selector: null,\n                properties: {\n                    show: DataViewObjects.getValue<boolean>(objects, GanttChartProps.legend.show, true),\n                    position: DataViewObjects.getValue<boolean>(objects, GanttChartProps.legend.position, true), //TODO: change type of prop\n                    showTitle: DataViewObjects.getValue<boolean>(objects, GanttChartProps.legend.showTitle, true),\n                    titleText: DataViewObjects.getValue<string>(objects, GanttChartProps.legend.titleText, \"\"), //TODO: default text ?\n                    labelColor: DataViewObjects.getFillColor(objects, GanttChartProps.legend.labelColor, Gantt.DefaultValues.LegendLabelColor),\n                    fontSize: DataViewObjects.getValue<number>(objects, GanttChartProps.legend.fontSize, Gantt.DefaultValues.LegendFontSize)\n                },\n                objectName: GanttChartProps.legend.show.objectName\n            });\n        }\n\n        /** \n        * handle \"Data Colors\" card\n        * @param enumeration The instance to be pushed into \"Data Colors\" card\n        * @param objects Dataview objects\n        */\n        private enumerateDataPoints(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\n            let taskSeries: GanttSeries[] = this.data.series;\n\n            taskSeries.forEach((item: GanttSeries) => {\n                enumeration.pushInstance({\n                    objectName: 'dataPoint',\n                    displayName: item.name,\n                    selector: ColorHelper.normalizeSelector(item.identity.getSelector(), false),\n                    properties: {\n                        fill: { solid: { color: item.fill } }\n                    }\n                });\n            });\n        }\n            \n        /** \n        * handle \"Task Completion\" card\n        * @param enumeration The instance to be pushed into \"Task Completion\" card\n        * @param objects Dataview objects\n        */\n        private enumerateTaskCompletion(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\n            enumeration.pushInstance({\n                selector: null,\n                properties: {\n                    fill: DataViewObjects.getFillColor(objects, GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor)\n                },\n                objectName: GanttChartProps.taskCompletion.fill.objectName\n            });\n        }\n        \n        /** \n        * handle \"Labels\" card\n        * @param enumeration The instance to be pushed into \"Data Labels\" card\n        * @param objects Dataview objects\n        */\n        private enumerateTaskLabels(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\n            enumeration.pushInstance({\n                selector: null,\n                properties: {\n                    show: DataViewObjects.getValue<boolean>(objects, GanttChartProps.taskLabels.show, true),\n                    fill: DataViewObjects.getFillColor(objects, GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor),\n                    fontSize: DataViewObjects.getValue<number>(objects, GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize),\n                    width: DataViewObjects.getValue<number>(objects, GanttChartProps.taskLabels.width, Gantt.DefaultValues.TaskLabelWidth),\n                },\n                objectName: GanttChartProps.taskLabels.show.objectName\n            });\n        }\n      \n        /** \n        * handle \"Data Labels\" card\n        * @param enumeration The instance to be pushed into \"Task Resource\" card\n        * @param objects Dataview objects\n        */\n        private enumerateDataLabels(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\n            enumeration.pushInstance({\n                selector: null,\n                properties: {\n                    show: DataViewObjects.getValue<boolean>(objects, GanttChartProps.taskResource.show, true),\n                    fill: DataViewObjects.getFillColor(objects, GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor),\n                    fontSize: DataViewObjects.getValue<number>(objects, GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize)\n                },\n                objectName: GanttChartProps.taskResource.show.objectName\n            });\n        }\n\n        private enumerateDateType(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\n            enumeration.pushInstance({\n                selector: null,\n                properties: {\n                    type: DataViewObjects.getValue<string>(objects, GanttChartProps.ganttDateType.type, DefaultDateType),\n                },\n                objectName: GanttChartProps.ganttDateType.type.objectName\n            });\n        }        \n        /** \n        * handle the property pane options\n        * @param objects Dataview enumerate objects\n        */\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\n            let dataView = this.dataView;\n            if (!dataView)\n                return;\n\n            let enumeration = new ObjectEnumerationBuilder();\n\n            switch (options.objectName) {\n                case 'legend':\n                    this.enumerateLegendOptions(enumeration, dataView.metadata.objects);\n                    break;\n                case 'dataPoint':\n                    this.enumerateDataPoints(enumeration, dataView.metadata.objects);\n                    break;\n                case 'taskLabels':\n                    this.enumerateTaskLabels(enumeration, dataView.metadata.objects);\n                    break;\n                case 'taskCompletion':\n                    this.enumerateTaskCompletion(enumeration, dataView.metadata.objects);\n                    break;\n                case 'taskResource':\n                    this.enumerateDataLabels(enumeration, dataView.metadata.objects);\n                    break;\n                case 'ganttDateType':\n                    this.enumerateDateType(enumeration, dataView.metadata.objects);\n                    break;\n            }\n            return enumeration.complete();\n        }\n    }\n\n    export interface GanttBehaviorOptions {\n        clearCatcher: D3.Selection;\n        taskSelection: D3.Selection;\n        legendSelection: D3.Selection;\n        interactivityService: IInteractivityService;\n    }\n\n    export class GanttChartBehavior implements IInteractiveBehavior {\n        private options: GanttBehaviorOptions;\n\n        public bindEvents(options: GanttBehaviorOptions, selectionHandler: ISelectionHandler) {\n            this.options = options;\n            let clearCatcher = options.clearCatcher;\n\n            options.taskSelection.on('click', (d: SelectableDataPoint) => {\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\n                d3.event.stopPropagation();\n            });\n\n            clearCatcher.on('click', () => {\n                selectionHandler.handleClearSelection();\n            });\n        }\n\n        public renderSelection(hasSelection: boolean) {\n            let options = this.options;\n            let ganttMaxOpacity = Gantt.getMaxTaskOpacity();\n            let ganttMinOpacity = Gantt.getMinTaskOpacity();\n\n            options.taskSelection.style(\"opacity\", (d: SelectableDataPoint) => {\n                return (hasSelection && !d.selected) ? ganttMinOpacity : ganttMaxOpacity;\n            });\n\n        }\n    }\n\n    export class GanttChartWarning implements IVisualWarning {\n        public get code(): string {\n            return \"GanttChartWarning\";\n        }\n\n        public getMessages(resourceProvider: IStringResourceProvider): IVisualErrorMessage {\n            let message: string = \"This visual requires task value\",\n                titleKey: string = \"\",\n                detailKey: string = \"\",\n                visualMessage: IVisualErrorMessage;\n\n            visualMessage = {\n                message: message,\n                title: resourceProvider.get(titleKey),\n                detail: resourceProvider.get(detailKey)\n            };\n\n            return visualMessage;\n        }\n    }\n}","/*\n*  Power BI Visualizations\n*\n*  Copyright (c) Microsoft Corporation\n*  All rights reserved. \n*  MIT License\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n*  The above copyright notice and this permission notice shall be included in \n*  all copies or substantial portions of the Software.\n*\n*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n*  THE SOFTWARE.\n*/\n\nmodule powerbi.visuals.samples {\n\timport ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n\timport createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\n\timport SelectionManager = utility.SelectionManager;\n\timport px = jsCommon.PixelConverter.toString;\n\timport pt = jsCommon.PixelConverter.fromPoint;\n\timport fromPointToPixel = jsCommon.PixelConverter.fromPointToPixel;\n\n\texport const Months: IEnumType = createEnumType([\n\t\t{ value: 1, displayName: 'January' },\n\t\t{ value: 2, displayName: 'February' },\n\t\t{ value: 3, displayName: 'March' },\n\t\t{ value: 4, displayName: 'April' },\n\t\t{ value: 5, displayName: 'May' },\n\t\t{ value: 6, displayName: 'June' },\n\t\t{ value: 7, displayName: 'July' },\n\t\t{ value: 8, displayName: 'August' },\n\t\t{ value: 9, displayName: 'September' },\n\t\t{ value: 10, displayName: 'October' },\n\t\t{ value: 11, displayName: 'November' },\n\t\t{ value: 12, displayName: 'December' }\n\t]);\n\n\texport const WeekDays: IEnumType = createEnumType([\n\t\t{ value: 0, displayName: 'Sunday' },\n\t\t{ value: 1, displayName: 'Monday' },\n\t\t{ value: 2, displayName: 'Tuesday' },\n\t\t{ value: 3, displayName: 'Wednesday' },\n\t\t{ value: 4, displayName: 'Thursday' },\n\t\t{ value: 5, displayName: 'Friday' },\n\t\t{ value: 6, displayName: 'Saturday' }\n\t]);\n\n\texport enum GranularityType {\n\t\tyear,\n\t\tquarter,\n\t\tmonth,\n\t\tweek,\n\t\tday\n\t}\n\n\texport interface GranularityName {\n\t\tgranularityType: GranularityType;\n\t\tname: string;\n\t}\n\n\texport interface TimelineMargins {\n\t\tLeftMargin: number;\n\t\tRightMargin: number;\n\t\tTopMargin: number;\n\t\tBottomMargin: number;\n\t\tCellWidth: number;\n\t\tCellHeight: number;\n\t\tStartXpoint: number;\n\t\tStartYpoint: number;\n\t\tElementWidth: number;\n\t\tMinCellWidth: number;\n\t\tMaxCellHeight: number;\n\t\tPeriodSlicerRectWidth: number;\n\t\tPeriodSlicerRectHeight: number;\n\t}\n\n\texport interface DefaultTimelineProperties {\n\t\tDefaultLabelsShow: boolean;\n\t\tTimelineDefaultTextSize: number;\n\t\tTimelineDefaultCellColor: string;\n\t\tTimelineDefaultCellColorOut: string;\n\t\tTimelineDefaultTimeRangeShow: boolean;\n\t\tDefaultTimeRangeColor: string;\n\t\tDefaultLabelColor: string;\n\t\tDefaultGranularity: GranularityType;\n\t\tDefaultFirstMonth: number;\n\t\tDefaultFirstDay: number;\n\t\tDefaultFirstWeekDay: number;\n\t}\n\n\texport interface TimelineSelectors {\n\t\tTimelineVisual: ClassAndSelector;\n\t\tSelectionRangeContainer: ClassAndSelector;\n\t\ttextLabel: ClassAndSelector;\n\t\tLowerTextCell: ClassAndSelector;\n\t\tUpperTextCell: ClassAndSelector;\n\t\tUpperTextArea: ClassAndSelector;\n\t\tLowerTextArea: ClassAndSelector;\n\t\tRangeTextArea: ClassAndSelector;\n\t\tCellsArea: ClassAndSelector;\n\t\tCursorsArea: ClassAndSelector;\n\t\tMainArea: ClassAndSelector;\n\t\tSelectionCursor: ClassAndSelector;\n\t\tCell: ClassAndSelector;\n\t\tCellRect: ClassAndSelector;\n\t\tVertLine: ClassAndSelector;\n\t\tTimelineSlicer: ClassAndSelector;\n\t\tPeriodSlicerGranularities: ClassAndSelector;\n\t\tPeriodSlicerSelection: ClassAndSelector;\n\t\tPeriodSlicerSelectionRect: ClassAndSelector;\n\t\tPeriodSlicerRect: ClassAndSelector;\n\t}\n\n\texport interface TimelineLabel {\n\t\ttitle: string;\n\t\ttext: string;\n\t\tid: number;\n\t}\n\n\texport interface ExtendedLabel {\n\t\tyearLabels?: TimelineLabel[];\n\t\tquarterLabels?: TimelineLabel[];\n\t\tmonthLabels?: TimelineLabel[];\n\t\tweekLabels?: TimelineLabel[];\n\t\tdayLabels?: TimelineLabel[];\n\t}\n\n\tconst SelectedCellColorProp: DataViewObjectPropertyIdentifier = { objectName: 'cells', propertyName: 'fillSelected' };\n\tconst UnselectedCellColorProp: DataViewObjectPropertyIdentifier = { objectName: 'cells', propertyName: 'fillUnselected' };\n\tconst TimeRangeColorProp: DataViewObjectPropertyIdentifier = { objectName: 'rangeHeader', propertyName: 'fontColor' };\n\tconst TimeRangeSizeProp: DataViewObjectPropertyIdentifier = { objectName: 'rangeHeader', propertyName: 'textSize' };\n\tconst TimeRangeShowProp: DataViewObjectPropertyIdentifier = { objectName: 'rangeHeader', propertyName: 'show' };\n\tconst LabelsColorProp: DataViewObjectPropertyIdentifier = { objectName: 'labels', propertyName: 'fontColor' };\n\tconst LabelsSizeProp: DataViewObjectPropertyIdentifier = { objectName: 'labels', propertyName: 'textSize' };\n\tconst LabelsShowProp: DataViewObjectPropertyIdentifier = { objectName: 'labels', propertyName: 'show' };\n\tconst CalendarMonthProp: DataViewObjectPropertyIdentifier = { objectName: 'calendar', propertyName: 'month' };\n\tconst CalendarDayProp: DataViewObjectPropertyIdentifier = { objectName: 'calendar', propertyName: 'day' };\n\tconst WeekDayProp: DataViewObjectPropertyIdentifier = { objectName: 'weekDay', propertyName: 'day' };\n\tconst GranularityNames: GranularityName[] = [\n\t\t{\n\t\t\tgranularityType: GranularityType.year,\n\t\t\tname: \"year\"\n\t\t}, {\n\t\t\tgranularityType: GranularityType.quarter,\n\t\t\tname: \"quarter\"\n\t\t}, {\n\t\t\tgranularityType: GranularityType.month,\n\t\t\tname: \"month\"\n\t\t}, {\n\t\t\tgranularityType: GranularityType.week,\n\t\t\tname: \"week\"\n\t\t}, {\n\t\t\tgranularityType: GranularityType.day,\n\t\t\tname: \"day\"\n\t\t}];\n\n\texport interface DatePeriod {\n\t\tidentifierArray: (string | number)[];\n\t\tstartDate: Date;\n\t\tendDate: Date;\n\t\tyear: number;\n\t\tweek: number[];\n\t\tfraction: number;\n\t\tindex: number;\n\t}\n\n\texport interface Granularity {\n\t\tgetType(): GranularityType;\n\t\tsplitDate(date: Date): (string | number)[];\n\t\tgetDatePeriods(): DatePeriod[];\n\t\tresetDatePeriods(): void;\n\t\tgetExtendedLabel(): ExtendedLabel;\n\t\tsetExtendedLabel(extendedLabel: ExtendedLabel): void;\n\t\tcreateLabels(granularity: Granularity): TimelineLabel[];\n\t\tsameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean;\n\t\tgenerateLabel(datePeriod: DatePeriod): TimelineLabel;\n\t\taddDate(date: Date, identifierArray: (string | number)[]);\n\t\tsetNewEndDate(date: Date): void;\n\t\tsplitPeriod(index: number, newFraction: number, newDate: Date): void;\n\t}\n\n\texport interface TimelineCursorOverElement {\n\t\tindex: number;\n\t\tdatapoint: TimelineDatapoint;\n\t}\n\n\texport class TimelineGranularity {\n\t\tprivate datePeriods: DatePeriod[] = [];\n\t\tprivate extendedLabel: ExtendedLabel;\n\n\t\t/**\n\t\t* Returns the short month name of the given date (e.g. Jan, Feb, Mar)\n\t\t*/\n\t\tpublic shortMonthName(date: Date): string {\n\t\t\treturn date.toString().split(' ')[1];\n\t\t}\n\n\t\tpublic resetDatePeriods(): void {\n\t\t\tthis.datePeriods = [];\n\t\t}\n\n\t\tpublic getDatePeriods() {\n\t\t\treturn this.datePeriods;\n\t\t}\n\n\t\tpublic getExtendedLabel(): ExtendedLabel {\n\t\t\treturn this.extendedLabel;\n\t\t}\n\n\t\tpublic setExtendedLabel(extendedLabel: ExtendedLabel): void {\n\t\t\tthis.extendedLabel = extendedLabel;\n\t\t}\n\n\t\tpublic createLabels(granularity: Granularity): TimelineLabel[] {\n\t\t\tlet labels: TimelineLabel[] = [];\n\t\t\tlet lastDatePeriod: DatePeriod;\n\t\t\t_.map(this.datePeriods, (x) => {\n\t\t\t\tif (_.isEmpty(labels) || !granularity.sameLabel(x, lastDatePeriod)) {\n\t\t\t\t\tlastDatePeriod = x;\n\t\t\t\t\tlabels.push(granularity.generateLabel(x));\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn labels;\n\t\t}\n\n\t\t/**\n\t\t* Adds the new date into the given datePeriods array\n\t\t* If the date corresponds to the last date period, given the current granularity,\n\t\t* it will be added to that date period. Otherwise, a new date period will be added to the array.\n\t\t* i.e. using Month granularity, Feb 2 2015 corresponds to Feb 3 2015.\n\t\t* It is assumed that the given date does not correspond to previous date periods, other than the last date period\n\t\t*/\n\t\tpublic addDate(date: Date, identifierArray: (string | number)[]): void {\n\t\t\tlet datePeriods: DatePeriod[] = this.getDatePeriods();\n\t\t\tlet lastDatePeriod: DatePeriod = datePeriods[datePeriods.length - 1];\n\t\t\tif (datePeriods.length === 0 || !_.isEqual(lastDatePeriod.identifierArray, identifierArray)) {\n\t\t\t\tif (datePeriods.length > 0)\n\t\t\t\t\tlastDatePeriod.endDate = date;\n\t\t\t\tdatePeriods.push({\n\t\t\t\t\tidentifierArray: identifierArray,\n\t\t\t\t\tstartDate: date,\n\t\t\t\t\tendDate: date,\n\t\t\t\t\tweek: this.determineWeek(date),\n\t\t\t\t\tyear: this.determineYear(date),\n\t\t\t\t\tfraction: 1,\n\t\t\t\t\tindex: datePeriods.length\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t\tlastDatePeriod.endDate = date;\n\t\t}\n\n\t\tpublic setNewEndDate(date: Date): void {\n\t\t\t_.last(this.datePeriods).endDate = date;\n\t\t}\n\n\t\t/**\n\t\t * Splits a given period into two periods.\n\t\t * The new period is added after the index of the old one, while the old one is simply updated.\n\t\t * @param index The index of the date priod to be split\n\t\t * @param newFraction The fraction value of the new date period\n\t\t * @param newDate The date in which the date period is split\n\t\t */\n\t\tpublic splitPeriod(index: number, newFraction: number, newDate: Date): void {\n\t\t\tlet oldDatePeriod: DatePeriod = this.datePeriods[index];\n\t\t\toldDatePeriod.fraction -= newFraction;\n\t\t\tlet newDateObject: DatePeriod = {\n\t\t\t\tidentifierArray: oldDatePeriod.identifierArray,\n\t\t\t\tstartDate: newDate,\n\t\t\t\tendDate: oldDatePeriod.endDate,\n\t\t\t\tweek: this.determineWeek(newDate),\n\t\t\t\tyear: this.determineYear(newDate),\n\t\t\t\tfraction: newFraction,\n\t\t\t\tindex: oldDatePeriod.index + oldDatePeriod.fraction\n\t\t\t};\n\t\t\toldDatePeriod.endDate = newDate;\n\t\t\tthis.datePeriods.splice(index + 1, 0, newDateObject);\n\t\t}\n\n\t\tprivate previousMonth(month: number): number {\n\t\t\treturn (month > 0) ? month - 1 : 11;\n\t\t}\n\n\t\tprivate nextMonth(month: number): number {\n\t\t\treturn (month < 11) ? month + 1 : 0;\n\t\t}\n\n\t\tprivate countWeeks(startDate: Date, endDate: Date): number {\n\t\t\tlet totalDays: number;\n\t\t\tif (endDate.getFullYear() === startDate.getFullYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() >= startDate.getDate())\n\t\t\t\ttotalDays = endDate.getDate() - startDate.getDate();\n\t\t\telse {\n\t\t\t\ttotalDays = endDate.getDate() - 1;\n\t\t\t\tlet lastMonth = this.nextMonth(startDate.getMonth());\n\t\t\t\tlet month = endDate.getMonth();\n\t\t\t\twhile (month !== lastMonth) {\n\t\t\t\t\ttotalDays += new Date(endDate.getFullYear(), month, 0).getDate();\n\t\t\t\t\tmonth = this.previousMonth(month);\n\t\t\t\t}\n\t\t\t\ttotalDays += new Date(endDate.getFullYear(), lastMonth, 0).getDate() - startDate.getDate();\n\t\t\t}\n\t\t\treturn 1 + Math.floor(totalDays / 7);\n\t\t}\n\n\t\tpublic determineWeek(date: Date): number[] {\n\t\t\tvar year = date.getFullYear();\n\t\t\tif (this.inPreviousYear(date))\n\t\t\t\tyear--;\n\t\t\tlet dateOfFirstWeek: Date = Timeline.calendar.getDateOfFirstWeek(year);\n\t\t\tlet weeks: number = this.countWeeks(dateOfFirstWeek, date);\n\t\t\treturn [weeks, year];\n\t\t}\n\n\t\tprivate inPreviousYear(date: Date): boolean {\n\t\t\tlet dateOfFirstWeek: Date = Timeline.calendar.getDateOfFirstWeek(date.getFullYear());\n\t\t\treturn date < dateOfFirstWeek;\n\t\t}\n\n\t\tpublic determineYear(date: Date): number {\n\t\t\tlet firstDay: Date = new Date(date.getFullYear(), Timeline.calendar.getFirstMonthOfYear(), Timeline.calendar.getFirstDayOfYear());\n\t\t\treturn date.getFullYear() - ((firstDay <= date) ? 0 : 1);\n\t\t}\n\t}\n\n\texport class DayGranularity extends TimelineGranularity implements Granularity {\n\t\tpublic getType(): GranularityType {\n\t\t\treturn GranularityType.day;\n\t\t}\n\n\t\tpublic splitDate(date: Date): (string | number)[] {\n\t\t\treturn [this.shortMonthName(date), date.getDate(), date.getFullYear()];\n\t\t}\n\n\t\tpublic sameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean {\n\t\t\treturn firstDatePeriod.startDate.getTime() === secondDatePeriod.startDate.getTime();\n\t\t}\n\n\t\tpublic generateLabel(datePeriod: DatePeriod): TimelineLabel {\n\t\t\treturn {\n\t\t\t\ttitle: this.shortMonthName(datePeriod.startDate) + ' ' + datePeriod.startDate.getDate() + ' - ' + datePeriod.year,\n\t\t\t\ttext: datePeriod.startDate.getDate().toString(),\n\t\t\t\tid: datePeriod.index\n\t\t\t};\n\t\t}\n\t}\n\n\texport class MonthGranularity extends TimelineGranularity implements Granularity {\n\t\tpublic getType(): GranularityType {\n\t\t\treturn GranularityType.month;\n\t\t}\n\n\t\tpublic splitDate(date: Date): (string | number)[] {\n\t\t\treturn [this.shortMonthName(date), date.getFullYear()];\n\t\t}\n\n\t\tpublic sameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean {\n\t\t\treturn this.shortMonthName(firstDatePeriod.startDate) === this.shortMonthName(secondDatePeriod.startDate);\n\t\t}\n\n\t\tpublic generateLabel(datePeriod: DatePeriod): TimelineLabel {\n\t\t\tlet shortMonthName = this.shortMonthName(datePeriod.startDate);\n\t\t\treturn {\n\t\t\t\ttitle: shortMonthName,\n\t\t\t\ttext: shortMonthName,\n\t\t\t\tid: datePeriod.index\n\t\t\t};\n\t\t}\n\t}\n\n\texport class WeekGranularity extends TimelineGranularity implements Granularity {\n\t\tpublic getType(): GranularityType {\n\t\t\treturn GranularityType.week;\n\t\t}\n\n\t\tpublic splitDate(date: Date): (string | number)[] {\n\t\t\treturn this.determineWeek(date);\n\t\t}\n\n\t\tpublic sameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean {\n\t\t\treturn _.isEqual(firstDatePeriod.week, secondDatePeriod.week);\n\t\t}\n\n\t\tpublic generateLabel(datePeriod: DatePeriod): TimelineLabel {\n\t\t\treturn {\n\t\t\t\ttitle: 'Week ' + datePeriod.week[0] + ' - ' + datePeriod.week[1],\n\t\t\t\ttext: 'W' + datePeriod.week[0],\n\t\t\t\tid: datePeriod.index\n\t\t\t};\n\t\t}\n\t}\n\n\texport class QuarterGranularity extends TimelineGranularity implements Granularity {\n\t\t/**\n\t\t * Returns the date's quarter name (e.g. Q1, Q2, Q3, Q4)\n\t\t * @param date A date \n\t\t */\n\t\tprivate quarterText(date: Date): string {\n\t\t\tlet quarter = 3;\n\t\t\tlet year = date.getFullYear();\n\t\t\twhile (date < Timeline.calendar.getQuarterStartDate(year, quarter))\n\t\t\t\tif (quarter > 0)\n\t\t\t\t\tquarter--;\n\t\t\t\telse {\n\t\t\t\t\tquarter = 3;\n\t\t\t\t\tyear--;\n\t\t\t\t}\n\t\t\tquarter++;\n\t\t\treturn 'Q' + quarter;\n\t\t}\n\n\t\tpublic getType(): GranularityType {\n\t\t\treturn GranularityType.quarter;\n\t\t}\n\n\t\tpublic splitDate(date: Date): (string | number)[] {\n\t\t\treturn [this.quarterText(date), date.getFullYear()];\n\t\t}\n\n\t\tpublic sameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean {\n\t\t\treturn this.quarterText(firstDatePeriod.startDate) === this.quarterText(secondDatePeriod.startDate)\n\t\t\t\t&& firstDatePeriod.year === secondDatePeriod.year;\n\t\t}\n\n\t\tpublic generateLabel(datePeriod: DatePeriod): TimelineLabel {\n\t\t\tlet quarter = this.quarterText(datePeriod.startDate);\n\t\t\treturn {\n\t\t\t\ttitle: quarter + ' ' + datePeriod.year,\n\t\t\t\ttext: quarter,\n\t\t\t\tid: datePeriod.index\n\t\t\t};\n\t\t}\n\t}\n\n\texport class YearGranularity extends TimelineGranularity implements Granularity {\n\t\tpublic getType(): GranularityType {\n\t\t\treturn GranularityType.year;\n\t\t}\n\n\t\tpublic splitDate(date: Date): (string | number)[] {\n\t\t\treturn [date.getFullYear()];\n\t\t}\n\n\t\tpublic sameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean {\n\t\t\treturn firstDatePeriod.year === secondDatePeriod.year;\n\t\t}\n\n\t\tpublic generateLabel(datePeriod: DatePeriod): TimelineLabel {\n\t\t\treturn {\n\t\t\t\ttitle: 'Year ' + datePeriod.year,\n\t\t\t\ttext: datePeriod.year.toString(),\n\t\t\t\tid: datePeriod.index\n\t\t\t};\n\t\t}\n\t}\n\n\texport class TimelineGranularityData {\n\t\tprivate dates: Date[];\n\t\tprivate granularities: Granularity[];\n\t\tprivate endingDate: Date;\n\n\t\t/**\n\t\t * Returns the date of the previos day \n\t\t * @param date The following date\n\t\t */\n\t\tpublic static previousDay(date: Date): Date {\n\t\t\tlet prevDay: Date = new Date(date.getTime());\n\t\t\tprevDay.setDate(prevDay.getDate() - 1);\n\t\t\treturn prevDay;\n\t\t}\n\n\t\t/**\n\t\t * Returns the date of the next day \n\t\t * @param date The previous date\n\t\t */\n\t\tpublic static nextDay(date: Date): Date {\n\t\t\tlet nextDay: Date = new Date(date.getTime());\n\t\t\tnextDay.setDate(nextDay.getDate() + 1);\n\t\t\treturn nextDay;\n\t\t}\n\n\t\t/**\n\t\t* Returns an array of dates with all the days between the start date and the end date\n\t\t*/\n\t\tprivate setDatesRange(startDate: Date, endDate: Date): void {\n\t\t\tthis.dates = [];\n\t\t\tlet date: Date = startDate;\n\t\t\twhile (date <= endDate) {\n\t\t\t\tthis.dates.push(date);\n\t\t\t\tdate = TimelineGranularityData.nextDay(date);\n\t\t\t}\n\t\t}\n\n\t\tconstructor(startDate: Date, endDate: Date) {\n\t\t\tthis.granularities = [];\n\t\t\tthis.setDatesRange(startDate, endDate);\n\t\t\tlet lastDate: Date = this.dates[this.dates.length - 1];\n\t\t\tthis.endingDate = TimelineGranularityData.nextDay(lastDate);\n\t\t}\n\n\t\t/**\n\t\t * Adds a new granularity to the array of granularities.\n\t\t * Resets the new granularity, adds all dates to it, and then edits the last date period with the ending date.\n\t\t * @param granularity The new granularity to be added\n\t\t */\n\t\tpublic addGranularity(granularity: Granularity): void {\n\t\t\tgranularity.resetDatePeriods();\n\t\t\tfor (let date of this.dates) {\n\t\t\t\tlet identifierArray: (string | number)[] = granularity.splitDate(date);\n\t\t\t\tgranularity.addDate(date, identifierArray);\n\t\t\t}\n\t\t\tgranularity.setNewEndDate(this.endingDate);\n\t\t\tthis.granularities.push(granularity);\n\t\t}\n\n\t\t/**\n\t\t * Returns a specific granularity from the array of granularities\n\t\t * @param index The index of the requested granularity\n\t\t */\n\t\tpublic getGranularity(index: number): Granularity {\n\t\t\treturn this.granularities[index];\n\t\t}\n\n\t\tpublic createGranularities(): void {\n\t\t\tthis.granularities = [];\n\t\t\tthis.addGranularity(new YearGranularity());\n\t\t\tthis.addGranularity(new QuarterGranularity());\n\t\t\tthis.addGranularity(new MonthGranularity());\n\t\t\tthis.addGranularity(new WeekGranularity());\n\t\t\tthis.addGranularity(new DayGranularity());\n\t\t}\n\n\t\tpublic createLabels(): void {\n\t\t\tthis.granularities.forEach((x) => {\n\t\t\t\tx.setExtendedLabel({\n\t\t\t\t\tdayLabels: x.getType() >= GranularityType.day ? x.createLabels(this.granularities[GranularityType.day]) : [],\n\t\t\t\t\tweekLabels: x.getType() >= GranularityType.week ? x.createLabels(this.granularities[GranularityType.week]) : [],\n\t\t\t\t\tmonthLabels: x.getType() >= GranularityType.month ? x.createLabels(this.granularities[GranularityType.month]) : [],\n\t\t\t\t\tquarterLabels: x.getType() >= GranularityType.quarter ? x.createLabels(this.granularities[GranularityType.quarter]) : [],\n\t\t\t\t\tyearLabels: x.getType() >= GranularityType.year ? x.createLabels(this.granularities[GranularityType.year]) : [],\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\texport class Utils {\n\t\t/**\n\t\t * Returns the date of the start of the selection\n\t\t * @param timelineData The TimelineData which contains all the date periods\n\t\t */\n\t\tpublic static getStartSelectionDate(timelineData: TimelineData): Date {\n\t\t\treturn timelineData.currentGranularity.getDatePeriods()[timelineData.selectionStartIndex].startDate;\n\t\t}\n\n\t\t/**\n\t\t * Returns the date of the end of the selection\n\t\t * @param timelineData The TimelineData which contains all the date periods\n\t\t */\n\t\tpublic static getEndSelectionDate(timelineData: TimelineData): Date {\n\t\t\treturn timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex].endDate;\n\t\t}\n\n\t\t/**\n\t\t * Returns the date period of the end of the selection\n\t\t * @param timelineData The TimelineData which contains all the date periods\n\t\t */\n\t\tpublic static getEndSelectionPeriod(timelineData: TimelineData): DatePeriod {\n\t\t\treturn timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex];\n\t\t}\n\n\t\t/**\n\t\t * Returns the color of a cell, depending on whether its date period is between the selected date periods\n\t\t * @param d The TimelineDataPoint of the cell\n\t\t * @param timelineData The TimelineData with the selected date periods\n\t\t * @param timelineFormat The TimelineFormat with the chosen colors\n\t\t */\n\t\tpublic static getCellColor(d: TimelineDatapoint, timelineData: TimelineData, cellFormat: CellFormat): string {\n\t\t\tlet inSelectedPeriods: boolean = d.datePeriod.startDate >= Utils.getStartSelectionDate(timelineData) && d.datePeriod.endDate <= Utils.getEndSelectionDate(timelineData);\n\t\t\treturn inSelectedPeriods ? cellFormat.colorInProperty : cellFormat.colorOutProperty;\n\t\t}\n\n\t\t/**\n\t\t * Returns the granularity type of the given granularity name\n\t\t * @param granularityName The name of the granularity\n\t\t */\n\t\tpublic static getGranularityType(granularityName: string): GranularityType {\n\t\t\tlet index: number = _.findIndex(GranularityNames, x => x.name === granularityName);\n\t\t\treturn GranularityNames[index].granularityType;\n\t\t}\n\n\t\t/**\n\t\t * Returns the name of the granularity type\n\t\t * @param granularity The type of granularity\n\t\t */\n\t\tpublic static getGranularityName(granularity: GranularityType): string {\n\t\t\tlet index: number = _.findIndex(GranularityNames, x => x.granularityType === granularity);\n\t\t\treturn GranularityNames[index].name;\n\t\t}\n\n\t\t/**\n\t\t * Splits the date periods of the current granularity, in case the stard and end of the selection is in between a date period.\n\t\t * i.e. for a quarter granularity and a selection between Feb 6 and Dec 23, the date periods for Q1 and Q4 will be split accordingly\n\t\t * @param timelineData The TimelineData that contains the date periods\n\t\t * @param startDate The starting date of the selection\n\t\t * @param endDate The ending date of the selection\n\t\t */\n\t\tpublic static separateSelection(timelineData: TimelineData, startDate: Date, endDate: Date): void {\n\t\t\tlet datePeriods: DatePeriod[] = timelineData.currentGranularity.getDatePeriods();\n\t\t\tlet startDateIndex: number = _.findIndex(datePeriods, x => startDate < x.endDate);\n\t\t\tlet endDateIndex: number = _.findIndex(datePeriods, x => endDate <= x.endDate);\n\t\t\ttimelineData.selectionStartIndex = startDateIndex;\n\t\t\ttimelineData.selectionEndIndex = endDateIndex;\n\t\t\tlet startRatio: number = Utils.getDateRatio(datePeriods[startDateIndex], startDate, true);\n\t\t\tlet endRatio: number = Utils.getDateRatio(datePeriods[endDateIndex], endDate, false);\n\t\t\tif (endRatio > 0)\n\t\t\t\ttimelineData.currentGranularity.splitPeriod(endDateIndex, endRatio, endDate);\n\t\t\tif (startRatio > 0) {\n\t\t\t\tlet startFration: number = datePeriods[startDateIndex].fraction - startRatio;\n\t\t\t\ttimelineData.currentGranularity.splitPeriod(startDateIndex, startFration, startDate);\n\t\t\t\ttimelineData.selectionStartIndex++;\n\t\t\t\ttimelineData.selectionEndIndex++;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Returns the ratio of the given date compared to the whole date period.\n\t\t * The ratio is calculated either from the start or the end of the date period.\n\t\t * i.e. the ratio of Feb 7 2016 compared to the month of Feb 2016,\n\t\t * is 0.2142 from the start of the month, or 0.7857 from the end of the month.\n\t\t * @param datePeriod The date period that contain the specified date\n\t\t * @param date The date\n\t\t * @param fromStart Whether to calculater the ratio from the start of the date period.\n\t\t */\n\t\tpublic static getDateRatio(datePeriod: DatePeriod, date: Date, fromStart: boolean): number {\n\t\t\tlet dateDifference: number = fromStart ? date.getTime() - datePeriod.startDate.getTime() : datePeriod.endDate.getTime() - date.getTime();\n\t\t\tlet periodDifference: number = datePeriod.endDate.getTime() - datePeriod.startDate.getTime();\n\t\t\treturn periodDifference === 0 ? 0 : dateDifference / periodDifference;\n\t\t}\n\n\t\t/**\n\t\t* Returns the time range text, depending on the given granularity (e.g. \"Feb 3 2014 - Apr 5 2015\", \"Q1 2014 - Q2 2015\")\n\t\t*/\n\t\tpublic static timeRangeText(timelineData: TimelineData): string {\n\t\t\tlet startSelectionDateArray: (string | number)[] = timelineData.currentGranularity.splitDate(Utils.getStartSelectionDate(timelineData));\n\t\t\tlet endSelectionDateArray: (string | number)[] = timelineData.currentGranularity.splitDate(Utils.getEndSelectionPeriod(timelineData).startDate);\n\t\t\treturn startSelectionDateArray.join(' ') + ' - ' + endSelectionDateArray.join(' ');\n\t\t}\n\n\t\tpublic static dateRangeText(datePeriod: DatePeriod): string {\n\t\t\treturn datePeriod.startDate.toDateString() + ' - ' + TimelineGranularityData.previousDay(datePeriod.endDate).toDateString();\n\t\t}\n\n\t\t/**\n\t\t * Combines the first two partial date periods, into a single date period.\n\t\t * Returns whether a partial date period was found.\n\t\t * i.e. combines \"Feb 1 2016 - Feb 5 2016\" with \"Feb 5 2016 - Feb 29 2016\" into \"Feb 1 2016 - Feb 29 2016\"\n\t\t * @param datePeriods The list of date periods\n\t\t */\n\t\tpublic static unseparateSelection(datePeriods: DatePeriod[]): boolean {\n\t\t\tlet separationIndex: number = _.findIndex(datePeriods, x => x.fraction < 1);\n\t\t\tif (separationIndex >= 0) {\n\t\t\t\tdatePeriods[separationIndex].endDate = datePeriods[separationIndex + 1].endDate;\n\t\t\t\tdatePeriods[separationIndex].fraction += datePeriods[separationIndex + 1].fraction;\n\t\t\t\tdatePeriods.splice(separationIndex + 1, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\texport interface TimelineProperties {\n\t\tleftMargin: number;\n\t\trightMargin: number;\n\t\ttopMargin: number;\n\t\tbottomMargin: number;\n\t\ttextYPosition: number;\n\t\tstartXpoint: number;\n\t\tstartYpoint: number;\n\t\telementWidth: number;\n\t\telement: any;\n\t\tcellWidth: number;\n\t\tcellHeight: number;\n\t\tcellsYPosition: number;\n\t}\n\n\texport interface TimelineFormat {\n\t\tcellFormat?: CellFormat;\n\t\trangeTextFormat?: LabelFormat;\n\t\tlabelFormat?: LabelFormat;\n\t\tcalendarFormat?: CalendarFormat;\n\t}\n\n\texport interface LabelFormat {\n\t\tshowProperty: boolean;\n\t\tsizeProperty: number;\n\t\tcolorProperty: string;\n\t}\n\n\texport interface CalendarFormat {\n\t\tfirstMonthProperty: number;\n\t\tfirstDayProperty: number;\n\t\tweekDayProperty: number;\n\t}\n\n\texport interface CellFormat {\n\t\tcolorInProperty: string;\n\t\tcolorOutProperty: string;\n\t}\n\n\texport interface TimelineData {\n\t\tdragging?: boolean;\n\t\tcategorySourceName?: string;\n\t\tcolumnIdentity?: powerbi.data.SQColumnRefExpr;\n\t\ttimelineDatapoints?: TimelineDatapoint[];\n\t\telementsCount?: number;\n\t\tselectionStartIndex?: number;\n\t\tselectionEndIndex?: number;\n\t\tcursorDataPoints?: CursorDatapoint[];\n\t\tcurrentGranularity?: Granularity;\n\t}\n\n\texport interface CursorDatapoint {\n\t\tx: number;\n\t\tcursorIndex: number;\n\t\tselectionIndex: number;\n\t}\n\n\texport interface TimelineDatapoint {\n\t\tindex: number;\n\t\tdatePeriod: DatePeriod;\n\t}\n\n\texport interface DateDictionary {\n\t\t[year: number]: Date;\n\t}\n\n\texport class Calendar {\n\t\tprivate firstDayOfWeek: number;\n\t\tprivate firstMonthOfYear: number;\n\t\tprivate firstDayOfYear: number;\n\t\tprivate dateOfFirstWeek: DateDictionary;\n\t\tprivate quarterFirstMonths: number[];\n\n\t\tpublic getFirstDayOfWeek(): number {\n\t\t\treturn this.firstDayOfWeek;\n\t\t}\n\n\t\tpublic getFirstMonthOfYear(): number {\n\t\t\treturn this.firstMonthOfYear;\n\t\t}\n\n\t\tpublic getFirstDayOfYear(): number {\n\t\t\treturn this.firstDayOfYear;\n\t\t}\n\n\t\tpublic getQuarterStartDate(year: number, quarterIndex: number): Date {\n\t\t\treturn new Date(year, this.quarterFirstMonths[quarterIndex], this.firstDayOfYear);\n\t\t}\n\n\t\tpublic isChanged(calendarFormat: CalendarFormat): boolean {\n\t\t\treturn this.firstMonthOfYear !== (calendarFormat.firstMonthProperty - 1)\n\t\t\t\t|| this.firstDayOfYear !== calendarFormat.firstDayProperty\n\t\t\t\t|| this.firstDayOfWeek !== calendarFormat.weekDayProperty;\n\t\t}\n\n\t\tconstructor(calendarFormat: CalendarFormat) {\n\t\t\tthis.firstDayOfWeek = calendarFormat.weekDayProperty;\n\t\t\tthis.firstMonthOfYear = calendarFormat.firstMonthProperty - 1;\n\t\t\tthis.firstDayOfYear = calendarFormat.firstDayProperty;\n\t\t\tthis.dateOfFirstWeek = {};\n\t\t\tthis.quarterFirstMonths = [0, 3, 6, 9].map((x) => x + this.firstMonthOfYear);\n\t\t}\n\n\t\tprivate calculateDateOfFirstWeek(year: number): Date {\n\t\t\tlet date: Date = new Date(year, this.firstMonthOfYear, this.firstDayOfYear);\n\t\t\twhile (date.getDay() !== this.firstDayOfWeek)\n\t\t\t\tdate = TimelineGranularityData.nextDay(date);\n\t\t\treturn date;\n\t\t}\n\n\t\tpublic getDateOfFirstWeek(year: number): Date {\n\t\t\tif (!this.dateOfFirstWeek[year])\n\t\t\t\tthis.dateOfFirstWeek[year] = this.calculateDateOfFirstWeek(year);\n\t\t\treturn this.dateOfFirstWeek[year];\n\t\t}\n\t}\n\n\texport class Timeline implements IVisual {\n\t\tprivate requiresNoUpdate: boolean = false;\n\t\tprivate foreignSelection: boolean = false;\n\t\tprivate timelineProperties: TimelineProperties;\n\t\tprivate timelineFormat: TimelineFormat;\n\t\tprivate timelineData: TimelineData;\n\t\tprivate timelineGranularityData: TimelineGranularityData;\n\t\tprivate hostServices: IVisualHostServices;\n\t\tprivate svg: D3.Selection;\n\t\tprivate timelineDiv: D3.Selection;\n\t\tprivate body: D3.Selection;\n\t\tprivate rangeText: D3.Selection;\n\t\tprivate mainGroupElement: D3.Selection;\n\t\tprivate yearLabelsElement: D3.Selection;\n\t\tprivate quarterLabelsElement: D3.Selection;\n\t\tprivate monthLabelsElement: D3.Selection;\n\t\tprivate weekLabelsElement: D3.Selection;\n\t\tprivate dayLabelsElement: D3.Selection;\n\t\tprivate cellsElement: D3.Selection;\n\t\tprivate cursorGroupElement: D3.Selection;\n\t\tprivate selectorContainer: D3.Selection;\n\t\tprivate options: VisualUpdateOptions;\n\t\tprivate periodSlicerRect: D3.Selection;\n\t\tprivate selectedText: D3.Selection;\n\t\tprivate selector = ['Y', 'Q', 'M', 'W', 'D'];\n\t\tprivate initialized: boolean;\n\t\tprivate selectionManager: SelectionManager;\n\t\tprivate clearCatcher: D3.Selection;\n\t\tprivate dataView: DataView;\n\t\tprivate valueType: string;\n\t\tprivate values: any[];\n\t\tprivate svgWidth: number;\n\t\tprivate newGranularity: GranularityType;\n\t\tpublic static calendar: Calendar;\n\t\tpublic static capabilities: VisualCapabilities = {\n\t\t\tdataRoles: [{\n                name: 'Time',\n                kind: powerbi.VisualDataRoleKind.Grouping,\n                displayName: 'Time'\n            }],\n\t\t\tdataViewMappings: [{\n\t\t\t\tconditions: [\n\t\t\t\t\t{ 'Time': { max: 1 } }\n\t\t\t\t],\n\t\t\t\tcategorical: {\n\t\t\t\t\tcategories: {\n\t\t\t\t\t\tfor: { in: 'Time' },\n\t\t\t\t\t\tdataReductionAlgorithm: { sample: {} }\n\t\t\t\t\t},\n\t\t\t\t\tvalues: {\n\t\t\t\t\t\tselect:\n\t\t\t\t\t\t[{\n\t\t\t\t\t\t\tbind: { to: 'Time' }\n\t\t\t\t\t\t}]\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}],\n\t\t\tobjects: {\n\t\t\t\tgeneral: {\n\t\t\t\t\tdisplayName: 'General',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tformatString: {\n\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\tformatting: {\n\t\t\t\t\t\t\t\t\tformatString: true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tselected: {\n\t\t\t\t\t\t\ttype: { bool: true }\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfilter: {\n\t\t\t\t\t\t\ttype: { filter: {} },\n\t\t\t\t\t\t\trule: {\n\t\t\t\t\t\t\t\toutput: {\n\t\t\t\t\t\t\t\t\tproperty: 'selected',\n\t\t\t\t\t\t\t\t\tselector: ['Time'],\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tcalendar: {\n\t\t\t\t\tdisplayName: 'Fiscal Year Start',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tmonth: {\n\t\t\t\t\t\t\tdisplayName: 'Month',\n\t\t\t\t\t\t\ttype: { enumeration: Months }\n\t\t\t\t\t\t},\n\t\t\t\t\t\tday: {\n\t\t\t\t\t\t\tdisplayName: 'Day',\n\t\t\t\t\t\t\ttype: { numeric: true }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tweekDay: {\n\t\t\t\t\tdisplayName: 'First Day of Week',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tday: {\n\t\t\t\t\t\t\tdisplayName: 'Day',\n\t\t\t\t\t\t\ttype: { enumeration: WeekDays }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trangeHeader: {\n\t\t\t\t\tdisplayName: 'Range Header',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tshow: {\n\t\t\t\t\t\t\tdisplayName: 'Show',\n\t\t\t\t\t\t\ttype: { bool: true }\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfontColor: {\n\t\t\t\t\t\t\tdisplayName: 'Font color',\n\t\t\t\t\t\t\ttype: { fill: { solid: { color: true } } }\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttextSize: {\n\t\t\t\t\t\t\tdisplayName: 'Text Size',\n\t\t\t\t\t\t\ttype: { numeric: true }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcells: {\n\t\t\t\t\tdisplayName: 'Cells',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tfillSelected: {\n\t\t\t\t\t\t\tdisplayName: 'Selected cell color',\n\t\t\t\t\t\t\ttype: { fill: { solid: { color: true } } }\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfillUnselected: {\n\t\t\t\t\t\t\tdisplayName: 'Unselected cell color',\n\t\t\t\t\t\t\ttype: { fill: { solid: { color: true } } }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tlabels: {\n\t\t\t\t\tdisplayName: 'Labels',\n\t\t\t\t\tproperties: {\n\t\t\t\t\t\tshow: {\n\t\t\t\t\t\t\tdisplayName: 'Show',\n\t\t\t\t\t\t\ttype: { bool: true }\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfontColor: {\n\t\t\t\t\t\t\tdisplayName: 'Font color',\n\t\t\t\t\t\t\ttype: { fill: { solid: { color: true } } }\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttextSize: {\n\t\t\t\t\t\t\tdisplayName: 'Text Size',\n\t\t\t\t\t\t\ttype: { numeric: true }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tprivate timelineMargins: TimelineMargins =\n\t\t{\n\t\t\tLeftMargin: 15,\n\t\t\tRightMargin: 15,\n\t\t\tTopMargin: 15,\n\t\t\tBottomMargin: 10,\n\t\t\tCellWidth: 40,\n\t\t\tCellHeight: 25,\n\t\t\tStartXpoint: 10,\n\t\t\tStartYpoint: 20,\n\t\t\tElementWidth: 30,\n\t\t\tMinCellWidth: 30,\n\t\t\tMaxCellHeight: 60,\n\t\t\tPeriodSlicerRectWidth: 15,\n\t\t\tPeriodSlicerRectHeight: 23\n\t\t};\n\n\t\tprivate defaultTimelineProperties: DefaultTimelineProperties =\n\t\t{\n\t\t\tDefaultLabelsShow: true,\n\t\t\tTimelineDefaultTextSize: 9,\n\t\t\tTimelineDefaultCellColor: \"#ADD8E6\",\n\t\t\tTimelineDefaultCellColorOut: \"#FFFFFF\",\n\t\t\tTimelineDefaultTimeRangeShow: true,\n\t\t\tDefaultTimeRangeColor: \"#777777\",\n\t\t\tDefaultLabelColor: \"#777777\",\n\t\t\tDefaultGranularity: GranularityType.month,\n\t\t\tDefaultFirstMonth: 1,\n\t\t\tDefaultFirstDay: 1,\n\t\t\tDefaultFirstWeekDay: 0\n\t\t};\n\n\t\tprivate timelineSelectors: TimelineSelectors =\n\t\t{\n\t\t\tTimelineVisual: createClassAndSelector('Timeline'),\n\t\t\tSelectionRangeContainer: createClassAndSelector('selectionRangeContainer'),\n\t\t\ttextLabel: createClassAndSelector('label'),\n\t\t\tLowerTextCell: createClassAndSelector('lowerTextCell'),\n\t\t\tUpperTextCell: createClassAndSelector('upperTextCell'),\n\t\t\tUpperTextArea: createClassAndSelector('upperTextArea'),\n\t\t\tLowerTextArea: createClassAndSelector('lowerTextArea'),\n\t\t\tRangeTextArea: createClassAndSelector('rangeTextArea'),\n\t\t\tCellsArea: createClassAndSelector('cellsArea'),\n\t\t\tCursorsArea: createClassAndSelector('cursorsArea'),\n\t\t\tMainArea: createClassAndSelector('mainArea'),\n\t\t\tSelectionCursor: createClassAndSelector('selectionCursor'),\n\t\t\tCell: createClassAndSelector('cell'),\n\t\t\tCellRect: createClassAndSelector('cellRect'),\n\t\t\tVertLine: createClassAndSelector('timelineVertLine'),\n\t\t\tTimelineSlicer: createClassAndSelector('timelineSlicer'),\n\t\t\tPeriodSlicerGranularities: createClassAndSelector('periodSlicerGranularities'),\n\t\t\tPeriodSlicerSelection: createClassAndSelector('periodSlicerSelection'),\n\t\t\tPeriodSlicerSelectionRect: createClassAndSelector('periodSlicerSelectionRect'),\n\t\t\tPeriodSlicerRect: createClassAndSelector('periodSlicerRect')\n\t\t};\n\n\t\t/**\n\t\t * Changes the current granularity depending on the given granularity type\n\t\t * Separates the new granularity's date periods which contain the start/end selection\n\t\t * Unseparates the date periods of the previous granularity.\n\t\t * @param granularity The new granularity type\n\t\t */\n\t\tpublic changeGranularity(granularity: GranularityType, startDate: Date, endDate: Date): void {\n\t\t\tif (Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()))\n\t\t\t\tUtils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods());\n\t\t\tthis.timelineData.currentGranularity = this.timelineGranularityData.getGranularity(granularity);\n\t\t\tUtils.separateSelection(this.timelineData, startDate, endDate);\n\t\t}\n\n\t\tpublic init(options: VisualInitOptions): void {\n\t\t\tthis.hostServices = options.host;\n\t\t\tthis.initialized = false;\n\t\t\tlet element = options.element;\n\t\t\tthis.selectionManager = new SelectionManager({ hostServices: options.host });\n\n\t\t\tthis.timelineProperties = {\n\t\t\t\telement: element,\n\t\t\t\ttextYPosition: 50,\n\t\t\t\tcellsYPosition: this.timelineMargins.TopMargin * 3 + 65,\n\t\t\t\ttopMargin: this.timelineMargins.TopMargin,\n\t\t\t\tbottomMargin: this.timelineMargins.BottomMargin,\n\t\t\t\tleftMargin: this.timelineMargins.LeftMargin,\n\t\t\t\tstartXpoint: this.timelineMargins.StartXpoint,\n\t\t\t\tstartYpoint: this.timelineMargins.StartYpoint,\n\t\t\t\tcellWidth: this.timelineMargins.CellWidth,\n\t\t\t\tcellHeight: this.timelineMargins.CellHeight,\n\t\t\t\telementWidth: this.timelineMargins.ElementWidth,\n\t\t\t\trightMargin: this.timelineMargins.RightMargin\n\t\t\t};\n\n\t\t\tthis.body = d3.select(element.get(0));\n\t\t\tthis.timelineDiv = this.body.append('div');\n\t\t\tthis.svg = this.timelineDiv.append('svg').attr('width', px(options.viewport.width)).classed(this.timelineSelectors.TimelineVisual.class, true);\n\t\t\tthis.clearCatcher = appendClearCatcher(this.svg);\n\n\t\t\tthis.clearCatcher.data([this])\n\t\t\t\t.on(\"click\", (timeline: Timeline) => timeline.clear())\n\t\t\t\t.on(\"touchstart\", (timeline: Timeline) => timeline.clear());\n\n\t\t\tthis.rangeText = this.svg.append('g').classed(this.timelineSelectors.RangeTextArea.class, true).append('text');\n\t\t\tthis.mainGroupElement = this.svg.append('g').classed(this.timelineSelectors.MainArea.class, true);\n\t\t\tthis.yearLabelsElement = this.mainGroupElement.append('g');\n\t\t\tthis.quarterLabelsElement = this.mainGroupElement.append('g');\n\t\t\tthis.monthLabelsElement = this.mainGroupElement.append('g');\n\t\t\tthis.weekLabelsElement = this.mainGroupElement.append('g');\n\t\t\tthis.dayLabelsElement = this.mainGroupElement.append('g');\n\t\t\tthis.cellsElement = this.mainGroupElement.append('g').classed(this.timelineSelectors.CellsArea.class, true);\n\t\t\tthis.cursorGroupElement = this.svg.append('g').classed(this.timelineSelectors.CursorsArea.class, true);\n\t\t}\n\n\t\tprivate clear(): void {\n\t\t\tthis.selectionManager.clear();\n\n\t\t\tif (this.timelineData) {\n\t\t\t\tthis.timelineData.selectionStartIndex = 0;\n\t\t\t\tthis.timelineData.selectionEndIndex = this.timelineData.currentGranularity.getDatePeriods().length - 1;\n\t\t\t\tif (_.any(this.timelineData.timelineDatapoints, (x) => x.index % 1 !== 0))\n\t\t\t\t\tthis.selectPeriod(this.timelineData.currentGranularity.getType());\n\t\t\t\telse {\n\t\t\t\t\tTimeline.updateCursors(this.timelineData, this.timelineProperties.cellWidth);\n\t\t\t\t\tthis.fillCells(this.timelineFormat.cellFormat);\n\t\t\t\t\tthis.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition);\n\t\t\t\t\tthis.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);\n\t\t\t\t}\n\t\t\t\tthis.setSelection(this.timelineData);\n\t\t\t}\n\t\t}\n\n\t\tprivate drawGranular(timelineProperties: TimelineProperties): void {\n\t\t\tlet dragPeriodRectState: boolean = false;\n\t\t\tlet startXpoint = timelineProperties.startXpoint;\n\t\t\tlet startYpoint = timelineProperties.startYpoint;\n\t\t\tlet elementWidth = timelineProperties.elementWidth;\n\t\t\tthis.selectorContainer = this.svg.append('g').classed(this.timelineSelectors.TimelineSlicer.class, true);\n\n\t\t\tthis.selectorContainer.on('mouseleave', d => dragPeriodRectState = false);\n\t\t\tlet fillRect = this.selectorContainer.append('rect');\n\t\t\tlet selectorPeriods = this.selector;\n\t\t\tfillRect.attr({\n\t\t\t\theight: px(1),\n\t\t\t\tx: px(startXpoint),\n\t\t\t\ty: px(startYpoint + 2),\n\t\t\t\twidth: px((selectorPeriods.length - 1) * elementWidth)\n\t\t\t});\n\n\t\t\tlet fillVertLine = this.selectorContainer.selectAll(\"vertLines\")\n\t\t\t\t.data(selectorPeriods).enter().append('rect');\n\t\t\tfillVertLine\n\t\t\t\t.classed(this.timelineSelectors.VertLine.class, true)\n\t\t\t\t.attr({\n\t\t\t\t\tx: (d, index) => px(startXpoint + index * elementWidth),\n\t\t\t\t\ty: px(startYpoint),\n\t\t\t\t\twidth: px(2),\n\t\t\t\t\theight: px(3)\n\t\t\t\t})\n\t\t\t\t.style({ 'cursor': 'pointer' });\n\n\t\t\tlet text = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerGranularities.selector)\n\t\t\t\t.data(selectorPeriods)\n\t\t\t\t.enter()\n\t\t\t\t.append(\"text\")\n\t\t\t\t.classed(this.timelineSelectors.PeriodSlicerGranularities.class, true);\n\n\t\t\tlet textLabels: any;\n\t\t\ttextLabels = text.text((d) => d)\n\t\t\t\t.attr({\n\t\t\t\t\tx: (d, index) => px(startXpoint - 3 + index * elementWidth),\n\t\t\t\t\ty: px(startYpoint - 3)\n\t\t\t\t});\n\t\t\tthis.selectedText = this.selectorContainer.append(\"text\").classed(this.timelineSelectors.PeriodSlicerSelection.class, true);\n\t\t\tthis.selectedText.text(Utils.getGranularityName(this.defaultTimelineProperties.DefaultGranularity))\n\t\t\t\t.attr({\n\t\t\t\t\tx: px(startXpoint + 2 * elementWidth),\n\t\t\t\t\ty: px(startYpoint + 17),\n\t\t\t\t});\n\n\t\t\tlet selRects = this.selectorContainer\n\t\t\t\t.selectAll(this.timelineSelectors.PeriodSlicerSelectionRect.selector)\n\t\t\t\t.data(selectorPeriods)\n\t\t\t\t.enter()\n\t\t\t\t.append('rect')\n\t\t\t\t.classed(this.timelineSelectors.PeriodSlicerSelectionRect.class, true);\n\n\t\t\tlet clickHandler: (d: any, index: number) => void = (d: any, index: number) => {\n\t\t\t\tthis.selectPeriod(index);\n\t\t\t\tdragPeriodRectState = true;\n\t\t\t};\n\n\t\t\tselRects.attr({\n\t\t\t\t\tx: (d, index) => px(startXpoint - elementWidth / 2 + index * elementWidth),\n\t\t\t\t\ty: px(3),\n\t\t\t\t\twidth: px(elementWidth),\n\t\t\t\t\theight: px(23)\n\t\t\t\t})\n\t\t\t\t.style({ 'cursor': 'pointer' })\n\t\t\t\t.on('mousedown', clickHandler)\n\t\t\t\t.on('touchstart', clickHandler)\n\t\t\t\t.on('mouseup', () => dragPeriodRectState = false)\n\t\t\t\t.on('touchend', () => dragPeriodRectState = false)\n\t\t\t\t.on(\"mouseover\", (d, index) => {\n\t\t\t\t\tif (dragPeriodRectState) {\n\t\t\t\t\t\tthis.selectPeriod(index);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tlet dragPeriodRect = d3.behavior.drag()\n\t\t\t\t.on(\"dragstart\", function (e, b) {\n\t\t\t\t\tdragPeriodRectState = true;\n\t\t\t\t})\n\t\t\t\t.on(\"dragend\", function (e, b) {\n\t\t\t\t\tdragPeriodRectState = false;\n\t\t\t\t});\n\n\t\t\tthis.periodSlicerRect = this.selectorContainer\n\t\t\t\t.append('rect').classed(this.timelineSelectors.PeriodSlicerRect.class, true)\n\t\t\t\t.attr({\n\t\t\t\t\tx: px(startXpoint - 6 + this.defaultTimelineProperties.DefaultGranularity * elementWidth),\n\t\t\t\t\ty: px(startYpoint - 16),\n\t\t\t\t\trx: px(4),\n\t\t\t\t\twidth: px(15),\n\t\t\t\t\theight: px(23)\n\t\t\t\t})\n\t\t\t\t.on('mouseup', d => dragPeriodRectState = false);\n\t\t\tthis.periodSlicerRect.call(dragPeriodRect);\n\t\t}\n\n\t\tpublic redrawPeriod(granularity: GranularityType): void {\n\t\t\tlet dx = this.timelineMargins.StartXpoint + granularity * this.timelineMargins.ElementWidth;\n\t\t\tthis.periodSlicerRect.transition().attr(\"x\", px(dx - 7));\n\t\t\tthis.selectedText.text(Utils.getGranularityName(granularity));\n\t\t\tlet startDate: Date = Utils.getStartSelectionDate(this.timelineData);\n\t\t\tlet endDate: Date = Utils.getEndSelectionDate(this.timelineData);\n\t\t\tthis.changeGranularity(granularity, startDate, endDate);\n\t\t}\n\n\t\tprivate static setMeasures(labelFormat: LabelFormat, granularityType: GranularityType, datePeriodsCount: number, viewport: IViewport, timelineProperties: TimelineProperties, timelineMargins: TimelineMargins) {\n\t\t\ttimelineProperties.cellsYPosition = timelineProperties.textYPosition;\n\t\t\tlet labelSize = fromPointToPixel(labelFormat.sizeProperty);\n\t\t\tif (labelFormat.showProperty)\n\t\t\t\ttimelineProperties.cellsYPosition += labelSize * 1.5 * (granularityType + 1);\n\t\t\tlet svgHeight = Math.max(0, viewport.height - timelineMargins.TopMargin);\n\t\t\tlet maxHeight = viewport.width - timelineMargins.RightMargin - timelineMargins.MinCellWidth * datePeriodsCount;\n\t\t\tlet height = Math.max(timelineMargins.MinCellWidth, Math.min(timelineMargins.MaxCellHeight, maxHeight, svgHeight - timelineProperties.cellsYPosition - 20));\n\t\t\tlet width = Math.max(timelineMargins.MinCellWidth, (viewport.width - height - timelineMargins.RightMargin) / datePeriodsCount);\n\t\t\ttimelineProperties.cellHeight = height;\n\t\t\ttimelineProperties.cellWidth = width;\n\t\t}\n\n\t\tprivate visualChangeOnly(options: VisualUpdateOptions): boolean {\n\t\t\tif (options && options.dataViews && options.dataViews[0] && options.dataViews[0].metadata &&\n\t\t\t\tthis.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].metadata) {\n\t\t\t\tlet newObjects = options.dataViews[0].metadata.objects;\n\t\t\t\tlet oldObjects = this.options.dataViews[0].metadata.objects;\n\t\t\t\tlet properties = ['rangeHeader', 'cells', 'labels'];\n\t\t\t\tlet metadataChanged = !properties.every((x) => _.isEqual(newObjects ? newObjects[x] : undefined, oldObjects ? oldObjects[x] : undefined));\n\t\t\t\treturn options.suppressAnimations || metadataChanged;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate unavailableType(dataViewCategorical: DataViewCategorical): boolean {\n\t\t\treturn !dataViewCategorical.categories\n\t\t\t\t|| dataViewCategorical.categories.length !== 1\n\t\t\t\t|| !dataViewCategorical.categories[0].values\n\t\t\t\t|| dataViewCategorical.categories[0].values.length === 0\n\t\t\t\t|| !dataViewCategorical.categories[0].source\n\t\t\t\t|| !dataViewCategorical.categories[0].source.type;\n\t\t}\n\n\t\tprivate unavailableChildIdentityField(dataViewTree: DataViewTree): boolean {\n\t\t\treturn !dataViewTree.root || !dataViewTree.root.childIdentityFields || dataViewTree.root.childIdentityFields.length === 0;\n\t\t}\n\n\t\tprivate createTimelineOptions(dataView: DataView): boolean {\n\t\t\tthis.dataView = dataView;\n\t\t\tif (!dataView.categorical\n\t\t\t\t|| !dataView.metadata\n\t\t\t\t|| this.unavailableType(dataView.categorical)\n\t\t\t\t|| !dataView.tree\n\t\t\t\t|| this.unavailableChildIdentityField(dataView.tree))\n\t\t\t\treturn false;\n\t\t\tlet columnExp = <powerbi.data.SQColumnRefExpr>dataView.tree.root.childIdentityFields[0];\n\t\t\tthis.valueType = columnExp ? columnExp.ref : null;\n\t\t\tif (!(dataView.categorical.categories[0].source.type.dateTime ||\n\t\t\t\t(dataView.categorical.categories[0].source.type.numeric && (this.valueType === 'Year' || this.valueType === 'Date'))))\n\t\t\t\treturn false;\n\t\t\tthis.values = this.prepareValues(this.dataView.categorical.categories[0].values);\n\t\t\treturn true;\n\t\t}\n\n\t\t//Public for testability.\n\t\tpublic prepareValues(values) {\n\t\t\t// remove null strings and rebuild string type date \n\t\t\t// (BUG #7266283 IN PBI-service)\n\t\t\tvalues = values.filter(Boolean);\n\t\t\tfor (var i in values) { \n\t\t\t\tvar item = values[i];\n\t\t\t\tif(typeof(item) === 'String' && (String(new Date(item)) !== 'Invalid Date')){\n\t\t\t\t\treturn values[i] = new Date(item);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn values;\n\t\t}\n\n\t\tprivate createTimelineData() {\n\t\t\tlet startDate: Date;\n\t\t\tlet endDate: Date;\n\t\t\tif (this.valueType === 'Year') {\n\t\t\t\tlet years: number[] = this.values;\n\t\t\t\tstartDate = new Date(_.min(years), 0);\n\t\t\t\tendDate = new Date(_.max(years), 11);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet dates: Date[] = this.values;\n\t\t\t\tstartDate = _.min(dates);\n\t\t\t\tendDate = _.max(dates);\n\t\t\t}\n\t\t\tif (!this.initialized)\n\t\t\t\tthis.drawGranular(this.timelineProperties);\n\t\t\tif (this.initialized) {\n\t\t\t\tlet actualEndDate = TimelineGranularityData.nextDay(endDate);\n\t\t\t\tlet daysPeriods = this.timelineGranularityData.getGranularity(GranularityType.day).getDatePeriods();\n\t\t\t\tlet prevStartDate = daysPeriods[0].startDate;\n\t\t\t\tlet prevEndDate = daysPeriods[daysPeriods.length - 1].endDate;\n\t\t\t\tlet changedSelection = startDate.getTime() >= prevStartDate.getTime() && actualEndDate.getTime() <= prevEndDate.getTime();\n\t\t\t\tthis.newGranularity = this.timelineData.currentGranularity.getType();\n\t\t\t\tif (changedSelection) {\n\t\t\t\t\tthis.foreignSelection = true;\n\t\t\t\t\tthis.changeGranularity(this.newGranularity, startDate, actualEndDate);\n\t\t\t\t\tthis.timelineFormat = Timeline.fillTimelineFormat(this.options.dataViews[0].metadata.objects, this.defaultTimelineProperties);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (actualEndDate < prevEndDate)\n\t\t\t\t\t\tendDate = daysPeriods[daysPeriods.length - 1].startDate;\n\t\t\t\t\tif (startDate > prevStartDate)\n\t\t\t\t\t\tstartDate = prevStartDate;\n\t\t\t\t\tthis.initialized = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!this.initialized) {\n\t\t\t\tthis.timelineGranularityData = new TimelineGranularityData(startDate, endDate);\n\t\t\t\tthis.timelineData = {\n\t\t\t\t\telementsCount: 0,\n\t\t\t\t\ttimelineDatapoints: [],\n\t\t\t\t\tcursorDataPoints: new Array<CursorDatapoint>()\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tpublic update(options: VisualUpdateOptions): void {\n\t\t\tlet visualChange: boolean = this.visualChangeOnly(options);\n\t\t\tthis.requiresNoUpdate = this.requiresNoUpdate && !visualChange;\n\t\t\tif (this.requiresNoUpdate) {\n\t\t\t\tif (this.foreignSelection)\n\t\t\t\t\tthis.foreignSelection = false;\n\t\t\t\telse\n\t\t\t\t\tthis.requiresNoUpdate = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.options = options;\n\t\t\tif (!options.dataViews || !options.dataViews[0])\n\t\t\t\treturn;\n\t\t\tlet validOptions: boolean = this.createTimelineOptions(options.dataViews[0]);\n\t\t\tif (!validOptions) {\n\t\t\t\tthis.clearData();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.newGranularity = this.defaultTimelineProperties.DefaultGranularity;\n\t\t\tif (!visualChange)\n\t\t\t\tthis.createTimelineData();\n\t\t\tthis.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, options.dataViews[0], this.initialized, this.newGranularity, options.viewport, this.timelineMargins);\n\t\t\tthis.render(this.timelineData, this.timelineFormat, this.timelineProperties, options);\n\t\t\tthis.initialized = true;\n\t\t}\n\n\t\tpublic selectPeriod(periodNameIndex): void {\n\t\t\tthis.redrawPeriod(periodNameIndex);\n\t\t\tthis.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, this.options.dataViews[0], this.initialized, this.timelineData.currentGranularity.getType(), this.options.viewport, this.timelineMargins);\n\t\t\tthis.render(this.timelineData, this.timelineFormat, this.timelineProperties, this.options);\n\t\t}\n\n\t\tprivate static isDataNotMatch(dataView): boolean {\n\t\t\tif (dataView.categorical.categories.length <= 0 ||\n\t\t\t\tdataView.categorical.categories[0] === undefined ||\n\t\t\t\tdataView.categorical.categories[0].identityFields === undefined ||\n\t\t\t\tdataView.categorical.categories[0].identityFields.length <= 0)\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic static converter(timelineData: TimelineData, timelineProperties: TimelineProperties, defaultTimelineProperties: DefaultTimelineProperties, timelineGranularityData: TimelineGranularityData, dataView: DataView, initialized: boolean, granularityType: GranularityType, viewport: IViewport, timelineMargins: TimelineMargins): TimelineFormat {\n\t\t\tlet timelineFormat = Timeline.fillTimelineFormat(dataView.metadata.objects, defaultTimelineProperties);\n\t\t\tif (!initialized) {\n\t\t\t\ttimelineData.cursorDataPoints.push({ x: 0, selectionIndex: 0, cursorIndex: 0 });\n\t\t\t\ttimelineData.cursorDataPoints.push({ x: 0, selectionIndex: 0, cursorIndex: 1 });\n\t\t\t}\n\t\t\tif (!initialized || Timeline.calendar.isChanged(timelineFormat.calendarFormat)) {\n\t\t\t\tTimeline.calendar = new Calendar(timelineFormat.calendarFormat);\n\t\t\t\ttimelineGranularityData.createGranularities();\n\t\t\t\ttimelineGranularityData.createLabels();\n\t\t\t\ttimelineData.currentGranularity = timelineGranularityData.getGranularity(granularityType);\n\t\t\t\ttimelineData.selectionStartIndex = 0;\n\t\t\t\ttimelineData.selectionEndIndex = timelineData.currentGranularity.getDatePeriods().length - 1;\n\t\t\t}\n\t\t\ttimelineData.categorySourceName = dataView.categorical.categories[0].source.displayName;\n\t\t\ttimelineData.columnIdentity = <powerbi.data.SQColumnRefExpr>dataView.categorical.categories[0].identityFields[0];\n\t\t\tif (dataView.categorical.categories[0].source.type.numeric) {\n\t\t\t\ttimelineData.columnIdentity.ref = \"Date\";\n\t\t\t}\n\t\t\tif (this.isDataNotMatch(dataView))\n\t\t\t\treturn;\n\t\t\tlet timelineElements: DatePeriod[] = timelineData.currentGranularity.getDatePeriods();\n\t\t\ttimelineData.elementsCount = timelineElements.length;\n\t\t\ttimelineData.timelineDatapoints = [];\n\t\t\tfor (let currentTimePeriod of timelineElements) {\n\t\t\t\tlet datapoint: TimelineDatapoint = {\n\t\t\t\t\tindex: currentTimePeriod.index,\n\t\t\t\t\tdatePeriod: currentTimePeriod\n\t\t\t\t};\n\t\t\t\ttimelineData.timelineDatapoints.push(datapoint);\n\t\t\t}\n\t\t\tlet countFullCells = timelineData.currentGranularity.getDatePeriods().filter((x) => x.index % 1 === 0).length;\n\t\t\tTimeline.setMeasures(timelineFormat.labelFormat, timelineData.currentGranularity.getType(), countFullCells, viewport, timelineProperties, timelineMargins);\n\t\t\tTimeline.updateCursors(timelineData, timelineProperties.cellWidth);\n\t\t\treturn timelineFormat;\n\t\t}\n\n\t\tprivate render(timelineData: TimelineData, timelineFormat: TimelineFormat, timelineProperties: TimelineProperties, options: VisualUpdateOptions): void {\n\t\t\tlet timelineDatapointsCount = this.timelineData.timelineDatapoints.filter((x) => x.index % 1 === 0).length;\n\t\t\tthis.svgWidth = 1 + this.timelineProperties.cellHeight + timelineProperties.cellWidth * timelineDatapointsCount;\n\t\t\tthis.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);\n\t\t\tthis.timelineDiv.attr({\n\t\t\t\theight: px(options.viewport.height),\n\t\t\t\twidth: px(options.viewport.width),\n\t\t\t\t'drag-resize-disabled': true\n\t\t\t}).style({\n\t\t\t\t'overflow-x': 'auto',\n\t\t\t\t'overflow-y': 'auto'\n\t\t\t});\n\t\t\tthis.svg.attr({\n\t\t\t\theight: px(Math.max(0, options.viewport.height - this.timelineMargins.TopMargin)),\n\t\t\t\twidth: px(Math.max(0, this.svgWidth))\n\t\t\t});\n\t\t\tlet fixedTranslateString: string = SVGUtil.translate(timelineProperties.leftMargin, timelineProperties.topMargin);\n\t\t\tlet translateString: string = SVGUtil.translate(timelineProperties.cellHeight / 2, timelineProperties.topMargin);\n\t\t\tthis.mainGroupElement.attr('transform', translateString);\n\t\t\tthis.selectorContainer.attr('transform', fixedTranslateString);\n\t\t\tthis.cursorGroupElement.attr('transform', translateString);\n\n\t\t\tlet extendedLabels = this.timelineData.currentGranularity.getExtendedLabel();\n\t\t\tlet granularityType = this.timelineData.currentGranularity.getType();\n\t\t\tlet yPos = 0, yDiff = 1.50;\n\t\t\tthis.renderLabels(extendedLabels.yearLabels, this.yearLabelsElement, yPos, granularityType === 0);\n\t\t\tyPos += yDiff;\n\t\t\tthis.renderLabels(extendedLabels.quarterLabels, this.quarterLabelsElement, yPos, granularityType === 1);\n\t\t\tyPos += yDiff;\n\t\t\tthis.renderLabels(extendedLabels.monthLabels, this.monthLabelsElement, yPos, granularityType === 2);\n\t\t\tyPos += yDiff;\n\t\t\tthis.renderLabels(extendedLabels.weekLabels, this.weekLabelsElement, yPos, granularityType === 3);\n\t\t\tyPos += yDiff;\n\t\t\tthis.renderLabels(extendedLabels.dayLabels, this.dayLabelsElement, yPos, granularityType === 4);\n\t\t\tthis.renderCells(timelineData, timelineFormat, timelineProperties, options.suppressAnimations);\n\t\t\tthis.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);\n\t\t}\n\n\t\tprivate renderLabels(labels: TimelineLabel[], labelsElement: D3.Selection, index: number, isLast: boolean): void {\n\t\t\tlet labelTextSelection = labelsElement.selectAll(this.timelineSelectors.textLabel.selector);\n\t\t\tif (!this.timelineFormat.labelFormat.showProperty) {\n\t\t\t\tlabelTextSelection.remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet labelsGroupSelection = labelTextSelection.data(labels);\n\t\t\tlabelsGroupSelection.enter().append('text').classed(this.timelineSelectors.textLabel.class, true);\n\n\t\t\tlabelsGroupSelection.text((x: TimelineLabel, id: number) => {\n\t\t\t\tif (!isLast && id === 0 && labels.length > 1) {\n\t\t\t\t\tlet fontSize = pt(this.timelineFormat.labelFormat.sizeProperty);\n\t\t\t\t\tlet textProperties: powerbi.TextProperties = {\n\t\t\t\t\t\ttext: labels[0].text,\n\t\t\t\t\t\tfontFamily: 'arial',\n\t\t\t\t\t\tfontSize: fontSize\n\t\t\t\t\t};\n\t\t\t\t\tlet halfFirstTextWidth = TextMeasurementService.measureSvgTextWidth(textProperties) / 2;\n\t\t\t\t\ttextProperties = {\n\t\t\t\t\t\ttext: labels[1].text,\n\t\t\t\t\t\tfontFamily: 'arial',\n\t\t\t\t\t\tfontSize: fontSize\n\t\t\t\t\t};\n\t\t\t\t\tlet halfSecondTextWidth = TextMeasurementService.measureSvgTextWidth(textProperties) / 2;\n\t\t\t\t\tlet diff = this.timelineProperties.cellWidth * (labels[1].id - labels[0].id);\n\t\t\t\t\tif (diff < halfFirstTextWidth + halfSecondTextWidth)\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tlet labelFormattedTextOptions: LabelFormattedTextOptions = {\n\t\t\t\t\tlabel: x.text,\n\t\t\t\t\tmaxWidth: this.timelineProperties.cellWidth * (isLast ? 0.90 : 3),\n\t\t\t\t\tfontSize: this.timelineFormat.labelFormat.sizeProperty\n\t\t\t\t};\n\t\t\t\treturn dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);\n\t\t\t})\n\t\t\t\t.style('font-size', pt(this.timelineFormat.labelFormat.sizeProperty))\n\t\t\t\t.attr({\n\t\t\t\t\tx: (x: TimelineLabel) => (x.id + 0.5) * this.timelineProperties.cellWidth,\n\t\t\t\t\ty: this.timelineProperties.textYPosition + (1 + index) * fromPointToPixel(this.timelineFormat.labelFormat.sizeProperty),\n\t\t\t\t\tfill: this.timelineFormat.labelFormat.colorProperty\n\t\t\t\t}).append('title').text((x: TimelineLabel) => x.title);\n\t\t\tlabelsGroupSelection.exit().remove();\n\t\t}\n\n\t\tprivate clearData(): void {\n\t\t\tthis.initialized = false;\n\t\t\tthis.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).remove();\n\t\t\tthis.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector).remove();\n\t\t\tthis.rangeText.text(\"\");\n\t\t\tthis.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).remove();\n\t\t\tthis.svg.select(this.timelineSelectors.TimelineSlicer.selector).remove();\n\t\t}\n\n\t\tprivate static updateCursors(timelineData: TimelineData, cellWidth: number): void {\n\t\t\tlet startDate: DatePeriod = timelineData.timelineDatapoints[timelineData.selectionStartIndex].datePeriod;\n\t\t\ttimelineData.cursorDataPoints[0].selectionIndex = startDate.index;\n\t\t\tlet endDate: DatePeriod = timelineData.timelineDatapoints[timelineData.selectionEndIndex].datePeriod;\n\t\t\ttimelineData.cursorDataPoints[1].selectionIndex = (endDate.index + endDate.fraction);\n\t\t}\n\n\t\tprivate static fillTimelineFormat(objects: any, timelineProperties: DefaultTimelineProperties): TimelineFormat {\n\t\t\tlet timelineFormat: TimelineFormat =\n\t\t\t\t{\n\t\t\t\t\trangeTextFormat: {\n\t\t\t\t\t\tshowProperty: DataViewObjects.getValue<boolean>(objects, TimeRangeShowProp, timelineProperties.TimelineDefaultTimeRangeShow),\n\t\t\t\t\t\tcolorProperty: DataViewObjects.getFillColor(objects, TimeRangeColorProp, timelineProperties.DefaultTimeRangeColor),\n\t\t\t\t\t\tsizeProperty: DataViewObjects.getValue<number>(objects, TimeRangeSizeProp, timelineProperties.TimelineDefaultTextSize)\n\t\t\t\t\t},\n\t\t\t\t\tcellFormat: {\n\t\t\t\t\t\tcolorInProperty: DataViewObjects.getFillColor(objects, SelectedCellColorProp, timelineProperties.TimelineDefaultCellColor),\n\t\t\t\t\t\tcolorOutProperty: DataViewObjects.getFillColor(objects, UnselectedCellColorProp, timelineProperties.TimelineDefaultCellColorOut)\n\t\t\t\t\t},\n\t\t\t\t\tlabelFormat: {\n\t\t\t\t\t\tshowProperty: DataViewObjects.getValue<boolean>(objects, LabelsShowProp, timelineProperties.DefaultLabelsShow),\n\t\t\t\t\t\tcolorProperty: DataViewObjects.getFillColor(objects, LabelsColorProp, timelineProperties.DefaultLabelColor),\n\t\t\t\t\t\tsizeProperty: DataViewObjects.getValue<number>(objects, LabelsSizeProp, timelineProperties.TimelineDefaultTextSize)\n\t\t\t\t\t},\n\t\t\t\t\tcalendarFormat: {\n\t\t\t\t\t\tfirstMonthProperty: DataViewObjects.getValue<number>(objects, CalendarMonthProp, 1),\n\t\t\t\t\t\tfirstDayProperty: Math.max(1, Math.min(31, DataViewObjects.getValue<number>(objects, CalendarDayProp, timelineProperties.DefaultFirstDay))),\n\t\t\t\t\t\tweekDayProperty: Math.max(0, Math.min(6, DataViewObjects.getValue<number>(objects, WeekDayProp, timelineProperties.DefaultFirstWeekDay)))\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\treturn timelineFormat;\n\t\t}\n\n\t\tpublic fillCells(cellFormat: CellFormat): void {\n\t\t\tlet dataPoints = this.timelineData.timelineDatapoints;\n\t\t\tlet cellSelection = this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).data(dataPoints);\n\t\t\tcellSelection.attr('fill', d => Utils.getCellColor(d, this.timelineData, cellFormat));\n\t\t}\n\n\t\tpublic renderCells(timelineData: TimelineData, timelineFormat: TimelineFormat, timelineProperties: TimelineProperties, suppressAnimations: any): void {\n\t\t\tlet allDataPoints = timelineData.timelineDatapoints;\n\t\t\tlet totalX = 0;\n\t\t\tlet cellsSelection = this.cellsElement.selectAll(this.timelineSelectors.CellRect.selector).data(allDataPoints);\n\t\t\tcellsSelection.enter().append('rect').classed(this.timelineSelectors.CellRect.class, true);\n\t\t\tcellsSelection\n\t\t\t\t.attr({\n\t\t\t\t\theight: px(timelineProperties.cellHeight),\n\t\t\t\t\twidth: (d: TimelineDatapoint) => px(d.datePeriod.fraction * timelineProperties.cellWidth),\n\t\t\t\t\tx: (d: TimelineDatapoint) => {\n\t\t\t\t\t\tlet value = totalX;\n\t\t\t\t\t\ttotalX += d.datePeriod.fraction * timelineProperties.cellWidth;\n\t\t\t\t\t\treturn px(value);\n\t\t\t\t\t},\n\t\t\t\t\ty: px(timelineProperties.cellsYPosition),\n\t\t\t\t\tid: (d: TimelineDatapoint) => d.index\n\t\t\t\t});\n\n\t\t\tlet clickHandler: (d: TimelineDatapoint, index: number) => void = (d: TimelineDatapoint, index: number) => {\n\t\t\t\td3.event.preventDefault();\n\t\t\t\tlet cursorDataPoints = this.timelineData.cursorDataPoints;\n\t\t\t\tlet keyEvent: any = d3.event;\n\t\t\t\tif (keyEvent.altKey || keyEvent.shiftKey) {\n\t\t\t\t\tif (this.timelineData.selectionEndIndex < index) {\n\t\t\t\t\t\tcursorDataPoints[1].selectionIndex = (d.datePeriod.index + d.datePeriod.fraction);\n\t\t\t\t\t\ttimelineData.selectionEndIndex = index;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcursorDataPoints[0].selectionIndex = d.datePeriod.index;\n\t\t\t\t\t\ttimelineData.selectionStartIndex = index;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttimelineData.selectionStartIndex = index;\n\t\t\t\t\ttimelineData.selectionEndIndex = index;\n\t\t\t\t\tcursorDataPoints[0].selectionIndex = d.datePeriod.index;\n\t\t\t\t\tcursorDataPoints[1].selectionIndex = (d.datePeriod.index + d.datePeriod.fraction);\n\t\t\t\t}\n\n\t\t\t\tthis.fillCells(timelineFormat.cellFormat);\n\t\t\t\tthis.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);\n\t\t\t\tthis.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);\n\t\t\t\tthis.setSelection(timelineData);\n\t\t\t};\n\n\t\t\tcellsSelection\n\t\t\t\t.on('click', clickHandler)\n\t\t\t\t.on(\"touchstart\", clickHandler);\n\n\t\t\tthis.fillCells(timelineFormat.cellFormat);\n\t\t\tcellsSelection.exit().remove();\n\t\t}\n\n\t\tpublic dragstarted(): void {\n\t\t\tthis.timelineData.dragging = true;\n\t\t}\n\n\t\tpublic dragged(currentCursor: CursorDatapoint): void {\n\t\t\tif (this.timelineData.dragging === true) {\n\t\t\t\tlet xScale = 1;\n\t\t\t\tlet container = d3.select(this.timelineSelectors.TimelineVisual.selector);\n\n\t\t\t\tif (container) {\n\t\t\t\t\tlet transform = container.style(\"transform\");\n\t\t\t\t\tif (transform !== undefined && transform !== 'none') {\n\t\t\t\t\t\tlet str = transform.split(\"(\")[1];\n\t\t\t\t\t\txScale = Number(str.split(\", \")[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet cursorOverElement: TimelineCursorOverElement = this.findCursorOverElement(d3.event.x);\n\n\t\t\t\tif (!cursorOverElement) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet currentlyMouseOverElement: TimelineDatapoint = cursorOverElement.datapoint,\n\t\t\t\t\tcurrentlyMouseOverElementIndex: number = cursorOverElement.index;\n\n\t\t\t\tif (currentCursor.cursorIndex === 0 && currentlyMouseOverElementIndex <= this.timelineData.selectionEndIndex) {\n\t\t\t\t\tthis.timelineData.selectionStartIndex = currentlyMouseOverElementIndex;\n\t\t\t\t\tthis.timelineData.cursorDataPoints[0].selectionIndex = currentlyMouseOverElement.datePeriod.index;\n\t\t\t\t}\n\n\t\t\t\tif (currentCursor.cursorIndex === 1 && currentlyMouseOverElementIndex >= this.timelineData.selectionStartIndex) {\n\t\t\t\t\tthis.timelineData.selectionEndIndex = currentlyMouseOverElementIndex;\n\t\t\t\t\tthis.timelineData.cursorDataPoints[1].selectionIndex = (currentlyMouseOverElement.datePeriod.index + currentlyMouseOverElement.datePeriod.fraction);\n\t\t\t\t}\n\n\t\t\t\tthis.fillCells(this.timelineFormat.cellFormat);\n\t\t\t\tthis.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition);\n\t\t\t\tthis.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Note: Public for testability.\n\t\t */\n\t\tpublic findCursorOverElement(x: number): TimelineCursorOverElement {\n\t\t\tlet timelineDatapoints: TimelineDatapoint[] = this.timelineData.timelineDatapoints || [],\n\t\t\t\tlength: number = timelineDatapoints.length,\n\t\t\t\tcellWidth: number = this.timelineProperties.cellWidth;\n\n\t\t\tif (timelineDatapoints[0] && timelineDatapoints[1] && x <= timelineDatapoints[1].index * cellWidth) {\n\t\t\t\treturn {\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tdatapoint: timelineDatapoints[0]\n\t\t\t\t};\n\t\t\t} else if (timelineDatapoints[length - 1] && x >= timelineDatapoints[length - 1].index * cellWidth) {\n\t\t\t\treturn {\n\t\t\t\t\tindex: length - 1,\n\t\t\t\t\tdatapoint: timelineDatapoints[length - 1]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfor (let i = 1; i < length; i++) {\n\t\t\t\tlet left: number = timelineDatapoints[i].index * cellWidth,\n\t\t\t\t\tright: number = timelineDatapoints[i + 1].index * cellWidth;\n\n\t\t\t\tif (x >= left && x <= right) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tdatapoint: timelineDatapoints[i]\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic dragended(): void {\n\t\t\tthis.setSelection(this.timelineData);\n\t\t}\n\n\t\tprivate drag = d3.behavior.drag()\n\t\t\t.origin((d: CursorDatapoint) => {\n\t\t\t\td.x = d.selectionIndex * this.timelineProperties.cellWidth;\n\n\t\t\t\treturn d;\n\t\t\t})\n\t\t\t.on(\"dragstart\", () => { this.dragstarted(); })\n\t\t\t.on(\"drag\", (d: CursorDatapoint) => { this.dragged(d); })\n\t\t\t.on(\"dragend\", () => { this.dragended(); });\n\n\t\tpublic renderCursors(timelineData: TimelineData, timelineFormat: TimelineFormat, cellHeight: number, cellsYPosition: number): D3.UpdateSelection {\n\t\t\tlet cursorSelection = this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).data(timelineData.cursorDataPoints);\n\t\t\tcursorSelection.enter().append('path').classed(this.timelineSelectors.SelectionCursor.class, true);\n\n\t\t\tcursorSelection.attr(\"transform\", (d: CursorDatapoint) => SVGUtil.translate(d.selectionIndex * this.timelineProperties.cellWidth, cellHeight / 2 + cellsYPosition)).attr({\n\t\t\t\td: d3.svg.arc()\n\t\t\t\t\t.innerRadius(0)\n\t\t\t\t\t.outerRadius(cellHeight / 2)\n\t\t\t\t\t.startAngle(d => d.cursorIndex * Math.PI + Math.PI)\n\t\t\t\t\t.endAngle(d => d.cursorIndex * Math.PI + 2 * Math.PI)\n\t\t\t})\n\t\t\t\t.call(this.drag);\n\n\t\t\tcursorSelection.exit().remove();\n\t\t\treturn cursorSelection;\n\t\t}\n\n\t\tpublic renderTimeRangeText(timelineData: TimelineData, timeRangeFormat: LabelFormat): void {\n            let leftMargin = (GranularityNames.length + 2) * this.timelineProperties.elementWidth;\n            let maxWidth = this.svgWidth - leftMargin - this.timelineProperties.leftMargin;\n\n\t\t\tif (timeRangeFormat.showProperty && maxWidth > 0) {\n\t\t\t\tlet timeRangeText = Utils.timeRangeText(timelineData);\n\t\t\t\tlet labelFormattedTextOptions: LabelFormattedTextOptions = {\n\t\t\t\t\tlabel: timeRangeText,\n\t\t\t\t\tmaxWidth: maxWidth,\n\t\t\t\t\tfontSize: timeRangeFormat.sizeProperty\n\t\t\t\t};\n\t\t\t\tlet actualText = dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);\n\t\t\t\tthis.rangeText.classed(this.timelineSelectors.SelectionRangeContainer.class, true);\n\t\t\t\tthis.rangeText.attr({\n\t\t\t\t\tx: (GranularityNames.length) * (this.timelineProperties.elementWidth + this.timelineProperties.leftMargin),\n\t\t\t\t\ty: 40,\n\t\t\t\t\tfill: timeRangeFormat.colorProperty\n\t\t\t\t})\n\t\t\t\t\t.style({\n\t\t\t\t\t\t'font-size': pt(timeRangeFormat.sizeProperty)\n\t\t\t\t\t}).text(actualText)\n\t\t\t\t\t.append('title').text(timeRangeText);;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthis.rangeText.text(\"\");\n\t\t}\n\n\t\tpublic setSelection(timelineData: TimelineData): void {\n\t\t\tthis.requiresNoUpdate = true;\n\t\t\tlet lower: data.SQConstantExpr = powerbi.data.SQExprBuilder.dateTime(Utils.getStartSelectionDate(timelineData));\n\t\t\tlet upper: data.SQConstantExpr = powerbi.data.SQExprBuilder.dateTime(new Date(Utils.getEndSelectionDate(timelineData).getTime() - 1));\n\t\t\tlet filterExpr = powerbi.data.SQExprBuilder.between(timelineData.columnIdentity, lower, upper);\n\t\t\tlet filter = powerbi.data.SemanticFilter.fromSQExpr(filterExpr);\n\t\t\tlet objects: VisualObjectInstancesToPersist = {\n\t\t\t\tmerge: [\n\t\t\t\t\t<VisualObjectInstance>{\n\t\t\t\t\t\tobjectName: \"general\",\n\t\t\t\t\t\tselector: undefined,\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\"filter\": filter,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\t\t\tthis.hostServices.persistProperties(objects);\n\t\t\tthis.hostServices.onSelect({ data: [] });\n\t\t}\n\n\t\t// This function retruns the values to be displayed in the property pane for each object.\n\t\t// Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do\n\t\t// validation and return other values/defaults \n\t\tpublic enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\n\t\t\tlet enumeration = new ObjectEnumerationBuilder();\n\t\t\tswitch (options.objectName) {\n\t\t\t\tcase 'rangeHeader':\n\t\t\t\t\tthis.enumerateRangeHeader(enumeration, this.dataView);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'cells':\n\t\t\t\t\tthis.enumerateCells(enumeration, this.dataView);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'labels':\n\t\t\t\t\tthis.enumerateLabels(enumeration, this.dataView);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'calendar':\n\t\t\t\t\tthis.enumerateCalendar(enumeration, this.dataView);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'weekDay':\n\t\t\t\t\tthis.enumerateWeekDay(enumeration, this.dataView);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn enumeration.complete();\n\t\t}\n\n\t\tpublic enumerateRangeHeader(enumeration: ObjectEnumerationBuilder, dataview: DataView): void {\n\t\t\tlet objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\n\t\t\tenumeration.pushInstance({\n\t\t\t\tobjectName: 'rangeHeader',\n\t\t\t\tdisplayName: 'Selection Color',\n\t\t\t\tselector: null,\n\t\t\t\tproperties: {\n\t\t\t\t\tshow: DataViewObjects.getValue<boolean>(objects, TimeRangeShowProp, this.defaultTimelineProperties.TimelineDefaultTimeRangeShow),\n\t\t\t\t\tfontColor: DataViewObjects.getFillColor(objects, TimeRangeColorProp, this.defaultTimelineProperties.DefaultTimeRangeColor),\n\t\t\t\t\ttextSize: DataViewObjects.getValue<number>(objects, TimeRangeSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tpublic enumerateCells(enumeration: ObjectEnumerationBuilder, dataview: DataView): void {\n\t\t\tlet objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\n\t\t\tenumeration.pushInstance({\n\t\t\t\tobjectName: 'cells',\n\t\t\t\tselector: null,\n\t\t\t\tproperties: {\n\t\t\t\t\tfillSelected: DataViewObjects.getFillColor(objects, SelectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColor),\n\t\t\t\t\tfillUnselected: DataViewObjects.getFillColor(objects, UnselectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColorOut)\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tpublic enumerateLabels(enumeration: ObjectEnumerationBuilder, dataview: DataView): void {\n\t\t\tlet objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\n\t\t\tenumeration.pushInstance({\n\t\t\t\tobjectName: 'labels',\n\t\t\t\tselector: null,\n\t\t\t\tproperties: {\n\t\t\t\t\tshow: DataViewObjects.getValue<boolean>(objects, LabelsShowProp, this.defaultTimelineProperties.DefaultLabelsShow),\n\t\t\t\t\tfontColor: DataViewObjects.getFillColor(objects, LabelsColorProp, this.defaultTimelineProperties.DefaultLabelColor),\n\t\t\t\t\ttextSize: DataViewObjects.getValue<number>(objects, LabelsSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tpublic enumerateCalendar(enumeration: ObjectEnumerationBuilder, dataview: DataView): void {\n\t\t\tlet objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\n\t\t\tenumeration.pushInstance({\n\t\t\t\tobjectName: 'calendar',\n\t\t\t\tselector: null,\n\t\t\t\tproperties: {\n\t\t\t\t\tmonth: Math.max(1, Math.min(12, DataViewObjects.getValue<number>(objects, CalendarMonthProp, 1))),\n\t\t\t\t\tday: Math.max(1, Math.min(31, DataViewObjects.getValue<number>(objects, CalendarDayProp, 1))),\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tpublic enumerateWeekDay(enumeration: ObjectEnumerationBuilder, dataview: DataView): void {\n\t\t\tlet objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\n\t\t\tenumeration.pushInstance({\n\t\t\t\tobjectName: 'weekDay',\n\t\t\t\tselector: null,\n\t\t\t\tproperties: {\n\t\t\t\t\tday: Math.max(0, Math.min(6, DataViewObjects.getValue<number>(objects, WeekDayProp, 0)))\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n\n    import ValueFormatter = powerbi.visuals.valueFormatter;\n    import SelectionManager = utility.SelectionManager;\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n\n    export interface StreamData {\n        dataPoints: StreamDataPoint[][];\n        legendData: LegendData;\n        valueFormatter: IValueFormatter;\n        categoryFormatter: IValueFormatter;\n        streamGraphSettings: StreamGraphSettings;\n    }\n\n    export interface StreamDataPoint {\n        x: number;\n        y: number;\n        y0?: number;\n        identity: SelectionId;\n    }\n\n    export interface StreamGraphSettings {\n        legendSettings: StreamGraphLegendSettings;\n        categoryAxisSettings: StreamGraphAxisSettings;\n        valueAxisSettings: StreamGraphAxisSettings;\n    }\n\n    export interface StreamGraphLegendSettings {\n        show: boolean;\n        showTitle: boolean;\n        titleText: string;\n        labelColor: string;\n        fontSize: number;\n    }\n\n    export interface StreamGraphAxisSettings {\n        show: boolean;\n        axisColor: string;\n        showAxisTitle: boolean;\n    }\n\n    export interface StreamProperty {\n        [propertyName: string]: DataViewObjectPropertyIdentifier;\n    }\n\n    const StreamGraphAxisGraphicsContextClassName = 'axisGraphicsContext';\n    const StreamGraphXAxisClassName = 'x axis';\n    const StreamGraphYAxisClassName = 'y axis';\n    const StreamGraphDefaultAxisColor = \"#777\";\n    const StreamGraphDefaultFontSizeInPoints: number = 8;\n    const DefaultLegendFontSizeInPt = 8;\n    const DefaultLegendLabelFillColor: string = '#666666';\n    const StreamGraphDefaultFontFamily: string = 'wf_segoe-ui_normal';\n    const StreamGraphDefaultFontWeight: string = 'normal';\n    const StreamGraphDefaultSettings: StreamGraphSettings = {\n        legendSettings: {\n            show: true,\n            showTitle: true,\n            labelColor: DefaultLegendLabelFillColor,\n            titleText: \"\",\n            fontSize: DefaultLegendFontSizeInPt\n        },\n        categoryAxisSettings: {\n            show: true,\n            axisColor: StreamGraphDefaultAxisColor,\n            showAxisTitle: false,\n        },\n        valueAxisSettings: {\n            show: true,\n            axisColor: StreamGraphDefaultAxisColor,\n            showAxisTitle: false,\n        },\n    };\n\n    export class StreamGraph implements IVisual {\n        private static VisualClassName = 'streamGraph';\n\n        private static Properties: any = {\n            general: {\n                formatString: <DataViewObjectPropertyIdentifier>{\n                    objectName: 'general',\n                    propertyName: 'formatString'\n                }\n            },\n            legend: {\n                show: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"legend\",\n                    propertyName: \"show\"\n                }\n            },\n            categoryAxis: {\n                show: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"categoryAxis\",\n                    propertyName: \"show\"\n                },\n                axisColor: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"categoryAxis\",\n                    propertyName: \"axisColor\"\n                },\n                showAxisTitle: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"categoryAxis\",\n                    propertyName: \"showAxisTitle\"\n                }\n            },\n            valueAxis: {\n                show: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"valueAxis\",\n                    propertyName: \"show\"\n                },\n                axisColor: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"valueAxis\",\n                    propertyName: \"axisColor\"\n                },\n                showAxisTitle: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"valueAxis\",\n                    propertyName: \"showAxisTitle\"\n                }\n            }\n        };\n\n        private static Layer: ClassAndSelector = {\n            'class': 'layer',\n            selector: '.layer'\n        };\n\n        private static XAxisLabel: ClassAndSelector = {\n            'class': 'xAxisLabel',\n            selector: '.xAxisLabel'\n        };\n\n        private static YAxisLabel: ClassAndSelector = {\n            'class': 'yAxisLabel',\n            selector: '.yAxisLabel'\n        };\n\n        private static MaxNumberOfAxisXValues: number = 5;\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: 'Category',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'Category',\n                }, {\n                    name: 'Series',\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'Series',\n                }, {\n                    name: 'Y',\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Values'),\n                },\n            ],\n            dataViewMappings: [{\n                conditions: [\n                    { 'Category': { max: 1 }, 'Series': { max: 0 } },\n                    { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }\n                ],\n                categorical: {\n                    categories: {\n                        for: { in: 'Category' },\n                        dataReductionAlgorithm: { bottom: {} }\n                    },\n                    values: {\n                        group: {\n                            by: 'Series',\n                            select: [{ for: { in: 'Y' } }],\n                            dataReductionAlgorithm: { bottom: {} }\n                        }\n                    },\n                }\n            }],\n            objects: {\n                general: {\n                    displayName: 'General',\n                    properties: {\n                        formatString: { type: { formatting: { formatString: true } } },\n                        wiggle: {\n                            type: { bool: true },\n                            displayName: 'Wiggle'\n                        }\n                    }\n                },\n                categoryAxis: {\n                    displayName: 'X-Axis',\n                    properties: {\n                        show: {\n                            displayName: 'show',\n                            type: { bool: true }\n                        },\n                        showAxisTitle: {\n                            displayName: 'Title',\n                            type: { bool: true }\n                        },\n                        axisColor: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                },\n                valueAxis: {\n                    displayName: 'Y-Axis',\n                    properties: {\n                        show: {\n                            displayName: 'show',\n                            type: { bool: true }\n                        },\n                        showAxisTitle: {\n                            displayName: 'Title',\n                            type: { bool: true }\n                        },\n                        axisColor: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        }\n                    }\n                },\n                legend: {\n                    displayName: 'Legend',\n                    properties: {\n                        show: {\n                            displayName: 'show',\n                            type: { bool: true }\n                        },\n                        position: {\n                            displayName: 'Position',\n                            type: { enumeration: legendPosition.type }\n                        },\n                        showTitle: {\n                            displayName: 'Title',\n                            type: { bool: true }\n                        },\n                        titleText: {\n                            displayName: 'Legend Name',\n                            type: { text: true },\n                            suppressFormatPainterCopy: true\n                        },\n                        labelColor: {\n                            displayName: 'Color',\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        fontSize: {\n                            displayName: 'Text Size',\n                            type: { formatting: { fontSize: true } }\n                        }\n                    }\n                }\n            }\n        };\n\n        private margin: IMargin = { left: 45, right: 20, bottom: 20, top: 20 };\n\n        private viewport: IViewport;\n\n        private svg: D3.Selection;\n        private axisGraphicsContext: D3.Selection;\n        private xAxis: D3.Selection;\n        private yAxis: D3.Selection;\n        private colors: IDataColorPalette;\n        private selectionManager: utility.SelectionManager;\n        private dataView: DataView;\n        private legend: ILegend;\n        private legendObjectProperties: DataViewObject;\n        private data: StreamData;\n\n        public converter(dataView: DataView, colors: IDataColorPalette): StreamData {\n            if (!dataView || !dataView.categorical || !dataView.categorical.values || !dataView.categorical.categories)\n                return null;\n\n            let catDv: DataViewCategorical = dataView.categorical,\n                values: DataViewValueColumns = catDv.values,\n                dataPoints: StreamDataPoint[][] = [],\n                legendData: LegendData = {\n                    dataPoints: [],\n                    title: values[0].source.displayName,\n                    fontSize: StreamGraphDefaultFontSizeInPoints,\n                },\n                value: number = 0,\n                valueFormatter: IValueFormatter,\n                categoryFormatter: IValueFormatter;\n\n            for (let i = 0; i < values.length; i++) {\n                dataPoints.push([]);\n\n                if (values[i].source.groupName) {\n                    legendData.dataPoints.push({\n                        label: values[i].source.groupName,\n                        color: colors.getColorByIndex(i).value,\n                        icon: LegendIcon.Box,\n                        selected: false,\n                        identity: SelectionId.createWithId(values[i].identity)\n                    });\n                }\n\n                for (let k = 0; k < values[i].values.length; k++) {\n                    let id: SelectionId = SelectionIdBuilder\n                        .builder()\n                        .withSeries(dataView.categorical.values, dataView.categorical.values[i])\n                        .createSelectionId(),\n                        y: number = values[i].values[k];\n\n                    if (y > value) {\n                        value = y;\n                    }\n\n                    dataPoints[i].push({\n                        x: k,\n                        y: y,\n                        identity: id\n                    });\n                }\n            }\n\n            let streamGraphSettings: StreamGraphSettings = this.parseSettings(dataView);\n\n            valueFormatter = ValueFormatter.create({\n                format: \"g\",\n                value: value\n            });\n\n            categoryFormatter = ValueFormatter.create({\n                format: ValueFormatter.getFormatString(\n                    catDv.categories[0].source,\n                    StreamGraph.Properties.general.formatString),\n                value: catDv.categories[0].values\n            });\n\n            return {\n                dataPoints: dataPoints,\n                legendData: legendData,\n                valueFormatter: valueFormatter,\n                categoryFormatter: categoryFormatter,\n                streamGraphSettings: streamGraphSettings\n            };\n        }\n\n        private parseSettings(dataView: DataView): StreamGraphSettings {\n            if (!dataView || !dataView.metadata)\n                return StreamGraphDefaultSettings;\n\n            let objects: DataViewObjects = dataView.metadata.objects;\n            let streamGraphSettings = _.clone(StreamGraphDefaultSettings);\n\n            let categoryAxisSettings = streamGraphSettings.categoryAxisSettings;\n            categoryAxisSettings.show = DataViewObjects.getValue<boolean>(objects, StreamGraph.Properties.categoryAxis.show, categoryAxisSettings.show);\n            categoryAxisSettings.axisColor = <string>DataViewObjects.getFillColor(objects, StreamGraph.Properties.categoryAxis.axisColor, categoryAxisSettings.axisColor);\n            categoryAxisSettings.showAxisTitle = DataViewObjects.getValue<boolean>(objects, StreamGraph.Properties.categoryAxis.showAxisTitle, categoryAxisSettings.showAxisTitle);\n\n            let valueAxisSettings = streamGraphSettings.valueAxisSettings;\n            valueAxisSettings.show = DataViewObjects.getValue<boolean>(objects, StreamGraph.Properties.valueAxis.show, valueAxisSettings.show);\n            valueAxisSettings.axisColor = <string>DataViewObjects.getFillColor(objects, StreamGraph.Properties.valueAxis.axisColor, valueAxisSettings.axisColor);\n            valueAxisSettings.showAxisTitle = DataViewObjects.getValue<boolean>(objects, StreamGraph.Properties.valueAxis.showAxisTitle, valueAxisSettings.showAxisTitle);\n\n            return streamGraphSettings;\n        }\n\n        public init(options: VisualInitOptions): void {\n            let element: JQuery = options.element;\n\n            this.selectionManager = new SelectionManager({ hostServices: options.host });\n\n            this.svg = d3.select(element.get(0))\n                .append('svg')\n                .classed(StreamGraph.VisualClassName, true)\n                .style('position', 'absolute');\n\n            this.axisGraphicsContext = this.svg.append('g')\n                .classed(StreamGraphAxisGraphicsContextClassName, true);\n\n            this.xAxis = this.axisGraphicsContext.append(\"g\").classed(StreamGraphXAxisClassName, true);\n            this.yAxis = this.axisGraphicsContext.append(\"g\").classed(StreamGraphYAxisClassName, true);\n\n            this.colors = options.style.colorPalette.dataColors;\n\n            this.legend = createLegend(element, false, null, true);\n        }\n\n        public update(options: VisualUpdateOptions): void {\n            if (!options.dataViews || !options.dataViews[0] || !options.dataViews[0].categorical) {\n                this.clearData();\n                return;\n            };\n\n            this.viewport = {\n                width: Math.max(0, options.viewport.width),\n                height: Math.max(0, options.viewport.height)\n            };\n\n            let duration: number = options.suppressAnimations ? 0 : 250,\n                dataView: DataView = this.dataView = options.dataViews[0],\n                data: StreamData = this.data = this.converter(dataView, this.colors);\n\n            if (!data || !data.dataPoints || !data.dataPoints.length) {\n                this.clearData();\n                return;\n            }\n\n            let dataPoints: StreamDataPoint[][] = data.dataPoints;\n\n            this.renderLegend(data);\n            this.updateViewPort();\n            this.renderXAxisLabels();\n            this.renderYAxisLabels();\n\n            let height: number = Math.max(0, this.viewport.height - this.margin.top);\n\n            this.svg.attr({\n                'width': this.viewport.width,\n                'height': height\n            });\n\n            let stack: D3.Layout.StackLayout = d3.layout.stack();\n\n            if (this.getWiggle(dataView))\n                stack.offset('wiggle');\n\n            let layers: StreamDataPoint[][] = stack(dataPoints);\n\n            let xScale: D3.Scale.LinearScale = d3.scale.linear()\n                .domain([0, dataPoints[0].length - 1])\n                .range([this.margin.left, this.viewport.width - this.margin.right]);\n\n            let yScale: D3.Scale.LinearScale = d3.scale.linear()\n                .domain([0, d3.max(layers, (layer) => {\n                    return d3.max(layer, (d) => {\n                        return d.y0 + d.y;\n                    });\n                })])\n                .range([height - this.margin.bottom, this.margin.top]);\n\n            let area: D3.Svg.Area = d3.svg.area()\n                .interpolate('basis')\n                .x(d => xScale(d.x))\n                .y0(d => yScale(d.y0))\n                .y1(d => yScale(d.y0 + d.y));\n\n            let selectionManager: SelectionManager = this.selectionManager;\n\n            let selection: D3.UpdateSelection = this.svg.selectAll(StreamGraph.Layer.selector)\n                .data(layers);\n\n            selection.enter()\n                .append('path')\n                .classed(StreamGraph.Layer.class, true);\n\n            selection\n                .style(\"fill\", (d, i) => this.colors.getColorByIndex(i).value)\n                .on('click', function (d) {\n                    selectionManager.select(d[0].identity).then(ids=> {\n                        if (ids.length > 0) {\n                            selection.style('opacity', 0.5);\n                            d3.select(this).style('opacity', 1);\n                        } else\n                            selection.style('opacity', 1);\n                    });\n                })\n                .transition()\n                .duration(duration)\n                .attr(\"d\", area);\n\n            selection.exit().remove();\n\n            this.drawAxis(data, xScale, yScale);\n        }\n\n        private drawAxis(data: StreamData, xScale: D3.Scale.LinearScale, yScale: D3.Scale.LinearScale) {\n            let shiftY: number = this.viewport.height - this.margin.bottom - this.margin.top,\n                shiftX: number = this.viewport.width - this.margin.left - this.margin.right,\n                xAxis: D3.Svg.Axis = d3.svg.axis();\n\n            xAxis.scale(xScale)\n                .orient(\"bottom\")\n                .tickFormat(((item: any, index: number): any => {\n                    if (data.categoryFormatter)\n                        item = data.categoryFormatter.format(item);\n\n                    if (index != null && xAxis.tickValues() &&\n                        (index === 0 || index === xAxis.tickValues().length - 1)) {\n                        item = TextMeasurementService.getTailoredTextOrDefault(\n                            StreamGraph.getTextPropertiesFunction(item),\n                            (index ? this.margin.right : this.margin.left) * 2);\n                    }\n                    return item;\n                }).bind(xAxis));\n\n            let yAxis: D3.Svg.Axis = d3.svg.axis()\n                .scale(yScale)\n                .orient(\"left\")\n                .tickFormat((item: any): any => {\n                    if (data.valueFormatter) {\n                        return data.valueFormatter.format(item);\n                    }\n                    return item;\n                });\n\n            this.setMaxTicks(xAxis, shiftX, StreamGraph.MaxNumberOfAxisXValues);\n            this.setMaxTicks(yAxis, shiftY);\n\n            let valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;\n            if (valueAxisSettings.show) {\n                let axisColor: Fill = valueAxisSettings.axisColor;\n                this.yAxis\n                    .attr(\"transform\", SVGUtil.translate(this.margin.left, 0))\n                    .call(yAxis);\n                this.yAxis.selectAll(\"text\").style(\"fill\", axisColor);\n            } else\n                this.yAxis.selectAll(\"*\").remove();\n\n            let categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;\n            if (categoryAxisSettings.show) {\n                let axisColor: Fill = categoryAxisSettings.axisColor;\n                this.xAxis\n                    .attr(\"transform\", SVGUtil.translate(0, shiftY))\n                    .call(xAxis);\n                this.xAxis.selectAll(\"text\").style(\"fill\", axisColor);\n            } else\n                this.xAxis.selectAll(\"*\").remove();\n        }\n\n        private renderYAxisLabels(): void {\n            this.yAxis.selectAll(StreamGraph.YAxisLabel.selector).remove();\n\n            let valueAxisSettings: StreamGraphAxisSettings = this.data.streamGraphSettings.valueAxisSettings;\n            if (valueAxisSettings.show) {\n                this.margin.left = 45;\n                if (valueAxisSettings.showAxisTitle)\n                    if (this.dataView.categorical.values.source) {\n                        let marginLeft = this.margin.left = 65;\n                        let categoryAxisSettings: StreamGraphAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;\n                        let isXAxisOn: boolean = categoryAxisSettings.show === true;\n                        let isXTitleOn: boolean = categoryAxisSettings.showAxisTitle === true;\n                        let height: number = isXAxisOn ? isXTitleOn ? this.viewport.height - this.margin.bottom : this.viewport.height - this.margin.top : this.viewport.height;\n                        let yAxisText: string = this.dataView.categorical.values.source.displayName;\n                        let yAxisClass: string = StreamGraph.YAxisLabel.class;\n                        let yAxisLabel: D3.Selection = this.yAxis.append(\"text\")\n                            .style(\"text-anchor\", \"middle\")\n                            .text(yAxisText)\n                            .call((text: D3.Selection) => {\n                                text.each(function () {\n                                    let text = d3.select(this);\n                                    text.attr({\n                                        class: yAxisClass,\n                                        transform: \"rotate(-90)\",\n                                        y: -marginLeft + 5,\n                                        x: -(height / 2),\n                                        dy: \"1em\"\n                                    });\n                                });\n                            });\n\n                        yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\n                            height,\n                            TextMeasurementService.svgEllipsis);\n                    } else\n                        valueAxisSettings.showAxisTitle = false;\n            } else\n                this.margin.left = 20;\n        }\n\n        private renderXAxisLabels(): void {\n            this.xAxis.selectAll(StreamGraph.XAxisLabel.selector).remove();\n\n            let categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;\n            if (categoryAxisSettings.show) {\n                this.margin.bottom = 20;\n                if (categoryAxisSettings.showAxisTitle)\n                    if (this.dataView.categorical.categories[0].source) {\n                        let marginBottom = this.margin.bottom = 40;\n                        let valueAxisSettings: StreamGraphAxisSettings = this.data.streamGraphSettings.valueAxisSettings;\n                        let isYAxisOn: boolean = valueAxisSettings.show === true;\n                        let isYTitleOn: boolean = valueAxisSettings.showAxisTitle === true;\n                        let width: number = isYAxisOn ? isYTitleOn ? this.viewport.width + this.margin.left : this.viewport.width + this.margin.right : this.viewport.width;\n                        let xAxisText: string = this.dataView.categorical.categories[0].source.displayName;\n                        let xAxisClass: string = StreamGraph.XAxisLabel.class;\n                        let xAxisLabel: D3.Selection = this.xAxis.append(\"text\")\n                            .style(\"text-anchor\", \"middle\")\n                            .text(xAxisText)\n                            .call((text: D3.Selection) => {\n                                text.each(function () {\n                                    let text = d3.select(this);\n                                    text.attr({\n                                        class: xAxisClass,\n                                        transform: SVGUtil.translate(width / 2, marginBottom - 5)\n                                    });\n                                });\n                            });\n\n                        xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\n                            width,\n                            TextMeasurementService.svgEllipsis);\n                    } else\n                        categoryAxisSettings.showAxisTitle = false;\n            } else\n                this.margin.bottom = 10;\n        }\n\n        private renderLegend(streamGraphData: StreamData): void {\n            let legendData: LegendData = streamGraphData.legendData;\n            if (!legendData || !this.dataView || !this.dataView.metadata)\n                return;\n\n            this.legendObjectProperties = DataViewObjects.getObject(this.dataView.metadata.objects, \"legend\", {});\n\n            if (this.legendObjectProperties) {\n                LegendData.update(legendData, this.legendObjectProperties);\n\n                let position: string = <string>this.legendObjectProperties[legendProps.position];\n\n                if (position)\n                    this.legend.changeOrientation(LegendPosition[position]);\n            }\n            this.legend.drawLegend(legendData, _.clone(this.viewport));\n            Legend.positionChartArea(this.svg, this.legend);\n        }\n\n        private updateViewPort(): void {\n            let legendMargins: IViewport = this.legend.getMargins();\n            let legendPosition = LegendPosition[<string>this.legendObjectProperties[legendProps.position]];\n\n            switch (legendPosition) {\n                case LegendPosition.Top:\n                case LegendPosition.TopCenter:\n                case LegendPosition.Bottom:\n                case LegendPosition.BottomCenter: {\n                    this.viewport.height -= legendMargins.height;\n                    break;\n                }\n                case LegendPosition.Left:\n                case LegendPosition.LeftCenter:\n                case LegendPosition.Right:\n                case LegendPosition.RightCenter: {\n                    this.viewport.width -= legendMargins.width;\n                    break;\n                }\n            }\n        }\n\n        private setMaxTicks(axis: D3.Svg.Axis, maxSize: number, maxValue?: number): void {\n            let maxTicks = maxValue === undefined\n                ? this.getTicksByAxis(axis).length\n                : Math.min(maxValue, this.getTicksByAxis(axis).length);\n\n            if (axis.scale().domain.toString() === d3.scale.linear().domain.toString())\n                axis.ticks(this.getFittedTickLength(axis, maxSize, maxTicks));\n            else\n                axis.tickValues(this.getFittedTickValues(axis, maxSize, maxTicks));\n        }\n\n        private getFittedTickLength(axis: D3.Svg.Axis, maxSize: number, maxTicks: number): number {\n            for (let ticks: any[] = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks);\n                maxTicks > 0 && maxSize > 0 && (this.measureTicks(ticks, measureTickFunction) > maxSize || axis.scale().ticks([maxTicks]).length > maxTicks);\n                maxTicks-- , ticks = this.getTicksByAxis(axis)) {\n                axis.ticks(maxTicks);\n            }\n            return maxTicks;\n        }\n\n        private getFittedTickValues(axis: D3.Svg.Axis, maxSize: number, maxTicks: number): any[] {\n            let ticks: any[] = this.getTicksByAxis(axis),\n                maxWidthOf2Ticks: number,\n                tickPairsWidths: any[] = [],\n                measureTickFunction: (any) => number = this.getMeasureTickFunction(axis, ticks);\n\n            for (let currentMaxTicks: number = maxTicks, indexes: number[] = [];\n                maxTicks > 0 && maxSize > 0;\n                currentMaxTicks-- , indexes = []) {\n                switch (currentMaxTicks) {\n                    case 0:\n                        return [];\n                    case 1:\n                        indexes = [0];\n                        break;\n                    case 2:\n                        indexes = [0, ticks.length - 1];\n                        break;\n                    default:\n                        let takeEvery: number = ticks.length / (currentMaxTicks - 1);\n\n                        for (let i = 0; i < currentMaxTicks - 1; i++) {\n                            indexes.push(Math.round(takeEvery * i));\n                        }\n\n                        indexes.push(ticks.length - 1);\n                        break;\n                }\n\n                let ticksIndexes: any[][] = indexes.map(x => [ticks[x], x]);\n                maxWidthOf2Ticks = (maxSize / ticks.length) * 2;\n\n                ticksIndexes.reduce((a, b) => {\n                    tickPairsWidths.push([measureTickFunction(a[0]) + measureTickFunction(b[0]), (b[1] - a[1]) * maxWidthOf2Ticks]);\n                    return b;\n                });\n\n                if (!tickPairsWidths.some(x => x[0] > x[1])) {\n                    return ticksIndexes.map(x => x[0]);\n                }\n            }\n            return [];\n        }\n\n        private measureTicks(ticks: any[], measureTickFunction: (number) => any): number {\n            return ticks.map((x: any) => measureTickFunction(x)).reduce((a: number, b: number) => a + b);\n        }\n\n        private getTicksByAxis(axis: D3.Svg.Axis): any[] {\n            let scale = axis.scale();\n            let result: any = axis.tickValues() === null\n                ? scale.ticks\n                    ? scale.ticks.apply(scale, axis.ticks())\n                    : scale.domain()\n                : axis.tickValues();\n\n            return result.length === undefined ? [result] : result;\n        }\n\n        private getMeasureTickFunction(axis: D3.Svg.Axis, ticks: string[]): (number) => any {\n            let measureFunction = axis.orient() === \"top\" || axis.orient() === \"bottom\"\n                ? TextMeasurementService.measureSvgTextWidth\n                : TextMeasurementService.measureSvgTextHeight;\n\n            let cache = {};\n\n            return function (x: any): number {\n                return cache[x]\n                    ? cache[x]\n                    : cache[x] = measureFunction(StreamGraph.getTextPropertiesFunction(axis.tickFormat()(x))) + axis.tickPadding();\n            };\n        }\n\n        private static getTextPropertiesFunction(text: string): TextProperties {\n            let fontFamily: string = StreamGraphDefaultFontFamily,\n                fontSize: string = jsCommon.PixelConverter.fromPoint(StreamGraphDefaultFontSizeInPoints),\n                fontWeight: string = StreamGraphDefaultFontWeight;\n\n            return { text: text, fontFamily: fontFamily, fontSize: fontSize, fontWeight: fontWeight };\n        }\n\n        private getWiggle(dataView: DataView) {\n            if (dataView && dataView.metadata) {\n                let objects = dataView.metadata.objects;\n\n                if (objects) {\n                    let general = DataViewObjects.getObject(objects, 'general', undefined);\n\n                    if (general)\n                        return <boolean>general['wiggle'];\n                }\n            }\n            return true;\n        }\n\n        private enumerateValueAxisValues(enumeration: ObjectEnumerationBuilder): void {\n\n            let valueAxisSettings: StreamGraphAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.valueAxisSettings : StreamGraphDefaultSettings.valueAxisSettings;\n\n            enumeration.pushInstance({\n                selector: null,\n                objectName: 'valueAxis',\n                displayName: \"Y-Axis\",\n                properties: {\n                    show: valueAxisSettings.show,\n                    showAxisTitle: valueAxisSettings.showAxisTitle,\n                    axisColor: valueAxisSettings.axisColor,\n                }\n            });\n        }\n\n        private enumerateCategoryAxisValues(enumeration: ObjectEnumerationBuilder): void {\n            let categoryAxisSettings: StreamGraphAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.categoryAxisSettings : StreamGraphDefaultSettings.categoryAxisSettings;\n\n            enumeration.pushInstance({\n                selector: null,\n                objectName: 'categoryAxis',\n                displayName: \"X-Axis\",\n                properties: {\n                    show: categoryAxisSettings.show,\n                    showAxisTitle: categoryAxisSettings.showAxisTitle,\n                    axisColor: categoryAxisSettings.axisColor,\n                }\n            });\n        }\n\n        private enumerateLegend(enumeration: ObjectEnumerationBuilder): void {\n            let legendSettings: DataViewObject = this.legendObjectProperties ? this.legendObjectProperties : {};\n\n            enumeration.pushInstance({\n                selector: null,\n                objectName: 'legend',\n                displayName: \"Legend\",\n                properties: {\n                    show: this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.legendSettings.show : true,\n                    position: LegendPosition[this.legend.getOrientation()],\n                    showTitle: DataViewObject.getValue<boolean>(legendSettings, legendProps.showTitle, true),\n                    titleText: DataViewObject.getValue<string>(legendSettings, legendProps.titleText, \"\"),\n                    labelColor: DataViewObject.getValue<string>(legendSettings, legendProps.labelColor, DefaultLegendLabelFillColor),\n                    fontSize: DataViewObject.getValue<number>(legendSettings, legendProps.fontSize, DefaultLegendFontSizeInPt)\n                }\n            });\n        }\n\n        private clearData() {\n            this.svg.selectAll(StreamGraph.Layer.selector).remove();\n            this.legend.drawLegend({ dataPoints: [] }, this.viewport);\n            this.yAxis.selectAll(\"*\").remove();\n            this.xAxis.selectAll(\"*\").remove();\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\n            let enumeration: ObjectEnumerationBuilder = new ObjectEnumerationBuilder(),\n                dataView = this.dataView;\n\n            switch (options.objectName) {\n                case 'legend':\n                    if (dataView\n                        && dataView.categorical\n                        && dataView.categorical.values\n                        && dataView.categorical.values.source)\n                            this.enumerateLegend(enumeration);\n                    break;\n                case 'categoryAxis':\n                    this.enumerateCategoryAxisValues(enumeration);\n                    break;\n                case 'valueAxis':\n                    this.enumerateValueAxisValues(enumeration);\n                    break;\n                case 'general':\n                    let general: VisualObjectInstance = {\n                        objectName: 'general',\n                        displayName: 'General',\n                        selector: null,\n                        properties: {\n                            wiggle: this.getWiggle(dataView)\n                        }\n                    };\n\n                    enumeration.pushInstance(general);\n                    break;\n            }\n            return enumeration.complete();\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *   \n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *   \n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import SelectionManager = utility.SelectionManager;\n    export interface SunburstSlice {\n        children?: SunburstSlice[];\n        value?: any;\n        color?: string;\n        name?: string;\n        parent?: SunburstSlice;\n        selector: SelectionId;\n        total: number;\n        tooltipInfo?: TooltipDataItem[];\n    }\n\n    export interface SunburstViewModel {\n        root: SunburstSlice;\n    }\n\n    export var sunburstRoleNames = {\n        nodes: 'Nodes',\n        values: 'Values',\n    };\n\n    export class Sunburst implements IVisual {\n        private static minOpacity = 0.2;\n        private svg: D3.Selection;\n        private g: D3.Selection;\n        private arc: D3.Svg.Arc;\n        private total: number = 0;\n        private viewport: IViewport;\n        private colors: IDataColorPalette;\n        private selectionManager: SelectionManager;\n\n        private static roleNames = {\n            nodes: 'Nodes',\n            values: 'Values',\n        };\n\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: Sunburst.roleNames.nodes,\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'Groups'\n                }, {\n                    name: Sunburst.roleNames.values,\n                    kind: VisualDataRoleKind.Measure,\n                    displayName: 'Values'\n                }\n            ],\n            objects: {\n                general: {\n                    displayName: data.createDisplayNameGetter('Visual_General'),\n                    properties: {\n                        formatString: {\n                            type: { formatting: { formatString: true } },\n                        },\n                    },\n                },\n            },\n            dataViewMappings: [{\n                conditions: [\n                    { 'Groups': { min: 0 }, 'Values': { max: 1 } },\n                ],\n                matrix: {\n                    rows: {\n                        for: { in: Sunburst.roleNames.nodes },\n                    },\n                    values: {\n                        for: { in: Sunburst.roleNames.values }\n                    },\n                }\n            }],\n        };\n\n        public init(options: VisualInitOptions): void {\n            this.arc = d3.svg.arc()\n                .startAngle(function(d) { return d.x; })\n                .endAngle(function(d) { return d.x + d.dx; })\n                .innerRadius(function(d) { return Math.sqrt(d.y); })\n                .outerRadius(function(d) { return Math.sqrt(d.y + d.dy); });\n\n            this.colors = options.style.colorPalette.dataColors;\n            this.selectionManager = new SelectionManager({ hostServices: options.host });\n            this.svg = d3.select(options.element.get(0)).append('svg');\n            this.svg.classed('mainDrawArea', true);\n            this.g = this.svg.append('g');\n            this.g.classed(\"container\", true);\n            this.svg.append(\"text\")\n                .classed(\"sunBurstPercentageFixed\", true);\n\n            this.svg.on('mousedown', (d) => {\n                this.svg.selectAll(\"path\").style(\"opacity\", 1);\n                this.svg.select(\".sunBurstPercentageFixed\").style(\"opacity\", 0);\n                this.selectionManager.clear();\n            });\n        }\n\n        private static setAllUnhide(selection): void {\n            selection.attr(\"setUnHide\", \"true\");\n        }\n\n        public update(options: VisualUpdateOptions): void {\n            if (options.dataViews.length > 0) {\n                var data = this.converter(options.dataViews[0], this.colors);\n                this.viewport = options.viewport;\n                this.updateInternal(data);\n            }\n        }\n\n        private updateInternal(dataRootNode: SunburstSlice): void {\n            this.svg.attr({\n                'height': this.viewport.height,\n                'width': this.viewport.width\n            });\n            this.g.attr('transform', SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));\n            var radius = Math.min(this.viewport.width, this.viewport.height) / 2;\n            var partition = d3.layout.partition()\n                .size([2 * Math.PI, radius * radius])\n                .value((d) => { return d.value; });\n            var path = this.g.datum(dataRootNode).selectAll(\"path\")\n                .data(partition.nodes);\n            path.enter().append(\"path\");\n            path.attr(\"display\", (d) => { return d.depth ? null : \"none\"; })\n                .attr(\"d\", this.arc)\n                .style(\"stroke\", \"#fff\")\n                .style(\"fill\", (d) => { return d.color; })\n                .style(\"fill-rule\", \"evenodd\")\n                .on(\"mousedown\", (d) => {\n                    if (d.selector) {\n                        this.selectionManager.select(d.selector);\n                    }\n                    d3.selectAll(\"path\").call(Sunburst.setAllUnhide).attr('setUnHide', null);\n                    this.highlightPath(d, this, true);\n                    var percentageFixedText = this.svg.select(\".sunBurstPercentageFixed\");\n                    var percentage = this.total === 0 ? 0 : (100 * d.total / this.total).toPrecision(3);\n                    percentageFixedText.text(d ? percentage + \"%\" : \"\");\n                    percentageFixedText.style(\"fill\", d.color);\n                    this.onResize();\n                    event.stopPropagation();\n                });\n            this.renderTooltip(path);\n            path.exit().remove();\n\n            this.onResize();\n        }\n\n        // Get all parents of the node\n        private static getTreePath(node) {\n            var path = [];\n            var current = node;\n            while (current.parent) {\n                path.unshift(current);\n                current = current.parent;\n            }\n            return path;\n        }\n\n        private onResize(): void {\n            var width = this.viewport.width;\n            var height = this.viewport.height;\n            var percentageFixedText = this.svg.select(\".sunBurstPercentageFixed\");\n            var textWidth = powerbi.TextMeasurementService.measureSvgTextElementWidth(percentageFixedText[0][0]);\n\n            percentageFixedText.style(\"opacity\", 1);\n            percentageFixedText.attr(\"y\", (height / 2 + 4));\n            percentageFixedText.attr(\"x\", ((width / 2) - (textWidth / 2)));\n        }\n\n        private highlightPath(d, sunBurst, setUnhide): void {\n            var parentsArray = d ? Sunburst.getTreePath(d) : [];\n            // Set opacity for all the segments.\n            sunBurst.svg.selectAll(\"path\").each(function() {\n                if (d3.select(this).attr('setUnHide') !== 'true') {\n                    d3.select(this).style(\"opacity\", Sunburst.minOpacity);\n                }\n            });\n            // Highlight only ancestors of the current segment.\n            sunBurst.svg.selectAll(\"path\")\n                .filter(function(node) {\n                    return (parentsArray.indexOf(node) >= 0);\n                }).each(function() {\n                    d3.select(this).style(\"opacity\", 1);\n                    if (setUnhide === true) {\n                        d3.select(this).attr('setUnHide', 'true');\n                    }\n                });\n        }\n\n        private renderTooltip(selection: D3.UpdateSelection): void {\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) => {\n                return (<SunburstSlice>tooltipEvent.data).tooltipInfo;\n            });\n        }\n\n        private static getTooltipData(displayName: string, value: number): TooltipDataItem[] {\n            return [{\n                displayName: displayName,\n                value: value < 0 ? \"\" : value.toString()\n            }];\n        }\n\n        private covertTreeNodeToSunBurstNode(originParentNode: DataViewTreeNode, sunburstParentNode: SunburstSlice,\n            colors: IColorScale, pathIdentity: DataViewScopeIdentity[], color): SunburstSlice {\n            var selector: powerbi.data.Selector;\n            if (originParentNode.identity) {\n                pathIdentity = pathIdentity.concat([originParentNode.identity]);\n                selector = { data: pathIdentity, };\n            }\n\n            var selectionId = pathIdentity.length === 0 ? null : new SelectionId(selector, false);\n            var valueToSet = originParentNode.values ? originParentNode.values[0].value : 0;\n\n            var newSunNode: SunburstSlice = {\n                name: originParentNode.name,\n                value: Math.max(valueToSet, 0),\n                selector: selectionId,\n                total: valueToSet\n            };\n            if (originParentNode.value) {\n                newSunNode.color = color ? color : colors.getColor(originParentNode.value).value;\n            }\n            this.total += newSunNode.value;\n            if (originParentNode.children && originParentNode.children.length > 0) {\n\n                newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, -1);\n\n                newSunNode.children = [];\n                for (var i = 0; i < originParentNode.children.length; i++) {\n                    var newChild = this.covertTreeNodeToSunBurstNode(originParentNode.children[i], newSunNode, colors, pathIdentity, newSunNode.color);\n                    newSunNode.children.push(newChild);\n                    newSunNode.total += newChild.total;\n                }\n            } else {\n                newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, valueToSet);\n            }\n            if (sunburstParentNode) {\n                newSunNode.parent = sunburstParentNode;\n            }\n\n            return newSunNode;\n        }\n\n        public converter(dataView: DataView, colors: IDataColorPalette): SunburstSlice {\n            var colorScale = colors.getNewColorScale();\n            this.total = 0;\n            var root: SunburstSlice = this.covertTreeNodeToSunBurstNode(dataView.matrix.rows.root, null, colorScale, [], undefined);\n\n            return root;\n        }\n    }\n}","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *   \n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *   \n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.samples {\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\n    import SelectionManager = utility.SelectionManager;\n\n    export interface LineDotPoint {\n        time: number | Date;\n        value: number;\n        dot: number;\n        sum: number;\n        selector: SelectionId;\n    }\n\n    export interface Legend {\n        text: string;\n        transform?: string;\n        dx?: string;\n        dy?: string;\n    }\n\n    export interface LineDotChartViewModel {\n        points: LineDotPoint[];\n        settings: LineDotChartSettings;\n        xAxis: IAxisProperties;\n        yAxis: IAxisProperties;\n        yAxis2: IAxisProperties;\n        legends: Legend[];\n    };\n\n    export interface LineDotChartSettings {\n        lineFill: string;\n        lineThickness: number;\n        dotFill: string;\n        dotSizeMin: number;\n        dotSizeMax: number;\n        counterTitle: string;\n        // precision: number;\n        xAxisTitle: string;\n        yAxisTitle: string;\n        duration: number;\n        isanimated: boolean;\n        isstopped: boolean;\n    };\n\n    export class LineDotChart implements IVisual {\n        private selectionManager: SelectionManager;\n        private hostServices: IVisualHostServices;\n        private isDateTime: boolean;\n\n        private static DefaultSettings: LineDotChartSettings = {\n            lineFill: 'rgb(102, 212, 204)',\n            lineThickness: 3,\n            dotFill: '#005c55',\n            dotSizeMin: 4,\n            dotSizeMax: 38,\n            counterTitle: 'Total features',\n            // precision: 2,\n            xAxisTitle: '',\n            yAxisTitle: '',\n            duration: 20,\n            isanimated: true,\n            isstopped: true\n        };\n\n        /**\n        * Informs the System what it can do\n        * Fields, Formatting options, data reduction & QnA hints\n        */\n        public static capabilities: VisualCapabilities = {\n            dataRoles: [\n                {\n                    name: \"Date\",\n                    kind: VisualDataRoleKind.Grouping,\n                    displayName: 'Date'\n                }, \n                {\n                    name: \"Values\",\n                    kind: VisualDataRoleKind.Measure,\n                    displayName:'Values'\n                },\n                // {\n                //     name: \"Labels\",\n                //     kind: VisualDataRoleKind.Measure,\n                //     displayName: 'Labels'\n                // }\n            ],\n            dataViewMappings: [{\n                conditions: [{\n                    \"Date\": {\n                        min: 0,\n                        max: 1\n                    },\n                    \"Values\": {\n                        min: 0,\n                        max: 1\n                    },\n                    \"Labels\": {\n                        min: 0,\n                        max: 1\n                    }\n                }],\n                categorical: {\n                    categories: {\n                        for: { in: \"Date\" },\n                        dataReductionAlgorithm: { sample: {} }\n                    },\n                    values: {\n                        for: { in: \"Values\" }\n                    },\n                    // labels: {\n                    //     for: { in: \"Labels\" }\n                    // }\n                }\n            }],\n            objects: {\n                general: {\n                    displayName: data.createDisplayNameGetter(\"Visual_General\"),\n                    properties: {\n                        formatString: {\n                            type: {\n                                formatting: {\n                                    formatString: true\n                                }\n                            },\n                        }\n                    },\n                },\n                lineoptions: {\n                    displayName: 'Line',\n                    properties: {\n                        fill: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        lineThickness: {\n                            displayName: 'Thickness',\n                            type: { numeric: true }\n                        }\n                    }\n                },\n                dotoptions: {\n                    displayName: 'Dot',\n                    properties: {\n                        color: {\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\n                            type: { fill: { solid: { color: true } } }\n                        },\n                        dotSizeMin: {\n                            displayName: 'Min size',\n                            type: { numeric: true }\n                        },\n                        dotSizeMax: {\n                            displayName: 'Min size',\n                            type: { numeric: true }\n                        }\n                    }\n                },\n                counteroptions: {\n                    displayName: 'Counter',\n                    properties: {\n                        counterTitle: {\n                            displayName: 'Title',\n                            type: { text: true }\n                        }\n                    }\n                },\n                misc: {\n                    displayName: 'Animation',\n                    properties: {\n                        isanimated: {\n                            displayName: 'Animated',\n                            type: { bool: true }\n                        },\n                        isstopped: {\n                            displayName: 'Stop on load',\n                            type: { bool: true }\n                        },\n                        duration: {\n                            displayName: 'Time',\n                            type: { numeric: true }\n                        }\n                    }\n                }\n                // ,\n                // labels: {\n                //     displayName: data.createDisplayNameGetter('Visual_DataPointsLabels'),\n                //     properties: {\n                //         labelPrecision: {\n                //             displayName: data.createDisplayNameGetter('Visual_Precision'),\n                //             type: { numeric: true }\n                //         }\n                //     }\n                // }\n            }\n        };\n\n        private static Identity: ClassAndSelector = {\n            \"class\": \"lineDotChart\",\n            selector: \".lineDotChart\"\n        };\n\n        private static Axes: ClassAndSelector = {\n            \"class\": \"axes\",\n            selector: \".axes\"\n        };\n\n        private static Axis: ClassAndSelector = {\n            \"class\": \"axis\",\n            selector: \".axis\"\n        };\n\n        private static Legends: ClassAndSelector = {\n            \"class\": \"legends\",\n            selector: \".legends\"\n        };\n\n        private static Legend: ClassAndSelector = {\n            \"class\": \"legend\",\n            selector: \".legend\"\n        };\n\n        private static Values: ClassAndSelector = {\n            \"class\": \"line\",\n            selector: \".line\"\n        };\n\n        private static Properties: any = {\n            general: {\n                formatString: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"general\",\n                    propertyName: \"formatString\"\n                }\n            },\n            lineoptions: {\n                fill: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"lineoptions\",\n                    propertyName: \"fill\"\n                },\n                lineThickness: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"lineoptions\",\n                    propertyName: \"lineThickness\"\n                }\n            },\n            dotoptions: {\n                color: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"dotoptions\",\n                    propertyName: \"color\"\n                },\n                dotSizeMin: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"dotoptions\",\n                    propertyName: \"dotSizeMin\"\n                },\n                dotSizeMax: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"dotoptions\",\n                    propertyName: \"dotSizeMax\"\n                }\n            },\n            counteroptions: {\n                counterTitle: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"counteroptions\",\n                    propertyName: \"counterTitle\"\n                }\n            },\n            // labels: {\n            //     labelPrecision: <DataViewObjectPropertyIdentifier>{\n            //         objectName: \"labels\",\n            //         propertyName: \"labelPrecision\"\n            //     }\n            // },\n            misc: {\n                isanimated: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"misc\",\n                    propertyName: \"isanimated\"\n                },\n                isstopped: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"misc\",\n                    propertyName: \"isstopped\"\n                },\n                duration: <DataViewObjectPropertyIdentifier>{\n                    objectName: \"misc\",\n                    propertyName: \"duration\"\n                }\n            }\n        };\n\n        private model: LineDotChartViewModel;\n        private root: D3.Selection;\n        private main: D3.Selection;\n        private axes: D3.Selection;\n        private axisX: D3.Selection;\n        private axisY: D3.Selection;\n        private axisY2: D3.Selection;\n        private legends: D3.Selection;\n        private line: D3.Selection;\n        private colors: IDataColorPalette;\n\n        private margin: IMargin = {\n            top: 10,\n            right: 30,\n            bottom: 10,\n            left: 10\n        };\n\n        private LegendSize: number = 50;\n        private AxisSize: number = 30;\n\n        /* One time setup*/\n        public init(options: VisualInitOptions): void {\n            this.hostServices = options.host;\n            this.selectionManager = new SelectionManager({ hostServices: this.hostServices });\n            this.root = d3.select(options.element.get(0))\n                .append('svg')\n                .classed(LineDotChart.Identity.class, true);\n\n            this.root.on('click', (d: LineDotPoint) => { this.clearSelection(); } );\n\n            this.main = this.root.append('g');\n            this.axes = this.main.append('g').classed(LineDotChart.Axes.class, true);\n            this.axisX = this.axes.append('g').classed(LineDotChart.Axis.class, true);\n            this.axisY = this.axes.append('g').classed(LineDotChart.Axis.class, true);\n            this.axisY2 = this.axes.append('g').classed(LineDotChart.Axis.class, true);\n            this.legends = this.main.append('g').classed(LineDotChart.Legends.class, true);\n            this.line = this.main.append('g').classed(LineDotChart.Values.class, true);\n\n            this.colors = options.style && options.style.colorPalette\n                ? options.style.colorPalette.dataColors\n                : new DataColorPalette();\n        }\n\n        /* Called for data, size, formatting changes*/\n        public update(options: VisualUpdateOptions) {\n            if (!options.dataViews || !options.dataViews[0]) {\n                return;\n            }\n\n            var viewport: IViewport = options.viewport;\n            var model: LineDotChartViewModel = this.model = this.converter(options.dataViews[0], viewport);\n            // if (!model) {\n            //     return;\n            // }\n\n            this.clearSelection();\n            this.resize(viewport);\n            // this.draw(model, !options.suppressAnimations);\n            this.draw(model);\n        }\n\n        /*About to remove your visual, do clean up here */\n        public destroy() {\n            this.root = null;\n        }\n\n        public setIsStopped(isstopped: Boolean): void {\n            var objects: VisualObjectInstancesToPersist = {\n                merge: [\n                    <VisualObjectInstance>{\n                        objectName: \"misc\",\n                        selector: undefined,\n                        properties: {\n                            \"isstopped\": isstopped,\n                        }\n                    }\n                ]\n            };\n            this.hostServices.persistProperties(objects);\n            this.hostServices.onSelect({ data: [] });\n        }\n\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\n            var instances: VisualObjectInstance[] = [];\n\n            if (!this.model || !this.model.settings) {\n                return instances;\n            }\n\n            var settings: LineDotChartSettings = this.model.settings;\n\n            switch (options.objectName) {\n                case \"lineoptions\":\n                    var lineoptions: VisualObjectInstance = {\n                        objectName: \"lineoptions\",\n                        displayName: \"lineoptions\",\n                        selector: null,\n                        properties: {\n                            fill: settings.lineFill,\n                            lineThickness: settings.lineThickness\n                        }\n                    };\n\n                    instances.push(lineoptions);\n                    break;\n\n                case \"dotoptions\":\n                    var dotoptions: VisualObjectInstance = {\n                        objectName: \"dotoptions\",\n                        displayName: \"dotoptions\",\n                        selector: null,\n                        properties: {\n                            color: settings.dotFill,\n                            dotSizeMin: settings.dotSizeMin,\n                            dotSizeMax: settings.dotSizeMax\n                        }\n                    };\n\n                    instances.push(dotoptions);\n                    break;\n\n                case \"counteroptions\":\n                    var counteroptions: VisualObjectInstance = {\n                        objectName: \"counteroptions\",\n                        displayName: \"counteroptions\",\n                        selector: null,\n                        properties: {\n                            counterTitle: settings.counterTitle\n                        }\n                    };\n\n                    instances.push(counteroptions);\n                    break;\n\n                // case \"labels\":\n                //     var labels: VisualObjectInstance = {\n                //         objectName: \"labels\",\n                //         displayName: \"labels\",\n                //         selector: null,\n                //         properties: {\n                //             labelPrecision: settings.precision\n                //         }\n                //     };\n\n                //     instances.push(labels);\n                //     break;\n\n                case \"misc\": \n                    var misc: VisualObjectInstance = {\n                        objectName: \"misc\",\n                        displayName: \"misc\",\n                        selector: null,\n                        properties: {\n                            isanimated: settings.isanimated,\n                            isstopped: settings.isstopped,\n                            duration: settings.duration\n                        }\n                    };\n\n                    instances.push(misc);\n                    break;\n            }\n\n            return instances;\n        }\n\n        private selectDot(dotelement: SVGCircleElement, selector: SelectionId) {\n            var dot: D3.Selection = d3.select(dotelement);\n            if (!dot.classed('point_selected')) {\n                if (selector) {\n                    this.selectionManager.select(selector);\n                }\n\n                this.root.classed(\"filtered\", true);\n                this.line.selectAll('circle.point')\n                    .classed('point_selected', false);\n                d3.select(dotelement)\n                    .classed('point_selected', true);\n            } else {\n                this.clearSelection();\n            }\n\n            d3.event.stopPropagation();\n        }\n\n        private clearSelection(): void {\n            this.root.classed(\"filtered\", false);\n            this.root.selectAll(\"circle.point\").classed(\"point_selected\", false);\n            this.selectionManager.clear();\n        }\n\n        // Convert a DataView into a view model\n        private converter(dataView: DataView, viewport: IViewport): LineDotChartViewModel {\n            if (!dataView.categorical ||\n                !dataView.categorical.categories ||\n                !dataView.categorical.categories[0] ||\n                !dataView.categorical.categories[0].values ||\n                !(dataView.categorical.categories[0].values.length > 0) ||\n                !dataView.categorical ||\n                !dataView.categorical.values ||\n                !dataView.categorical.values[0] ||\n                !dataView.categorical.values[0].values ||\n                !(dataView.categorical.values[0].values.length > 0)\n            ) {\n                return null;\n            }\n\n            var values: any[] = [];\n            var metadataColumn: DataViewMetadataColumn;\n            var extent: any[];\n            var min: any;\n            var max: any;\n            var that = this;\n\n            var categoryType: ValueType = AxisHelper.getCategoryValueType(dataView.categorical.categories[0].source, true);\n            this.isDateTime = AxisHelper.isDateTime(categoryType);\n            var isScalar = true;\n\n            var settings: LineDotChartSettings = this.parseSettings(dataView);\n            var effectiveWidth: number = Math.max(0, viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize);\n            var effectiveHeight: number = Math.max(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize);\n\n            var format: string = \"\";\n            var formatter: IValueFormatter;\n\n            // X for categories\n            values = dataView.categorical.categories[0].values;\n            metadataColumn = dataView.categorical.categories[0].source;\n            extent = d3.extent(values);\n\n            if (this.isDateTime) {\n                min = extent[0].getTime();\n                max = extent[1].getTime();\n\n                min = new Date(min);\n                max = new Date(max + (max - min)*.05);\n\n                // var xDomain: number[] = isScalar ? [min, max] : [min.getTime(), max.getTime()]\n                // var format: string = \"MMM dd yyyy HH:mm\";\n                format = \"MMM dd yyyy\";\n                formatter = valueFormatter.create({ format: format });\n            } else {\n                min = extent[0];\n                max = extent[1];\n\n                max = max + (max - min)*.05;\n\n                formatter = valueFormatter.create({ value: 0 });\n            }\n\n            var xAxis = AxisHelper.createAxis({\n                pixelSpan: effectiveWidth,\n                dataDomain: [min, max],\n                metaDataColumn: metadataColumn,\n                formatString: null,\n                //formatString: LineDotChart.Properties.general.formatString,\n                outerPadding: 0,\n                isCategoryAxis: true,\n                isScalar: isScalar,\n                isVertical: false,\n                forcedTickCount: undefined,\n                useTickIntervalForDisplayUnits: true,\n                // axisPrecision: settings.precision,\n                getValueFn: (index, type) => {\n                    if(that.isDateTime) {\n                        return formatter.format(new Date(index));\n                    } else {\n                        return index;\n                    }\n                }\n            });\n            xAxis.formatter = formatter;\n\n            metadataColumn = dataView.categorical.values[0].source;\n\n            values = dataView.categorical.values[0].values;\n            extent = d3.extent(values);\n            min = extent[0];\n            max = extent[1];\n\n            var result: LineDotPoint[] = [];\n            var value_sum: number = 0;\n            var value: number = 0;\n            var time: number = 0;\n            var selector: SelectionId;\n\n            for (var i = 0; i < dataView.categorical.categories[0].values.length; i++) {\n                value = dataView.categorical.values[0].values[i];\n                time = dataView.categorical.categories[0].values[i];\n                value_sum += value;\n                selector = SelectionId.createWithId(dataView.categorical.categories[0].identity[i]);\n                result.push({\n                    dot: (value - min) / (max - min),\n                    value: value,\n                    sum: value_sum,\n                    time: time,\n                    selector: selector\n                });\n            }\n\n            // make some space for counter + 25%\n            value_sum = value_sum + (value_sum - min) * 0.10;\n\n            var yAxis = AxisHelper.createAxis({\n                pixelSpan: effectiveHeight,\n                dataDomain: [min, value_sum],\n                metaDataColumn: metadataColumn,\n                formatString: null,\n                outerPadding: 0,\n                isCategoryAxis: false,\n                isScalar: true,\n                isVertical: true,\n                useTickIntervalForDisplayUnits: true\n            });\n\n            var yAxis2 = AxisHelper.createAxis({\n                pixelSpan: effectiveHeight,\n                dataDomain: [min, value_sum],\n                metaDataColumn: metadataColumn,\n                formatString: null,\n                outerPadding: 0,\n                isCategoryAxis: false,\n                isScalar: true,\n                isVertical: true,\n                useTickIntervalForDisplayUnits: true\n            });\n            yAxis2.axis.orient('right');\n\n            // Show gridlines on the chart to make the values more readable.\n            // TODO: Make this a configuration setting that can be toggled.\n            // xAxis.axis = xAxis.axis.tickSize(-effectiveHeight);\n            // yAxis.axis = yAxis.axis.tickSize(-effectiveWidth);\n            return {\n                points: result,\n                settings: settings,\n                xAxis: xAxis,\n                yAxis: yAxis,\n                yAxis2: yAxis2,\n                legends: this.generateAxisLabels(viewport, settings)\n            };\n        }\n\n        private parseSettings(dataView: DataView): LineDotChartSettings {\n            if (!dataView ||\n                !dataView.metadata ||\n                !dataView.metadata.columns ||\n                !dataView.metadata.columns[0]) {\n                return null;\n            }\n\n            var objects: DataViewObjects = dataView.metadata.objects;\n            var lineFillColorHelper: ColorHelper = new ColorHelper(this.colors, LineDotChart.Properties.lineoptions.fill, LineDotChart.DefaultSettings.lineFill);\n            var dotFillColorHelper: ColorHelper = new ColorHelper(this.colors, LineDotChart.Properties.dotoptions.color, LineDotChart.DefaultSettings.dotFill);\n            var xAxisTitle: string = LineDotChart.DefaultSettings.xAxisTitle;\n            var yAxisTitle: string = LineDotChart.DefaultSettings.yAxisTitle;\n\n            if (\n                dataView.categorical.categories[0] &&\n                dataView.categorical.categories[0].source &&\n                dataView.categorical.categories[0].source.displayName &&\n                dataView.categorical.values[0] &&\n                dataView.categorical.values[0].source &&\n                dataView.categorical.values[0].source.displayName) {\n                xAxisTitle = dataView.categorical.categories[0].source.displayName;\n                yAxisTitle = dataView.categorical.values[0].source.displayName;\n            }\n\n            var lineThickness: number = LineDotChart.DefaultSettings.lineThickness;\n            var dotSizeMin: number = LineDotChart.DefaultSettings.dotSizeMin;\n            var dotSizeMax: number = LineDotChart.DefaultSettings.dotSizeMax;\n            var counterTitle: string = LineDotChart.DefaultSettings.counterTitle;\n            var isanimated: boolean = LineDotChart.DefaultSettings.isanimated;\n            var isstopped: boolean = LineDotChart.DefaultSettings.isstopped;\n            var duration: number = LineDotChart.DefaultSettings.duration;\n            if (objects) {\n                lineThickness = DataViewObjects.getValue(\n                    objects,\n                    LineDotChart.Properties.lineoptions.lineThickness,\n                    LineDotChart.DefaultSettings.lineThickness\n                );\n                dotSizeMin = DataViewObjects.getValue(\n                    objects,\n                    LineDotChart.Properties.dotoptions.dotSizeMin,\n                    LineDotChart.DefaultSettings.dotSizeMin\n                );\n                dotSizeMax = DataViewObjects.getValue(\n                    objects,\n                    LineDotChart.Properties.dotoptions.dotSizeMax,\n                    LineDotChart.DefaultSettings.dotSizeMax\n                );\n                counterTitle = DataViewObjects.getValue(\n                    objects,\n                    LineDotChart.Properties.counteroptions.counterTitle,\n                    LineDotChart.DefaultSettings.counterTitle\n                );\n                isanimated = DataViewObjects.getValue(\n                    objects,\n                    LineDotChart.Properties.misc.isanimated,\n                    LineDotChart.DefaultSettings.isanimated\n                );\n                isstopped = DataViewObjects.getValue(\n                    objects,\n                    LineDotChart.Properties.misc.isstopped,\n                    LineDotChart.DefaultSettings.isstopped\n                );\n                duration = DataViewObjects.getValue(\n                    objects,\n                    LineDotChart.Properties.misc.duration,\n                    LineDotChart.DefaultSettings.duration\n                );\n                \n            }\n\n            return {\n                // precision: LineDotChart.getPrecision(objects),\n                xAxisTitle: xAxisTitle,\n                yAxisTitle: yAxisTitle,\n                lineFill: lineFillColorHelper.getColorForMeasure(objects, ''),\n                lineThickness: lineThickness,\n                dotFill: dotFillColorHelper.getColorForMeasure(objects, ''),\n                dotSizeMin: dotSizeMin,\n                dotSizeMax: dotSizeMax,\n                counterTitle: counterTitle,\n                isstopped: isstopped,\n                isanimated: isanimated,\n                duration: duration\n            };\n        }\n\n        // private static getPrecision(objects: DataViewObjects): number {\n        //     if (!objects) {\n        //         return LineDotChart.DefaultSettings.precision;\n        //     }\n\n        //     var precision: number = DataViewObjects.getValue(\n        //         objects,\n        //         LineDotChart.Properties.labels.labelPrecision,\n        //         LineDotChart.DefaultSettings.precision);\n\n        //     if (precision < LineDotChart.MinPrecision) {\n        //         return LineDotChart.MinPrecision;\n        //     }\n\n        //     return precision;\n        // }\n\n        private generateAxisLabels(viewport: IViewport, settings: LineDotChartSettings): Legend[] {\n            return [\n                {\n                    transform: SVGUtil.translate(\n                        (viewport.width - this.margin.left - this.margin.right) / 2,\n                        (viewport.height - this.margin.top - this.margin.bottom)),\n                    text: settings.xAxisTitle,\n                    dx: \"1em\",\n                    dy: \"-1em\"\n                }, {\n                    transform: SVGUtil.translateAndRotate(\n                        0,\n                        (viewport.height - this.margin.top - this.margin.bottom) / 2,\n                        0,\n                        0,\n                        270),\n                    text: settings.yAxisTitle,\n                    dx: \"3em\"\n                }\n            ];\n        }\n\n        private resize(viewport: IViewport): void {\n            this.root.attr({\n                'height': Math.max(0, viewport.height),\n                'width': Math.max(0, viewport.width)\n            });\n\n            this.main.attr('transform', SVGUtil.translate(this.margin.left, this.margin.top));\n            this.legends.attr('transform', SVGUtil.translate(this.margin.left, this.margin.top));\n            this.line.attr('transform', SVGUtil.translate(this.margin.left + this.LegendSize, 0));\n            this.axes.attr('transform', SVGUtil.translate(this.margin.left + this.LegendSize, 0));\n            this.axisX.attr('transform', SVGUtil.translate(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize));\n            this.axisY2.attr('transform', SVGUtil.translate(viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize, 0));\n        }\n\n        private draw(model: LineDotChartViewModel): void {\n            var that = this;\n            // Clear canvas\n            this.line.selectAll('*').remove();\n\n            this.legends.selectAll('*').remove();\n            this.axisX.selectAll('*').remove();\n            this.axisY.selectAll('*').remove();\n            this.axisY2.selectAll('*').remove();\n\n            if (!model) {\n                return;\n            }\n\n            this.renderLegends(model);\n\n            if (model && model.points && model.points.length) {\n\n                this.axisX.call(model.xAxis.axis);\n                this.axisY.call(model.yAxis.axis);\n                this.axisY2.call(model.yAxis2.axis);\n\n                if (model.settings.isanimated) {\n                    var playBtn = this.line\n                        .append(\"g\")\n                        .classed(\"lineDotChart__playBtn\", true)\n                        .attr(\"transform\", \"translate(40, 20)\");\n\n                    playBtn\n                        .append(\"circle\")\n                        .attr(\"r\", 34 / 2);\n\n                    // play / reset buttin\n                    if (model.settings.isstopped) {\n                        playBtn\n                            .append(\"path\")\n                            .attr(\"d\", \"M0 2l10 6-10 6z\")\n                            .attr(\"transform\", \"translate(-4,-8)\");\n\n                        playBtn\n                            .on('click.lineDotChart__playBt', function() {\n                                that.setIsStopped(false);\n                            });\n\n                        return;\n                    } else {\n                        playBtn\n                            .append(\"path\")\n                            .attr(\"d\", \"M0 2l10 6-10 6z\")\n                            .attr(\"transform-origin\", \"center\")\n                            .attr(\"transform\", \"translate(6, 8) rotate(180)\");\n\n                        playBtn\n                            .append(\"rect\")\n                            .attr(\"width\", \"2\")\n                            .attr(\"height\", \"12\")\n                            .attr(\"transform\", \"translate(-7,-6)\");\n\n                        playBtn\n                            .on('click.lineDotChart__playBt', function() {\n                                that.setIsStopped(true);\n                            });\n                    }\n                }\n\n                var clip = this.line\n                    .append(\"clipPath\")\n                    .attr(\"id\", \"lineClip\")\n                    .append(\"rect\")\n                    .attr(\"x\", 0)\n                    .attr(\"y\", 0)\n                    .attr(\"width\", 1)\n                    .attr(\"height\", 10000);\n\n                // Draw the line\n                var line: D3.Svg.Line = d3.svg.line()\n                    .x((d: LineDotPoint) => model.xAxis.scale(d.time))\n                    .y((d: LineDotPoint) => model.yAxis.scale(d.sum));\n                    // .interpolate(\"basis\");\n\n                var lineSelection: D3.UpdateSelection = this.line.selectAll('path.plot')\n                    .data([model.points]);\n\n                lineSelection.enter().append('path');\n                lineSelection\n                    .classed('plot', true)\n                    .attr('stroke', (d, i) => model.settings.lineFill)\n                    .attr('stroke-width', model.settings.lineThickness)\n                    .attr('d', line);\n\n                var totalLength: number = (<SVGPathElement>lineSelection.node()).getTotalLength();\n                var line_left = (<SVGPathElement>lineSelection.node()).getPointAtLength(0).x;\n                var line_right = (<SVGPathElement>lineSelection.node()).getPointAtLength(totalLength).x;\n\n                lineSelection\n                    .attr(\"clip-path\", \"url(\" + location.href + \"#lineClip)\");\n\n                if(!model.settings.isanimated) {\n                    clip\n                        .interrupt()\n                        .attr('x', line_left)\n                        .attr('width', line_right - line_left);\n                } else {\n                    clip\n                        .attr('x', line_left)\n                        .interrupt()\n                        .transition()\n                        .ease(\"linear\")\n                        .duration(model.settings.duration * 1000)\n                        .attr('width', line_right - line_left);\n                }\n                lineSelection\n                    .exit().remove();\n\n                var point_time: number = 300;\n                var counter_time: number = 0; // point_time / 100;\n\n                // Draw the individual data points that will be shown on hover with a tooltip\n                var lineTipSelection: D3.UpdateSelection = this.line.selectAll('circle.point')\n                    .data(model.points);\n\n                var that = this;\n\n                lineTipSelection.enter()\n                    .append('circle')\n                    .attr('fill', model.settings.dotFill)\n                    .attr('opacity', .77)\n                    .attr('r', (d: LineDotPoint) => model.settings.dotSizeMin + d.dot * (model.settings.dotSizeMax - model.settings.dotSizeMin))\n                    .classed('point', true)\n                    .on('mouseover.point', this.showDataPoint)\n                    .on('mouseout.point', this.hideDataPoint)\n                    .on(\"click.point\", function(d: LineDotPoint) {\n                        that.selectDot(this, d.selector);\n                    });\n\n                if (!model.settings.isanimated) {\n                    lineTipSelection\n                        .interrupt()\n                        .attr('transform', (d: LineDotPoint) => \n                            'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(1)'\n                        );\n                } else {\n                    lineTipSelection\n                        .interrupt()\n                        .attr('transform', (d: LineDotPoint) => \n                            'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(0.005)'\n                        )\n                        .transition()\n                        .duration(point_time)\n                        .delay((d: LineDotPoint, i: number) => this.pointDelay(model.points, i, model.settings.duration))\n                        .ease(\"linear\")\n                        .attr('transform', (d: LineDotPoint) => \n                            'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(3.4)'\n                        )\n                        .transition()\n                        .duration(point_time)\n                        .delay((d: LineDotPoint, i: number) => this.pointDelay(model.points, i, model.settings.duration) + point_time)\n                        .ease(\"elastic\")\n                        .attr('transform', (d: LineDotPoint) =>\n                            'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(1)'\n                        );\n                }\n\n                lineTipSelection.exit().remove();\n\n                for (var i = 0; i < lineTipSelection[0].length; i++) {\n                    this.addTooltip(model, lineTipSelection[0][i]);\n                }\n\n                // Feature Counter text \n                var lineTextSelection: D3.UpdateSelection = this.line.selectAll('text')\n                    .data(model.points);\n\n                lineTextSelection.enter()\n                    .append(\"text\")\n                    .classed('text', true)\n                    .text((d: LineDotPoint, i: number) => {\n                        // if (model.points[i + 1]) {\n                            return model.settings.counterTitle + ' ' + (i + 1);\n                        // } else {\n                        //     // TODO: CRAZY hard code\n                        //     return model.settings.counterTitle + ' 265'\n                        // }\n                    })\n                    .attr('x', line_right - 260)\n                    .attr('y', 30);\n\n                if (!model.settings.isanimated) {\n                    // opacity 1 only for last\n                    lineTextSelection\n                        .interrupt()\n                        .attr('transform', 'translate(0 0)')\n                        .attr('opacity', (d: LineDotPoint, i: number) => Number(i === model.points.length - 1));\n                } else {\n                    lineTextSelection\n                        // .attr('transform', 'translate(-40 0)')\n                        .attr('opacity', 0)\n                        .interrupt()\n                        .transition()\n                        .duration(counter_time)\n                        .delay((d: LineDotPoint, i: number) => this.pointDelay(model.points, i, model.settings.duration))\n                        .attr('transform', 'translate(0 0)')\n                        .attr('opacity', 1)\n                        .transition()\n                        .duration(counter_time)\n                        .delay((d: LineDotPoint, i: number) => {\n                            if (model.points[i + 1]) {\n                                return this.pointDelay(model.points, i+1, model.settings.duration);\n                            } else {\n                                return Number.POSITIVE_INFINITY;\n                            }\n                        })\n                        // .attr('transform', 'translate(40 0)')\n                        .attr('opacity', 0)\n                     ;\n\n                }\n                lineTextSelection.exit().remove();\n\n            }\n        }\n\n        private pointDelay(points: LineDotPoint[], num: number, animation_duration: number): number {\n            if (!points.length || !points[num] || num === 0) {\n                return 0;\n            }\n            if (this.isDateTime) {\n                let time: Date = <Date>points[num].time;\n                var min: number = (<Date>points[0].time).getTime();\n                var max: number = (<Date>points[points.length - 1].time).getTime();\n                var val: number = time.getTime();\n            } else {\n                let time: number = <number>points[num].time;\n                var min: number = <number>points[0].time;\n                var max: number = <number>points[points.length - 1].time;\n                var val: number = time;\n            }\n            return animation_duration * 1000 * (val - min) / (max - min);\n        }\n\n        private showDataPoint(data: LineDotPoint, index: number): void {\n            d3.select(<any>this).classed('show', true);\n        }\n\n        private hideDataPoint(data: LineDotPoint, index: number): void {\n            d3.select(<any>this).classed('show', false);\n        }\n\n        private addTooltip(model: LineDotChartViewModel, element: any): void {\n            var selection: D3.Selection = d3.select(element);\n            var data: LineDotPoint = selection.datum();\n            TooltipManager.addTooltip(selection, (event) => {\n                return [\n                    {\n                        displayName: model.settings.xAxisTitle,\n                        value: model.xAxis.formatter.format(data.time)\n                    },\n                    {\n                        displayName: model.settings.yAxisTitle,\n                        value: data.value.toString()\n                    }\n                ];\n            });\n        }\n\n        private renderLegends(model: LineDotChartViewModel): void {\n            var legendSelection: D3.UpdateSelection = this.legends\n                .selectAll(LineDotChart.Legend.selector)\n                .data(model.legends);\n\n            legendSelection\n                .enter()\n                .append(\"svg:text\");\n\n            legendSelection\n                .attr(\"x\", 0)\n                .attr(\"y\", 0)\n                .attr(\"dx\", (item: Legend) => item.dx)\n                .attr(\"dy\", (item: Legend) => item.dy)\n                .attr(\"transform\", (item: Legend) => item.transform)\n                .text((item: Legend) => item.text)\n                .classed(LineDotChart.Legend.class, true);\n\n            legendSelection\n                .exit()\n                .remove();\n        }\n    }\n}\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals.plugins {\r\n    export let sunburstCustom: IVisualPlugin = {\r\n        name: 'sunburstCustom',\r\n        watermarkKey: 'defaultWatermark',\r\n        capabilities: samples.Sunburst.capabilities,\r\n        create: () => new samples.Sunburst()\r\n    };\r\n\r\n    export let asterPlot: IVisualPlugin = {\r\n        name: 'asterPlot',\r\n        capabilities: samples.AsterPlot.capabilities,\r\n        create: () => new samples.AsterPlot()\r\n    };\r\n\r\n    export var tornadoChart: IVisualPlugin = {\r\n        name: \"tornadoChart\",\r\n        capabilities: samples.TornadoChart.capabilities,\r\n        create: () => new samples.TornadoChart()\r\n    };\r\n\r\n    export var sankeyDiagram: IVisualPlugin = {\r\n        name: \"sankeyDiagram\",\r\n        capabilities: samples.SankeyDiagram.capabilities,\r\n        create: () => new samples.SankeyDiagram()\r\n    };\r\n\r\n    export let mekkoChart: IVisualPlugin = {\r\n        name: 'mekkoChart',\r\n        watermarkKey: 'mekko',\r\n        capabilities: samples.MekkoChart.capabilities,\r\n        create: () => new samples.MekkoChart({ chartType: samples.MekkoChartType.HundredPercentStackedColumn }),\r\n        customizeQuery: ColumnChart.customizeQuery,\r\n        getSortableRoles: (visualSortableOptions?: VisualSortableOptions) => ColumnChart.getSortableRoles(visualSortableOptions),\r\n    };\r\n    \r\n    export var bulletChart: IVisualPlugin = {\r\n        name: \"bulletChart\",\r\n        capabilities: samples.BulletChart.capabilities,\r\n        create: () => new samples.BulletChart()\r\n    };\r\n\t\r\n\texport var wordCloud: IVisualPlugin = {\r\n        name: \"wordCloud\",\r\n        capabilities: samples.WordCloud.capabilities,\r\n        create: () => new samples.WordCloud()\r\n    };\r\n\t\r\n\texport var chicletSlicer: IVisualPlugin = {\r\n        name: 'chicletSlicer',\r\n        capabilities: samples.ChicletSlicer.capabilities,\r\n        create: () => new samples.ChicletSlicer()\r\n    };\r\n\t\r\n\texport var chordChart: IVisualPlugin = {\r\n        name: \"chordChart\",\r\n        capabilities: samples.ChordChart.capabilities,\r\n        create: () => new samples.ChordChart()\r\n    };\r\n\t\r\n\texport var enhancedScatterChart: IVisualPlugin = {\r\n        name: 'enhancedScatterChart',\r\n        capabilities: samples.EnhancedScatterChart.capabilities,\r\n        create: () => new samples.EnhancedScatterChart()\r\n    };\r\n\t\r\n\texport var radarChart: IVisualPlugin = {\r\n        name: 'radarChart',\r\n        capabilities: samples.RadarChart.capabilities,\r\n        create: () => new samples.RadarChart()\r\n    };\r\n\t\r\n\texport var dotPlot: IVisualPlugin = {\r\n        name: 'dotPlot',\r\n        capabilities: samples.DotPlot.capabilities,\r\n        create: () => new samples.DotPlot()\r\n    };\r\n\r\n    export var histogram: IVisualPlugin = {\r\n        name: \"histogram\",\r\n        capabilities: samples.Histogram.capabilities,\r\n        create: () => new samples.Histogram()\r\n    };\r\n    \r\n    export var colorBarChart: IVisualPlugin = {\r\n        name: \"colorBarChart\",\r\n        capabilities: samples.ColorBarChart.capabilities,\r\n        create: () => new samples.ColorBarChart()\r\n    };\r\n\r\n\texport var timeline: IVisualPlugin = {\r\n        name: 'timeline',\r\n        capabilities: samples.Timeline.capabilities,\r\n        create: () => new samples.Timeline()\r\n    };\r\n\t\r\n\texport var forceGraph: IVisualPlugin = {\r\n        name: \"forceGraph\",\r\n        capabilities: samples.ForceGraph.capabilities,\r\n        create: () => new samples.ForceGraph()\r\n    };\r\n\r\n    export let gantt: IVisualPlugin = {\r\n        name: \"gantt\",\r\n        capabilities: samples.Gantt.capabilities,\r\n        create: () => new samples.Gantt()\r\n    };\r\n\r\n    export let streamGraph: IVisualPlugin = {\r\n        name: \"streamGraph\",\r\n        capabilities: samples.StreamGraph.capabilities,\r\n        create: () => new samples.StreamGraph()\r\n    };\r\n\r\n    export var lineDotChart: IVisualPlugin = {\r\n        name: \"lineDotChart\",\r\n        capabilities: samples.LineDotChart.capabilities,\r\n        create: () => new samples.LineDotChart()\r\n    };\r\n    \r\n    \r\n}","\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\nmodule powerbi.visuals.visualPluginFactory {\n    export class CustomVisualPluginService extends VisualPluginService {\n        private customVisualPlugins: jsCommon.IStringDictionary<IVisualPlugin>;\n\n        public constructor() {\n            super({});\n\n            this.initCustomVisualPlugins();\n        }\n\n        public getVisuals(): IVisualPlugin[] {\n            let registry: jsCommon.IStringDictionary<IVisualPlugin> = this.customVisualPlugins,\n                names: string[] = Object.keys(registry);\n\n            return names.map((name: string) => registry[name]);\n        }\n\n        public getPlugin(type: string): IVisualPlugin {\n            if (!type) {\n                return null;\n            }\n\n            let plugin: IVisualPlugin = this.customVisualPlugins[type];\n\n            if (!plugin) {\n                return null;\n            }\n\n            return plugin;\n        }\n\n        public capabilities(type: string): VisualCapabilities {\n            let plugin: IVisualPlugin = this.getPlugin(type);\n\n            if (plugin) {\n                return plugin.capabilities;\n            }\n\n            return {};\n        }\n\n        private initCustomVisualPlugins(): void {\n            // Aster Plot\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.asterPlot, () => new samples.AsterPlot());\n\n            // Tornado Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.tornadoChart, () => new samples.TornadoChart({\n                animator: new BaseAnimator()\n            }));\n\n            // Sankey Diagram\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.sankeyDiagram, () => new samples.SankeyDiagram());\n\n            // Mekko Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.mekkoChart, () => new samples.MekkoChart({\n                chartType: samples.MekkoChartType.HundredPercentStackedColumn,\n                isScrollable: true,\n                animator: new WebColumnChartAnimator(),\n                behavior: new CartesianChartBehavior([new ColumnChartWebBehavior()])\n            }));\n\n            // Bullet Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.bulletChart, () => new samples.BulletChart());\n\n            // Word Cloud\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.wordCloud, () => new samples.WordCloud({\n                animator: new BaseAnimator()\n            }));\n\n            // Chiclet Slicer\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.chicletSlicer, () => new samples.ChicletSlicer({\n                behavior: new samples.ChicletSlicerWebBehavior()\n            }));\n\n            // Enhanced Scatter Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.enhancedScatterChart, () => new samples.EnhancedScatterChart());\n\n            // Radar Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.radarChart, () => new samples.RadarChart({\n                animator: new BaseAnimator()\n            }));\n            // DotPlot\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.dotPlot, () => new samples.DotPlot({\n                animator: new BaseAnimator()\n            }));\n\n            // Histogram\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.histogram, () => new samples.Histogram({\n                animator: new BaseAnimator()\n            }));\n\n            // Force Graph\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.forceGraph, () => new samples.ForceGraph());\n\n            // Gantt Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.gantt, () => new samples.Gantt());\n\n            // Stream Graph\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.streamGraph, () => new samples.StreamGraph());\n        }\n    }\n\n    export function createCustomVisualPluginService(): IVisualPluginService {\n        return new CustomVisualPluginService();\n    }\n}"],"sourceRoot":"/source/"}